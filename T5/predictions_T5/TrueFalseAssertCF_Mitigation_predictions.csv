index,source_code,formatted_source,review_comment,target,formatted_target,predictions,exact_match,exact_match_rank,Pred_Target_Lev_dist,Pred_Source_Lev_dist,source_target_lev_dist,source_target_word_difference,BLEU_score,ROUGE_score,unchanged_highlight,target_code_change_out_of_scope,unchanged_target,DataTypeCFSource,DataTypeCFComment,DataTypeCFTarget,IfElseCFSource,IfElseCFComment,IfElseCFTarget,ExceptionCFSource,ExceptionCFComment,ExceptionCFTarget,DeadCodeCFSource,DeadCodeCFComment,DeadCodeCFTarget,TryNcatchCFSource,TryNcatchCFComment,TryNcatchCFTarget,DataFlowCFSource,DataFlowCFComment,DataFlowCFTarget,EqualAssertCFSource,EqualAssertCFComment,EqualAssertCFTarget,NullAssertCFSource,NullAssertCFComment,NullAssertCFTarget,TrueFalseAssertCFSource,TrueFalseAssertCFComment,TrueFalseAssertCFTarget,ShuffleNamesCFSource,ShuffleNamesCFComment,ShuffleNamesCFTarget,RandomNamesCFSource,RandomNamesCFComment,RandomNamesCFTarget,IndependentSwapCFSource,IndependentSwapCFComment,IndependentSwapCFTarget,defUseBreakCFSource,defUseBreakCFComment,defUseBreakCFTarget,predictions_TrueFalseAssertCF_Mitigation,exact_match_TrueFalseAssertCF_Mitigation
69,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START> assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <END> assertFalse(rankDetails.areDuplicatesAllowed()); }","public class DummyClass {
    public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() {
        FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails();
        assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType());
        assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);
        assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);
        assertFalse(rankDetails.areDuplicatesAllowed());
    }
}",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }","public class DummyClass {
    public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() {
        FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails();
        assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType());
        assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE);
        assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE);
        assertFalse(rankDetails.areDuplicatesAllowed());
    }
}","['public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertTrue(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked()); assertEquals(FeedbackRankQuestionDetails.NO_VALUE, rankDetails.getMaxOptionsToBeRanked()); assertFalse(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals( rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertNotNull(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertNotNull(rankDetails.getMinOptionsToBeRanked()); assertEquals(FeedbackRankQuestionDetails.NO_VALUE, rankDetails.getMaxOptionsToBeRanked()); assertFalse(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertRank(rankDetails.areDuplicatesAllowed()); }', 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); {']",True,0,0,37,42,5,1.0,0.999999995,False,False,False,,,,,,,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START>assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> assertFalse(rankDetails.areDuplicatesAllowed()); }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }","public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { boolean var = false; if (var) var = true; FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START>assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> assertFalse(rankDetails.areDuplicatesAllowed()); }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { boolean var = false; if (var) var = true; FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }","public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { try { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START>assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> assertFalse(rankDetails.areDuplicatesAllowed()); } catch (Exception e) { throw e; } }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { try { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); } catch (Exception e) { throw e; } }",,,,,,,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); if (FeedbackQuestionType.RANK_OPTIONS != rankDetails.getQuestionType()) { assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); } assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START>assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> assertFalse(rankDetails.areDuplicatesAllowed()); }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); if (FeedbackQuestionType.RANK_OPTIONS != rankDetails.getQuestionType()) { assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); } if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } assertFalse(rankDetails.areDuplicatesAllowed()); }","public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { <START>assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }",,,,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails wxaod = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, wxaod.getQuestionType()); assertTrue(wxaod.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START> assertTrue(wxaod.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <END> assertFalse(wxaod.areDuplicatesAllowed()); }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails wxaod = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, wxaod.getQuestionType()); assertEquals(wxaod.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(wxaod.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(wxaod.areDuplicatesAllowed()); }",,,,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); FeedbackRankOptionsQuestionDetails jzgvd = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,jzgvd.getQuestionType()); assertTrue(jzgvd.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START>assertTrue(jzgvd.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE);<END> assertFalse(jzgvd.areDuplicatesAllowed()); }",assertEquals instead,"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); FeedbackRankOptionsQuestionDetails jzgvd = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, jzgvd.getQuestionType()); assertEquals(jzgvd.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(jzgvd.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(jzgvd.areDuplicatesAllowed()); }","1- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
2- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
3- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
4- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
5- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); assertTrue(rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
6- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } assertTrue(rankDetails.areDuplicatesAllowed()); assertFalse(rankDetails.areDuplicatesAllowed()); }
7- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
8- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
9- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked()); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.areDuplicatesAllowed()); } }
10- public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS,rankDetails.getQuestionType()); if (rankDetails.getMinOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.getMaxOptionsToBeRanked() != FeedbackRankQuestionDetails.NO_VALUE) { assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); } if (rankDetails.areDuplicatesAllowed()) { assertFalse(rankDetails.isDuplicatesAllowed()); } }",0
85,"public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); <START> } catch (IllegalArgumentException e) { <END> Assert.assertTrue(false); } Assert.assertTrue(true); }","public class DummyClass {
    public void testSuccessfulStartTransport() {
        try {
            CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport"");
            transportManager.registerTransport(carbonTransport);
            transportManager.startTransport(""dummyTransport"");
        } catch (IllegalArgumentException e) {
            Assert.assertTrue(false);
        }
        Assert.assertTrue(true);
    }
}","throw this error, handled test runtime","public void testSuccessfulStartTransport() { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }","public class DummyClass {
    public void testSuccessfulStartTransport() {
        CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport"");
        transportManager.registerTransport(carbonTransport);
        transportManager.startTransport(""dummyTransport"");
    }
}","['public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertFalse(false); } Assert.assertTrue(true); }', 'public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.fail(false); } Assert.assertTrue(true); }', 'public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertTrue(false); } Assert.assertTrue(true); }', 'public void testSuccessfulStartTransport() throws IllegalArgumentException { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }', 'public void testSuccessfulStartTransport() throws Exception { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }', 'public void testSuccessfulStartTransport() { synchronized ( CustomCarbonTransport.class) { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } }', 'public void testSuccessfulStartTransport() { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }', 'public void testSuccessfulStartTransport() { for (CustomCarbonTransport carbonTransport : new CustomCarbonTransport(""dummyTransport"")) { transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } }', 'public void testSuccessfulStartTransport() { while (true) { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } }', 'public void testSuccessfulStartTransport() { }']",True,6,0,26,124,6,1.0,0.999999995,False,False,False,,,,,,,"public void testSuccessfulStartTransport() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); <START>} catch (IllegalArgumentException e) {<END> Assert.assertTrue(false); } Assert.assertTrue(true); }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }","public void testSuccessfulStartTransport() { boolean var = false; if (var) var = true; try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); <START>} catch (IllegalArgumentException e) {<END> Assert.assertTrue(false); } Assert.assertTrue(true); }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { boolean var = false; if (var) var = true; CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }",,,,,,,,,,,,,"public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); <START>} catch (IllegalArgumentException e) {<END> if (!false) { Assert.assertTrue(false); } } if (!true) { Assert.assertTrue(true); } }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }","public void testSuccessfulStartTransport() { try { CustomCarbonTransport e = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(e); transportManager.startTransport(""dummyTransport""); <START> } catch (IllegalArgumentException carbonTransport) { <END> Assert.assertTrue(false); } Assert.assertTrue(true); }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { CustomCarbonTransport e = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(e); transportManager.startTransport(""dummyTransport""); }","public void testSuccessfulStartTransport() { try { CustomCarbonTransport ohayn = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(ohayn); transportManager.startTransport(""dummyTransport""); <START> } catch (IllegalArgumentException svyrs) { <END> Assert.assertTrue(false); } Assert.assertTrue(true); }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { CustomCarbonTransport ohayn = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(ohayn); transportManager.startTransport(""dummyTransport""); }",,,,"public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); CustomCarbonTransport xnrmu = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(xnrmu); transportManager.startTransport(""dummyTransport""); <START>} catch (IllegalArgumentException e) {<END> Assert.assertTrue(false); } Assert.assertTrue(true); }","throw this error, handled test runtime","public void testSuccessfulStartTransport() { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); CustomCarbonTransport xnrmu = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(xnrmu); transportManager.startTransport(""dummyTransport""); }","1- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { if (!false) { Assert.assertTrue(false); } } if (!true) { Assert.assertTrue(true); } }
2- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertFalse(false); Assert.assertTrue(false); } if (!true) { Assert.assertTrue(true); } }
3- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertFalse(false); } if (!true) { Assert.assertTrue(true); } }
4- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertTrue(false); } if (!true) { Assert.assertTrue(true); } }
5- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.fail(""Expected IllegalArgumentException""); } if (!true) { Assert.assertTrue(true); } }
6- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { if (!false) { Assert.assertTrue(false); } } Assert.assertTrue(true); }
7- public void testSuccessfulStartTransport() throws IllegalArgumentException { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); }
8- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { if (!false) { Assert.assertTrue(false); } } }
9- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { Assert.assertTrue(false); } }
10- public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(""dummyTransport""); transportManager.registerTransport(carbonTransport); transportManager.startTransport(""dummyTransport""); } catch (IllegalArgumentException e) { if (!false) { Assert.assertTrue(false); } } if (!true) { Assert. assertTrue(true); } }",0
233,public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START> assertTrue(tbm.getSize() == 0); <END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); },"public class DummyClass {
    public void testDynamicItem_AddOne() {
        contextRule.createAndRunWorkbench(window);
        ToolBarManager tbm = getManager(toolBar);
        assertTrue(tbm.getSize() == 0);
        MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class);
        toolBar.getChildren().add(toolItem1);
        assertTrue(tbm.getSize() == 1);
    }
}","sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }","public class DummyClass {
    public void testDynamicItem_AddOne() {
        contextRule.createAndRunWorkbench(window);
        ToolBarManager tbm = getManager(toolBar);
        assertEquals(tbm.getSize(), 0);
        MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class);
        toolBar.getChildren().add(toolItem1);
        assertEquals(tbm.getSize(), 1);
    }
}","['public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(0, tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(0,tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(0, tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, toolItem1.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(0, tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(-1, tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(""No Mbm.getSize() returned false"", 0,bm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, tbm.getSize()); }', 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(""No Mbm.getSize() == 0, mbm.getSize()); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(1, mbm.getSize()); }']",True,0,0,42,42,3,1.0,0.999999995,False,False,False,,,,,,,"public void testDynamicItem_AddOne() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START>assertTrue(tbm.getSize() == 0);<END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); }","sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }",public void testDynamicItem_AddOne() { boolean var = false; if (var) var = true; contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START>assertTrue(tbm.getSize() == 0);<END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { boolean var = false; if (var) var = true; contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }",public void testDynamicItem_AddOne() { try { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START>assertTrue(tbm.getSize() == 0);<END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); } catch (Exception e) { throw e; } },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { try { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); } catch (Exception e) { throw e; } }",,,,,,,,,,public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { <START>assertTrue(tbm.getSize() == 0);<END> } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertTrue(tbm.getSize() == 1); } },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }",public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START> assertTrue(tbm.getSize() == 0); <END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }",public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager ihvrm = getManager(toolBar); <START> assertTrue(ihvrm.getSize() == 0); <END> MToolItem asspe = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(asspe); assertTrue(ihvrm.getSize() == 1); },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager ihvrm = getManager(toolBar); assertEquals(ihvrm.getSize(), 0); MToolItem asspe = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(asspe); assertEquals(ihvrm.getSize(), 1); }",,,,public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); ToolBarManager dgmgr = getManager(toolBar); <START>assertTrue(dgmgr.getSize() == 0);<END> MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(dgmgr.getSize() == 1); },"sense assertEquals below, actual in failing case","public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); ToolBarManager dgmgr = getManager(toolBar); assertEquals(dgmgr.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(dgmgr.getSize(), 1); }","1- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(tbm.getSize(), 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(tbm.getSize(), 1); } }
2- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(tbm.getSize(), 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(1, tbm.getSize()); } }
3- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(0, tbm.getSize()); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(1, tbm.getSize()); } }
4- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertTrue(tbm.getSize() == 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(1, tbm.getSize()); } }
5- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertTrue(tbm.getSize() == 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(tbm.getSize(), 1); } }
6- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertTrue(tbm.getSize() == 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertTrue(tbm.getSize() == 1); } }
7- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(1, tbm.getSize()); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(1, tbm.getSize()); } }
8- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(1, tbm.getSize()); } }
9- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertTrue(tbm.getSize() == 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(tbm.getSize(), 1); } }
10- public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); if (tbm.getSize() != 0) { assertEquals(tbm.getSize(), 0); } MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); if (tbm.getSize() != 1) { assertEquals(tbm.getPosition(), 1); } }",0
279,"private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); <START> Assert.assertTrue(""test"", false); <END> }","public class DummyClass {
    private void compare(ByteString a, ByteString b) {
        Assert.assertTrue(underTest.compare(a, b) < 0);
        Assert.assertTrue(underTest.compare(b, a) > 0);
        Assert.assertTrue(underTest.compare(b, b) == 0);
        Assert.assertTrue(""test"", false);
    }
}",Please remove this committing,"private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }","public class DummyClass {
    private void compare(ByteString a, ByteString b) {
        Assert.assertTrue(underTest.compare(a, b) < 0);
        Assert.assertTrue(underTest.compare(b, a) > 0);
        Assert.assertTrue(underTest.compare(b, b) == 0);
    }
}","['private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert. assertTrue(underTest.compare(b, b) == 0); }', 'private void compare(ByteString a, ByteString b) { Assert. assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert. assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0);', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); assertFalse(""test""); }', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0);Realization.release(); }', 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0);  }', '}', 'private']",True,0,0,42,60,2,1.0,0.999999995,False,False,False,,,,,,,"private void compare(ByteString a,ByteString b) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.assertTrue(underTest.compare(a,b) < 0); Assert.assertTrue(underTest.compare(b,a) > 0); Assert.assertTrue(underTest.compare(b,b) == 0); <START>Assert.assertTrue(""test"",false);<END> }",Please remove this committing,"private void compare(ByteString a, ByteString b) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }","private void compare(ByteString a,ByteString b) { boolean var = false; if (var) var = true; Assert.assertTrue(underTest.compare(a,b) < 0); Assert.assertTrue(underTest.compare(b,a) > 0); Assert.assertTrue(underTest.compare(b,b) == 0); <START>Assert.assertTrue(""test"",false);<END> }",Please remove this committing,"private void compare(ByteString a, ByteString b) { boolean var = false; if (var) var = true; Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }","private void compare(ByteString a,ByteString b) { try { Assert.assertTrue(underTest.compare(a,b) < 0); Assert.assertTrue(underTest.compare(b,a) > 0); Assert.assertTrue(underTest.compare(b,b) == 0); <START>Assert.assertTrue(""test"",false);<END> } catch (Exception e) { throw e; } }",Please remove this committing,"private void compare(ByteString a, ByteString b) { try { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); } catch (Exception e) { throw e; } }",,,,,,,,,,"private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } <START>Assert.assertTrue(""test"",false);<END> }",Please remove this committing,"private void compare(ByteString a, ByteString b) { if (underTest.compare(a, b) >= 0) { Assert.assertTrue(underTest.compare(a, b) < 0); } if (underTest.compare(b, a) <= 0) { Assert.assertTrue(underTest.compare(b, a) > 0); } if (underTest.compare(b, b) != 0) { Assert.assertTrue(underTest.compare(b, b) == 0); } }","private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); <START> Assert.assertTrue(""test"", false); <END> }",Please remove this committing,"private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }","private void compare(ByteString oldyn, ByteString ejpaa) { Assert.assertTrue(underTest.compare(oldyn, ejpaa) < 0); Assert.assertTrue(underTest.compare(ejpaa, oldyn) > 0); Assert.assertTrue(underTest.compare(ejpaa, ejpaa) == 0); <START> Assert.assertTrue(""test"", false); <END> }",Please remove this committing,"private void compare(ByteString oldyn, ByteString ejpaa) { Assert.assertTrue(underTest.compare(oldyn, ejpaa) < 0); Assert.assertTrue(underTest.compare(ejpaa, oldyn) > 0); Assert.assertTrue(underTest.compare(ejpaa, ejpaa) == 0); }",,,,,,,"1- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } Assert.assertTrue(""test"", false); }
2- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } Assert.assertTrue(""test"",false); }
3- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } }
4- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } Assert.assertFalse(""test"", false); }
5- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } return; }
6- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } Assert.assertTrue(""test"",False); }
7- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } = false; }
8- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } Assert.assertTrue(""test"", false);
9- private void compare(ByteString a,ByteString b) { if (underTest.compare(a,b) >= 0) { Assert.assertTrue(underTest.compare(a,b) < 0); } if (underTest.compare(b,a) <= 0) { Assert.assertTrue(underTest.compare(b,a) > 0); } if (underTest.compare(b,b) != 0) { Assert.assertTrue(underTest.compare(b,b) == 0); } break; }
10- private",0
372,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { <START> Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid); <END> Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }","public class DummyClass {
    public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() {
        Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);
        Assert.assertTrue(
                new Allergen(null, concept, ""other value"")
                        .isSameAllergen(new Allergen(null, concept, ""OTHER VALUE"")));
    }
}",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }","public class DummyClass {
    public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() {
        Concept concept =
                Context.getConceptService()
                        .getConceptByUuid(Allergen.getOtherNonCodedConceptUuid());
        Assert.assertTrue(
                new Allergen(null, concept, ""other value"")
                        .isSameAllergen(new Allergen(null, concept, ""OTHER VALUE"")));
    }
}","['public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"")).isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.otherNonCodedConceptUuid); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(newAllergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(allNonCodedConceptUuid); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen().getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER Value""))); }', 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER Values""))); }']",True,0,0,31,41,2,1.0,0.999999995,False,False,False,,,,,,,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);<END> Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }","public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { boolean var = false; if (var) var = true; <START>Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);<END> Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { boolean var = false; if (var) var = true; Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); }","public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { try { <START>Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);<END> Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } catch (Exception e) { throw e; } }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { try { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { <START>Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);<END> if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); if (!new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null, concept, ""other value"").isSameAllergen(new Allergen(null, concept, ""OTHER VALUE""))); } }",,,,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { <START> Concept jbugz = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid); <END> Assert.assertTrue(new Allergen(null, jbugz, ""other value"").isSameAllergen(new Allergen(null, jbugz, ""OTHER VALUE""))); }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept jbugz = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, jbugz, ""other value"").isSameAllergen(new Allergen(null, jbugz, ""OTHER VALUE""))); }",,,,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid); <START>Concept lztgd = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid);<END> Assert.assertTrue(new Allergen(null,lztgd,""other value"").isSameAllergen(new Allergen(null,lztgd,""OTHER VALUE""))); }",for otherNonCodedConceptUuid,"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Concept lztgd = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, lztgd, ""other value"").isSameAllergen(new Allergen(null, lztgd, ""OTHER VALUE""))); }","1- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
2- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(AllergenOtherNonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
3- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(AllergenUtils.otherNonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
4- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(NonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
5- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(AllergenUtil.otherNonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
6- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(nonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
7- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(AllergenCore.otherNonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
8- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
9- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(AllergenService.getOtherNonCodedConceptUuid()); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))); } }
10- public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); if (!new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE""))) { Assert.assertTrue(new Allergen(null,concept,""other value"").isSameAllergen(new Allergen(null,concept,""OTHER VALUE()))); } }",0
415,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); <START> boolean actual = check.accepts(rule, context); <END> assertFalse(actual); }","public class DummyClass {
    public void testAcceptWhenIsNotExpectedClass() {
        when(rule.getId()).thenReturn(""SomeOtherClass"");
        boolean actual = check.accepts(rule, context);
        assertFalse(actual);
    }
}","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }","public class DummyClass {
    public void testAcceptWhenIsNotExpectedClass() {
        when(rule.getId()).thenReturn(""SomeOtherClass"");
        final boolean actual = check.accepts(rule, context);
        assertFalse(actual);
    }
}","['public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); check.accepts(rule, context); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClasses""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); assertTrue(check.accepts(rule, context)); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOther Class""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); check.accepts(rule, context); assertFalse(actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse (actual); }', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual);', 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); if (check.accepts(rule, context)) { } }']",True,0,0,32,32,1,1.0,0.999999995,True,True,False,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); <START> Boolean actual = check.accepts(rule, context); <END> assertFalse(actual); }","for consistency, please final Boolean actual","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }",,,,"public void testAcceptWhenIsNotExpectedClass() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); when(rule.getId()).thenReturn(""SomeOtherClass""); <START>boolean actual = check.accepts(rule,context);<END> assertFalse(actual); }","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }","public void testAcceptWhenIsNotExpectedClass() { boolean var = false; if (var) var = true; when(rule.getId()).thenReturn(""SomeOtherClass""); <START>boolean actual = check.accepts(rule,context);<END> assertFalse(actual); }","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { boolean var = false; if (var) var = true; when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }","public void testAcceptWhenIsNotExpectedClass() { try { when(rule.getId()).thenReturn(""SomeOtherClass""); <START>boolean actual = check.accepts(rule,context);<END> assertFalse(actual); } catch (Exception e) { throw e; } }","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { try { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); <START>boolean actual = check.accepts(rule,context);<END> if (actual) { assertFalse(actual); } }","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); if (actual) { assertFalse(actual); } }",,,,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); <START> boolean ibhrt = check.accepts(rule, context); <END> assertFalse(ibhrt); }","for consistency, please final boolean ibhrt","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean ibhrt = check.accepts(rule, context); assertFalse(ibhrt); }",,,,"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule,context); <START>boolean asulv = check.accepts(rule,context);<END> assertFalse(asulv); }","for consistency, please final boolean actual","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); boolean asulv = check.accepts(rule, context); assertFalse(asulv); }","1- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule, context); if (actual) { assertFalse(actual); } }
2- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule,context); if (actual) { assertFalse(actual); } }
3- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule,Context); if (actual) { assertFalse(actual); } }
4- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); Boolean actual = check.accepts(rule, context); if (actual) { assertFalse(actual); } }
5- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts (rule, context); if (actual) { assertFalse(actual); } }
6- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClasses""); boolean actual = check.accepts(rule, context); if (actual) { assertFalse(actual); } }
7- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts<>(rule, context); if (actual) { assertFalse(actual); } }
8- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = Check.accepts(rule, context); if (actual) { assertFalse(actual); } }
9- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); boolean actual = check.accepts(rule, context); assertTrue (actual); }
10- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); assertTrue(check.accepts(rule, context)); }",0
587,"public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START> bot.textInGroup(""Text"", 1); <END> assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","public class DummyClass {
    public void typesTextInReadOnly() throws Exception {
        final SWTBotText text = bot.textInGroup(""Text"", 1);
        assertTrue(text.isReadOnly());
        try {
            text.typeText("""");
            fail(""Expecting an exception"");
        } catch (Exception e) {
            assertEquals(""TextBox is read-only"", e.getMessage());
        }
    }
}","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","public class DummyClass {
    public void typesTextInReadOnly() throws Exception {
        bot.checkBox(""SWT.READ_ONLY"").select();
        final SWTBotText text = bot.textInGroup(""Text"");
        assertTrue(text.isReadOnly());
        try {
            text.typeText("""");
            fail(""Expecting an exception"");
        } catch (Exception e) {
            assertEquals(""TextBox is read-only"", e.getMessage());
        }
    }
}","['public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"")); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot =checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot().checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(SWT.READ_ONLY).select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (final IOException e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-Only"", e.getMessage()); } }', 'public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } } }']",True,0,0,67,69,4,1.0,0.999999995,False,False,False,,,,,,,"public void typesTextInReadOnly() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final SWTBotText text = <START>bot.textInGroup(""Text"",1);<END> assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","public void typesTextInReadOnly() throws Exception { boolean var = false; if (var) var = true; final SWTBotText text = <START>bot.textInGroup(""Text"",1);<END> assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { boolean var = false; if (var) var = true; bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }",,,,,,,,,,"public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START>bot.textInGroup(""Text"",1);<END> assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { if (""TextBox is read-only"" != e.getMessage()) { assertEquals(""TextBox is read-only"",e.getMessage()); } } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { if (""TextBox is read-only"" != e.getMessage()) { assertEquals(""TextBox is read-only"", e.getMessage()); } } }","public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START>bot.textInGroup(""Text"",1);<END> if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START> bot.textInGroup(""Text"", 1); <END> assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); assertTrue(text.isReadOnly()); try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","public void typesTextInReadOnly() throws Exception { final SWTBotText jmtjz = <START> bot.textInGroup(""Text"", 1); <END> assertTrue(jmtjz.isReadOnly()); try { jmtjz.typeText(""""); fail(""Expecting an exception""); } catch (Exception ankqp) { assertEquals(""TextBox is read-only"", ankqp.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText jmtjz = bot.textInGroup(""Text""); assertTrue(jmtjz.isReadOnly()); try { jmtjz.typeText(""""); fail(""Expecting an exception""); } catch (Exception ankqp) { assertEquals(""TextBox is read-only"", ankqp.getMessage()); } }",,,,"public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START>bot.textInGroup(""Text"",1);<END> SWTBotText upbqr = bot.textInGroup(""Text"",1); assertTrue(upbqr.isReadOnly()); try { upbqr.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }","Instead, start bot.checkBox(""SWT.READ_ONLY"").select();","public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); SWTBotText upbqr = bot.textInGroup(""Text""); assertTrue(upbqr.isReadOnly()); try { upbqr.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"", e.getMessage()); } }","1- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"",1); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
2- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"", 1); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
3- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text""); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
4- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"", """"); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
5- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"").select(); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
6- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"", 0); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
7- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"",(0)); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
8- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"",1""); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
9- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"",(1)); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } }
10- public void typesTextInReadOnly() throws Exception { bot.checkBox(""SWT.READ_ONLY"").select(); final SWTBotText text = bot.textInGroup(""Text"",1); if (!text.isReadOnly()) { assertTrue(text.isReadOnly()); } try { text.typeText(""""); fail(""Expecting an exception""); } catch (Exception e) { assertEquals(""TextBox is read-only"",e.getMessage()); } } }",0
606,"public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); <START> assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); <END> }","public class DummyClass {
    public void testUnhandledExceptionStoredOnCrashReportEnabled() {
        CrashReporter.storeUnhandledException(exception);
        assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
    }
}","This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); for readability. This is valid for occurrences","public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public class DummyClass {
    public void testUnhandledExceptionStoredOnCrashReportEnabled() {
        CrashReporter.storeUnhandledException(exception);
        assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
    }
}","['public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual file exists"", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text must be empty"", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text must be empty."", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text does not match."", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual message is empty"", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""CrashReporter.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text must be empty."", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty(); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text does not match."", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty(); }', 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(""The actual text must be empty."", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty); }']",True,0,0,31,31,2,1.0,0.999999995,False,False,False,,,,,,,"public void testUnhandledExceptionStoredOnCrashReportEnabled() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> }","This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); for readability. This is valid for occurrences","public void testUnhandledExceptionStoredOnCrashReportEnabled() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public void testUnhandledExceptionStoredOnCrashReportEnabled() { boolean var = false; if (var) var = true; CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> }","This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); for readability. This is valid for occurrences","public void testUnhandledExceptionStoredOnCrashReportEnabled() { boolean var = false; if (var) var = true; CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public void testUnhandledExceptionStoredOnCrashReportEnabled() { try { CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> } catch (Exception e) { throw e; } }","This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); for readability. This is valid for occurrences","public void testUnhandledExceptionStoredOnCrashReportEnabled() { try { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); if (!!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()) { <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> } }","This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); for readability. This is valid for occurrences","public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); if (sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()) { assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); } }",,,,,,,,,,,,,"1- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
2- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue (!(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty())); }
3- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
4- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }
5- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue (!(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }
6- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(""sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
7- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(""("" + sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
8- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(""UnhandledExceptionStoredOnCrashReportEnabled"") .isEmpty(); }
9- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue("""")); }
10- public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertTrue(""UnhandledExceptionStoredOnCrashReportEnabled"", sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }",0
719,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { <START> assertTrue(e.getMessage().contains(""Connection refused"")); <END> } }","public class DummyClass {
    public void testWrongPortConnection() throws Exception {
        BlockingChannel channel =
                new SSLBlockingChannel(
                        hostName,
                        sslPort + 1,
                        new MetricRegistry(),
                        10000,
                        10000,
                        10000,
                        2000,
                        sslSocketFactory,
                        clientSSLConfig);
        try {
            channel.connect();
            fail(""should have thrown!"");
        } catch (IOException e) {
            assertTrue(e.getMessage().contains(""Connection refused""));
        }
    }
}",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { } }","public class DummyClass {
    public void testWrongPortConnection() throws Exception {
        BlockingChannel channel =
                new SSLBlockingChannel(
                        hostName,
                        sslPort + 1,
                        new MetricRegistry(),
                        10000,
                        10000,
                        10000,
                        2000,
                        sslSocketFactory,
                        clientSSLConfig);
        try {
            channel.connect();
            fail(""should have thrown!"");
        } catch (IOException e) {
        }
    }
}","['public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { fail(e.getMessage()); } }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { LOG.error(""Connection refused"", e); } }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { Assert.fail(e.getMessage()); } }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { } }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); channel.connect(); }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); while (channel.connect()) { fail(""should have thrown!""); } }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); channel.connect(); fail(""should have thrown!""); }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); assertFalse(channel.connect()); }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); }', 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig);SyntaxException.connect(); }']",True,3,0,60,85,2,1.0,0.999999995,False,False,False,,,,,,,"public void testWrongPortConnection() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { <START>assertTrue(e.getMessage().contains(""Connection refused""));<END> } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { } }","public void testWrongPortConnection() throws Exception { boolean var = false; if (var) var = true; BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { <START>assertTrue(e.getMessage().contains(""Connection refused""));<END> } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { boolean var = false; if (var) var = true; BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { } }",,,,,,,,,,,,,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { if (!e.getMessage().contains(""Connection refused"")) { <START>assertTrue(e.getMessage().contains(""Connection refused""));<END> } } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { } }","public void testWrongPortConnection() throws Exception { BlockingChannel e = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { e.connect(); fail(""should have thrown!""); } catch (IOException channel) <START> { assertTrue(channel.getMessage().contains(""Connection <END> refused"")); } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { BlockingChannel e = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { e.connect(); fail(""should have thrown!""); } catch (IOException channel) { } }","public void testWrongPortConnection() throws Exception { BlockingChannel ydyxf = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { ydyxf.connect(); fail(""should have thrown!""); } catch (IOException foaue) <START> { assertTrue(foaue.getMessage().contains(""Connection <END> refused"")); } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { BlockingChannel ydyxf = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { ydyxf.connect(); fail(""should have thrown!""); } catch (IOException foaue) { } }",,,,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); BlockingChannel eozuj = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { eozuj.connect(); fail(""should have thrown!""); } catch (IOException e) { <START>assertTrue(e.getMessage().contains(""Connection refused""));<END> } }",a bad idea checking for exception messages in place,"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); BlockingChannel eozuj = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { eozuj.connect(); fail(""should have thrown!""); } catch (IOException e) { } }","1- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
2- public void testWrongPortConnection() throws IOException { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
3- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1, new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
4- public void testWrongPortConnection() { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
5- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains( ""Connection refused"")); } }
6- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch ( IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
7- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000, 10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
8- public void testWrongPortConnection() throws APIException { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
9- public void testWrongPortConnection() throws TException { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000,10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }
10- public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName,sslPort + 1,new MetricRegistry(),10000, 10000,10000,2000,sslSocketFactory,clientSSLConfig); try { channel.connect(); fail(""should have thrown!""); } catch (IOException e) { assertTrue(e.getMessage().contains(""Connection refused"")); } }",0
751,"public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START> Throwable cause = getRootCause(e); <END> assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","public class DummyClass {
    public void propagate_RuntimeException_when_handler_throws() {
        ModelTests.clearModel();
        FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false);
        Command command = Given.ACommand.createProject();
        try {
            dispatchCommand(faultyAggregate, env(command.getMessage()));
            failNotThrows();
        } catch (RuntimeException e) {
            @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"")
            Throwable cause = getRootCause(e);
            assertTrue(cause instanceof IllegalStateException);
            assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage());
        }
    }
}","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","public class DummyClass {
    public void propagate_RuntimeException_when_handler_throws() {
        ModelTests.clearModel();
        FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false);
        Command command = Given.ACommand.createProject();
        try {
            dispatchCommand(faultyAggregate, env(command.getMessage()));
            failNotThrows();
        } catch (RuntimeException e) {
            Throwable cause = getRootCause(e);
            assertTrue(cause instanceof IllegalStateException);
            assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage());
        }
    }
}","['public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { assertEquals(FaultyAggregate.BROKEN_HANDLER, e.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { RuntimeException cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { FaultyException cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { if (e instanceof IllegalStateException) { assertEquals(FaultyAggregate.BROKEN_HANDLER, e.getMessage()); } } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { FaultyAggregate.BROKEN_HANDLER, e.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { FaultyLogger.log(e, ""Error caught in Faulty%s. Exception message is "" + e.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { FaultyLogger.log(e, ""Error caught in Faulty%s."", e.getMessage()); } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { FaultyLogger.log(e, ""Error caught in Faulty%s. Exception message is "" + e.getMessage()); return; } }', 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); }']",True,0,0,82,82,1,1.0,0.999999995,True,True,False,,,,,,,"public void propagate_RuntimeException_when_handler_throws() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START>Throwable cause = getRootCause(e);<END> assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","public void propagate_RuntimeException_when_handler_throws() { boolean var = false; if (var) var = true; ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START>Throwable cause = getRootCause(e);<END> assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { boolean var = false; if (var) var = true; ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }",,,,,,,,,,"public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START>Throwable cause = getRootCause(e);<END> assertTrue(cause instanceof IllegalStateException); if (FaultyAggregate.BROKEN_HANDLER != cause.getMessage()) { assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); if (FaultyAggregate.BROKEN_HANDLER != cause.getMessage()) { assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } } }","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START>Throwable cause = getRootCause(e);<END> if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate e = new FaultyAggregate(ID, true, false); Command faultyAggregate = Given.ACommand.createProject(); try { dispatchCommand(e, env(faultyAggregate.getMessage())); failNotThrows(); } catch (RuntimeException command) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") Throwable <START> cause = getRootCause(command); <END> assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate e = new FaultyAggregate(ID, true, false); Command faultyAggregate = Given.ACommand.createProject(); try { dispatchCommand(e, env(faultyAggregate.getMessage())); failNotThrows(); } catch (RuntimeException command) { Throwable cause = getRootCause(command); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate mnmgr = new FaultyAggregate(ID, true, false); Command eufib = Given.ACommand.createProject(); try { dispatchCommand(mnmgr, env(eufib.getMessage())); failNotThrows(); } catch (RuntimeException fhbuz) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") Throwable <START> osmmq = getRootCause(fhbuz); <END> assertTrue(osmmq instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, osmmq.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate mnmgr = new FaultyAggregate(ID, true, false); Command eufib = Given.ACommand.createProject(); try { dispatchCommand(mnmgr, env(eufib.getMessage())); failNotThrows(); } catch (RuntimeException fhbuz) { Throwable osmmq = getRootCause(fhbuz); assertTrue(osmmq instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, osmmq.getMessage()); } }",,,,"public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); FaultyAggregate lrwjo = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(lrwjo,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(""ThrowableResultOfMethodCallIgnored"") <START>Throwable cause = getRootCause(e);<END> assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }","above, please fix code alignment","public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); FaultyAggregate lrwjo = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(lrwjo, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }","1- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
2- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
3- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }
4- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
5- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
6- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }
7- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
8- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,Env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
9- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate,env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }
10- public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID,true,false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, environment(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); if (!cause instanceof IllegalStateException) { assertTrue(cause instanceof IllegalStateException); } assertEquals(FaultyAggregate.BROKEN_HANDLER,cause.getMessage()); } }",0
832,"public void testAddJumpStitchPoint() { <START> EmbroideryStream stream = new DSTStream(); <END> stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }","public class DummyClass {
    public void testAddJumpStitchPoint() {
        EmbroideryStream stream = new DSTStream();
        stream.addJump();
        stream.addStitchPoint(0, 0);
        assertEquals(1, stream.getPointList().size());
        assertTrue(stream.getPointList().get(0).isJumpPoint());
    }
}",Please move a @before function,"public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }","public class DummyClass {
    public void testAddJumpStitchPoint() {
        stream.addJump();
        stream.addStitchPoint(0, 0);
        assertEquals(1, stream.getPointList().size());
        assertTrue(stream.getPointList().get(0).isJumpPoint());
    }
}","['public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }', 'public void testAddJumpStitchPoint() { addToStitchPoint(false); }', 'public void testAddJumpStitchPoint() { fromStitch.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }', 'public void testAddJumpStitchPoint() { addToStitchPoint((byte) 0x3, new byte[] {0, 0, (byte) 0x3, 3}; }', 'public void testAddJumpStitchPoint() { when(ocisStitchPointFromStitchPoint(any())).thenReturn(DSTStream); when(ocisStitchPointFromHyphen()).thenReturn(0L); assertTrue(ocisStitchPointFromHyphen()); }', 'public void testAddJumpStitchPoint() { addToStitchPoint((byte) 0, 0); assertEquals(1, new byte[] { 0x01, 0x02 }); }', 'public void testAddJumpStitchPoint() { addToStitchPoint((byte) 0x3, new byte[] {0, 0, (byte) 0x3, ""},""); }', 'public void testAddJumpStitchPoint() { when(ocisStitchPointFromStitchPoint(any())).thenReturn(DSTStream); when(ocisStitchPointFromStore()).thenReturn(0L); assertTrue(ocisStitchPointFromStore()); }', 'public void testAddJumpStitchPoint() { when(ocisStitchPointFromStitchPoint(any())).thenReturn(DSTStream); when(ocisStitchPointFromHyphen()).thenReturn(0L); assertTrue(ocisHyphenFromHyphen()); }', 'public void testAddJumpStitchPoint() { addToStitchPoint(new DSTStream()); }']",True,0,0,69,69,5,1.0,0.999999995,False,False,False,,,,,,,"public void testAddJumpStitchPoint() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>EmbroideryStream stream = new DSTStream();<END> stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }",Please move a @before function,"public void testAddJumpStitchPoint() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }","public void testAddJumpStitchPoint() { boolean var = false; if (var) var = true; <START>EmbroideryStream stream = new DSTStream();<END> stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }",Please move a @before function,"public void testAddJumpStitchPoint() { boolean var = false; if (var) var = true; stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }","public void testAddJumpStitchPoint() { try { <START>EmbroideryStream stream = new DSTStream();<END> stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); } catch (Exception e) { throw e; } }",Please move a @before function,"public void testAddJumpStitchPoint() { try { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); } catch (Exception e) { throw e; } }",,,,,,,"public void testAddJumpStitchPoint() { <START>EmbroideryStream stream = new DSTStream();<END> stream.addJump(); stream.addStitchPoint(0,0); if (1 != stream.getPointList().size()) { assertEquals(1,stream.getPointList().size()); } assertTrue(stream.getPointList().get(0).isJumpPoint()); }",Please move a @before function,"public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); if (1 != stream.getPointList().size()) { assertEquals(1, stream.getPointList().size()); } assertTrue(stream.getPointList().get(0).isJumpPoint()); }","public void testAddJumpStitchPoint() { <START>EmbroideryStream stream = new DSTStream();<END> stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }",Please move a @before function,"public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }",,,,"public void testAddJumpStitchPoint() { <START> EmbroideryStream twexr = new DSTStream(); <END> twexr.addJump(); twexr.addStitchPoint(0, 0); assertEquals(1, twexr.getPointList().size()); assertTrue(twexr.getPointList().get(0).isJumpPoint()); }",Please move a @before function,"public void testAddJumpStitchPoint() { twexr.addJump(); twexr.addStitchPoint(0, 0); assertEquals(1, twexr.getPointList().size()); assertTrue(twexr.getPointList().get(0).isJumpPoint()); }",,,,"public void testAddJumpStitchPoint() { EmbroideryStream stream = new DSTStream(); <START>EmbroideryStream enyzg = new DSTStream();<END> enyzg.addJump(); enyzg.addStitchPoint(0,0); assertEquals(1,enyzg.getPointList().size()); assertTrue(enyzg.getPointList().get(0).isJumpPoint()); }",Please move a @before function,"public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }","1- public void testAddJumpStitchPoint() { EmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
2- public void testAddJumpStitchPoint() { EmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1, stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
3- public void testAddJumpStitchPoint() { stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
4- public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
5- public void testAddJumpStitchPoint() { JmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
6- public void testAddJumpStitchPoint() { ImbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
7- public void testAddJumpStitchPoint() { GmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
8- public void testAddJumpStitchPoint() { EmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint()); } }
9- public void testAddJumpStitchPoint() { EmbroideryStream stream = new DSTStream(); stream.addJump(); stream.addStitchPoint(0,0); assertEquals(1,stream.getPointList().size()); if (!stream.getPointList().get(0).isJumpPoint()) { assertTrue(stream.getPointList().get(0).isJumpPoint); } }
10- public void testAddJumpStitchPoint() { byte[] data = new byte[] {0, 0, 1); byte[]StitchPoint = new byte[] { 0, 0, 0 }; new DSTStream(data); }",0
838,<START> public void testListAccessCredentials() throws InterruptedException { <END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },"public class DummyClass {
    public void testListAccessCredentials() throws InterruptedException {
        List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials();
        assertNotNull(access);
        assertTrue(access.size() > 0);
    }
}",Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },"public class DummyClass {
    public void testListAccessCredentials() {
        List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials();
        assertNotNull(access);
        assertTrue(access.size() > 0);
    }
}","['public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> accessibleStorage = sharedStorageApi().getAccessCredentials(); assertNotNull(accessibleStorage); assertTrue(accessibleStorage.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(""Access should be empty"", access.size() > 0); }', 'public void testListAccessRequirements() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessUsername() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi.getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size()  > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(Access); assertTrue(access.size() > 0); }', 'public void testListAccessCredential() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } {']",True,0,0,54,54,2,1.0,0.999999995,False,False,False,,,,,,,"<START>public void testListAccessCredentials() throws InterruptedException {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }",Remove InterruptedException signature,"public void testListAccessCredentials() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }",<START>public void testListAccessCredentials() throws InterruptedException {<END> boolean var = false; if (var) var = true; List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { boolean var = false; if (var) var = true; List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },<START>public void testListAccessCredentials() throws InterruptedException {<END> try { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } catch (Exception e) { throw e; } },Remove InterruptedException signature,public void testListAccessCredentials() { try { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } catch (Exception e) { throw e; } },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(access.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(access.size() > 0); },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } },,,,<START> public void testListAccessCredentials() throws InterruptedException { <END> List<SharedStorageAccess> jmzfn = sharedStorageApi().getAccessCredentials(); assertNotNull(jmzfn); assertTrue(jmzfn.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> jmzfn = sharedStorageApi().getAccessCredentials(); assertNotNull(jmzfn); assertTrue(jmzfn.size() > 0); },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); List<SharedStorageAccess> twnfh = sharedStorageApi().getAccessCredentials(); assertNotNull(twnfh); assertTrue(twnfh.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); List<SharedStorageAccess> twnfh = sharedStorageApi().getAccessCredentials(); assertNotNull(twnfh); assertTrue(twnfh.size() > 0); },"1- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } }
2- public void testListAccessCredentials() throws InterruptedException { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } }
3- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be the instance of Freestyle access"", access); if (access.size() <= 0) { assertTrue(""Access data should be the instance of Freestyle access"", access.size() > 0); } }
4- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access access should not return null"", access); if (access.size() <= 0) { assertTrue(""Access should be empty"", access.size() > 0); } }
5- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be the instance of Freenodes"", access); if (access.size() <= 0) { assertTrue(""Access data should be the instance of Freenodes"", access.size() > 0); } }
6- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be the instance of FreeAccessAccess""); if (access.size() <= 0) { assertTrue(""Access data should be the instance of FreeAccessAccess is called"", access.size() > 0); } }
7- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be thrown""); if (access.size() <= 0) { assertTrue(""Access data should be thrown"", access.size() > 0); } }
8- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be deleted"", access); if (access.size() <= 0) { assertTrue(""Access data should be be empty"", access.size() > 0); } }
9- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be the instance of FreeAccessAccess""); if (access.size() <= 0) { assertTrue(""Access data should be the instance of FreeAccessAccess"".equals(access.size())); } }
10- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(""Access data should be deleted"", access); if (access.size() <= 0) { assertTrue(""Access data should be > 0); } }",1
954,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> }","public class DummyClass {
    public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() {
        List<VdsNetworkInterface> result =
                dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.size() == 0);
    }
}",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public class DummyClass {
    public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() {
        List<VdsNetworkInterface> result =
                dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
}","['public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertFalse(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(!result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertNotNull(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertEquals(0, result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGed_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID(), true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty(), """"); }']",True,0,0,36,36,4,1.0,0.999999995,False,False,False,,,,,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) var = true; List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) var = true; List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { try { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> } catch (Exception e) { throw e; } }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { try { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); } catch (Exception e) { throw e; } }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); if (result == null) { assertNotNull(result); } <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); if (result == null) { assertNotNull(result); } assertTrue(result.isEmpty()); }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.size() != 0) { <START>assertTrue(result.size() == 0);<END> } }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); if (!result.isEmpty()) { assertTrue(result.isEmpty()); } }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> isyuf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(isyuf); <START> assertTrue(isyuf.size() == 0); <END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> isyuf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(isyuf); assertTrue(isyuf.isEmpty()); }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); List<VdsNetworkInterface> gmevf = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(gmevf); <START>assertTrue(gmevf.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); List<VdsNetworkInterface> gmevf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(gmevf); assertTrue(gmevf.isEmpty()); }","1- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); assertTrue(result.isEmpty()); }
2- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""Expected no result to be empty""); } }
3- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""Expected no result to be present""); } }
4- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""Expected no more than zero""); } }
5- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""Expected no result to be thrown""); } }
6- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""No result to fetch was found""); } }
7- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""Expected no result to beisEmpty""); } }
8- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""No result was thrown""); } }
9- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""No result to fetch""); } }
10- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.isEmpty()) { fail(""No result was found""); } }",0
1052,"public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); <START> assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); <END> CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public class DummyClass {
    public void testSharedPreferencesClearedAfterLoggingException() {
        CrashReporter.storeUnhandledException(exception);
        assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
        CrashReporter.sendUnhandledCaughtException();
        assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
    }
}",assertFalse(...);,"public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public class DummyClass {
    public void testSharedPreferencesClearedAfterLoggingException() {
        CrashReporter.storeUnhandledException(exception);
        assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
        CrashReporter.sendUnhandledCaughtException();
        assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty());
    }
}","['public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""error"".equals(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""("" + sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""CrashReporter.checkAction(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT), """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""error"".equals(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT), """").isEmpty()); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""CrashReporter.should have failed toCleared""); }', 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(""CrashReporter.checkAction(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT), """").isEmpty()); }']",True,0,0,31,31,2,1.0,0.999999995,False,False,False,,,,,,,"public void testSharedPreferencesClearedAfterLoggingException() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }",assertFalse(...);,"public void testSharedPreferencesClearedAfterLoggingException() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public void testSharedPreferencesClearedAfterLoggingException() { boolean var = false; if (var) var = true; CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }",assertFalse(...);,"public void testSharedPreferencesClearedAfterLoggingException() { boolean var = false; if (var) var = true; CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); }","public void testSharedPreferencesClearedAfterLoggingException() { try { CrashReporter.storeUnhandledException(exception); <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); } catch (Exception e) { throw e; } }",assertFalse(...);,"public void testSharedPreferencesClearedAfterLoggingException() { try { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); if (!!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()) { <START>assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty());<END> } CrashReporter.sendUnhandledCaughtException(); if (!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()) { assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); } }",assertFalse(...);,"public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); if (sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()) { assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); } CrashReporter.sendUnhandledCaughtException(); if (!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()) { assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, """").isEmpty()); } }",,,,,,,,,,,,,"1- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
2- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
3- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
4- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
5- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
6- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue (!(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty())); }
7- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue (!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
8- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
9- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); assertTrue(""(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); }
10- public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); CrashReporter.sendUnhandledCaughtException(); assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT,"""").isEmpty()); assertTrue("""")); }",0
1122,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType)t); <END> assertNotNull(s[0]); }","public class DummyClass {
    public void arrayType() {
        Type type = parseType(""int[]"");
        assertTrue(type.isArrayType());
        ArrayType arrayType = type.asArrayType();
        final ArrayType[] s = new ArrayType[1];
        type.ifArrayType(t -> s[0] = (ArrayType) t);
        assertNotNull(s[0]);
    }
}",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public class DummyClass {
    public void arrayType() {
        Type type = parseType(""int[]"");
        assertTrue(type.isArrayType());
        ArrayType arrayType = type.asArrayType();
        final ArrayType[] s = new ArrayType[1];
        type.ifArrayType(t -> s[0] = t);
        assertNotNull(s[0]);
    }
}","['public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.assertArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.assertArrayType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = toArrayType(t)); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.setArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.returnType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type. ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = T.ArrayType.LIST); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = T.ArrayType.IN; assertNotNull(s[0]); }']",True,0,0,26,37,2,1.0,0.999999995,False,False,False,,,,,,,"public void arrayType() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { boolean var = false; if (var) var = true; Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { boolean var = false; if (var) var = true; Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { try { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); } catch (Exception e) { throw e; } }",Huh? point is a cast necessary,"public void arrayType() { try { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); } catch (Exception e) { throw e; } }",,,,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); if (s[0] == null) { assertNotNull(s[0]); } }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); if (s[0] == null) { assertNotNull(s[0]); } }",,,,"public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void type() { Type s = parseType(""int[]""); assertTrue(s.isArrayType()); ArrayType type = s.asArrayType(); final ArrayType[] arrayType = new ArrayType[1]; <START> s.ifArrayType(t -> arrayType[0] = (ArrayType) <END> t); assertNotNull(arrayType[0]); }",Huh? point is a cast necessary,"public void type() { Type s = parseType(""int[]""); assertTrue(s.isArrayType()); ArrayType type = s.asArrayType(); final ArrayType[] arrayType = new ArrayType[1]; s.ifArrayType(t -> arrayType[0] = t); assertNotNull(arrayType[0]); }","public void zjsph() { Type sdjzm = parseType(""int[]""); assertTrue(sdjzm.isArrayType()); ArrayType zjsph = sdjzm.asArrayType(); final ArrayType[] cjtcp = new ArrayType[1]; <START> sdjzm.ifArrayType(rlzdi -> cjtcp[0] = (ArrayType) <END> rlzdi); assertNotNull(cjtcp[0]); }",Huh? point is a cast necessary,"public void zjsph() { Type sdjzm = parseType(""int[]""); assertTrue(sdjzm.isArrayType()); ArrayType zjsph = sdjzm.asArrayType(); final ArrayType[] cjtcp = new ArrayType[1]; sdjzm.ifArrayType(rlzdi -> cjtcp[0] = rlzdi); assertNotNull(cjtcp[0]); }","public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); final ArrayType[] s = new ArrayType[1]; ArrayType arrayType = type.asArrayType(); <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); final ArrayType[] s = new ArrayType[1]; ArrayType arrayType = type.asArrayType(); type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { Type type = parseType(""int[]""); Type usfiv = parseType(""int[]""); assertTrue(usfiv.isArrayType()); ArrayType arrayType = usfiv.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> usfiv.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); Type usfiv = parseType(""int[]""); assertTrue(usfiv.isArrayType()); ArrayType arrayType = usfiv.asArrayType(); final ArrayType[] s = new ArrayType[1]; usfiv.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","1- public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
2- public void arrayType() { if (!parseType(""int[]"")) { assertTrue(type.isArrayType()); } ArrayType arrayType = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
3- public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); assertNotNull(s[0]); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
4- public void arrayType() { Type type = parseType(INTEGER_ARRAY); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
5- public void arrayType() { if (!parseType(""int[]"")) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); } else { type.ifArrayType(t -> s[0] = (ArrayType) t); } }
6- public void arrayType() { Type type; parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
7- public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); return; }
8- public void arrayType() { Type type = parseType(""/int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
9- public void arrayType() { if (!parseType(""int[]"")) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
10- public void arrayType() { if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }",0
1198,public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect( Collectors.toList()).isEmpty()); <END> },"public class DummyClass {
    public void testNUllVmElementForFloatingDisk() {
        List<DiskVmElement> allDves = dao.getAll();
        assertTrue(
                allDves.stream()
                        .filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))
                        .collect(Collectors.toList())
                        .isEmpty());
    }
}",need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); },"public class DummyClass {
    public void testNUllVmElementForFloatingDisk() {
        List<DiskVmElement> allDves = dao.getAll();
        assertTrue(
                allDves.stream()
                        .noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)));
    }
}","['public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertEquals(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertEquals(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAll(allDves, FixturesTool.FLOATING_DISK_ID); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAllDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAllDves(allDves, FixturesTool.FLOATING_DISK_ID); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDSves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }', 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAllVms(allDves, FixturesTool.FLOATING_DISK_ID); }']",True,3,0,74,74,5,1.0,0.999999995,False,False,False,,,,,,,"public void testNUllVmElementForFloatingDisk() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); }<END>",need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),"public void testNUllVmElementForFloatingDisk() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); }",public void testNUllVmElementForFloatingDisk() { boolean var = false; if (var) var = true; List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { boolean var = false; if (var) var = true; List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); },public void testNUllVmElementForFloatingDisk() { try { List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); } catch (Exception e) { throw e; } }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { try { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); } catch (Exception e) { throw e; } },,,,,,,,,,<START>public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (!allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()) { assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); } }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (!allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))) { assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); } },public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); },public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> zguhv = dao.getAll(); <START> assertTrue(zguhv.stream().filter(nygcz -> nygcz.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(nygcz -> nygcz.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> zguhv = dao.getAll(); assertTrue(zguhv.stream().noneMatch(nygcz -> nygcz.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); },,,,public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); List<DiskVmElement> rvibh = dao.getAll(); <START> assertTrue(rvibh.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()); }<END>,need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID),public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); List<DiskVmElement> rvibh = dao.getAll(); assertTrue(rvibh.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); },"1- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (!allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()) { } }
2- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (!allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()) { testNUllVmElementForFloatingDisk(allDves); } }
3- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (!allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect(Collectors.toList()).isEmpty()) { return; } }
4- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }
5- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertEquals(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }
6- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))) { } }
7- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAllDves(allDves, FixturesTool.FLOATING_DISK_ID, FixturesTool.FLOATING_DISK_ID); }
8- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); if (allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)); }
9- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); }
10- public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertAllDves(allDves, FixturesTool.FLOATING_DISK_ID); }",0
1288,"public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); <START> Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0); <END> } }","public class DummyClass {
    public void testRound() throws Exception {
        ResultSet rs;
        for (double val : roundVals) {
            rs = methodWatcher.executeQuery(""values ROUND("" + val + "")"");
            Assert.assertTrue(rs.next());
            Assert.assertEquals(Math.round(val), rs.getDouble(1), 0.0);
        }
    }
}","Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }","public class DummyClass {
    public void testRound() throws Exception {
        ResultSet rs;
        for (double val : roundVals) {
            rs = methodWatcher.executeQuery(""values ROUND("" + val + "")"");
            Assert.assertTrue(rs.next());
            Assert.assertEquals(Math.round(val), rs.getLong(1));
        }
    }
}","['public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; for(int val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val), rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; int size = 0; for(int val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; int size = 0; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; boolean isLong = true; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; for(final double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }', 'public void testRound() throws Exception { ResultSet rs; long val = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); }', 'public void testRound() throws Exception { ResultSet rs; boolean isLong = true; for(double val : roundVals){ rs = methodWatcher.executeQuery(""values ROUND(""+val+"")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val), rs.getLong(1)); } }']",True,0,0,35,35,2,1.0,0.999999995,False,False,False,,,,,,,"public void testRound() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); <START>Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0);<END> } }","Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val), rs.getLong(1)); } }","public void testRound() throws Exception { boolean var = false; if (var) var = true; ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); <START>Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0);<END> } }","Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { boolean var = false; if (var) var = true; ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val), rs.getLong(1)); } }","public void testRound() throws Exception { try { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); <START>Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0);<END> } } catch (Exception e) { throw e; } }","Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { try { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val), rs.getLong(1)); } } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } <START>Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0);<END> } }","Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val), rs.getLong(1)); } }","public void testRound() throws Exception { ResultSet val; for (double rs : roundVals) { val = methodWatcher.executeQuery(""values <START> ROUND("" + <END> rs + "")""); Assert.assertTrue(val.next()); Assert.assertEquals(Math.round(rs), val.getDouble(1), 0.0); } }","Assert.assertEquals(Math.round(val),val.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { ResultSet val; for (double rs : roundVals) { val = methodWatcher.executeQuery(""values ROUND("" + rs + "")""); Assert.assertTrue(val.next()); Assert.assertEquals(Math.round(rs), val.getLong(1)); } }","public void testRound() throws Exception { ResultSet hajar; for (double kpcgp : roundVals) { hajar = methodWatcher.executeQuery(""values <START> ROUND("" + <END> kpcgp + "")""); Assert.assertTrue(hajar.next()); Assert.assertEquals(Math.round(kpcgp), hajar.getDouble(1), 0.0); } }","Assert.assertEquals(Math.round(kpcgp),hajar.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint","public void testRound() throws Exception { ResultSet hajar; for (double kpcgp : roundVals) { hajar = methodWatcher.executeQuery(""values ROUND("" + kpcgp + "")""); Assert.assertTrue(hajar.next()); Assert.assertEquals(Math.round(kpcgp), hajar.getLong(1)); } }",,,,,,,"1- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getLong(1)); } }
2- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val), rs.getLong(1)); } }
3- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); }Assert.assertEquals(Math.round(val),rs.getLong(1)); } }
4- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getDouble(1)); } }
5- public void testRound() throws Exception { ResultSet rs; for (int val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getLong(1)); } }
6- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getLong(1)); } } {
7- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Double.parseDouble(val),rs.getLong(1)); } }
8- public void testRound() throws Exception { ResultSet rs; for ( double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getLong(1)); } }
9- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round( val),rs.getLong(1)); } }
10- public void testRound() throws Exception { ResultSet rs; for (double val : roundVals) { rs = methodWatcher.executeQuery(""values ROUND("" + val + "")""); if (!rs.next()) { Assert.assertTrue(rs.next()); } Assert.assertEquals(Math.round(val),rs.getLong(1)); } }NP",1
1302,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { <START> assertTrue(dataObject.getProperty(""id"") != null); <END> int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","public class DummyClass {
    private void formFieldsShouldNotBeGeneratedForPersistenceId(
            List<FieldDefinition> formModelFields) {
        assertTrue(dataObject.getProperty(""id"") != null);
        int EXPECTED_FORM_FIELD_COUNT =
                finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1;
        assertEquals(
                ""Form field should be generated for every data field except of persistence id"",
                EXPECTED_FORM_FIELD_COUNT,
                formModelFields.size());
    }
}",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","public class DummyClass {
    private void formFieldsShouldNotBeGeneratedForPersistenceId(
            List<FieldDefinition> formModelFields) {
        assertNotNull(dataObject.getProperty(""id""));
        int EXPECTED_FORM_FIELD_COUNT =
                finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1;
        assertEquals(
                ""Form field should be generated for every data field except of persistence id"",
                EXPECTED_FORM_FIELD_COUNT,
                formModelFields.size());
    }
}","['private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'public void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'protected void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertTrue(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(dataObject.getProperty(""id""), is("""")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }', 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()).isEqualTo(1); }']",True,0,0,40,40,4,1.0,0.999999995,False,False,False,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { <START> assertTrue(dataObject.getProperty(""id"") != null); <END> Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }",,,,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>assertTrue(dataObject.getProperty(""id"") != null);<END> int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { boolean var = false; if (var) var = true; <START>assertTrue(dataObject.getProperty(""id"") != null);<END> int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { boolean var = false; if (var) var = true; assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { try { <START>assertTrue(dataObject.getProperty(""id"") != null);<END> int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); } catch (Exception e) { throw e; } }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { try { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); } catch (Exception e) { throw e; } }",,,,,,,,,,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { if (dataObject.getProperty(""id"") == null) { <START>assertTrue(dataObject.getProperty(""id"") != null);<END> } int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) <START> { assertTrue(dataObject.getProperty(""id"") != <END> null); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> wlusb) <START> { assertTrue(dataObject.getProperty(""id"") != <END> null); int rsehl = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", rsehl, wlusb.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> wlusb) { assertNotNull(dataObject.getProperty(""id"")); int rsehl = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", rsehl, wlusb.size()); }",,,,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { <START>assertTrue(dataObject.getProperty(""id"") != null);<END> int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; int fsbob = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",fsbob,formModelFields.size()); }",@jsoltes Assert#assertNotNull(java.lang.Object) method here,"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; int fsbob = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", fsbob, formModelFields.size()); }","1- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
2- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
3- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(dataObject.getProperty(""id"") != null); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
4- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""dataObject.getProperty(""id"") != null, is(notNullValue())); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
5- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""mapping list should not be null"", dataObject.getProperty(""id"") != null); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
6- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"") != null); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
7- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""dataObject.getProperty(""id"") != null, is(notNullValue())); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
8- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""mapping list should not be null"", dataObject.getProperty(""id"") != null); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
9- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""dataObject.getProperty(""id"") != null, is(""id"")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }
10- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertThat(""dataObject.getProperty(""id"") != null, is(not(nullValue())); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(),path).size() - 1; assertThat(""Form field should be generated for every data field except of persistence id"",EXPECTED_FORM_FIELD_COUNT,formModelFields.size()); }",0
1347,"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { <START> ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList()); <END> fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }","public class DummyClass {
    private void assertInvalidPath(String path) {
        SubfieldTokenizer tokenizer = new SubfieldTokenizer(path);
        try {
            ImmutableList<PathElement> pathElements =
                    Streams.stream(tokenizer).collect(toImmutableList());
            fail(""Expected failure"");
        } catch (PrestoException e) {
            assertTrue(e.getMessage().startsWith(""Invalid subfield path: ""));
        }
    }
}",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }","public class DummyClass {
    private void assertInvalidPath(String path) {
        SubfieldTokenizer tokenizer = new SubfieldTokenizer(path);
        try {
            Streams.stream(tokenizer).collect(toImmutableList());
            fail(""Expected failure"");
        } catch (PrestoException e) {
            assertTrue(e.getMessage().startsWith(""Invalid subfield path: ""));
        }
    }
}","['private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(ImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect( toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Stream.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(inputStream).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(ofImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } {', 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try', '} }']",True,0,0,62,68,2,1.0,0.999999995,False,False,False,,,,,,,"private void assertInvalidPath(String path) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { <START>ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList());<END> fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String path) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }","private void assertInvalidPath(String path) { boolean var = false; if (var) var = true; SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { <START>ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList());<END> fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String path) { boolean var = false; if (var) var = true; SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }",,,,,,,,,,,,,"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { <START>ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList());<END> fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }","private void assertInvalidPath(String e) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(e); try { <START> ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList()); <END> fail(""Expected failure""); } catch (PrestoException path) { assertTrue(path.getMessage().startsWith(""Invalid subfield path: "")); } }",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String e) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(e); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException path) { assertTrue(path.getMessage().startsWith(""Invalid subfield path: "")); } }","private void assertInvalidPath(String antlz) { SubfieldTokenizer cifvh = new SubfieldTokenizer(antlz); try { <START> ImmutableList<PathElement> xsnkq = Streams.stream(cifvh).collect(toImmutableList()); <END> fail(""Expected failure""); } catch (PrestoException nufsc) { assertTrue(nufsc.getMessage().startsWith(""Invalid subfield path: "")); } }",nit: Streams.stream(cifvh).collect(toImmutableList()); is good enough. (Assignment xsnkq is necessary),"private void assertInvalidPath(String antlz) { SubfieldTokenizer cifvh = new SubfieldTokenizer(antlz); try { Streams.stream(cifvh).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException nufsc) { assertTrue(nufsc.getMessage().startsWith(""Invalid subfield path: "")); } }",,,,"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); SubfieldTokenizer svtvd = new SubfieldTokenizer(path); try { <START>ImmutableList<PathElement> pathElements = Streams.stream(svtvd).collect(toImmutableList());<END> fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }",nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary),"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); SubfieldTokenizer svtvd = new SubfieldTokenizer(path); try { Streams.stream(svtvd).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } }","1- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
2- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(inputStream).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
3- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(path).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
4- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(path); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
5- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(reader).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
6- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(channel).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
7- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(filePath).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
8- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(598).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
9- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(map(path)::collect); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: "")); } } }
10- private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList()); fail(""Expected failure""); } catch (PrestoException e) { if (!e.getMessage().startsWith(""Invalid subfield path: "")) { assertTrue(e.getMessage().startsWith(""Invalid subfield path: ())); } } }",0
1360,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); <START> Assertion.assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); <END> }","public class DummyClass {
    public void anonUserOnMobileCanSeeAppPromotion() {
        Promoting promoting = findPromoting();
        Assertion.assertTrue(promoting.isMobileBannerDisplayed());
        Assertion.assertStringContains(
                promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT);
    }
}",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }","public class DummyClass {
    public void anonUserOnMobileCanSeeAppPromotion() {
        Promoting promoting = findPromoting();
        assertTrue(promoting.isMobileBannerDisplayed());
        assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT);
    }
}","['public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isFalse(); assertThat(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isFalse(); assertThat(promoting.getPromotionAppMobileText()).isEqualTo(MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isFalse(); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting).isMobileBannerDisplayed(); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isNotNull(); assertThat(promoting.getPromotionAppMobileText()).isEqualTo(MOBILE_PROMOTION_TEXT); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isFalse(); assertThat(promoting.getPromotionAppMobileText(), is(MOBILE_PROMOTION_TEXT)); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertThat(promoting.isMobileBannerDisplayed()).isFalse(); assertThat(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT).toString(); }', 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (promoting.isMobileBannerDisplayed()) { assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); } }']",True,0,0,36,46,4,1.0,0.999999995,False,False,False,,,,,,,"public void anonUserOnMobileCanSeeAppPromotion() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); <START>Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT);<END> }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }","public void anonUserOnMobileCanSeeAppPromotion() { boolean var = false; if (var) var = true; Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); <START>Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT);<END> }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { boolean var = false; if (var) var = true; Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }","public void anonUserOnMobileCanSeeAppPromotion() { try { Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); <START>Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT);<END> } catch (Exception e) { throw e; } }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { try { Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } <START>Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT);<END> }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { assertTrue(promoting.isMobileBannerDisplayed()); } assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }",,,,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting fifkk = findPromoting(); Assertion.assertTrue(fifkk.isMobileBannerDisplayed()); <START> Assertion.assertStringContains(fifkk.getPromotionAppMobileText(), <END> MOBILE_PROMOTION_TEXT); }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting fifkk = findPromoting(); assertTrue(fifkk.isMobileBannerDisplayed()); assertStringContains(fifkk.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }",,,,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); Promoting kmfrv = findPromoting(); Assertion.assertTrue(kmfrv.isMobileBannerDisplayed()); <START>Assertion.assertStringContains(kmfrv.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT);<END> }",static imports for form Assertion,"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); Promoting kmfrv = findPromoting(); assertTrue(kmfrv.isMobileBannerDisplayed()); assertStringContains(kmfrv.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }","1- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
2- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
3- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } assertThat(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
4- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } assertEquals(exceptionStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT)); }
5- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } Assertion.assertStringContains(promoing.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
6- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { assertTrue(promoting.isMobileBannerDisplayed()); } Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
7- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } checkStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT); }
8- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } String exceptionString = promoting.getPromotionAppMobileText(); assertTrue(exceptionString.contains(exceptionString)); }
9- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } assertTrue(ASSERT_FRTION_TEXT); }
10- public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); if (!promoting.isMobileBannerDisplayed()) { Assertion.assertTrue(promoting.isMobileBannerDisplayed()); } Assertion.assertStringContains(promoting.getPromotionAppMobileText(),MOBILE_PROMOTION_TEXT()); }",0
1442,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; <START> AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster); <END> List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public class DummyClass {
    public void createFeaturesTest() throws IOException {
        String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""};
        AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);
        List<String> features = new ArrayList<>();
        generator.createFeatures(features, tokens, 3, null);
        Assert.assertEquals(2, features.size());
        Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010""));
        Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101""));
    }
}",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public class DummyClass {
    public void createFeaturesTest() throws IOException {
        String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""};
        List<String> features = new ArrayList<>();
        generator.createFeatures(features, tokens, 3, null);
        Assert.assertEquals(2, features.size());
        Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010""));
        Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101""));
    }
}","['public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator().createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert. assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator. createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010"",00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster==0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }', 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""}; }', 'public void createFeaturesTest() throws IOException { }']",True,0,0,110,110,3,1.0,0.999999995,False,False,False,,,,,,,"public void createFeaturesTest() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { boolean var = false; if (var) var = true; String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { boolean var = false; if (var) var = true; String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { try { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } catch (Exception e) { throw e; } }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { try { String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } catch (Exception e) { throw e; } }",,,,,,,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); if (2 != features.size()) { Assert.assertEquals(2,features.size()); } Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); if (2 != features.size()) { Assert.assertEquals(2, features.size()); } Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }","public void createFeaturesTest() throws IOException { String[] generator = new String[] { ""he"", ""went"", ""with"", ""you"" }; <START> AdaptiveFeatureGenerator features = new BrownBigramFeatureGenerator(brownCluster); <END> List<String> tokens = new ArrayList<>(); features.createFeatures(tokens, generator, 3, null); Assert.assertEquals(2, tokens.size()); Assert.assertTrue(tokens.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(tokens.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] generator = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> tokens = new ArrayList<>(); features.createFeatures(tokens, generator, 3, null); Assert.assertEquals(2, tokens.size()); Assert.assertTrue(tokens.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(tokens.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { String[] isrok = new String[] { ""he"", ""went"", ""with"", ""you"" }; <START> AdaptiveFeatureGenerator debjp = new BrownBigramFeatureGenerator(brownCluster); <END> List<String> fpvgg = new ArrayList<>(); debjp.createFeatures(fpvgg, isrok, 3, null); Assert.assertEquals(2, fpvgg.size()); Assert.assertTrue(fpvgg.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(fpvgg.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] isrok = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> fpvgg = new ArrayList<>(); debjp.createFeatures(fpvgg, isrok, 3, null); Assert.assertEquals(2, fpvgg.size()); Assert.assertTrue(fpvgg.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(fpvgg.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { List<String> features = new ArrayList<>(); String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; String[] flpro = new String[] { ""he"",""went"",""with"",""you"" }; <START>AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);<END> List<String> features = new ArrayList<>(); generator.createFeatures(features,flpro,3,null); Assert.assertEquals(2,features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }",This line moved @Before method too,"public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"", ""went"", ""with"", ""you"" }; String[] flpro = new String[] { ""he"", ""went"", ""with"", ""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, flpro, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); }","1- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
2- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
3- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); coordinationProvider.createFeatures(features, tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
4- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); coordinationService.createFeatures(features, tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
5- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2, features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
6- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator().createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
7- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
8- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); dtos.add(42); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101"")); } }
9- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010"",00101"")); } }
10- public void createFeaturesTest() throws IOException { String[] tokens = new String[] { ""he"",""went"",""with"",""you"" }; List<String> features = new ArrayList<>(); generator.createFeatures(features,tokens,3,null); Assert.assertEquals(2,features.size()); if (!features.contains(""pbrowncluster,browncluster=0101,0010"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010"")); } if (!features.contains(""pbrowncluster,browncluster=01010,00101"")) { Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010(),00101"")); } }",0
1468,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, <START> Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); <END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public class DummyClass {
    public void testGetPermittedStorageDomains() {
        List<StorageDomain> result =
                dao.getPermittedStorageDomainsByStoragePool(
                        EXISTING_USER_ID,
                        ActionGroup.CONFIGURE_VM_STORAGE,
                        Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));
        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(result.get(0).getId(), existingDomain.getId());
    }
}",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public class DummyClass {
    public void testGetPermittedStorageDomains() {
        List<StorageDomain> result =
                dao.getPermittedStorageDomainsByStoragePool(
                        EXISTING_USER_ID,
                        ActionGroup.CONFIGURE_VM_STORAGE,
                        new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d""));
        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(result.get(0).getId(), existingDomain.getId());
    }
}","['public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-mm09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, final Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,.Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105ed"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,MOUNT_ID); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertTrue(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, null); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }']",True,0,0,45,46,3,1.0,0.999999995,False,False,False,,,,,,,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { boolean var = false; if (var) var = true; List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) var = true; List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { try { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); } catch (Exception e) { throw e; } }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { try { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); } catch (Exception e) { throw e; } }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); if (result.get(0).getId() != existingDomain.getId()) { assertEquals(result.get(0).getId(),existingDomain.getId()); } }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); if (result.get(0).getId() != existingDomain.getId()) { assertEquals(result.get(0).getId(), existingDomain.getId()); } }","public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(), existingDomain.getId()); }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> ympjw = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, <START> ActionGroup.CONFIGURE_VM_STORAGE, <END> Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(ympjw); assertFalse(ympjw.isEmpty()); assertEquals(ympjw.get(0).getId(), existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> ympjw = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(ympjw); assertFalse(ympjw.isEmpty()); assertEquals(ympjw.get(0).getId(), existingDomain.getId()); }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> List<StorageDomain> kkleh = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(kkleh); assertFalse(kkleh.isEmpty()); assertEquals(kkleh.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); List<StorageDomain> kkleh = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(kkleh); assertFalse(kkleh.isEmpty()); assertEquals(kkleh.get(0).getId(), existingDomain.getId()); }","1- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
2- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
3- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-mm09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
4- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-"");09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
5- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-so09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
6- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-.09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
7- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552- a09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
8- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-fd09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
9- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-vv09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }
10- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-f09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }",0
1490,"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); <START> System.out.println(pageProjectionOutput.getClass().getSimpleName()); <END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","public class DummyClass {
    public void testGeneratedClassName() {
        PageFunctionCompiler functionCompiler =
                new PageFunctionCompiler(createTestMetadataManager(), 0);
        String planNodeId = ""7"";
        String stageId = ""20170707_223500_67496_zguwn.2"";
        String classSuffix = stageId + ""_"" + planNodeId;
        Supplier<PageProjection> projectionSupplier =
                functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix));
        PageProjection projection = projectionSupplier.get();
        PageProjectionOutput pageProjectionOutput =
                projection.project(
                        SESSION,
                        new DriverYieldSignal(),
                        createLongBlockPage(0),
                        SelectedPositions.positionsRange(0, 1));
        System.out.println(pageProjectionOutput.getClass().getSimpleName());
        assertTrue(
                pageProjectionOutput
                        .getClass()
                        .getSimpleName()
                        .startsWith(
                                ""PageProjectionOutput_""
                                        + stageId.replace('.', '_')
                                        + ""_""
                                        + planNodeId));
    }
}",remove this line,"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","public class DummyClass {
    public void testGeneratedClassName() {
        PageFunctionCompiler functionCompiler =
                new PageFunctionCompiler(createTestMetadataManager(), 0);
        String planNodeId = ""7"";
        String stageId = ""20170707_223500_67496_zguwn.2"";
        String classSuffix = stageId + ""_"" + planNodeId;
        Supplier<PageProjection> projectionSupplier =
                functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix));
        PageProjection projection = projectionSupplier.get();
        PageProjectionOutput pageProjectionOutput =
                projection.project(
                        SESSION,
                        new DriverYieldSignal(),
                        createLongBlockPage(0),
                        SelectedPositions.positionsRange(0, 1));
        assertTrue(
                pageProjectionOutput
                        .getClass()
                        .getSimpleName()
                        .startsWith(
                                ""PageProjectionOutput_""
                                        + stageId.replace('.', '_')
                                        + ""_""
                                        + planNodeId));
    }
}","['public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 2)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496.zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId().replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection().project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\')) + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496-zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); }', 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace(\'.\', \'_\') + ""_"" + planNodeId)); } {']",True,0,0,95,95,1,1.0,0.999999995,False,False,False,,,,,,,"public void testGeneratedClassName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); }",remove this line,"public void testGeneratedClassName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","public void testGeneratedClassName() { boolean var = false; if (var) var = true; PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); }",remove this line,"public void testGeneratedClassName() { boolean var = false; if (var) var = true; PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","public void testGeneratedClassName() { try { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } catch (Exception e) { throw e; } }",remove this line,"public void testGeneratedClassName() { try { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }",remove this line,"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); } }","public void testGeneratedClassName() { PageFunctionCompiler classSuffix = new PageFunctionCompiler(createTestMetadataManager(), 0); String projection = ""7""; String projectionSupplier = ""20170707_223500_67496_zguwn.2""; String stageId = projectionSupplier + ""_"" + projection; Supplier<PageProjection> functionCompiler = classSuffix.compileProjection(ADD_10_EXPRESSION, Optional.of(stageId)); PageProjection pageProjectionOutput = functionCompiler.get(); PageProjectionOutput planNodeId = pageProjectionOutput.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, <START> 1)); <END> System.out.println(planNodeId.getClass().getSimpleName()); assertTrue(planNodeId.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + projectionSupplier.replace('.', '_') + ""_"" + projection)); }",remove this line,"public void testGeneratedClassName() { PageFunctionCompiler classSuffix = new PageFunctionCompiler(createTestMetadataManager(), 0); String projection = ""7""; String projectionSupplier = ""20170707_223500_67496_zguwn.2""; String stageId = projectionSupplier + ""_"" + projection; Supplier<PageProjection> functionCompiler = classSuffix.compileProjection(ADD_10_EXPRESSION, Optional.of(stageId)); PageProjection pageProjectionOutput = functionCompiler.get(); PageProjectionOutput planNodeId = pageProjectionOutput.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(planNodeId.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + projectionSupplier.replace('.', '_') + ""_"" + projection)); }","public void testGeneratedClassName() { PageFunctionCompiler nxbmt = new PageFunctionCompiler(createTestMetadataManager(), 0); String hests = ""7""; String szfxl = ""20170707_223500_67496_zguwn.2""; String xevtp = szfxl + ""_"" + hests; Supplier<PageProjection> wkxfv = nxbmt.compileProjection(ADD_10_EXPRESSION, Optional.of(xevtp)); PageProjection liorh = wkxfv.get(); PageProjectionOutput wqsfo = liorh.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, <START> 1)); <END> System.out.println(wqsfo.getClass().getSimpleName()); assertTrue(wqsfo.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + szfxl.replace('.', '_') + ""_"" + hests)); }",remove this line,"public void testGeneratedClassName() { PageFunctionCompiler nxbmt = new PageFunctionCompiler(createTestMetadataManager(), 0); String hests = ""7""; String szfxl = ""20170707_223500_67496_zguwn.2""; String xevtp = szfxl + ""_"" + hests; Supplier<PageProjection> wkxfv = nxbmt.compileProjection(ADD_10_EXPRESSION, Optional.of(xevtp)); PageProjection liorh = wkxfv.get(); PageProjectionOutput wqsfo = liorh.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(wqsfo.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + szfxl.replace('.', '_') + ""_"" + hests)); }","public void testGeneratedClassName() { String planNodeId = ""7""; PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); }",remove this line,"public void testGeneratedClassName() { String planNodeId = ""7""; PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); PageFunctionCompiler blwnc = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = blwnc.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); <START>System.out.println(pageProjectionOutput.getClass().getSimpleName());<END> assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); }",remove this line,"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); PageFunctionCompiler blwnc = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = blwnc.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.', '_') + ""_"" + planNodeId)); }","1- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
2- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
3- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId); } }
4- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) {assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
5- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
6- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496.zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
7- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput .getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
8- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_'"") + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
9- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (! pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }
10- public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(),0); String planNodeId = ""7""; String stageId = ""20170707_223500_67496_zguwn.2""; String classSuffix = stageId + ""_"" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION,Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection .project(SESSION,new DriverYieldSignal(),createLongBlockPage(0),SelectedPositions.positionsRange(0,1)); System.out.println(pageProjectionOutput.getClass().getSimpleName()); if (!pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)) { assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(""PageProjectionOutput_"" + stageId.replace('.','_') + ""_"" + planNodeId)); } }",0
1505,"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); <START> verify(dragComponentGroupView, times(1)).setExpanded(false); <END> verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public class DummyClass {
    public void testAddDraggableGroupsWithExperimental() {
        disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName());
        disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName());
        disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName());
        disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName());
        presenter.addDraggableGroups(
                Arrays.asList(
                        new Group1LayoutComponentPaletteGroupProvider(true),
                        new Group2LayoutComponentPaletteGroupProvider(),
                        new Group3LayoutComponentPaletteGroupProvider()));
        verify(dragComponentGroupPresenter, times(2)).init(any());
        verify(dragComponentGroupPresenter, times(2)).getView();
        verify(dragComponentGroupView, times(1)).setExpanded(true);
        verify(dragComponentGroupView, times(1)).setExpanded(false);
        verify(view, times(2)).addDraggableComponentGroup(any());
        assertEquals(2, presenter.getLayoutDragComponentGroups().size());
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group1LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent1.ID));
        assertTrue(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent2.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent3.ID));
        assertNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group2LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent1.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent2.ID));
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group3LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group3LayoutComponentPaletteGroupProvider.ID,
                        Group3LayoutDragComponent1.ID));
    }
}",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public class DummyClass {
    public void testAddDraggableGroupsWithExperimental() {
        disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName());
        disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName());
        disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName());
        disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName());
        presenter.addDraggableGroups(
                Arrays.asList(
                        new Group1LayoutComponentPaletteGroupProvider(true),
                        new Group2LayoutComponentPaletteGroupProvider(),
                        new Group3LayoutComponentPaletteGroupProvider()));
        verify(dragComponentGroupPresenter, times(2)).init(any());
        verify(dragComponentGroupPresenter, times(2)).getView();
        verify(dragComponentGroupView).setExpanded(true);
        verify(dragComponentGroupView).setExpanded(false);
        verify(view, times(2)).addDraggableComponentGroup(any());
        assertEquals(2, presenter.getLayoutDragComponentGroups().size());
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group1LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent1.ID));
        assertTrue(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent2.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent3.ID));
        assertNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group2LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent1.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent2.ID));
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group3LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group3LayoutComponentPaletteGroupProvider.ID,
                        Group3LayoutDragComponent1.ID));
    }
}","['public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDigitGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDescrComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDigitComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDigitGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDescrGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDescrGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addTelephoneComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDigitComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDigitComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }']",True,0,0,46,46,5,1.0,0.999999995,False,False,False,,,,,,,"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) var = true; disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) var = true; disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { try { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); } catch (Exception e) { throw e; } }",more times(1),"public void testAddDraggableGroupsWithExperimental() { try { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); } catch (Exception e) { throw e; } }",,,,"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); if (2 != presenter.getLayoutDragComponentGroups().size()) { assertEquals(2,presenter.getLayoutDragComponentGroups().size()); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); if (2 != presenter.getLayoutDragComponentGroups().size()) { assertEquals(2, presenter.getLayoutDragComponentGroups().size()); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); } }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); } }",,,,,,,,,,,,,"1- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
2- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView, times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
3- public void testAddDigitGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
4- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDescrComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
5- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDigitComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
6- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
7- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDigitComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
8- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).add buildersComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
9- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDigitComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable
10- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addTelephoneComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggable",0
1531,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); <START> String newline = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public class DummyClass {
    public void testConverter() throws Exception {
        String converterName = cs.getConverterName(""application/pdf"", ""text/plain"");
        assertEquals(""pdf2text"", converterName);
        checkConverterAvailability(converterName);
        checkCommandAvailability(""pdftotext"");
        BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf"");
        BlobHolder result = cs.convert(converterName, pdfBH, null);
        assertNotNull(result);
        List<Blob> blobs = result.getBlobs();
        assertNotNull(blobs);
        assertEquals(1, blobs.size());
        Blob blob = result.getBlob();
        assertNotNull(blob);
        assertEquals(""text/plain"", blob.getMimeType());
        assertTrue(blob.getLength() > 0);
        String newline = System.getProperty(""line.separator"");
        assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString());
    }
}",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public class DummyClass {
    public void testConverter() throws Exception {
        String converterName = cs.getConverterName(""application/pdf"", ""text/plain"");
        assertEquals(""pdf2text"", converterName);
        checkConverterAvailability(converterName);
        checkCommandAvailability(""pdftotext"");
        BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf"");
        BlobHolder result = cs.convert(converterName, pdfBH, null);
        assertNotNull(result);
        List<Blob> blobs = result.getBlobs();
        assertNotNull(blobs);
        assertEquals(1, blobs.size());
        Blob blob = result.getBlob();
        assertNotNull(blob);
        assertEquals(""text/plain"", blob.getMimeType());
        assertTrue(blob.getLength() > 0);
        String newline = System.lineSeparator();
        assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString());
    }
}","['public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + "":\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline, blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertEquals(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +(""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""<f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + "":\\f"", blob.getString()); {']",True,0,0,42,42,2,1.0,0.999999995,False,False,False,,,,,,,"public void testConverter() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { boolean var = false; if (var) var = true; String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { boolean var = false; if (var) var = true; String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { try { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); } catch (Exception e) { throw e; } }",System.lineSeparator(),"public void testConverter() throws Exception { try { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); } catch (Exception e) { throw e; } }",,,,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1, blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); if (""pdf2text"" != converterName) { assertEquals(""pdf2text"",converterName); } checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); if (1 != blobs.size()) { assertEquals(1,blobs.size()); } Blob blob = result.getBlob(); assertNotNull(blob); if (""text/plain"" != blob.getMimeType()) { assertEquals(""text/plain"",blob.getMimeType()); } assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> if (""Hello from a PDF Document!"" + newline + newline + ""\f"" != blob.getString()) { assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); } }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); if (""pdf2text"" != converterName) { assertEquals(""pdf2text"", converterName); } checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); if (1 != blobs.size()) { assertEquals(1, blobs.size()); } Blob blob = result.getBlob(); assertNotNull(blob); if (""text/plain"" != blob.getMimeType()) { assertEquals(""text/plain"", blob.getMimeType()); } assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); if (""Hello from a PDF Document!"" + newline + newline + ""\f"" != blob.getString()) { assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); } }","public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { String newline = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", newline); checkConverterAvailability(newline); checkCommandAvailability(""pdftotext""); BlobHolder blobs = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder pdfBH = cs.convert(newline, blobs, null); assertNotNull(pdfBH); List<Blob> blob = pdfBH.getBlobs(); assertNotNull(blob); assertEquals(1, blob.size()); Blob converterName = pdfBH.getBlob(); assertNotNull(converterName); assertEquals(""text/plain"", converterName.getMimeType()); assertTrue(converterName.getLength() > 0); <START> String result = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + result + result + ""\f"", converterName.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String newline = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", newline); checkConverterAvailability(newline); checkCommandAvailability(""pdftotext""); BlobHolder blobs = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder pdfBH = cs.convert(newline, blobs, null); assertNotNull(pdfBH); List<Blob> blob = pdfBH.getBlobs(); assertNotNull(blob); assertEquals(1, blob.size()); Blob converterName = pdfBH.getBlob(); assertNotNull(converterName); assertEquals(""text/plain"", converterName.getMimeType()); assertTrue(converterName.getLength() > 0); String result = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + result + result + ""\f"", converterName.getString()); }","public void testConverter() throws Exception { String hiuct = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", hiuct); checkConverterAvailability(hiuct); checkCommandAvailability(""pdftotext""); BlobHolder iuwvh = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder ufoyj = cs.convert(hiuct, iuwvh, null); assertNotNull(ufoyj); List<Blob> uhqgn = ufoyj.getBlobs(); assertNotNull(uhqgn); assertEquals(1, uhqgn.size()); Blob rbybt = ufoyj.getBlob(); assertNotNull(rbybt); assertEquals(""text/plain"", rbybt.getMimeType()); assertTrue(rbybt.getLength() > 0); <START> String osvsx = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + osvsx + osvsx + ""\f"", rbybt.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String hiuct = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", hiuct); checkConverterAvailability(hiuct); checkCommandAvailability(""pdftotext""); BlobHolder iuwvh = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder ufoyj = cs.convert(hiuct, iuwvh, null); assertNotNull(ufoyj); List<Blob> uhqgn = ufoyj.getBlobs(); assertNotNull(uhqgn); assertEquals(1, uhqgn.size()); Blob rbybt = ufoyj.getBlob(); assertNotNull(rbybt); assertEquals(""text/plain"", rbybt.getMimeType()); assertTrue(rbybt.getLength() > 0); String osvsx = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + osvsx + osvsx + ""\f"", rbybt.getString()); }",,,,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); String whrok = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",whrok); checkConverterAvailability(whrok); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(whrok,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); String whrok = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", whrok); checkConverterAvailability(whrok); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(whrok, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","1- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
2- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline, blob.getString()); }
3- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline,blob.getString()); }
4- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline.replace(""\f"",blob.getString()); }
5- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +\f"",blob.getString()); }
6- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
7- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline); }
8- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline.replace(""%"",blob.getString()); }
9- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline.substring(0, newline.length() - 1)); }
10- public void testConverter() throws Exception",0
1544,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START> IntStream.range(0, 4) <END> .boxed() .collect(Collectors.toList()) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = IntStream.range(0, 4) .boxed() .collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public class DummyClass {
    public void shouldConcatenateOneEmptyAndOneNonEmptyLists() {
        final List<Integer> list =
                Collections.unmodifiableList(
                        IntStream.range(0, 4).boxed().collect(Collectors.toList()));
        final List<Integer> actual = ListOps.concat(list, EMPTY_LIST);
        final List<Integer> expected = IntStream.range(0, 4).boxed().collect(Collectors.toList());
        assertNotNull(actual);
        assertFalse(actual.isEmpty());
        assertEquals(expected, actual);
    }
}",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public class DummyClass {
    public void shouldConcatenateOneEmptyAndOneNonEmptyLists() {
        final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4));
        final List<Integer> actual = ListOps.concat(list, EMPTY_LIST);
        final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4);
        assertNotNull(actual);
        assertFalse(actual.isEmpty());
        assertEquals(expected, actual);
    }
}","['public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOp.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOne emptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual()); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); {', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); =']",True,0,0,130,130,9,1.0,0.999999995,False,False,False,,,,,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) var = true; final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) var = true; final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { try { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); } catch (Exception e) { throw e; } }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { try { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); } catch (Exception e) { throw e; } }",,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); if (expected != actual) { assertEquals(expected,actual); } }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); if (expected != actual) { assertEquals(expected, actual); } }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> expected = Collections.unmodifiableList(<START> IntStream.range(0, 4).boxed().collect(Collectors.toList())); <END> final List<Integer> list = ListOps.concat(expected, EMPTY_LIST); final List<Integer> actual = IntStream.range(0, 4).boxed().collect(Collectors.toList()); assertNotNull(list); assertFalse(list.isEmpty()); assertEquals(actual, list); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> expected = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> list = ListOps.concat(expected, EMPTY_LIST); final List<Integer> actual = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(list); assertFalse(list.isEmpty()); assertEquals(actual, list); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> hwkpf = Collections.unmodifiableList(<START> IntStream.range(0, 4).boxed().collect(Collectors.toList())); <END> final List<Integer> hqdlo = ListOps.concat(hwkpf, EMPTY_LIST); final List<Integer> mpxju = IntStream.range(0, 4).boxed().collect(Collectors.toList()); assertNotNull(hqdlo); assertFalse(hqdlo.isEmpty()); assertEquals(mpxju, hqdlo); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> hwkpf = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> hqdlo = ListOps.concat(hwkpf, EMPTY_LIST); final List<Integer> mpxju = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(hqdlo); assertFalse(hqdlo.isEmpty()); assertEquals(mpxju, hqdlo); }",,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); List<Integer> chewz = Collections.unmodifiableList( IntStream.range(0,4).boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(chewz,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); List<Integer> chewz = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(chewz, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","1- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
2- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4))); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
3- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0,4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0,4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
4- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 6, 7)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
5- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
6- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0,1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
7- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
8- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
9- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 2, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }
10- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }",0
1556,public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START> assertFalse(ls.isDisplayECPolicy()); <END> },"public class DummyClass {
    public void processOptionsNone() throws IOException {
        LinkedList<String> options = new LinkedList<String>();
        Ls ls = new Ls();
        ls.processOptions(options);
        assertFalse(ls.isPathOnly());
        assertTrue(ls.isDirRecurse());
        assertFalse(ls.isHumanReadable());
        assertFalse(ls.isRecursive());
        assertFalse(ls.isOrderReverse());
        assertFalse(ls.isOrderSize());
        assertFalse(ls.isOrderTime());
        assertFalse(ls.isUseAtime());
        assertFalse(ls.isDisplayECPolicy());
    }
}",This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); },"public class DummyClass {
    public void processOptionsNone() throws IOException {
        LinkedList<String> options = new LinkedList<String>();
        Ls ls = new Ls();
        ls.processOptions(options);
        assertFalse(ls.isPathOnly());
        assertTrue(ls.isDirRecurse());
        assertFalse(ls.isHumanReadable());
        assertFalse(ls.isRecursive());
        assertFalse(ls.isOrderReverse());
        assertFalse(ls.isOrderSize());
        assertFalse(ls.isOrderTime());
        assertFalse(ls.isUseAtime());
    }
}","['public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); assertFalse(ls.isDisplayECPolicy()); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); assertTrue(ls.isDisplayECPolicy()); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); { assertFalse(ls.isDisplayECPolicy()); } }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertTrue(ls.isUseAtime()); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); if (ls.isUseAtime()) { assertFalse(ls.isDisplayECPolicy()); } }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime());""); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime());); }', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime());', 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); }']",True,0,0,26,63,1,1.0,0.999999995,False,False,False,,,,,,,"public void processOptionsNone() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START>assertFalse(ls.isDisplayECPolicy());<END> }",This is EC policy patch again. I abfs needs all,"public void processOptionsNone() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); }",public void processOptionsNone() throws IOException { boolean var = false; if (var) var = true; LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START>assertFalse(ls.isDisplayECPolicy());<END> },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { boolean var = false; if (var) var = true; LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); },public void processOptionsNone() throws IOException { try { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START>assertFalse(ls.isDisplayECPolicy());<END> } catch (Exception e) { throw e; } },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { try { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); } catch (Exception e) { throw e; } },,,,,,,,,,public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isDisplayECPolicy()) { <START>assertFalse(ls.isDisplayECPolicy());<END> } },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } },public void processOptionsNone() throws IOException { LinkedList<String> ls = new LinkedList<String>(); Ls options = new Ls(); options.processOptions(ls); assertFalse(options.isPathOnly()); assertTrue(options.isDirRecurse()); assertFalse(options.isHumanReadable()); assertFalse(options.isRecursive()); assertFalse(options.isOrderReverse()); assertFalse(options.isOrderSize()); assertFalse(options.isOrderTime()); assertFalse(options.isUseAtime()); <START> assertFalse(options.isDisplayECPolicy()); <END> },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { LinkedList<String> ls = new LinkedList<String>(); Ls options = new Ls(); options.processOptions(ls); assertFalse(options.isPathOnly()); assertTrue(options.isDirRecurse()); assertFalse(options.isHumanReadable()); assertFalse(options.isRecursive()); assertFalse(options.isOrderReverse()); assertFalse(options.isOrderSize()); assertFalse(options.isOrderTime()); assertFalse(options.isUseAtime()); },public void processOptionsNone() throws IOException { LinkedList<String> ibenj = new LinkedList<String>(); Ls swjtl = new Ls(); swjtl.processOptions(ibenj); assertFalse(swjtl.isPathOnly()); assertTrue(swjtl.isDirRecurse()); assertFalse(swjtl.isHumanReadable()); assertFalse(swjtl.isRecursive()); assertFalse(swjtl.isOrderReverse()); assertFalse(swjtl.isOrderSize()); assertFalse(swjtl.isOrderTime()); assertFalse(swjtl.isUseAtime()); <START> assertFalse(swjtl.isDisplayECPolicy()); <END> },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { LinkedList<String> ibenj = new LinkedList<String>(); Ls swjtl = new Ls(); swjtl.processOptions(ibenj); assertFalse(swjtl.isPathOnly()); assertTrue(swjtl.isDirRecurse()); assertFalse(swjtl.isHumanReadable()); assertFalse(swjtl.isRecursive()); assertFalse(swjtl.isOrderReverse()); assertFalse(swjtl.isOrderSize()); assertFalse(swjtl.isOrderTime()); assertFalse(swjtl.isUseAtime()); },public void processOptionsNone() throws IOException { Ls ls = new Ls(); LinkedList<String> options = new LinkedList<String>(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START>assertFalse(ls.isDisplayECPolicy());<END> },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { Ls ls = new Ls(); LinkedList<String> options = new LinkedList<String>(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); },public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); LinkedList<String> zvqgz = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(zvqgz); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START>assertFalse(ls.isDisplayECPolicy());<END> },This is EC policy patch again. I abfs needs all,public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); LinkedList<String> zvqgz = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(zvqgz); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); },"1- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }
2- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (!ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }
3- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if assertFalse(ls.isDisplayECPolicy()); }
4- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isUseECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }
5- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if(ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }
6- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } }
7- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } assertFalse(ls.isDisplayECPolicy()); }
8- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } {
9- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); LS ls = new Ls(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }
10- public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = newLs(); ls.processOptions(options); if (ls.isPathOnly()) { assertFalse(ls.isPathOnly()); } if (!ls.isDirRecurse()) { assertTrue(ls.isDirRecurse()); } if (ls.isHumanReadable()) { assertFalse(ls.isHumanReadable()); } if (ls.isRecursive()) { assertFalse(ls.isRecursive()); } if (ls.isOrderReverse()) { assertFalse(ls.isOrderReverse()); } if (ls.isOrderSize()) { assertFalse(ls.isOrderSize()); } if (ls.isOrderTime()) { assertFalse(ls.isOrderTime()); } if (ls.isUseAtime()) { assertFalse(ls.isUseAtime()); } if (ls.isDisplayECPolicy()) { assertFalse(ls.isDisplayECPolicy()); } }",1
1565,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START> expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); <END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public class DummyClass {
    public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception {
        String basedir = System.getProperty(""basedir"");
        if (basedir == null) {
            basedir = new File(""."").getCanonicalPath();
        }
        Path identityKeystorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks"");
        String identityKeystoreType = ""jks"";
        char[] identityKeystorePassword = ""horton"".toCharArray();
        char[] identityKeyPassphrase = ""horton"".toCharArray();
        String identityKeyAlias = ""server"";
        Path truststorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks"");
        String truststoreType = ""jks"";
        String truststorePasswordAlias = ""trust_store_password"";
        GatewayConfig config =
                createGatewayConfig(
                        true,
                        true,
                        identityKeystorePath,
                        identityKeystoreType,
                        identityKeyAlias,
                        truststorePath,
                        truststoreType,
                        truststorePasswordAlias);
        AliasService aliasService = createMock(AliasService.class);
        expect(aliasService.getGatewayIdentityKeystorePassword())
                .andReturn(identityKeystorePassword)
                .atLeastOnce();
        expect(aliasService.getGatewayIdentityPassphrase())
                .andReturn(identityKeyPassphrase)
                .atLeastOnce();
        expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password"")))
                .andReturn(null)
                .atLeastOnce();
        KeystoreService keystoreService = createMock(KeystoreService.class);
        replay(config, aliasService, keystoreService);
        JettySSLService sslService = new JettySSLService();
        sslService.setAliasService(aliasService);
        sslService.setKeystoreService(keystoreService);
        Object result = sslService.buildSslContextFactory(config);
        assertNotNull(result);
        assertTrue(result instanceof SslContextFactory);
        SslContextFactory sslContextFactory = (SslContextFactory) result;
        sslContextFactory.start();
        assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath());
        assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType());
        assertNotNull(sslContextFactory.getKeyStore());
        assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath());
        assertEquals(truststoreType, sslContextFactory.getTrustStoreType());
        assertNotNull(sslContextFactory.getTrustStore());
        assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias));
        assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias));
        verify(config, aliasService, keystoreService);
    }
}",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public class DummyClass {
    public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception {
        String basedir = System.getProperty(""basedir"");
        if (basedir == null) {
            basedir = new File(""."").getCanonicalPath();
        }
        Path identityKeystorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks"");
        String identityKeystoreType = ""jks"";
        char[] identityKeystorePassword = ""horton"".toCharArray();
        char[] identityKeyPassphrase = ""horton"".toCharArray();
        String identityKeyAlias = ""server"";
        Path truststorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks"");
        String truststoreType = ""jks"";
        String truststorePasswordAlias = ""trust_store_password"";
        GatewayConfig config =
                createGatewayConfig(
                        true,
                        true,
                        identityKeystorePath,
                        identityKeystoreType,
                        identityKeyAlias,
                        truststorePath,
                        truststoreType,
                        truststorePasswordAlias);
        AliasService aliasService = createMock(AliasService.class);
        expect(aliasService.getGatewayIdentityKeystorePassword())
                .andReturn(identityKeystorePassword)
                .atLeastOnce();
        expect(aliasService.getGatewayIdentityPassphrase())
                .andReturn(identityKeyPassphrase)
                .atLeastOnce();
        expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias)))
                .andReturn(null)
                .atLeastOnce();
        KeystoreService keystoreService = createMock(KeystoreService.class);
        replay(config, aliasService, keystoreService);
        JettySSLService sslService = new JettySSLService();
        sslService.setAliasService(aliasService);
        sslService.setKeystoreService(keystoreService);
        Object result = sslService.buildSslContextFactory(config);
        assertNotNull(result);
        assertTrue(result instanceof SslContextFactory);
        SslContextFactory sslContextFactory = (SslContextFactory) result;
        sslContextFactory.start();
        assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath());
        assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType());
        assertNotNull(sslContextFactory.getKeyStore());
        assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath());
        assertEquals(truststoreType, sslContextFactory.getTrustStoreType());
        assertNotNull(sslContextFactory.getTrustStore());
        assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias));
        assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias));
        verify(config, aliasService, keystoreService);
    }
}","['public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststore"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststorePasswordAlias"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststoreUsername"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststorePath"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststore"".toString(), sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststore Path.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService);', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias())); verify(config, aliasService, keystoreService); }']",True,0,0,35,35,2,1.0,0.999999995,False,False,False,,,,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (!(basedir == null)) { } else { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).<START> andReturn(identityKeystorePassword).<END> atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (!(basedir == null)) { } else { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) var = true; String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) var = true; String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { try { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); } catch (Exception e) { throw e; } }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { try { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); } catch (Exception e) { throw e; } }",,,,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); if (identityKeystorePath.toUri().toString() != sslContextFactory.getKeyStorePath()) { assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); } if (identityKeystoreType != sslContextFactory.getKeyStoreType()) { assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); } assertNotNull(sslContextFactory.getKeyStore()); if (truststorePath.toUri().toString() != sslContextFactory.getTrustStorePath()) { assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); } if (truststoreType != sslContextFactory.getTrustStoreType()) { assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); } assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); if (identityKeystorePath.toUri().toString() != sslContextFactory.getKeyStorePath()) { assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); } if (identityKeystoreType != sslContextFactory.getKeyStoreType()) { assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); } assertNotNull(sslContextFactory.getKeyStore()); if (truststorePath.toUri().toString() != sslContextFactory.getTrustStorePath()) { assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); } if (truststoreType != sslContextFactory.getTrustStoreType()) { assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); } assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); } verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); } verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String identityKeyPassphrase = System.getProperty(""sslContextFactory""); if (identityKeyPassphrase == null) { identityKeyPassphrase = new File(""."").getCanonicalPath(); } Path config = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] basedir = ""horton"".toCharArray(); char[] aliasService = ""horton"".toCharArray(); String identityKeystorePassword = ""server""; Path truststorePath = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststorePasswordAlias = ""jks""; String identityKeystorePath = ""trust_store_password""; GatewayConfig sslService = createGatewayConfig(true, true, config, identityKeystoreType, identityKeystorePassword, truststorePath, truststorePasswordAlias, identityKeystorePath); AliasService sslContextFactory = createMock(AliasService.class); expect(sslContextFactory.getGatewayIdentityKeystorePassword()).<START> andReturn(basedir).<END> atLeastOnce(); expect(sslContextFactory.getGatewayIdentityPassphrase()).andReturn(aliasService).atLeastOnce(); expect(sslContextFactory.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService truststoreType = createMock(KeystoreService.class); replay(sslService, sslContextFactory, truststoreType); JettySSLService keystoreService = new JettySSLService(); keystoreService.setAliasService(sslContextFactory); keystoreService.setKeystoreService(truststoreType); Object identityKeyAlias = keystoreService.buildSslContextFactory(sslService); assertNotNull(identityKeyAlias); assertTrue(identityKeyAlias instanceof SslContextFactory); SslContextFactory result = (SslContextFactory) identityKeyAlias; result.start(); assertEquals(config.toUri().toString(), result.getKeyStorePath()); assertEquals(identityKeystoreType, result.getKeyStoreType()); assertNotNull(result.getKeyStore()); assertEquals(truststorePath.toUri().toString(), result.getTrustStorePath()); assertEquals(truststorePasswordAlias, result.getTrustStoreType()); assertNotNull(result.getTrustStore()); assertTrue(result.getKeyStore().containsAlias(identityKeystorePassword)); assertFalse(result.getTrustStore().containsAlias(identityKeystorePassword)); verify(sslService, sslContextFactory, truststoreType); }",I this keystoreService instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String identityKeyPassphrase = System.getProperty(""sslContextFactory""); if (identityKeyPassphrase == null) { identityKeyPassphrase = new File(""."").getCanonicalPath(); } Path config = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] basedir = ""horton"".toCharArray(); char[] aliasService = ""horton"".toCharArray(); String identityKeystorePassword = ""server""; Path truststorePath = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststorePasswordAlias = ""jks""; String identityKeystorePath = ""trust_store_password""; GatewayConfig sslService = createGatewayConfig(true, true, config, identityKeystoreType, identityKeystorePassword, truststorePath, truststorePasswordAlias, identityKeystorePath); AliasService sslContextFactory = createMock(AliasService.class); expect(sslContextFactory.getGatewayIdentityKeystorePassword()).andReturn(basedir).atLeastOnce(); expect(sslContextFactory.getGatewayIdentityPassphrase()).andReturn(aliasService).atLeastOnce(); expect(sslContextFactory.getPasswordFromAliasForGateway(eq(identityKeystorePath))).andReturn(null).atLeastOnce(); KeystoreService truststoreType = createMock(KeystoreService.class); replay(sslService, sslContextFactory, truststoreType); JettySSLService keystoreService = new JettySSLService(); keystoreService.setAliasService(sslContextFactory); keystoreService.setKeystoreService(truststoreType); Object identityKeyAlias = keystoreService.buildSslContextFactory(sslService); assertNotNull(identityKeyAlias); assertTrue(identityKeyAlias instanceof SslContextFactory); SslContextFactory result = (SslContextFactory) identityKeyAlias; result.start(); assertEquals(config.toUri().toString(), result.getKeyStorePath()); assertEquals(identityKeystoreType, result.getKeyStoreType()); assertNotNull(result.getKeyStore()); assertEquals(truststorePath.toUri().toString(), result.getTrustStorePath()); assertEquals(truststorePasswordAlias, result.getTrustStoreType()); assertNotNull(result.getTrustStore()); assertTrue(result.getKeyStore().containsAlias(identityKeystorePassword)); assertFalse(result.getTrustStore().containsAlias(identityKeystorePassword)); verify(sslService, sslContextFactory, truststoreType); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String pvpmd = System.getProperty(""basedir""); if (pvpmd == null) { pvpmd = new File(""."").getCanonicalPath(); } Path butbs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String vsxmh = ""jks""; char[] bvgnw = ""horton"".toCharArray(); char[] xbqgd = ""horton"".toCharArray(); String uhrak = ""server""; Path ivdhs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String sezxr = ""jks""; String gisls = ""trust_store_password""; GatewayConfig pyyqn = createGatewayConfig(true, true, butbs, vsxmh, uhrak, ivdhs, sezxr, gisls); AliasService sfffi = createMock(AliasService.class); expect(sfffi.getGatewayIdentityKeystorePassword()).<START> andReturn(bvgnw).<END> atLeastOnce(); expect(sfffi.getGatewayIdentityPassphrase()).andReturn(xbqgd).atLeastOnce(); expect(sfffi.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService xoxpb = createMock(KeystoreService.class); replay(pyyqn, sfffi, xoxpb); JettySSLService tshda = new JettySSLService(); tshda.setAliasService(sfffi); tshda.setKeystoreService(xoxpb); Object wwrwv = tshda.buildSslContextFactory(pyyqn); assertNotNull(wwrwv); assertTrue(wwrwv instanceof SslContextFactory); SslContextFactory uzvxd = (SslContextFactory) wwrwv; uzvxd.start(); assertEquals(butbs.toUri().toString(), uzvxd.getKeyStorePath()); assertEquals(vsxmh, uzvxd.getKeyStoreType()); assertNotNull(uzvxd.getKeyStore()); assertEquals(ivdhs.toUri().toString(), uzvxd.getTrustStorePath()); assertEquals(sezxr, uzvxd.getTrustStoreType()); assertNotNull(uzvxd.getTrustStore()); assertTrue(uzvxd.getKeyStore().containsAlias(uhrak)); assertFalse(uzvxd.getTrustStore().containsAlias(uhrak)); verify(pyyqn, sfffi, xoxpb); }",I this gisls instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String pvpmd = System.getProperty(""basedir""); if (pvpmd == null) { pvpmd = new File(""."").getCanonicalPath(); } Path butbs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String vsxmh = ""jks""; char[] bvgnw = ""horton"".toCharArray(); char[] xbqgd = ""horton"".toCharArray(); String uhrak = ""server""; Path ivdhs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String sezxr = ""jks""; String gisls = ""trust_store_password""; GatewayConfig pyyqn = createGatewayConfig(true, true, butbs, vsxmh, uhrak, ivdhs, sezxr, gisls); AliasService sfffi = createMock(AliasService.class); expect(sfffi.getGatewayIdentityKeystorePassword()).andReturn(bvgnw).atLeastOnce(); expect(sfffi.getGatewayIdentityPassphrase()).andReturn(xbqgd).atLeastOnce(); expect(sfffi.getPasswordFromAliasForGateway(eq(gisls))).andReturn(null).atLeastOnce(); KeystoreService xoxpb = createMock(KeystoreService.class); replay(pyyqn, sfffi, xoxpb); JettySSLService tshda = new JettySSLService(); tshda.setAliasService(sfffi); tshda.setKeystoreService(xoxpb); Object wwrwv = tshda.buildSslContextFactory(pyyqn); assertNotNull(wwrwv); assertTrue(wwrwv instanceof SslContextFactory); SslContextFactory uzvxd = (SslContextFactory) wwrwv; uzvxd.start(); assertEquals(butbs.toUri().toString(), uzvxd.getKeyStorePath()); assertEquals(vsxmh, uzvxd.getKeyStoreType()); assertNotNull(uzvxd.getKeyStore()); assertEquals(ivdhs.toUri().toString(), uzvxd.getTrustStorePath()); assertEquals(sezxr, uzvxd.getTrustStoreType()); assertNotNull(uzvxd.getTrustStore()); assertTrue(uzvxd.getKeyStore().containsAlias(uhrak)); assertFalse(uzvxd.getTrustStore().containsAlias(uhrak)); verify(pyyqn, sfffi, xoxpb); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } String identityKeystoreType = ""jks""; Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } String identityKeystoreType = ""jks""; Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); String ennne = System.getProperty(""basedir""); if (ennne == null) { ennne = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(ennne,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(ennne,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); String ennne = System.getProperty(""basedir""); if (ennne == null) { ennne = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(ennne, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(ennne, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","1- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore
2- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().contains
3- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce();expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().contains
4- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce();expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore
5- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); verify(config,aliasService,keystoreService); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); } verify(config,aliasService,keystore
6- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); mock(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().contains
7- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword).timesOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().
8- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore
9- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); assertNull(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().
10- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expectedException.expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory",0
1576,"public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client client = ResteasyClientBuilder.newClient(); <END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","public class DummyClass {
    public void testOneway() throws Exception {
        latch = new CountDownLatch(1);
        Client client = ResteasyClientBuilder.newClient();
        WebTarget target =
                client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true"");
        long start = System.currentTimeMillis();
        Response response = target.request().put(Entity.entity(""content"", ""text/plain""));
        long end = System.currentTimeMillis() - start;
        Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());
        Assert.assertTrue(end < 1000);
        Assert.assertTrue(latch.await(2, TimeUnit.SECONDS));
        response.close();
    }
}","above, client needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","public class DummyClass {
    public void testOneway() throws Exception {
        latch = new CountDownLatch(1);
        WebTarget target =
                client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true"");
        long start = System.currentTimeMillis();
        Response response = target.request().put(Entity.entity(""content"", ""text/plain""));
        long end = System.currentTimeMillis() - start;
        Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus());
        Assert.assertTrue(end < 1000);
        Assert.assertTrue(latch.await(2, TimeUnit.SECONDS));
        response.close();
    }
}","['public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); client.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); System.out.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); safeClose(response); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); System.close(client); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); System.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }', 'public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = }']",True,7,0,26,77,3,1.0,0.999999995,False,False,False,"public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client client = ResteasyClientBuilder.newClient(); <END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","above, client needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }",,,,"public void testOneway() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); latch = new CountDownLatch(1); <START>Client client = ResteasyClientBuilder.newClient();<END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); response.close(); }","above, client needs closed","public void testOneway() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","public void testOneway() throws Exception { boolean var = false; if (var) var = true; latch = new CountDownLatch(1); <START>Client client = ResteasyClientBuilder.newClient();<END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); response.close(); }","above, client needs closed","public void testOneway() throws Exception { boolean var = false; if (var) var = true; latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","public void testOneway() throws Exception { try { latch = new CountDownLatch(1); <START>Client client = ResteasyClientBuilder.newClient();<END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); response.close(); } catch (Exception e) { throw e; } }","above, client needs closed","public void testOneway() throws Exception { try { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); } catch (Exception e) { throw e; } }",,,,,,,"public void testOneway() throws Exception { latch = new CountDownLatch(1); <START>Client client = ResteasyClientBuilder.newClient();<END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; if (HttpServletResponse.SC_ACCEPTED != response.getStatus()) { Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); } Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); response.close(); }","above, client needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; if (HttpServletResponse.SC_ACCEPTED != response.getStatus()) { Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); } Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","public void testOneway() throws Exception { latch = new CountDownLatch(1); <START>Client client = ResteasyClientBuilder.newClient();<END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }","above, client needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2, TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); } response.close(); }","public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client start = ResteasyClientBuilder.newClient(); <END> WebTarget client = start.client(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long end = System.currentTimeMillis(); Response target = client.request().put(Entity.entity(""content"", ""text/plain"")); long response = System.currentTimeMillis() - end; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, target.getStatus()); Assert.assertTrue(response < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); target.close(); }","above, start needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget client = start.client(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long end = System.currentTimeMillis(); Response target = client.request().put(Entity.entity(""content"", ""text/plain"")); long response = System.currentTimeMillis() - end; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, target.getStatus()); Assert.assertTrue(response < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); target.close(); }","public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client llxgh = ResteasyClientBuilder.newClient(); <END> WebTarget sxwwe = llxgh.sxwwe(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long dawjn = System.currentTimeMillis(); Response clzbe = sxwwe.request().put(Entity.entity(""content"", ""text/plain"")); long qibnu = System.currentTimeMillis() - dawjn; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, clzbe.getStatus()); Assert.assertTrue(qibnu < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); clzbe.close(); }","above, llxgh needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget sxwwe = llxgh.sxwwe(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long dawjn = System.currentTimeMillis(); Response clzbe = sxwwe.request().put(Entity.entity(""content"", ""text/plain"")); long qibnu = System.currentTimeMillis() - dawjn; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, clzbe.getStatus()); Assert.assertTrue(qibnu < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); clzbe.close(); }",,,,"public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); <START>Client tbpdu = ResteasyClientBuilder.newClient();<END> WebTarget target = tbpdu.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); response.close(); }","above, client needs closed","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); WebTarget tbpdu = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = tbpdu.request().put(Entity.entity(""content"", ""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","1- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
2- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } client.close(); }
3- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
4- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); } response.close(); }
5- public void testOneway() throws Exception { latch = new CountDownLatch(1);Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
6- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2, TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
7- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } }
8- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
9- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } assertTrue(latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }
10- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder().newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"",""text/plain"")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED,response.getStatus()); if (end >= 1000) { Assert.assertTrue(end < 1000); } if (!latch.await(2,TimeUnit.SECONDS)) { Assert.assertTrue(latch.await(2,TimeUnit.SECONDS)); } response.close(); }",0
1604,"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START> g1.setProperty(""group"", ""members"", Arrays.asList(""user1"")); <END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","public class DummyClass {
    public void testGetPrincipalWithoutReferences() throws Exception {
        DocumentModel u1 = getUser(""user1"");
        userManager.createUser(u1);
        DocumentModel g1 = getGroup(""group1"");
        g1.setProperty(""group"", ""members"", Arrays.asList(""user1""));
        userManager.createGroup(g1);
        DocumentModel g2 = getGroup(""group2"");
        g2.setProperty(""group"", ""members"", Arrays.asList(""user1""));
        userManager.createGroup(g2);
        NuxeoPrincipal principal1 = userManager.getPrincipal(""user1"");
        assertEquals(3, principal1.getAllGroups().size());
        principal1 = userManager.getPrincipal(""user1"", false);
        assertEquals(1, principal1.getAllGroups().size());
        assertTrue(principal1.isMemberOf(""defgr""));
        assertFalse(principal1.isMemberOf(""group1""));
    }
}",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","public class DummyClass {
    public void testGetPrincipalWithoutReferences() throws Exception {
        DocumentModel u1 = getUser(""user1"");
        userManager.createUser(u1);
        DocumentModel g1 = getGroup(""group1"");
        g1.setProperty(""group"", ""members"", List.of(""user1""));
        userManager.createGroup(g1);
        DocumentModel g2 = getGroup(""group2"");
        g2.setProperty(""group"", ""members"", List.of(""user1""));
        userManager.createGroup(g2);
        NuxeoPrincipal principal1 = userManager.getPrincipal(""user1"");
        assertEquals(3, principal1.getAllGroups().size());
        principal1 = userManager.getPrincipal(""user1"", false);
        assertEquals(1, principal1.getAllGroups().size());
        assertTrue(principal1.isMemberOf(""defgr""));
        assertFalse(principal1.isMemberOf(""group1""));
    }
}","['public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", Lists.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Lists.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Lists.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Collections.singletonList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", list(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", list(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", list.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", Lists.newArrayList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", Lists.newArrayList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"",List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }', 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", Lists.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }']",True,0,0,38,50,2,1.0,0.999999995,False,False,False,,,,,,,"public void testGetPrincipalWithoutReferences() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","public void testGetPrincipalWithoutReferences() throws Exception { boolean var = false; if (var) var = true; DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { boolean var = false; if (var) var = true; DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","public void testGetPrincipalWithoutReferences() throws Exception { try { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); } catch (Exception e) { throw e; } }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { try { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); } catch (Exception e) { throw e; } }",,,,,,,"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); if (3 != principal1.getAllGroups().size()) { assertEquals(3,principal1.getAllGroups().size()); } principal1 = userManager.getPrincipal(""user1"",false); if (1 != principal1.getAllGroups().size()) { assertEquals(1,principal1.getAllGroups().size()); } assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); if (3 != principal1.getAllGroups().size()) { assertEquals(3, principal1.getAllGroups().size()); } principal1 = userManager.getPrincipal(""user1"", false); if (1 != principal1.getAllGroups().size()) { assertEquals(1, principal1.getAllGroups().size()); } assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }","public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel principal1 = getUser(""user1""); userManager.createUser(principal1); DocumentModel g2 = getGroup(""group1""); <START> g2.setProperty(""group"", ""members"", Arrays.asList(""user1"")); <END> userManager.createGroup(g2); DocumentModel u1 = getGroup(""group2""); u1.setProperty(""group"", ""members"", Arrays.asList(""user1"")); userManager.createGroup(u1); NuxeoPrincipal g1 = userManager.getPrincipal(""user1""); assertEquals(3, g1.getAllGroups().size()); g1 = userManager.getPrincipal(""user1"", false); assertEquals(1, g1.getAllGroups().size()); assertTrue(g1.isMemberOf(""defgr"")); assertFalse(g1.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel principal1 = getUser(""user1""); userManager.createUser(principal1); DocumentModel g2 = getGroup(""group1""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); DocumentModel u1 = getGroup(""group2""); u1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(u1); NuxeoPrincipal g1 = userManager.getPrincipal(""user1""); assertEquals(3, g1.getAllGroups().size()); g1 = userManager.getPrincipal(""user1"", false); assertEquals(1, g1.getAllGroups().size()); assertTrue(g1.isMemberOf(""defgr"")); assertFalse(g1.isMemberOf(""group1"")); }","public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel gavre = getUser(""user1""); userManager.createUser(gavre); DocumentModel gescu = getGroup(""group1""); <START> gescu.setProperty(""group"", ""members"", Arrays.asList(""user1"")); <END> userManager.createGroup(gescu); DocumentModel nzsuu = getGroup(""group2""); nzsuu.setProperty(""group"", ""members"", Arrays.asList(""user1"")); userManager.createGroup(nzsuu); NuxeoPrincipal dnpyk = userManager.getPrincipal(""user1""); assertEquals(3, dnpyk.getAllGroups().size()); dnpyk = userManager.getPrincipal(""user1"", false); assertEquals(1, dnpyk.getAllGroups().size()); assertTrue(dnpyk.isMemberOf(""defgr"")); assertFalse(dnpyk.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel gavre = getUser(""user1""); userManager.createUser(gavre); DocumentModel gescu = getGroup(""group1""); gescu.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(gescu); DocumentModel nzsuu = getGroup(""group2""); nzsuu.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(nzsuu); NuxeoPrincipal dnpyk = userManager.getPrincipal(""user1""); assertEquals(3, dnpyk.getAllGroups().size()); dnpyk = userManager.getPrincipal(""user1"", false); assertEquals(1, dnpyk.getAllGroups().size()); assertTrue(dnpyk.isMemberOf(""defgr"")); assertFalse(dnpyk.isMemberOf(""group1"")); }",,,,"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); DocumentModel zxoga = getUser(""user1""); userManager.createUser(zxoga); DocumentModel g1 = getGroup(""group1""); <START>g1.setProperty(""group"",""members"",Arrays.asList(""user1""));<END> userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }",List.of(...),"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); DocumentModel zxoga = getUser(""user1""); userManager.createUser(zxoga); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"", ""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(""defgr"")); assertFalse(principal1.isMemberOf(""group1"")); }","1- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1"");g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
2- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
3- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1"");g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
4- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1"");g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
5- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
6- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
7- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
8- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1"");g1.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"", List.of(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
9- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1"");g1.setProperty(""group"",""members"", Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }
10- public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(""user1""); userManager.createUser(u1); DocumentModel g1 = getGroup(""group1""); g1.setProperty(""group"",""members"", Arrays.asList(""user1"")); userManager.createGroup(g1); DocumentModel g2 = getGroup(""group2""); g2.setProperty(""group"",""members"",Arrays.asList(""user1"")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(""user1""); assertEquals(3,principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(""user1"",false); assertEquals(1,principal1.getAllGroups().size()); if (!principal1.isMemberOf(""defgr"")) { assertTrue(principal1.isMemberOf(""defgr"")); } if (principal1.isMemberOf(""group1"")) { assertFalse(principal1.isMemberOf(""group1"")); } }",0
1621,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). <START> when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); <END> doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class)); }","public class DummyClass {
    public void validateSpaceNotEnough() throws Exception {
        AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
        doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
        doReturn(
                        new ValidationResult(
                                VdcBllMessages
                                        .ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN))
                .when(storageDomainValidator)
                .hasSpaceForNewDisks(any(List.class));
        doReturn(storageDomainValidator)
                .when(command)
                .createStorageDomainValidator(any(StorageDomain.class));
        assertFalse(command.validateSpaceRequirements());
        verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class));
        verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class));
    }
}",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }","public class DummyClass {
    public void validateSpaceNotEnough() throws Exception {
        AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
        doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
        doReturn(
                        new ValidationResult(
                                VdcBllMessages
                                        .ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN))
                .when(storageDomainValidator)
                .hasSpaceForNewDisks(anyList());
        doReturn(storageDomainValidator)
                .when(command)
                .createStorageDomainValidator(any(StorageDomain.class));
        assertFalse(command.validateSpaceRequirements());
        verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
        verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
    }
}","['public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator). hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()). hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator). isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { addVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList())); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }', 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); return; }']",True,0,0,47,47,6,1.0,0.999999995,False,False,False,,,,,,,"public void validateSpaceNotEnough() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).<START>when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));<END> doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(any(List.class)); }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }","public void validateSpaceNotEnough() throws Exception { boolean var = false; if (var) var = true; AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).<START>when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));<END> doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(any(List.class)); }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { boolean var = false; if (var) var = true; AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }","public void validateSpaceNotEnough() throws Exception { try { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).<START>when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));<END> doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(any(List.class)); } catch (Exception e) { throw e; } }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { try { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).<START>when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));<END> doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(any(List.class)); }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }",,,,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> bmsig = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new <START> ValidationResult(<END> VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); doReturn(storageDomainValidator).when(bmsig).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(bmsig.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class)); }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> bmsig = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(bmsig).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(bmsig.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }",,,,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); AddVmCommand<VmManagementParametersBase> rujxk = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).<START>when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));<END> doReturn(storageDomainValidator).when(rujxk).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(rujxk.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(any(List.class)); }",s/any(List.class)/anyList/,"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); AddVmCommand<VmManagementParametersBase> rujxk = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(rujxk).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(rujxk.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }","1- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList.class)); }
2- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList.class); }
3- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList()); }
4- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList); }
5- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList(List.class)); }
6- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyListList()); }
7- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList.class)); }
8- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyListList); }
9- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList.class)); }
10- public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0,0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult( VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); if (command.validateSpaceRequirements()) { assertFalse(command.validateSpaceRequirements()); } verify(storageDomainValidator).hasSpaceForNewDisks(anyList); verify(storageDomainValidator,never()).hasSpaceForClonedDisks(anyList.class); }",0
1631,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"") ) { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } else if (storageType.equals(""RAM_DISK"")) { <START> assertEquals(7L, storageTypeStats.get(""nodesInService"")); <END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public class DummyClass {
    public void testStorageTypeStatsJMX() throws Exception {
        URL baseUrl = new URL(cluster.getHttpUri(0));
        String result = readOutput(new URL(baseUrl, ""/jmx""));
        Map<String, Object> stat = (Map<String, Object>) JSON.parse(result);
        Object[] beans = (Object[]) stat.get(""beans"");
        Map<String, Object> blockStats = null;
        for (Object bean : beans) {
            Map<String, Object> map = (Map<String, Object>) bean;
            if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) {
                blockStats = map;
            }
        }
        assertNotNull(blockStats);
        Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats"");
        assertNotNull(storageTypeStatsList);
        assertEquals(4, storageTypeStatsList.length);
        Set<String> typesPresent = new HashSet<>();
        for (Object obj : storageTypeStatsList) {
            Map<String, Object> entry = (Map<String, Object>) obj;
            String storageType = (String) entry.get(""key"");
            Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value"");
            typesPresent.add(storageType);
            if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) {
                assertEquals(3L, storageTypeStats.get(""nodesInService""));
            } else if (storageType.equals(""RAM_DISK"")) {
                assertEquals(7L, storageTypeStats.get(""nodesInService""));
            } else if (storageType.equals(""NVDIMM"")) {
                assertEquals(1L, storageTypeStats.get(""nodesInService""));
            } else {
                fail();
            }
        }
        assertTrue(typesPresent.contains(""ARCHIVE""));
        assertTrue(typesPresent.contains(""DISK""));
        assertTrue(typesPresent.contains(""RAM_DISK""));
        assertTrue(typesPresent.contains(""NVDIMM""));
    }
}","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public class DummyClass {
    public void testStorageTypeStatsJMX() throws Exception {
        URL baseUrl = new URL(cluster.getHttpUri(0));
        String result = readOutput(new URL(baseUrl, ""/jmx""));
        Map<String, Object> stat = (Map<String, Object>) JSON.parse(result);
        Object[] beans = (Object[]) stat.get(""beans"");
        Map<String, Object> blockStats = null;
        for (Object bean : beans) {
            Map<String, Object> map = (Map<String, Object>) bean;
            if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) {
                blockStats = map;
            }
        }
        assertNotNull(blockStats);
        Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats"");
        assertNotNull(storageTypeStatsList);
        assertEquals(4, storageTypeStatsList.length);
        Set<String> typesPresent = new HashSet<>();
        for (Object obj : storageTypeStatsList) {
            Map<String, Object> entry = (Map<String, Object>) obj;
            String storageType = (String) entry.get(""key"");
            Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value"");
            typesPresent.add(storageType);
            switch (storageType) {
                case ""ARCHIVE"":
                case ""DISK"":
                    assertEquals(3L, storageTypeStats.get(""nodesInService""));
                    break;
                case ""RAM_DISK"":
                    assertEquals(7L, storageTypeStats.get(""nodesInService""));
                    break;
                case ""NVDIMM"":
                    assertEquals(1L, storageTypeStats.get(""nodesInService""));
                    break;
                default:
                    fail();
            }
        }
        assertTrue(typesPresent.contains(""ARCHIVE""));
        assertTrue(typesPresent.contains(""DISK""));
        assertTrue(typesPresent.contains(""RAM_DISK""));
        assertTrue(typesPresent.contains(""NVDIMM""));
    }
}","['public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + storageType); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj.toString()); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + storageType); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj.toString()); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }']",True,4,0,138,138,16,1.0,0.999999995,True,True,False,,,,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); if (!(storageType.equals(""ARCHIVE"") || storageType.equals(""DISK""))) { <START> if (!(<END> storageType.equals(""RAM_DISK""))) { if (!(storageType.equals(""NVDIMM""))) { fail(); } else { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } } else { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } } else { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (!(map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats""))) { } else { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) var = true; URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) var = true; URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { try { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } catch (Exception e) { throw e; } }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { try { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } catch (Exception e) { throw e; } }",,,,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); if (4 != storageTypeStatsList.length) { assertEquals(4,storageTypeStatsList.length); } Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { if (3L != storageTypeStats.get(""nodesInService"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } } else if ( storageType.equals(""RAM_DISK"")) { if (7L != storageTypeStats.get(""nodesInService"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } } else if (storageType.equals(""NVDIMM"")) { if (1L != storageTypeStats.get(""nodesInService"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); if (4 != storageTypeStatsList.length) { assertEquals(4, storageTypeStatsList.length); } Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": if (3L != storageTypeStats.get(""nodesInService"")) { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } break; case ""RAM_DISK"": if (7L != storageTypeStats.get(""nodesInService"")) { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } break; case ""NVDIMM"": if (1L != storageTypeStats.get(""nodesInService"")) { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } if (!typesPresent.contains(""ARCHIVE"")) { assertTrue(typesPresent.contains(""ARCHIVE"")); } if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } if (!typesPresent.contains(""ARCHIVE"")) { assertTrue(typesPresent.contains(""ARCHIVE"")); } if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }","public void testStorageTypeStatsJMX() throws Exception { URL bean = new URL(cluster.getHttpUri(0)); String baseUrl = readOutput(new URL(bean, ""/jmx"")); Map<String, Object> map = (Map<String, Object>) JSON.parse(baseUrl); Object[] result = (Object[]) map.get(""result""); Map<String, Object> obj = null; for (Object typesPresent : result) { Map<String, Object> storageTypeStatsList = (Map<String, Object>) typesPresent; if (storageTypeStatsList.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { obj = storageTypeStatsList; } } assertNotNull(obj); Object[] entry = (Object[]) obj.get(""StorageTypeStats""); assertNotNull(entry); assertEquals(4, entry.length); Set<String> beans = new HashSet<>(); for (Object storageType : entry) { Map<String, Object> storageTypeStats = (Map<String, Object>) storageType; String stat = (String) storageTypeStats.get(""key""); Map<String, Object> blockStats = (Map<String, Object>) storageTypeStats.get(""value""); beans.add(stat); if (stat.equals(""ARCHIVE"") || stat.equals(""DISK"")) { assertEquals(3L, blockStats.get(""nodesInService"")); } else <START> if (<END> stat.equals(""RAM_DISK"")) { assertEquals(7L, blockStats.get(""nodesInService"")); } else if (stat.equals(""NVDIMM"")) { assertEquals(1L, blockStats.get(""nodesInService"")); } else { fail(); } } assertTrue(beans.contains(""ARCHIVE"")); assertTrue(beans.contains(""DISK"")); assertTrue(beans.contains(""RAM_DISK"")); assertTrue(beans.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL bean = new URL(cluster.getHttpUri(0)); String baseUrl = readOutput(new URL(bean, ""/jmx"")); Map<String, Object> map = (Map<String, Object>) JSON.parse(baseUrl); Object[] result = (Object[]) map.get(""result""); Map<String, Object> obj = null; for (Object typesPresent : result) { Map<String, Object> storageTypeStatsList = (Map<String, Object>) typesPresent; if (storageTypeStatsList.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { obj = storageTypeStatsList; } } assertNotNull(obj); Object[] entry = (Object[]) obj.get(""StorageTypeStats""); assertNotNull(entry); assertEquals(4, entry.length); Set<String> beans = new HashSet<>(); for (Object storageType : entry) { Map<String, Object> storageTypeStats = (Map<String, Object>) storageType; String stat = (String) storageTypeStats.get(""key""); Map<String, Object> blockStats = (Map<String, Object>) storageTypeStats.get(""value""); beans.add(stat); switch(stat) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, blockStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, blockStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, blockStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(beans.contains(""ARCHIVE"")); assertTrue(beans.contains(""DISK"")); assertTrue(beans.contains(""RAM_DISK"")); assertTrue(beans.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL aoboc = new URL(cluster.getHttpUri(0)); String ccyhe = readOutput(new URL(aoboc, ""/jmx"")); Map<String, Object> nzedg = (Map<String, Object>) JSON.parse(ccyhe); Object[] hylhy = (Object[]) nzedg.get(""beans""); Map<String, Object> lpbec = null; for (Object fhzft : hylhy) { Map<String, Object> bsphv = (Map<String, Object>) fhzft; if (bsphv.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { lpbec = bsphv; } } assertNotNull(lpbec); Object[] qdiwj = (Object[]) lpbec.get(""StorageTypeStats""); assertNotNull(qdiwj); assertEquals(4, qdiwj.length); Set<String> prbdq = new HashSet<>(); for (Object rosve : qdiwj) { Map<String, Object> qbeym = (Map<String, Object>) rosve; String xqkfp = (String) qbeym.get(""key""); Map<String, Object> polqh = (Map<String, Object>) qbeym.get(""value""); prbdq.add(xqkfp); if (xqkfp.equals(""ARCHIVE"") || xqkfp.equals(""DISK"")) { assertEquals(3L, polqh.get(""nodesInService"")); } else <START> if (<END> xqkfp.equals(""RAM_DISK"")) { assertEquals(7L, polqh.get(""nodesInService"")); } else if (xqkfp.equals(""NVDIMM"")) { assertEquals(1L, polqh.get(""nodesInService"")); } else { fail(); } } assertTrue(prbdq.contains(""ARCHIVE"")); assertTrue(prbdq.contains(""DISK"")); assertTrue(prbdq.contains(""RAM_DISK"")); assertTrue(prbdq.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL aoboc = new URL(cluster.getHttpUri(0)); String ccyhe = readOutput(new URL(aoboc, ""/jmx"")); Map<String, Object> nzedg = (Map<String, Object>) JSON.parse(ccyhe); Object[] hylhy = (Object[]) nzedg.get(""beans""); Map<String, Object> lpbec = null; for (Object fhzft : hylhy) { Map<String, Object> bsphv = (Map<String, Object>) fhzft; if (bsphv.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { lpbec = bsphv; } } assertNotNull(lpbec); Object[] qdiwj = (Object[]) lpbec.get(""StorageTypeStats""); assertNotNull(qdiwj); assertEquals(4, qdiwj.length); Set<String> prbdq = new HashSet<>(); for (Object rosve : qdiwj) { Map<String, Object> qbeym = (Map<String, Object>) rosve; String xqkfp = (String) qbeym.get(""key""); Map<String, Object> polqh = (Map<String, Object>) qbeym.get(""value""); prbdq.add(xqkfp); switch(xqkfp) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, polqh.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, polqh.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, polqh.get(""nodesInService"")); break; default: fail(); } } assertTrue(prbdq.contains(""ARCHIVE"")); assertTrue(prbdq.contains(""DISK"")); assertTrue(prbdq.contains(""RAM_DISK"")); assertTrue(prbdq.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Map<String,Object> blockStats = null; Object[] beans = (Object[]) stat.get(""beans""); for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Map<String, Object> blockStats = null; Object[] beans = (Object[]) stat.get(""beans""); for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); URL poiwq = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(poiwq,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); URL poiwq = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(poiwq, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","1- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }
2- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L,storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L,storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }
3- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertEquals(typesPresent.contains(""DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""NVDIMM"")); }
4- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertEquals(""ARCHIVE"", storageType.contains(""DISK"")); assertEquals(""DISK"", storageType.contains(""DISK"")); assertEquals(""RAM_DISK"", storageTypeStats.contains(""RAM_DISK"")); assertEquals(""NVDIMM"", storageTypeStats.contains(""NVDIMM"")); }
5- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertEquals(""DISK"", storageType.contains(""DISK"")); assertEquals(""RAM_DISK"", storageTypeStats.contains(""RAM_DISK"")); assertEquals(""NVDIMM"", storageTypeStats.contains(""NVDIMM"")); }
6- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertEquals(typesPresent.contains(""DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }
7- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L,storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); }
8- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(1L, storageTypeStats.get(""nodesInService"")); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertEquals(""ARCHIVE"", storageType.equals(""ARCHIVE"")); assertEquals(typesPresent.contains(""DISK"")); assertEquals(""DISK"", storageType.contains(""DISK"")); assertEquals(""RAM_DISK"", storageTypeStats.contains(""RAM_DISK"")); assertEquals(""NVDIMM"", storageTypeStats.contains(""NVDIMM"")); }
9- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(1L, storageTypeStats.get(""nodesInService"")); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertEquals(7L, storageTypeStats.get(""ARCHIVE"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertEquals(typesPresent.contains(""DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""NVDIMM"")); }
10- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(1L, storageTypeStats.get(""nodesInService"")); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertEquals(2L, storageTypeStats.get(""ARCHIVE"")); assertEquals(2L, storageTypeStats.get(""ARCHIVE"")); }",0
1643,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", <START> PacketLineIn.DELIM, PacketLineIn.END); <END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","public class DummyClass {
    public void testV2LsRefs() throws Exception {
        RevCommit tip = remote.commit().message(""message"").create();
        remote.update(""master"", tip);
        server.updateRef(""HEAD"").link(""refs/heads/master"");
        RevTag tag = remote.tag(""tag"", tip);
        remote.update(""refs/tags/tag"", tag);
        ByteArrayInputStream recvStream =
                uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM, PacketLineIn.END);
        PacketLineIn pckIn = new PacketLineIn(recvStream);
        assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD""));
        assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master""));
        assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag""));
        assertTrue(pckIn.readString() == PacketLineIn.END);
    }
}",is DELIM needed here,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","public class DummyClass {
    public void testV2LsRefs() throws Exception {
        RevCommit tip = remote.commit().message(""message"").create();
        remote.update(""master"", tip);
        server.updateRef(""HEAD"").link(""refs/heads/master"");
        RevTag tag = remote.tag(""tag"", tip);
        remote.update(""refs/tags/tag"", tag);
        ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END);
        PacketLineIn pckIn = new PacketLineIn(recvStream);
        assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD""));
        assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master""));
        assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag""));
        assertTrue(pckIn.readString() == PacketLineIn.END);
    }
}","['public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.DELIM, PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.START); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.DELIMITER); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.DEFAULT); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.CLOSE); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.EXPIRE); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.CENTER); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }', 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\\n"", PacketLineIn.END, PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.end); }']",True,0,0,26,46,1,1.0,0.999999995,False,False,False,,,,,,,"public void testV2LsRefs() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"",<START>PacketLineIn.DELIM,PacketLineIn.END);<END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }",is DELIM needed here,"public void testV2LsRefs() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","public void testV2LsRefs() throws Exception { boolean var = false; if (var) var = true; RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"",<START>PacketLineIn.DELIM,PacketLineIn.END);<END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }",is DELIM needed here,"public void testV2LsRefs() throws Exception { boolean var = false; if (var) var = true; RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","public void testV2LsRefs() throws Exception { try { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"",<START>PacketLineIn.DELIM,PacketLineIn.END);<END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); } catch (Exception e) { throw e; } }",is DELIM needed here,"public void testV2LsRefs() throws Exception { try { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"",<START>PacketLineIn.DELIM,PacketLineIn.END);<END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }",is DELIM needed here,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"", tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", tip); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }","public void testV2LsRefs() throws Exception { RevCommit tag = remote.commit().message(""message"").create(); remote.update(""master"", tag); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag recvStream = remote.recvStream(""recvStream"", tag); remote.update(""refs/tags/recvStream"", recvStream); ByteArrayInputStream tip = uploadPackV2(""command=ls-refs\n"", <START> PacketLineIn.DELIM, PacketLineIn.END); <END> PacketLineIn pckIn = new PacketLineIn(tip); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(recvStream.toObjectId().getName() + "" refs/tags/recvStream"")); assertTrue(pckIn.readString() == PacketLineIn.END); }",is DELIM needed here,"public void testV2LsRefs() throws Exception { RevCommit tag = remote.commit().message(""message"").create(); remote.update(""master"", tag); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag recvStream = remote.recvStream(""recvStream"", tag); remote.update(""refs/tags/recvStream"", recvStream); ByteArrayInputStream tip = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(tip); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(recvStream.toObjectId().getName() + "" refs/tags/recvStream"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","public void testV2LsRefs() throws Exception { RevCommit jhywn = remote.commit().message(""message"").create(); remote.update(""master"", jhywn); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag clegj = remote.clegj(""tag"", jhywn); remote.update(""refs/tags/tag"", clegj); ByteArrayInputStream duxdj = uploadPackV2(""command=ls-refs\n"", <START> PacketLineIn.DELIM, PacketLineIn.END); <END> PacketLineIn zrfje = new PacketLineIn(duxdj); assertThat(zrfje.readString(), is(jhywn.toObjectId().getName() + "" HEAD"")); assertThat(zrfje.readString(), is(jhywn.toObjectId().getName() + "" refs/heads/master"")); assertThat(zrfje.readString(), is(clegj.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(zrfje.readString() == PacketLineIn.END); }",is DELIM needed here,"public void testV2LsRefs() throws Exception { RevCommit jhywn = remote.commit().message(""message"").create(); remote.update(""master"", jhywn); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag clegj = remote.clegj(""tag"", jhywn); remote.update(""refs/tags/tag"", clegj); ByteArrayInputStream duxdj = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn zrfje = new PacketLineIn(duxdj); assertThat(zrfje.readString(), is(jhywn.toObjectId().getName() + "" HEAD"")); assertThat(zrfje.readString(), is(jhywn.toObjectId().getName() + "" refs/heads/master"")); assertThat(zrfje.readString(), is(clegj.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(zrfje.readString() == PacketLineIn.END); }",,,,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); RevCommit nuvte = remote.commit().message(""message"").create(); remote.update(""master"",nuvte); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",nuvte); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"",<START>PacketLineIn.DELIM,PacketLineIn.END);<END> PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(nuvte.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(nuvte.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }",is DELIM needed here,"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); RevCommit nuvte = remote.commit().message(""message"").create(); remote.update(""master"", nuvte); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"", nuvte); remote.update(""refs/tags/tag"", tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(nuvte.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(nuvte.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() == PacketLineIn.END); }","1- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
2- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM, PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
3- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,598In.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
4- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); assertTrue(pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
5- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM, playerLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
6- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master)); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
7- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,rightChildPacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
8- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,disassociatePacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
9- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM,PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }
10- public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(""message"").create(); remote.update(""master"",tip); server.updateRef(""HEAD"").link(""refs/heads/master""); RevTag tag = remote.tag(""tag"",tip); remote.update(""refs/tags/tag"",tag); ByteArrayInputStream recvStream = uploadPackV2(""command=ls-refs\n"", PacketLineIn.DELIM, { PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" HEAD"")); assertThat(pckIn.readString(),is(tip.toObjectId().getName() + "" refs/heads/master"")); assertThat(pckIn.readString(),is(tag.toObjectId().getName() + "" refs/tags/tag"")); if (pckIn.readString() != PacketLineIn.END) { assertTrue(pckIn.readString() == PacketLineIn.END); } }",0
1652,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); <START> assertEquals(200000000, ct.getDuration()); <END> assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public class DummyClass {
    public void testProcessSingle() {
        Trace trace = new Trace();
        trace.setId(""btxnId"");
        trace.setBusinessTransaction(""btxnName"");
        trace.setStartTime(100);
        Consumer c = new Consumer();
        c.setUri(""uri"");
        c.setBaseTime(1);
        c.setDuration(200000000);
        c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault""));
        c.setEndpointType(""HTTP"");
        trace.getNodes().add(c);
        FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver();
        CompletionTime ct = null;
        try {
            ct = deriver.processOneToOne(null, trace);
        } catch (Exception e) {
            fail(""Failed: "" + e);
        }
        assertNotNull(ct);
        assertEquals(trace.getId(), ct.getId());
        assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction());
        assertEquals(c.getEndpointType(), ct.getEndpointType());
        assertFalse(ct.isInternal());
        assertEquals(trace.getStartTime(), ct.getTimestamp());
        assertEquals(c.getUri(), ct.getUri());
        assertEquals(200000000, ct.getDuration());
        assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT));
    }
}",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public class DummyClass {
    public void testProcessSingle() {
        Trace trace = new Trace();
        trace.setId(""btxnId"");
        trace.setBusinessTransaction(""btxnName"");
        trace.setStartTime(100000);
        Consumer c = new Consumer();
        c.setUri(""uri"");
        c.setBaseTime(1);
        c.setDuration(200000);
        c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault""));
        c.setEndpointType(""HTTP"");
        trace.getNodes().add(c);
        FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver();
        CompletionTime ct = null;
        try {
            ct = deriver.processOneToOne(null, trace);
        } catch (Exception e) {
            fail(""Failed: "" + e);
        }
        assertNotNull(ct);
        assertEquals(trace.getId(), ct.getId());
        assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction());
        assertEquals(c.getEndpointType(), ct.getEndpointType());
        assertFalse(ct.isInternal());
        assertEquals(trace.getStartTime(), ct.getTimestamp());
        assertEquals(c.getUri(), ct.getUri());
        assertEquals(200000, ct.getDuration());
        assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT));
    }
}","['public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(""200000"", ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(""trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals (200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(1200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(""trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }']",True,0,0,35,35,6,1.0,0.999999995,False,False,False,,,,,,,"public void testProcessSingle() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { boolean var = false; if (var) var = true; Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { boolean var = false; if (var) var = true; Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }",,,,,,,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); if (trace.getId() != ct.getId()) { assertEquals(trace.getId(),ct.getId()); } if (trace.getBusinessTransaction() != ct.getBusinessTransaction()) { assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); } if (c.getEndpointType() != ct.getEndpointType()) { assertEquals(c.getEndpointType(),ct.getEndpointType()); } assertFalse(ct.isInternal()); if (trace.getStartTime() != ct.getTimestamp()) { assertEquals(trace.getStartTime(),ct.getTimestamp()); } if (c.getUri() != ct.getUri()) { assertEquals(c.getUri(),ct.getUri()); } if (200000000 != ct.getDuration()) { <START>assertEquals(200000000,ct.getDuration());<END> } if (c.getProperties(Constants.PROP_FAULT) != ct.getProperties(Constants.PROP_FAULT)) { assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); } }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); if (trace.getId() != ct.getId()) { assertEquals(trace.getId(), ct.getId()); } if (trace.getBusinessTransaction() != ct.getBusinessTransaction()) { assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); } if (c.getEndpointType() != ct.getEndpointType()) { assertEquals(c.getEndpointType(), ct.getEndpointType()); } assertFalse(ct.isInternal()); if (trace.getStartTime() != ct.getTimestamp()) { assertEquals(trace.getStartTime(), ct.getTimestamp()); } if (c.getUri() != ct.getUri()) { assertEquals(c.getUri(), ct.getUri()); } if (200000 != ct.getDuration()) { assertEquals(200000, ct.getDuration()); } if (c.getProperties(Constants.PROP_FAULT) != ct.getProperties(Constants.PROP_FAULT)) { assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); } }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace deriver = new Trace(); deriver.setId(""btxnId""); deriver.setBusinessTransaction(""btxnName""); deriver.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); deriver.getNodes().add(c); FragmentCompletionTimeDeriver e = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = e.processOneToOne(null, deriver); } catch (Exception trace) { fail(""Failed: "" + trace); } assertNotNull(ct); assertEquals(deriver.getId(), ct.getId()); assertEquals(deriver.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(deriver.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); <START> assertEquals(200000000, ct.getDuration()); <END> assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace deriver = new Trace(); deriver.setId(""btxnId""); deriver.setBusinessTransaction(""btxnName""); deriver.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); deriver.getNodes().add(c); FragmentCompletionTimeDeriver e = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = e.processOneToOne(null, deriver); } catch (Exception trace) { fail(""Failed: "" + trace); } assertNotNull(ct); assertEquals(deriver.getId(), ct.getId()); assertEquals(deriver.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(deriver.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace mhtnr = new Trace(); mhtnr.setId(""btxnId""); mhtnr.setBusinessTransaction(""btxnName""); mhtnr.setStartTime(100); Consumer ijsee = new Consumer(); ijsee.setUri(""uri""); ijsee.setBaseTime(1); ijsee.setDuration(200000000); ijsee.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); ijsee.setEndpointType(""HTTP""); mhtnr.getNodes().add(ijsee); FragmentCompletionTimeDeriver gwxsx = new FragmentCompletionTimeDeriver(); CompletionTime xeqcq = null; try { xeqcq = gwxsx.processOneToOne(null, mhtnr); } catch (Exception tbiol) { fail(""Failed: "" + tbiol); } assertNotNull(xeqcq); assertEquals(mhtnr.getId(), xeqcq.getId()); assertEquals(mhtnr.getBusinessTransaction(), xeqcq.getBusinessTransaction()); assertEquals(ijsee.getEndpointType(), xeqcq.getEndpointType()); assertFalse(xeqcq.isInternal()); assertEquals(mhtnr.getStartTime(), xeqcq.getTimestamp()); assertEquals(ijsee.getUri(), xeqcq.getUri()); <START> assertEquals(200000000, xeqcq.getDuration()); <END> assertEquals(ijsee.getProperties(Constants.PROP_FAULT), xeqcq.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace mhtnr = new Trace(); mhtnr.setId(""btxnId""); mhtnr.setBusinessTransaction(""btxnName""); mhtnr.setStartTime(100000); Consumer ijsee = new Consumer(); ijsee.setUri(""uri""); ijsee.setBaseTime(1); ijsee.setDuration(200000); ijsee.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); ijsee.setEndpointType(""HTTP""); mhtnr.getNodes().add(ijsee); FragmentCompletionTimeDeriver gwxsx = new FragmentCompletionTimeDeriver(); CompletionTime xeqcq = null; try { xeqcq = gwxsx.processOneToOne(null, mhtnr); } catch (Exception tbiol) { fail(""Failed: "" + tbiol); } assertNotNull(xeqcq); assertEquals(mhtnr.getId(), xeqcq.getId()); assertEquals(mhtnr.getBusinessTransaction(), xeqcq.getBusinessTransaction()); assertEquals(ijsee.getEndpointType(), xeqcq.getEndpointType()); assertFalse(xeqcq.isInternal()); assertEquals(mhtnr.getStartTime(), xeqcq.getTimestamp()); assertEquals(ijsee.getUri(), xeqcq.getUri()); assertEquals(200000, xeqcq.getDuration()); assertEquals(ijsee.getProperties(Constants.PROP_FAULT), xeqcq.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); CompletionTime ct = null; FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); CompletionTime ct = null; FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); Trace ldfrh = new Trace(); ldfrh.setId(""btxnId""); ldfrh.setBusinessTransaction(""btxnName""); ldfrh.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); ldfrh.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,ldfrh); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(ldfrh.getId(),ct.getId()); assertEquals(ldfrh.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(ldfrh.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); Trace ldfrh = new Trace(); ldfrh.setId(""btxnId""); ldfrh.setBusinessTransaction(""btxnName""); ldfrh.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); ldfrh.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, ldfrh); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(ldfrh.getId(), ct.getId()); assertEquals(ldfrh.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(ldfrh.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","1- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
2- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
3- public void testProcessSingle() { Trace Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
4- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
5- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(""200000"",ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
6- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault())); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
7- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
8- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault)); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
9- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(1200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
10- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,(""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",0
1675,"private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); <START> assertEquals(true, feedbackEditPage.clickEditQuestionButton(1)); <END> feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }","public class DummyClass {
    private void testCancelNewOrEditQuestion() {
        ______TS(""Testing cancelling adding or editing questions"");
        feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question"");
        feedbackEditPage.clickNewQuestionButton();
        ______TS(""MCQ: click and cancel 'cancel new question'"");
        feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1));
        assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed());
        ______TS(""MCQ: click and confirm 'cancel new question'"");
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1));
        assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed());
        ______TS(""MCQ: click and cancel 'editing question'"");
        feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question"");
        feedbackEditPage.clickNewQuestionButton();
        feedbackEditPage.fillQuestionBox(""mcq qn"");
        feedbackEditPage.fillMcqOption(0, ""Choice 1"");
        feedbackEditPage.fillMcqOption(1, ""Choice 2"");
        feedbackEditPage.clickAddQuestionButton();
        assertEquals(true, feedbackEditPage.clickEditQuestionButton(1));
        feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1));
        assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1));
        ______TS(""MCQ: click and confirm 'editing question'"");
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1));
        assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1));
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1));
    }
}",assertTrue instead,"private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }","public class DummyClass {
    private void testCancelNewOrEditQuestion() {
        ______TS(""Testing cancelling adding or editing questions"");
        feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question"");
        feedbackEditPage.clickNewQuestionButton();
        ______TS(""MCQ: click and cancel 'cancel new question'"");
        feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1));
        assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed());
        ______TS(""MCQ: click and confirm 'cancel new question'"");
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1));
        assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed());
        ______TS(""MCQ: click and cancel 'editing question'"");
        feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question"");
        feedbackEditPage.clickNewQuestionButton();
        feedbackEditPage.fillQuestionBox(""mcq qn"");
        feedbackEditPage.fillMcqOption(0, ""Choice 1"");
        feedbackEditPage.fillMcqOption(1, ""Choice 2"");
        feedbackEditPage.clickAddQuestionButton();
        assertTrue(feedbackEditPage.clickEditQuestionButton(1));
        feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1));
        assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1));
        ______TS(""MCQ: click and confirm 'editing question'"");
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1));
        assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1));
        feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1));
    }
}","['private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); } }', 'private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel \'cancel new question\'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm \'cancel new question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel \'editing question\'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm \'editing question\'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); } }', 'private void testCancelNewOrEditQuestion() { }']",True,0,0,36,36,3,1.0,0.999999995,False,False,False,,,,,,,"private void testCancelNewOrEditQuestion() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); <START>assertEquals(true,feedbackEditPage.clickEditQuestionButton(1));<END> feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }",assertTrue instead,"private void testCancelNewOrEditQuestion() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }","private void testCancelNewOrEditQuestion() { boolean var = false; if (var) var = true; ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); <START>assertEquals(true,feedbackEditPage.clickEditQuestionButton(1));<END> feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }",assertTrue instead,"private void testCancelNewOrEditQuestion() { boolean var = false; if (var) var = true; ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }","private void testCancelNewOrEditQuestion() { try { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); <START>assertEquals(true,feedbackEditPage.clickEditQuestionButton(1));<END> feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); } catch (Exception e) { throw e; } }",assertTrue instead,"private void testCancelNewOrEditQuestion() { try { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); } catch (Exception e) { throw e; } }",,,,,,,"private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); if (true != feedbackEditPage.clickEditQuestionButton(1)) { <START>assertEquals(true,feedbackEditPage.clickEditQuestionButton(1));<END> } feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }",assertTrue instead,"private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }","private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); <START>assertEquals(true,feedbackEditPage.clickEditQuestionButton(1));<END> feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }",assertTrue instead,"private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0, ""Choice 1""); feedbackEditPage.fillMcqOption(1, ""Choice 2""); feedbackEditPage.clickAddQuestionButton(); if (!feedbackEditPage.clickEditQuestionButton(1)) { assertTrue(feedbackEditPage.clickEditQuestionButton(1)); } feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }",,,,,,,,,,,,,"1- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
2- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
3- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
4- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
5- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
6- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
7- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
8- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
9- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }
10- private void testCancelNewOrEditQuestion() { ______TS(""Testing cancelling adding or editing questions""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); ______TS(""MCQ: click and cancel 'cancel new question'""); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); if (!feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and confirm 'cancel new question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); if (feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()) { assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); } ______TS(""MCQ: click and cancel 'editing question'""); feedbackEditPage.selectNewQuestionType(""Multiple-choice (single answer) question""); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(""mcq qn""); feedbackEditPage.fillMcqOption(0,""Choice 1""); feedbackEditPage.fillMcqOption(1,""Choice 2""); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); if (!feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } ______TS(""MCQ: click and confirm 'editing question'""); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); if (feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)) { assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); } feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); {",0
1680,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { assertTrue( <START> identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); <END> assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse( identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }","public class DummyClass {
    public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception {
        assertTrue(
                identifierSourceService
                        .getAutoGenerationOption(Integer.parseInt(getUuid()))
                        .isAutomaticGenerationEnabled());
        assertTrue(
                identifierSourceService
                        .getAutoGenerationOption(Integer.parseInt(getUuid()))
                        .isManualEntryEnabled());
        SimpleObject autoGenerationOption = new SimpleObject();
        autoGenerationOption.add(""manualEntryEnabled"", false);
        autoGenerationOption.add(""automaticGenerationEnabled"", false);
        String json = new ObjectMapper().writeValueAsString(autoGenerationOption);
        MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid());
        req.setContent(json.getBytes());
        handle(req);
        assertFalse(
                identifierSourceService
                        .getAutoGenerationOption(Integer.parseInt(getUuid()))
                        .isAutomaticGenerationEnabled());
        assertFalse(
                identifierSourceService
                        .getAutoGenerationOption(Integer.parseInt(getUuid()))
                        .isManualEntryEnabled());
    }
}",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }","public class DummyClass {
    public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception {
        AutoGenerationOption autogenerationOption =
                identifierSourceService.getAutoGenerationOption(getId());
        assertTrue(autogenerationOption.isAutomaticGenerationEnabled());
        assertTrue(autogenerationOption.isManualEntryEnabled());
        SimpleObject autoGenerationOption = new SimpleObject();
        autoGenerationOption.add(""manualEntryEnabled"", false);
        autoGenerationOption.add(""automaticGenerationEnabled"", false);
        String json = new ObjectMapper().writeValueAsString(autoGenerationOption);
        MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid());
        req.setContent(json.getBytes());
        handle(req);
        AutoGenerationOption updatedAutogenerationOption =
                identifierSourceService.getAutoGenerationOption(getId());
        assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled());
        assertFalse(updatedAutogenerationOption.isManualEntryEnabled());
    }
}","['public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); autogenerationOption.isManualEntryEnabled(); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); ungenerationOption.isManualEntryEnabled(); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); ungenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); AutoGenerationOption autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertFalse(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); AutoGenerationOption.setAutomaticGenerationEnabled(false); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertTrue(updatedAutogenerationOption.isManualEntryEnabled()); }', 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); autogenerationOption.isManualEntryEnabled(); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); assertEquals(getId(), updatedAutogenerationOption.getId()); }']",True,1,0,294,294,13,1.0,0.999999995,False,False,False,,,,,,,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); assertTrue( identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse(<START>identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled());<END> assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }","public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { boolean var = false; if (var) var = true; assertTrue( identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse(<START>identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled());<END> assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { boolean var = false; if (var) var = true; AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }","public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { try { assertTrue( identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse(<START>identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled());<END> assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); } catch (Exception e) { throw e; } }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { try { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { if (! identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()) { assertTrue( identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); } if (!identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()) { assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); if (identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()) { assertFalse(<START>identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled());<END> } if (identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()) { assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); } }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (!autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (updatedAutogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); } if (updatedAutogenerationOption.isManualEntryEnabled()) { assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); } }","public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { assertTrue(<START> identifierSourceService.<END> getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject req = new SimpleObject(); req.add(""manualEntryEnabled"", false); req.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(req); MockHttpServletRequest autoGenerationOption = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); autoGenerationOption.setContent(json.getBytes()); handle(autoGenerationOption); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject req = new SimpleObject(); req.add(""manualEntryEnabled"", false); req.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(req); MockHttpServletRequest autoGenerationOption = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); autoGenerationOption.setContent(json.getBytes()); handle(autoGenerationOption); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }","public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { assertTrue(<START> identifierSourceService.<END> getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject nqftw = new SimpleObject(); nqftw.add(""manualEntryEnabled"", false); nqftw.add(""automaticGenerationEnabled"", false); String imgec = new ObjectMapper().writeValueAsString(nqftw); MockHttpServletRequest xmvtl = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); xmvtl.setContent(imgec.getBytes()); handle(xmvtl); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject nqftw = new SimpleObject(); nqftw.add(""manualEntryEnabled"", false); nqftw.add(""automaticGenerationEnabled"", false); String imgec = new ObjectMapper().writeValueAsString(nqftw); MockHttpServletRequest xmvtl = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); xmvtl.setContent(imgec.getBytes()); handle(xmvtl); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }",,,,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { assertTrue( identifierSourceService. getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); SimpleObject nhmta = new SimpleObject(); nhmta.add(""manualEntryEnabled"",false); nhmta.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(nhmta); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse(<START>identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled());<END> assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }",do need call Integer.parseInt(getUuid()) more in a method,"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); AutoGenerationOption nhmta = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(nhmta.isAutomaticGenerationEnabled()); assertTrue(nhmta.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"", false); autoGenerationOption.add(""automaticGenerationEnabled"", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }","1- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (! autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
2- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (!autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
3- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (! autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (updatedAutogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); } if (updatedAutogenerationOption.isManualEntryEnabled()) { assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); } }
4- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { if (! identifierSourceService. getAutoGenerationOption(getId())).isAutomaticGenerationEnabled()) { assertTrue( identifierSourceService. getAutoGenerationOption(getId())).isAutomaticGenerationEnabled()); } if (!identifierSourceService.getAutoGenerationOption(getId())).isManualEntryEnabled()) { assertTrue(identifierSourceService.getAutoGenerationOption(getId())).isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
5- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (! autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
6- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (!autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (updatedAutogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); } if (updatedAutogenerationOption.isManualEntryEnabled()) { assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); } }
7- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (! autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } AutoGenerationOption autogenerationOption.isManualEntryEnabled(); assertFalse(autogenerationOption.isManualEntryEnabled()); }
8- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { if (! identifierSourceService. getAutoGenerationOption(getId()).isAutomaticGenerationEnabled()) { assertTrue( identifierSourceService. getAutoGenerationOption(getId()).isAutomaticGenerationEnabled()); } if (!identifierSourceService.getAutoGenerationOption(getId()).isManualEntryEnabled()) { assertTrue(identifierSourceService.getAutoGenerationOption(getId()).isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
9- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (!autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } }
10- public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (! autogenerationOption.isAutomaticGenerationEnabled()) { assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); } if (!autogenerationOption.isManualEntryEnabled()) { assertTrue(autogenerationOption.isManualEntryEnabled()); } SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(""manualEntryEnabled"",false); autoGenerationOption.add(""automaticGenerationEnabled"",false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST,getURI() + ""/"" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); if (autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } if (autogenerationOption.isManualEntryEnabled()) { assertFalse(autogenerationOption.isManualEntryEnabled()); } if (!autogenerationOption.isAutomaticGenerationEnabled()) { assertFalse(autogenerationOption.isAutomaticGenerationEnabled()); } }",0
1688,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START> @Override public String getUniqueId() { return null; } <END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public class DummyClass {
    public void testReadProbabilitySimulationProperties() {
        SimulationDataProvider provider =
                new BPMN2SimulationDataProvider(
                        this.getClass()
                                .getResourceAsStream(
                                        ""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2""));
        Map<String, Object> data =
                provider.getSimulationDataForNode(
                        new Node() {
                            public List<Connection> getOutgoingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getOutgoingConnections() {
                                return null;
                            }

                            public NodeContainer getNodeContainer() {
                                return null;
                            }

                            public String getName() {
                                return ""Hello"";
                            }

                            public Object getMetaData(String name) {
                                return null;
                            }

                            public Map<String, Object> getMetaData() {
                                Map<String, Object> metaData = new HashMap<String, Object>();
                                metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03"");
                                return metaData;
                            }

                            public List<Connection> getIncomingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getIncomingConnections() {
                                return null;
                            }

                            public long getId() {
                                return 2;
                            }

                            @Override
                            public String getUniqueId() {
                                return null;
                            }

                            @Override
                            public String getNodeUniqueId() {
                                return null;
                            }
                        });
        assertNotNull(data);
        assertEquals(1, data.size());
        assertTrue(data.containsKey(SimulationConstants.PROBABILITY));
    }
}",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public class DummyClass {
    public void testReadProbabilitySimulationProperties() {
        SimulationDataProvider provider =
                new BPMN2SimulationDataProvider(
                        this.getClass()
                                .getResourceAsStream(
                                        ""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2""));
        Map<String, Object> data =
                provider.getSimulationDataForNode(
                        new Node() {
                            public List<Connection> getOutgoingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getOutgoingConnections() {
                                return null;
                            }

                            public NodeContainer getNodeContainer() {
                                return null;
                            }

                            public String getName() {
                                return ""Hello"";
                            }

                            public Object getMetaData(String name) {
                                return null;
                            }

                            public Map<String, Object> getMetaData() {
                                Map<String, Object> metaData = new HashMap<String, Object>();
                                metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03"");
                                return metaData;
                            }

                            public List<Connection> getIncomingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getIncomingConnections() {
                                return null;
                            }

                            public long getId() {
                                return 2;
                            }

                            @Override
                            public String getNodeUniqueId() {
                                return null;
                            }
                        });
        assertNotNull(data);
        assertEquals(1, data.size());
        assertTrue(data.containsKey(SimulationConstants.PROBABILITY));
    }
}","['public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public Node getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY())); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY())); }']",True,2,0,81,81,1,1.0,0.999999995,False,False,False,,,,,,,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public String getName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public long getId() <START> { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return 2; } @Override public String getUniqueId() <END> { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } @Override public String getNodeUniqueId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public String getName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public long getId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return 2; } @Override public String getNodeUniqueId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) var = true; SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) var = true; return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) var = true; return null; } public String getName() { boolean var = false; if (var) var = true; return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) var = true; return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) var = true; Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) var = true; return null; } public long getId() <START> { boolean var = false; if (var) var = true; return 2; } @Override public String getUniqueId() <END> { boolean var = false; if (var) var = true; return null; } @Override public String getNodeUniqueId() { boolean var = false; if (var) var = true; return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) var = true; SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) var = true; return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) var = true; return null; } public String getName() { boolean var = false; if (var) var = true; return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) var = true; return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) var = true; Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) var = true; return null; } public long getId() { boolean var = false; if (var) var = true; return 2; } @Override public String getNodeUniqueId() { boolean var = false; if (var) var = true; return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { try { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } catch (Exception e) { throw e; } }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { try { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } catch (Exception e) { throw e; } }",,,,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); if (1 != data.size()) { assertEquals(1,data.size()); } assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); if (1 != data.size()) { assertEquals(1, data.size()); } assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider type = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> name = type.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String metaData) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String data) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> provider = new HashMap<String, Object>(); provider.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return provider; } public List<Connection> getIncomingConnections(String metaData) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() <START> { return 2; } @Override public String getUniqueId() <END> { return null; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(name); assertEquals(1, name.size()); assertTrue(name.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider type = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> name = type.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String metaData) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String data) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> provider = new HashMap<String, Object>(); provider.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return provider; } public List<Connection> getIncomingConnections(String metaData) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(name); assertEquals(1, name.size()); assertTrue(name.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider zeqol = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> rhwbx = zeqol.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String khxju) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String gaxwu) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> biagu = new HashMap<String, Object>(); biagu.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return biagu; } public List<Connection> getIncomingConnections(String khxju) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() <START> { return 2; } @Override public String getUniqueId() <END> { return null; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(rhwbx); assertEquals(1, rhwbx.size()); assertTrue(rhwbx.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider zeqol = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> rhwbx = zeqol.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String khxju) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String gaxwu) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> biagu = new HashMap<String, Object>(); biagu.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return biagu; } public List<Connection> getIncomingConnections(String khxju) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(rhwbx); assertEquals(1, rhwbx.size()); assertTrue(rhwbx.containsKey(SimulationConstants.PROBABILITY)); }",,,,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); SimulationDataProvider baclf = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = baclf.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); Map<String,Object> auwvc = new HashMap<String,Object>(); auwvc.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return auwvc; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); SimulationDataProvider baclf = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = baclf.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); Map<String, Object> baclf = new HashMap<String, Object>(); baclf.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return baclf; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","1- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
2- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
3- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
4- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } public String getUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
5- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
6- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }
7- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }
8- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY())); } }
9- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY"")); } }
10- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); }",0
1689,"public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START> assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()); <END> assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public class DummyClass {
    public void testInputValidation() {
        ______TS(""CONST SUM:input validation"");
        feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn"");
        feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details"");
        feedbackEditPage.fillConstSumPointsBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion());
        feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion());
        assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1""));
        feedbackEditPage.clickDiscardChangesLinkForNewQuestion();
        feedbackEditPage.waitForConfirmationModalAndClickOk();
        assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());
        assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1));
    }
}","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public class DummyClass {
    public void testInputValidation() {
        ______TS(""CONST SUM:input validation"");
        feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn"");
        feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details"");
        feedbackEditPage.fillConstSumPointsBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion());
        feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion());
        assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1""));
        feedbackEditPage.clickDiscardChangesLinkForNewQuestion();
        feedbackEditPage.waitForConfirmationModalAndClickOk();
        assertEquals(
                Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());
        assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1));
    }
}","['public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsFromAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNotNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals( Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage. isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertNotNull(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:Input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertTrue(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); }']",True,0,0,65,65,3,1.0,0.999999995,False,False,False,,,,,,,"public void testInputValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { boolean var = false; if (var) var = true; ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { boolean var = false; if (var) var = true; ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { try { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } catch (Exception e) { throw e; } }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { try { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); } catch (Exception e) { throw e; } }",,,,"public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); } }","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsBoxForNewQuestion()) { assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); } feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()) { assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); } assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsBoxForNewQuestion()) { assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); } feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()) { assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); } assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); if (Collections.emptyList() != feedbackEditPage.getTextsForAllStatusMessagesToUser()) { assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); } assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); if (!feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()) { <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> } assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }",,,,,,,,,,,,,"1- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
2- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertNotNull(feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
3- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertNotNull(feedbackEditPage); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
4- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
5- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
6- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
7- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptySet(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }
8- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1); }
9- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName,1)); }
10- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }so",0
1697,"public void markAsMerged() throws Exception { <START> new Git(repo).commit().setAuthor(""JUnit"", ""junit@egit.org"") <END> .setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","public class DummyClass {
    public void markAsMerged() throws Exception {
        new Git(repo)
                .commit()
                .setAuthor(""JUnit"", ""junit@egit.org"")
                .setMessage(""Initial commit"")
                .call();
        GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false);
        GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd);
        GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds);
        String fileName = ""src/Main.java"";
        File file = testRepo.createFile(iProject, fileName);
        testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file"");
        testRepo.addToIndex(iProject.getFile("".classpath""));
        testRepo.addToIndex(iProject.getFile("".project""));
        testRepo.commit(""project files"");
        IFile workspaceFile = testRepo.getIFile(iProject, file);
        ResourceMapping mapping = new SimpleResourceMapping(workspaceFile);
        ResourceMapping[] inputMappings = new ResourceMapping[] {mapping};
        SubscriberScopeManager manager =
                new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true);
        testRepo.appendFileContent(file, ""some changes"");
        Status status = new Git(repo).status().call();
        assertEquals(0, status.getAdded().size());
        assertEquals(1, status.getModified().size());
        String repoRelativePath =
                testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString());
        assertTrue(status.getModified().contains(repoRelativePath));
        GitSubscriberMergeContext mergeContext =
                new GitSubscriberMergeContext(subscriber, manager, gsds);
        IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE);
        mergeContext.markAsMerged(node, true, null);
        status = new Git(repo).status().call();
        assertEquals(1, status.getChanged().size());
        assertEquals(0, status.getModified().size());
        assertTrue(status.getChanged().contains(repoRelativePath));
    }
}",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","public class DummyClass {
    public void markAsMerged() throws Exception {
        GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false);
        GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd);
        GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds);
        String fileName = ""src/Main.java"";
        File file = testRepo.createFile(iProject, fileName);
        testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file"");
        testRepo.addToIndex(iProject.getFile("".classpath""));
        testRepo.addToIndex(iProject.getFile("".project""));
        testRepo.commit(""project files"");
        IFile workspaceFile = testRepo.getIFile(iProject, file);
        ResourceMapping mapping = new SimpleResourceMapping(workspaceFile);
        ResourceMapping[] inputMappings = new ResourceMapping[] {mapping};
        SubscriberScopeManager manager =
                new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true);
        testRepo.appendFileContent(file, ""some changes"");
        Status status = new Git(repo).status().call();
        assertEquals(0, status.getAdded().size());
        assertEquals(1, status.getModified().size());
        String repoRelativePath =
                testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString());
        assertTrue(status.getModified().contains(repoRelativePath));
        GitSubscriberMergeContext mergeContext =
                new GitSubscriberMergeContext(subscriber, manager, gsds);
        IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE);
        mergeContext.markAsMerged(node, true, null);
        status = new Git(repo).status().call();
        assertEquals(1, status.getChanged().size());
        assertEquals(0, status.getModified().size());
        assertTrue(status.getChanged().contains(repoRelativePath));
    }
}","['public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { git.commit(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { commit(new Git(repo)); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().size()); assertEquals(0, status.getStatus().size()); assertTrue(status.getStatus().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().size()); assertEquals(0, status.getStatus().size()); assertTrue(status.getStatus().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().size()); assertEquals(0, status.getStatus().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().getChanged().size()); assertEquals(0, status.getStatus().getModified().size()); assertTrue(status.getStatus().getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception { git.commit(); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }', 'public void markAsMerged() throws Exception']",True,0,0,52,124,4,1.0,0.999999995,False,False,False,,,,,,,"public void markAsMerged() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","public void markAsMerged() throws Exception { boolean var = false; if (var) var = true; <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { boolean var = false; if (var) var = true; GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","public void markAsMerged() throws Exception { try { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); } catch (Exception e) { throw e; } }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { try { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); } catch (Exception e) { throw e; } }",,,,,,,"public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); if (0 != status.getAdded().size()) { assertEquals(0, status.getAdded().size()); } if (1 != status.getModified().size()) { assertEquals(1, status.getModified().size()); } String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); if (1 != status.getChanged().size()) { assertEquals(1, status.getChanged().size()); } if (0 != status.getModified().size()) { assertEquals(0, status.getModified().size()); } assertTrue(status.getChanged().contains(repoRelativePath)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); if (0 != status.getAdded().size()) { assertEquals(0, status.getAdded().size()); } if (1 != status.getModified().size()) { assertEquals(1, status.getModified().size()); } String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); if (1 != status.getChanged().size()) { assertEquals(1, status.getChanged().size()); } if (0 != status.getModified().size()) { assertEquals(0, status.getModified().size()); } assertTrue(status.getChanged().contains(repoRelativePath)); }","public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }","public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData workspaceFile = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet repoRelativePath = new GitSynchronizeDataSet(workspaceFile); GitResourceVariantTreeSubscriber mapping = new GitResourceVariantTreeSubscriber(repoRelativePath); String subscriber = ""src/Main.java""; File gsds = testRepo.createFile(iProject, subscriber); testRepo.appendContentAndCommit(iProject, gsds, ""class Main {}"", ""some gsds""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile inputMappings = testRepo.getIFile(iProject, gsds); ResourceMapping manager = new SimpleResourceMapping(inputMappings); ResourceMapping[] mergeContext = new ResourceMapping[] { manager }; SubscriberScopeManager file = new SubscriberScopeManager(""Scope"", mergeContext, mapping, true); testRepo.appendFileContent(gsds, ""some changes""); Status node = new Git(repo).node().call(); assertEquals(0, node.getAdded().size()); assertEquals(1, node.getModified().size()); String fileName = testRepo.getRepoRelativePath(inputMappings.getLocation().toPortableString()); assertTrue(node.getModified().contains(fileName)); GitSubscriberMergeContext status = new GitSubscriberMergeContext(mapping, file, repoRelativePath); IDiff gsd = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); status.markAsMerged(gsd, true, null); node = new Git(repo).node().call(); assertEquals(1, node.getChanged().size()); assertEquals(0, node.getModified().size()); assertTrue(node.getChanged().contains(fileName)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData workspaceFile = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet repoRelativePath = new GitSynchronizeDataSet(workspaceFile); GitResourceVariantTreeSubscriber mapping = new GitResourceVariantTreeSubscriber(repoRelativePath); String subscriber = ""src/Main.java""; File gsds = testRepo.createFile(iProject, subscriber); testRepo.appendContentAndCommit(iProject, gsds, ""class Main {}"", ""some gsds""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile inputMappings = testRepo.getIFile(iProject, gsds); ResourceMapping manager = new SimpleResourceMapping(inputMappings); ResourceMapping[] mergeContext = new ResourceMapping[] { manager }; SubscriberScopeManager file = new SubscriberScopeManager(""Scope"", mergeContext, mapping, true); testRepo.appendFileContent(gsds, ""some changes""); Status node = new Git(repo).node().call(); assertEquals(0, node.getAdded().size()); assertEquals(1, node.getModified().size()); String fileName = testRepo.getRepoRelativePath(inputMappings.getLocation().toPortableString()); assertTrue(node.getModified().contains(fileName)); GitSubscriberMergeContext status = new GitSubscriberMergeContext(mapping, file, repoRelativePath); IDiff gsd = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); status.markAsMerged(gsd, true, null); node = new Git(repo).node().call(); assertEquals(1, node.getChanged().size()); assertEquals(0, node.getModified().size()); assertTrue(node.getChanged().contains(fileName)); }","public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData ahhgd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet parzc = new GitSynchronizeDataSet(ahhgd); GitResourceVariantTreeSubscriber hupng = new GitResourceVariantTreeSubscriber(parzc); String fzwdz = ""src/Main.java""; File kxlgu = testRepo.createFile(iProject, fzwdz); testRepo.appendContentAndCommit(iProject, kxlgu, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile avvln = testRepo.getIFile(iProject, kxlgu); ResourceMapping gqgql = new SimpleResourceMapping(avvln); ResourceMapping[] rloin = new ResourceMapping[] { gqgql }; SubscriberScopeManager arxky = new SubscriberScopeManager(""Scope"", rloin, hupng, true); testRepo.appendFileContent(kxlgu, ""some changes""); Status cwenf = new Git(repo).cwenf().call(); assertEquals(0, cwenf.getAdded().size()); assertEquals(1, cwenf.getModified().size()); String gbjzm = testRepo.getRepoRelativePath(avvln.getLocation().toPortableString()); assertTrue(cwenf.getModified().contains(gbjzm)); GitSubscriberMergeContext quzrn = new GitSubscriberMergeContext(hupng, arxky, parzc); IDiff xwqhz = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); quzrn.markAsMerged(xwqhz, true, null); cwenf = new Git(repo).cwenf().call(); assertEquals(1, cwenf.getChanged().size()); assertEquals(0, cwenf.getModified().size()); assertTrue(cwenf.getChanged().contains(gbjzm)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData ahhgd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet parzc = new GitSynchronizeDataSet(ahhgd); GitResourceVariantTreeSubscriber hupng = new GitResourceVariantTreeSubscriber(parzc); String fzwdz = ""src/Main.java""; File kxlgu = testRepo.createFile(iProject, fzwdz); testRepo.appendContentAndCommit(iProject, kxlgu, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile avvln = testRepo.getIFile(iProject, kxlgu); ResourceMapping gqgql = new SimpleResourceMapping(avvln); ResourceMapping[] rloin = new ResourceMapping[] { gqgql }; SubscriberScopeManager arxky = new SubscriberScopeManager(""Scope"", rloin, hupng, true); testRepo.appendFileContent(kxlgu, ""some changes""); Status cwenf = new Git(repo).cwenf().call(); assertEquals(0, cwenf.getAdded().size()); assertEquals(1, cwenf.getModified().size()); String gbjzm = testRepo.getRepoRelativePath(avvln.getLocation().toPortableString()); assertTrue(cwenf.getModified().contains(gbjzm)); GitSubscriberMergeContext quzrn = new GitSubscriberMergeContext(hupng, arxky, parzc); IDiff xwqhz = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); quzrn.markAsMerged(xwqhz, true, null); cwenf = new Git(repo).cwenf().call(); assertEquals(1, cwenf.getChanged().size()); assertEquals(0, cwenf.getModified().size()); assertTrue(cwenf.getChanged().contains(gbjzm)); }","public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); String fileName = ""src/Main.java""; GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); String fileName = ""src/Main.java""; GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","public void markAsMerged() throws Exception { <START> new Git(repo).commit().<END> setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeData dlldz = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(dlldz); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }",initial commit created in setUp() method,"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeData dlldz = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(dlldz); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }","1- public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
2- public void markAsMerged() throws Exception { git.commit(). setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
3- public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = git.status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = git.status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
4- public void markAsMerged() throws Exception { commit(new Git(repo).commit()); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
5- public void markAsMerged() throws Exception { git.commit(). setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = git.status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = git.status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
6- public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String path = ""src/Main.java""; File file = testRepo.createFile(iProject, path); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
7- public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getStatus().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains(repoRelativePath)); } }
8- public void markAsMerged() throws Exception { git.commit().setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains (repoRelativePath)); } }
9- public void markAsMerged() throws Exception { git.commit(). setAuthor(""JUnit"", ""junit@egit.org"").setMessage(""Initial commit"").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber(gsds); String fileName = ""src/Main.java""; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, ""class Main {}"", ""some file""); testRepo.addToIndex(iProject.getFile("".classpath"")); testRepo.addToIndex(iProject.getFile("".project"")); testRepo.commit(""project files""); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(""Scope"", inputMappings, subscriber, true); testRepo.appendFileContent(file, ""some changes""); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); if (!status.getModified().contains(repoRelativePath)) { assertTrue(status.getModified().contains(repoRelativePath)); } GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext(subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(""src""), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); if (!status.getChanged().contains(repoRelativePath)) { assertTrue(status.getChanged().contains (repoRelativePath)); } }
10- public void markAsMerged() throws Exception { commit(new Git(repo).commit()); }",0
1706,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", <START> Collections.singletonList(user1.getName()), false, null, null, null, null, null); <END> session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public class DummyClass {
    public void testUserTasksAsUser() {
        DocumentModel document = getDocument();
        assertNotNull(document);
        taskService.createTask(
                session,
                administrator,
                document,
                ""Task assigned to user1"",
                Collections.singletonList(user1.getName()),
                false,
                null,
                null,
                null,
                null,
                null);
        session.save();
        List<Task> tasks = taskService.getTaskInstances(document, user1, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        Task task = tasks.get(0);
        assertEquals(""Task assigned to user1"", task.getName());
        List<String> pooledActorIds = task.getActors();
        assertEquals(1, pooledActorIds.size());
        assertTrue(pooledActorIds.contains(user1.getName()));
        tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
        try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
    }
}",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public class DummyClass {
    public void testUserTasksAsUser() {
        DocumentModel document = getDocument();
        assertNotNull(document);
        taskService.createTask(
                session,
                administrator,
                document,
                ""Task assigned to user1"",
                List.of(user1.getName()),
                false,
                null,
                null,
                null,
                null,
                null);
        session.save();
        List<Task> tasks = taskService.getTaskInstances(document, user1, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        Task task = tasks.get(0);
        assertEquals(""Task assigned to user1"", task.getName());
        List<String> pooledActorIds = task.getActors();
        assertEquals(1, pooledActorIds.size());
        assertTrue(pooledActorIds.contains(user1.getName()));
        tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
        try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
    }
}","['public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, true); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null, true); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.newArrayList(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.of(user1.getName(), user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } } {', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }IComplexNDArray', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }so(tasks); }']",True,0,0,44,48,2,1.0,0.999999995,False,False,False,,,,,,,"public void testUserTasksAsUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { boolean var = false; if (var) var = true; DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { boolean var = false; if (var) var = true; DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }",,,,,,,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } Task task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } List<String> pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } Task task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } List<String> pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } } }","public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { DocumentModel session1 = getDocument(); assertNotNull(session1); taskService.createTask(session, administrator, session1, ""Task assigned to <START> user1"", Collections.singletonList(user1.getName()), false, null, null, null, null, <END> null); session.save(); List<Task> pooledActorIds = taskService.getTaskInstances(session1, user1, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); Task document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); List<String> task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); try (CloseableCoreSession tasks = coreFeature.openCoreSession(user1.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel session1 = getDocument(); assertNotNull(session1); taskService.createTask(session, administrator, session1, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> pooledActorIds = taskService.getTaskInstances(session1, user1, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); Task document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); List<String> task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); try (CloseableCoreSession tasks = coreFeature.openCoreSession(user1.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } }","public void testUserTasksAsUser() { DocumentModel awpny = getDocument(); assertNotNull(awpny); taskService.createTask(session, administrator, awpny, ""Task assigned to <START> user1"", Collections.singletonList(user1.getName()), false, null, null, null, null, <END> null); session.save(); List<Task> esiuh = taskService.getTaskInstances(awpny, user1, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); Task lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); List<String> bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); try (CloseableCoreSession fsetu = coreFeature.openCoreSession(user1.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } try (CloseableCoreSession jtoht = coreFeature.openCoreSession(user2.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel awpny = getDocument(); assertNotNull(awpny); taskService.createTask(session, administrator, awpny, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> esiuh = taskService.getTaskInstances(awpny, user1, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); Task lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); List<String> bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); try (CloseableCoreSession fsetu = coreFeature.openCoreSession(user1.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } try (CloseableCoreSession jtoht = coreFeature.openCoreSession(user2.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } }",,,,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); DocumentModel debuk = getDocument(); assertNotNull(debuk); taskService.createTask(session,administrator,debuk,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(debuk,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(debuk,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(debuk,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); DocumentModel debuk = getDocument(); assertNotNull(debuk); taskService.createTask(session, administrator, debuk, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(debuk, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(debuk, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(debuk, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","1- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
2- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
3- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", Collections.singletonList(user1.getName()),false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
4- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
5- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName())); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
6- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null,true); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
7- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()), false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
8- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null, null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
9- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null)); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }
10- public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null, null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",0
1712,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); <END> assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }","public class DummyClass {
    public void testUpdatingJpaOutboundGatewayParser() throws Exception {
        setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway"");
        final AbstractMessageChannel inputChannel =
                TestUtils.getPropertyValue(
                        this.consumer, ""inputChannel"", AbstractMessageChannel.class);
        assertEquals(""in"", inputChannel.getComponentName());
        final JpaOutboundGateway jpaOutboundGateway =
                TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class);
        final OutboundGatewayType gatewayType =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class);
        assertEquals(OutboundGatewayType.UPDATING, gatewayType);
        long sendTimeout =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class);
        assertEquals(100, sendTimeout);
        assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class));
        final JpaExecutor jpaExecutor =
                TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class);
        assertNotNull(jpaExecutor);
        final Class<?> entityClass =
                TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class);
        assertEquals(
                ""org.springframework.integration.jpa.test.entity.StudentDomain"",
                entityClass.getName());
        final JpaOperations jpaOperations =
                TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class);
        assertNotNull(jpaOperations);
        final Boolean usePayloadAsParameterSource =
                TestUtils.getPropertyValue(
                        jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class);
        assertTrue(usePayloadAsParameterSource);
        final Integer order =
                TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class);
        assertEquals(Integer.valueOf(2), order);
        final PersistMode persistMode =
                TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class);
        assertEquals(PersistMode.PERSIST, persistMode);
        assertEquals(
                new Integer(100),
                TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class));
        assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class));
    }
}",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public class DummyClass {
    public void testUpdatingJpaOutboundGatewayParser() throws Exception {
        setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway"");
        final AbstractMessageChannel inputChannel =
                TestUtils.getPropertyValue(
                        this.consumer, ""inputChannel"", AbstractMessageChannel.class);
        assertEquals(""in"", inputChannel.getComponentName());
        final JpaOutboundGateway jpaOutboundGateway =
                TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class);
        final OutboundGatewayType gatewayType =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class);
        assertEquals(OutboundGatewayType.UPDATING, gatewayType);
        long sendTimeout =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class);
        assertEquals(100, sendTimeout);
        assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class));
        final JpaExecutor jpaExecutor =
                TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class);
        assertNotNull(jpaExecutor);
        final Class<?> entityClass =
                TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class);
        assertEquals(
                ""org.springframework.integration.jpa.test.entity.StudentDomain"",
                entityClass.getName());
        final JpaOperations jpaOperations =
                TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class);
        assertNotNull(jpaOperations);
        final Boolean usePayloadAsParameterSource =
                TestUtils.getPropertyValue(
                        jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class);
        assertTrue(usePayloadAsParameterSource);
        final Integer order =
                TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class);
        assertEquals(Integer.valueOf(2), order);
        final PersistMode persistMode =
                TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class);
        assertEquals(PersistMode.PERSIST, persistMode);
        assertEquals(
                Integer.valueOf(100),
                TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class));
        assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class));
    }
}","['public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(10, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperation"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,(""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final int order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(0, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); }']",True,0,0,39,39,5,1.0,0.999999995,False,False,False,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); <END> assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) var = true; setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) var = true; setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { try { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); } catch (Exception e) { throw e; } }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { try { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } catch (Exception e) { throw e; } }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); if (""in"" != inputChannel.getComponentName()) { assertEquals(""in"",inputChannel.getComponentName()); } final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); if (OutboundGatewayType.UPDATING != gatewayType) { assertEquals(OutboundGatewayType.UPDATING,gatewayType); } long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); if (100 != sendTimeout) { assertEquals(100,sendTimeout); } assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); if (""org.springframework.integration.jpa.test.entity.StudentDomain"" != entityClass.getName()) { assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); } final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); if (Integer.valueOf(2) != order) { assertEquals(Integer.valueOf(2),order); } final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); if (PersistMode.PERSIST != persistMode) { assertEquals(PersistMode.PERSIST,persistMode); } if (new Integer(100) != TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)) { <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> } assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); if (""in"" != inputChannel.getComponentName()) { assertEquals(""in"", inputChannel.getComponentName()); } final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); if (OutboundGatewayType.UPDATING != gatewayType) { assertEquals(OutboundGatewayType.UPDATING, gatewayType); } long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); if (100 != sendTimeout) { assertEquals(100, sendTimeout); } assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); if (""org.springframework.integration.jpa.test.entity.StudentDomain"" != entityClass.getName()) { assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); } final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); if (Integer.valueOf(2) != order) { assertEquals(Integer.valueOf(2), order); } final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); if (PersistMode.PERSIST != persistMode) { assertEquals(PersistMode.PERSIST, persistMode); } if (Integer.valueOf(100) != TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)) { assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); } assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> if (!TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); } }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel entityClass = TestUtils.getPropertyValue(this.consumer, ""entityClass"", AbstractMessageChannel.class); assertEquals(""in"", entityClass.getComponentName()); final JpaOutboundGateway jpaOperations = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType jpaExecutor = TestUtils.getPropertyValue(jpaOperations, ""jpaOutboundGateway"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, jpaExecutor); long persistMode = TestUtils.getPropertyValue(jpaOperations, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, persistMode); assertFalse(TestUtils.getPropertyValue(jpaOperations, ""requiresReply"", Boolean.class)); final JpaExecutor jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler.jpaOutboundGateway"", JpaExecutor.class); assertNotNull(jpaOutboundGateway); final Class<?> order = TestUtils.getPropertyValue(jpaOutboundGateway, ""usePayloadAsParameterSource"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", order.getName()); final JpaOperations inputChannel = TestUtils.getPropertyValue(jpaOutboundGateway, ""entityClass"", JpaOperations.class); assertNotNull(inputChannel); final Boolean gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", Boolean.class); assertTrue(gatewayType); final Integer usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaOperations, ""usePayloadAsParameterSource"", Integer.class); assertEquals(Integer.valueOf(2), usePayloadAsParameterSource); final PersistMode sendTimeout = <START> TestUtils.getPropertyValue(jpaOutboundGateway, ""sendTimeout"", PersistMode.class); assertEquals(PersistMode.PERSIST, sendTimeout); <END> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaOutboundGateway, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaOutboundGateway, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel entityClass = TestUtils.getPropertyValue(this.consumer, ""entityClass"", AbstractMessageChannel.class); assertEquals(""in"", entityClass.getComponentName()); final JpaOutboundGateway jpaOperations = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType jpaExecutor = TestUtils.getPropertyValue(jpaOperations, ""jpaOutboundGateway"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, jpaExecutor); long persistMode = TestUtils.getPropertyValue(jpaOperations, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, persistMode); assertFalse(TestUtils.getPropertyValue(jpaOperations, ""requiresReply"", Boolean.class)); final JpaExecutor jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler.jpaOutboundGateway"", JpaExecutor.class); assertNotNull(jpaOutboundGateway); final Class<?> order = TestUtils.getPropertyValue(jpaOutboundGateway, ""usePayloadAsParameterSource"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", order.getName()); final JpaOperations inputChannel = TestUtils.getPropertyValue(jpaOutboundGateway, ""entityClass"", JpaOperations.class); assertNotNull(inputChannel); final Boolean gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", Boolean.class); assertTrue(gatewayType); final Integer usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaOperations, ""usePayloadAsParameterSource"", Integer.class); assertEquals(Integer.valueOf(2), usePayloadAsParameterSource); final PersistMode sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""sendTimeout"", PersistMode.class); assertEquals(PersistMode.PERSIST, sendTimeout); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaOutboundGateway, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaOutboundGateway, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel hctqs = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", hctqs.getComponentName()); final JpaOutboundGateway xgsmx = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType vihlw = TestUtils.getPropertyValue(xgsmx, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, vihlw); long rtakt = TestUtils.getPropertyValue(xgsmx, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, rtakt); assertFalse(TestUtils.getPropertyValue(xgsmx, ""requiresReply"", Boolean.class)); final JpaExecutor mlcnp = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(mlcnp); final Class<?> brcej = TestUtils.getPropertyValue(mlcnp, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", brcej.getName()); final JpaOperations jyzii = TestUtils.getPropertyValue(mlcnp, ""jpaOperations"", JpaOperations.class); assertNotNull(jyzii); final Boolean wluln = TestUtils.getPropertyValue(mlcnp, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(wluln); final Integer kjwri = TestUtils.getPropertyValue(xgsmx, ""order"", Integer.class); assertEquals(Integer.valueOf(2), kjwri); final PersistMode pdqji = <START> TestUtils.getPropertyValue(mlcnp, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, pdqji); <END> assertEquals(new Integer(100), TestUtils.getPropertyValue(mlcnp, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(mlcnp, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel hctqs = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", hctqs.getComponentName()); final JpaOutboundGateway xgsmx = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType vihlw = TestUtils.getPropertyValue(xgsmx, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, vihlw); long rtakt = TestUtils.getPropertyValue(xgsmx, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, rtakt); assertFalse(TestUtils.getPropertyValue(xgsmx, ""requiresReply"", Boolean.class)); final JpaExecutor mlcnp = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(mlcnp); final Class<?> brcej = TestUtils.getPropertyValue(mlcnp, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", brcej.getName()); final JpaOperations jyzii = TestUtils.getPropertyValue(mlcnp, ""jpaOperations"", JpaOperations.class); assertNotNull(jyzii); final Boolean wluln = TestUtils.getPropertyValue(mlcnp, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(wluln); final Integer kjwri = TestUtils.getPropertyValue(xgsmx, ""order"", Integer.class); assertEquals(Integer.valueOf(2), kjwri); final PersistMode pdqji = TestUtils.getPropertyValue(mlcnp, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, pdqji); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(mlcnp, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(mlcnp, ""clearOnFlush"", Boolean.class)); }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); AbstractMessageChannel djzuw = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",djzuw.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); AbstractMessageChannel djzuw = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", djzuw.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","1- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); } }
2- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
3- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); } }
4- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
5- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
6- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
7- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100, sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); } }
8- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); } }
9- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"", Boolean.class)); } }
10- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }",0
1713,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); <START> } catch (Exception e) { <END> fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }","public class DummyClass {
    public void testUpgradeNotAllowed() throws Exception {
        setOldTimestampToInduceUpgrade = true;
        SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver =
                firstConnectionNSMappingServerEnabledClientEnabled();
        driver.resetCQS();
        Properties clientProps = getClientProperties(true, true);
        UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps);
        setOldTimestampToInduceUpgrade = false;
        try {
            driver.getConnectionQueryServices(getJdbcUrl(), clientProps);
        } catch (Exception e) {
            assertTrue(e instanceof UpgradeRequiredException);
        }
        assertEquals(hbaseTables, getHBaseTables());
        assertEquals(1, countUpgradeAttempts);
        assertEquals(0, actualSysCatUpgrades);
        Connection conn =
                driver.getConnectionQueryServices(getJdbcUrl(), new Properties())
                        .connect(getJdbcUrl(), new Properties());
        try {
            conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND);
            assertEquals(1, actualSysCatUpgrades);
        } catch (Exception e) {
            fail(""EXECUTE UPGRADE should not fail"");
        } finally {
            conn.close();
        }
    }
}",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }","public class DummyClass {
    public void testUpgradeNotAllowed() throws Exception {
        setOldTimestampToInduceUpgrade = true;
        SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver =
                firstConnectionNSMappingServerEnabledClientEnabled();
        driver.resetCQS();
        Properties clientProps = getClientProperties(true, true);
        UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps);
        setOldTimestampToInduceUpgrade = false;
        try {
            driver.getConnectionQueryServices(getJdbcUrl(), clientProps);
        } catch (Exception e) {
            assertTrue(e instanceof UpgradeRequiredException);
        }
        assertEquals(hbaseTables, getHBaseTables());
        assertEquals(1, countUpgradeAttempts);
        assertEquals(0, actualSysCatUpgrades);
        Connection conn =
                driver.getConnectionQueryServices(getJdbcUrl(), new Properties())
                        .connect(getJdbcUrl(), new Properties());
        try {
            conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND);
            assertEquals(1, actualSysCatUpgrades);
        } finally {
            conn.close();
        }
    }
}","['public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; driver.getConnectionQueryServices(getJdbcUrl(), clientProps); assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); UpgradeUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); return; } finally { conn.close(); } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close();; } }', 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } } {']",True,0,0,85,91,5,1.0,0.999999995,True,True,False,,,,,,,"public void testUpgradeNotAllowed() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); <START>} catch (Exception e) {<END> assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }","public void testUpgradeNotAllowed() throws Exception { boolean var = false; if (var) var = true; setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); <START>} catch (Exception e) {<END> assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { boolean var = false; if (var) var = true; setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }",,,,,,,,,,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); <START>} catch (Exception e) {<END> assertTrue(e instanceof UpgradeRequiredException); } if (hbaseTables != getHBaseTables()) { assertEquals(hbaseTables,getHBaseTables()); } if (1 != countUpgradeAttempts) { assertEquals(1,countUpgradeAttempts); } if (0 != actualSysCatUpgrades) { assertEquals(0,actualSysCatUpgrades); } Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); if (1 != actualSysCatUpgrades) { assertEquals(1,actualSysCatUpgrades); } } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } if (hbaseTables != getHBaseTables()) { assertEquals(hbaseTables, getHBaseTables()); } if (1 != countUpgradeAttempts) { assertEquals(1, countUpgradeAttempts); } if (0 != actualSysCatUpgrades) { assertEquals(0, actualSysCatUpgrades); } Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); if (1 != actualSysCatUpgrades) { assertEquals(1, actualSysCatUpgrades); } } finally { conn.close(); } }","public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); <START>} catch (Exception e) {<END> if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }","public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver e = firstConnectionNSMappingServerEnabledClientEnabled(); e.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { e.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception conn) { assertTrue(conn instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection driver = e.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { driver.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, <START> actualSysCatUpgrades); } catch (Exception conn) <END> { fail(""EXECUTE UPGRADE should not fail""); } finally { driver.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver e = firstConnectionNSMappingServerEnabledClientEnabled(); e.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { e.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception conn) { assertTrue(conn instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection driver = e.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { driver.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { driver.close(); } }","public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver cpgqt = firstConnectionNSMappingServerEnabledClientEnabled(); cpgqt.resetCQS(); Properties aectq = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(aectq); setOldTimestampToInduceUpgrade = false; try { cpgqt.getConnectionQueryServices(getJdbcUrl(), aectq); } catch (Exception ezacz) { assertTrue(ezacz instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection mubyb = cpgqt.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { mubyb.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, <START> actualSysCatUpgrades); } catch (Exception ezacz) <END> { fail(""EXECUTE UPGRADE should not fail""); } finally { mubyb.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver cpgqt = firstConnectionNSMappingServerEnabledClientEnabled(); cpgqt.resetCQS(); Properties aectq = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(aectq); setOldTimestampToInduceUpgrade = false; try { cpgqt.getConnectionQueryServices(getJdbcUrl(), aectq); } catch (Exception ezacz) { assertTrue(ezacz instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection mubyb = cpgqt.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { mubyb.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { mubyb.close(); } }",,,,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver iwtqm = firstConnectionNSMappingServerEnabledClientEnabled(); iwtqm.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { iwtqm.getConnectionQueryServices(getJdbcUrl(),clientProps); <START>} catch (Exception e) {<END> assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = iwtqm.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }",remove catch block,"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver iwtqm = firstConnectionNSMappingServerEnabledClientEnabled(); iwtqm.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { iwtqm.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = iwtqm.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }","1- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (Exception e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
2- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; driver.getConnectionQueryServices(getJdbcUrl(),clientProps); assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
3- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (UpgradeRequiredException e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
4- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
5- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; driver.getConnectionQueryServices(getJdbcUrl(), clientProps); assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
6- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (UpgradeRequiredException e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
7- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (SQLException e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
8- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (SQLException e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (SQLException e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); } }
9- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (Exception e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } catch (Exception e) { fail(""EXECUTE UPGRADE should not fail""); } finally { conn.close(); }
10- public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true,true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(),clientProps); } catch (Exception e) { if (!e instanceof UpgradeRequiredException) { assertTrue(e instanceof UpgradeRequiredException); } } assertEquals(hbaseTables,getHBaseTables()); assertEquals(1,countUpgradeAttempts); assertEquals(0,actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(),new Properties()).connect(getJdbcUrl(),new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1,actualSysCatUpgrades); } finally { conn.close(); } }",0
1714,"public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); <START> assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).get(), ""timeout""); <END> assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","public class DummyClass {
    public void testListenableTimeout() throws Exception {
        SettableFuture<String> rootFuture = SettableFuture.create();
        ListenableFuture<String> timeoutFuture =
                addTimeout(
                        rootFuture,
                        () -> ""timeout"",
                        new Duration(0, MILLISECONDS),
                        executorService);
        assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).get(), ""timeout"");
        assertTrue(timeoutFuture.isDone());
        assertFalse(timeoutFuture.isCancelled());
        assertFailure(
                () -> rootFuture.get(10, SECONDS),
                e -> assertInstanceOf(e, CancellationException.class));
        assertTrue(rootFuture.isDone());
        assertTrue(rootFuture.isCancelled());
    }
}","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","public class DummyClass {
    public void testListenableTimeout() throws Exception {
        SettableFuture<String> rootFuture = SettableFuture.create();
        ListenableFuture<String> timeoutFuture =
                addTimeout(
                        rootFuture,
                        () -> ""timeout"",
                        new Duration(0, MILLISECONDS),
                        executorService);
        assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout"");
        assertTrue(timeoutFuture.isDone());
        assertFalse(timeoutFuture.isCancelled());
        assertFailure(
                () -> rootFuture.get(10, SECONDS),
                e -> assertInstanceOf(e, CancellationException.class));
        assertTrue(rootFuture.isDone());
        assertTrue(rootFuture.isCancelled());
    }
}","['public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).get(), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""timeout"")); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed"")); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS)).orElse(""failed""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).first(), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).getValue(), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""FAILED""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }', 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).create(), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }']",True,0,0,26,40,2,1.0,0.999999995,False,False,False,,,,,,,"public void testListenableTimeout() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","public void testListenableTimeout() throws Exception { boolean var = false; if (var) var = true; SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { boolean var = false; if (var) var = true; SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","public void testListenableTimeout() throws Exception { try { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); } catch (Exception e) { throw e; } }","orElse(""failed"")","public void testListenableTimeout() throws Exception { try { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); } catch (Exception e) { throw e; } }",,,,,,,"public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); if (tryGetFutureValue(timeoutFuture,10,SECONDS).get() != ""timeout"") { <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> } assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); if (tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed"") != ""timeout"") { assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); } assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }","public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }","public void testListenableTimeout() throws Exception { SettableFuture<String> e = SettableFuture.create(); ListenableFuture<String> rootFuture = addTimeout(e, () -> ""timeout"", new Duration(0, MILLISECONDS), <START> executorService); assertEquals(tryGetFutureValue(rootFuture, 10, SECONDS).get(), <END> ""timeout""); assertTrue(rootFuture.isDone()); assertFalse(rootFuture.isCancelled()); assertFailure(() -> e.get(10, SECONDS), timeoutFuture -> assertInstanceOf(timeoutFuture, CancellationException.class)); assertTrue(e.isDone()); assertTrue(e.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> e = SettableFuture.create(); ListenableFuture<String> rootFuture = addTimeout(e, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(rootFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(rootFuture.isDone()); assertFalse(rootFuture.isCancelled()); assertFailure(() -> e.get(10, SECONDS), timeoutFuture -> assertInstanceOf(timeoutFuture, CancellationException.class)); assertTrue(e.isDone()); assertTrue(e.isCancelled()); }","public void testListenableTimeout() throws Exception { SettableFuture<String> yzvbo = SettableFuture.create(); ListenableFuture<String> xltpt = addTimeout(yzvbo, () -> ""timeout"", new Duration(0, MILLISECONDS), <START> executorService); assertEquals(tryGetFutureValue(xltpt, 10, SECONDS).get(), <END> ""timeout""); assertTrue(xltpt.isDone()); assertFalse(xltpt.isCancelled()); assertFailure(() -> yzvbo.get(10, SECONDS), qakne -> assertInstanceOf(qakne, CancellationException.class)); assertTrue(yzvbo.isDone()); assertTrue(yzvbo.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> yzvbo = SettableFuture.create(); ListenableFuture<String> xltpt = addTimeout(yzvbo, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(xltpt, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(xltpt.isDone()); assertFalse(xltpt.isCancelled()); assertFailure(() -> yzvbo.get(10, SECONDS), qakne -> assertInstanceOf(qakne, CancellationException.class)); assertTrue(yzvbo.isDone()); assertTrue(yzvbo.isCancelled()); }",,,,"public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); SettableFuture<String> jrtxs = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(jrtxs,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); <START>assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"");<END> assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> jrtxs.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); assertTrue(jrtxs.isDone()); assertTrue(jrtxs.isCancelled()); }","orElse(""failed"")","public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); SettableFuture<String> jrtxs = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(jrtxs, () -> ""timeout"", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(""failed""), ""timeout""); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> jrtxs.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(jrtxs.isDone()); assertTrue(jrtxs.isCancelled()); }","1- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(), ""timeout""); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
2- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout""); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
3- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),(""timeout"")); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
4- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),(""timeout""); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
5- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertTrue(tryGetFutureValue(timeoutFuture,10,SECONDS).get(), ""timeout"")); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
6- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"")); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
7- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(), ""timeout""); assertTrue(timeoutFuture.isDone()); if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
8- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertTrue(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout"")); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
9- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(""timeout"", tryGetFutureValue(timeoutFuture,10,SECONDS).get()); if (!timeoutFuture.isDone()) { assertTrue(timeoutFuture.isDone()); } if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }
10- public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture,() -> ""timeout"",new Duration(0,MILLISECONDS),executorService); assertEquals(tryGetFutureValue(timeoutFuture,10,SECONDS).get(),""timeout""); assertTrue(timeoutFuture.isDone()); if (timeoutFuture.isCancelled()) { assertFalse(timeoutFuture.isCancelled()); } assertFailure(() -> rootFuture.get(10,SECONDS),e -> assertInstanceOf(e,CancellationException.class)); if (!rootFuture.isDone()) { assertTrue(rootFuture.isDone()); } if (!rootFuture.isCancelled()) { assertTrue(rootFuture.isCancelled()); } }",0
1718,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); <START> assertTrue(arrival.await(20, TimeUnit.SECONDS)); <END> installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public class DummyClass {
    public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException {
        initAndCheck(m);
        CountDownLatch arrival = new CountDownLatch(2);
        CountDownLatch release = new CountDownLatch(1);
        AtomicInteger thrown = new AtomicInteger();
        AtomicInteger retried = new AtomicInteger();
        cache(0).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptorAfter(
                        new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class);
        cache(1).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        cache(2).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        Future<Object> future = fork(() -> cache(0).get(key));
        assertTrue(arrival.await(20, TimeUnit.SECONDS));
        installNewView(cache(0), cache(0));
        assertNull(future.get());
        assertEquals(1, thrown.get());
        assertEquals(0, retried.get());
        release.countDown();
    }
}",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public class DummyClass {
    public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException {
        initAndCheck(m);
        CountDownLatch arrival = new CountDownLatch(2);
        CountDownLatch release = new CountDownLatch(1);
        AtomicInteger thrown = new AtomicInteger();
        AtomicInteger retried = new AtomicInteger();
        cache(0).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptorAfter(
                        new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class);
        cache(1).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        cache(2).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        Future<Object> future = fork(() -> cache(0).get(key));
        assertTrue(arrival.await(10, TimeUnit.SECONDS));
        installNewView(cache(0), cache(0));
        assertNull(future.get());
        assertEquals(1, thrown.get());
        assertEquals(0, retried.get());
        release.countDown();
    }
}","['public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new CountDownLatch(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); int thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); int thrown = new AtomicInteger(); int retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); ByteBuf bootstrap = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new CountDownLatch(0); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get); assertEquals(0, retried.get()); release.countDown(); }']",True,4,0,26,27,2,1.0,0.999999995,False,False,False,,,,,,,"public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { boolean var = false; if (var) var = true; initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { boolean var = false; if (var) var = true; initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { try { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); } catch (Exception e) { throw e; } }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { try { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); } catch (Exception e) { throw e; } }",,,,"public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); if (1 != thrown.get()) { assertEquals(1,thrown.get()); } if (0 != retried.get()) { assertEquals(0,retried.get()); } release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); if (1 != thrown.get()) { assertEquals(1, thrown.get()); } if (0 != retried.get()) { assertEquals(0, retried.get()); } release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(10, TimeUnit.SECONDS)) { assertTrue(arrival.await(10, TimeUnit.SECONDS)); } installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method retried) throws ExecutionException, InterruptedException { initAndCheck(retried); CountDownLatch m = new CountDownLatch(2); CountDownLatch future = new CountDownLatch(1); AtomicInteger arrival = new AtomicInteger(); AtomicInteger thrown = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(arrival, thrown), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), <START> 0); Future<Object> <END> release = fork(() -> cache(0).get(key)); assertTrue(m.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(release.get()); assertEquals(1, arrival.get()); assertEquals(0, thrown.get()); future.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method retried) throws ExecutionException, InterruptedException { initAndCheck(retried); CountDownLatch m = new CountDownLatch(2); CountDownLatch future = new CountDownLatch(1); AtomicInteger arrival = new AtomicInteger(); AtomicInteger thrown = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(arrival, thrown), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); Future<Object> release = fork(() -> cache(0).get(key)); assertTrue(m.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(release.get()); assertEquals(1, arrival.get()); assertEquals(0, thrown.get()); future.countDown(); }","public void testBothOwnersSuspected(Method gpjrx) throws ExecutionException, InterruptedException { initAndCheck(gpjrx); CountDownLatch ittlm = new CountDownLatch(2); CountDownLatch tznpo = new CountDownLatch(1); AtomicInteger mtikk = new AtomicInteger(); AtomicInteger ixbvg = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(mtikk, ixbvg), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), <START> 0); Future<Object> <END> nmkex = fork(() -> cache(0).get(key)); assertTrue(ittlm.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(nmkex.get()); assertEquals(1, mtikk.get()); assertEquals(0, ixbvg.get()); tznpo.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method gpjrx) throws ExecutionException, InterruptedException { initAndCheck(gpjrx); CountDownLatch ittlm = new CountDownLatch(2); CountDownLatch tznpo = new CountDownLatch(1); AtomicInteger mtikk = new AtomicInteger(); AtomicInteger ixbvg = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(mtikk, ixbvg), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); Future<Object> nmkex = fork(() -> cache(0).get(key)); assertTrue(ittlm.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(nmkex.get()); assertEquals(1, mtikk.get()); assertEquals(0, ixbvg.get()); tznpo.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch release = new CountDownLatch(1); CountDownLatch arrival = new CountDownLatch(2); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch release = new CountDownLatch(1); CountDownLatch arrival = new CountDownLatch(2); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch yhgeq = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(yhgeq.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch yhgeq = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(yhgeq.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","1- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
2- public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
3- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20, TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
4- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20, TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
5- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertTrue(thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
6- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0);,0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
7- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); ArrayList<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
8- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
9- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); }
10- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { assertTrue(arrival.await(20,TimeUnit.SECONDS)); } installNewView(cache(0),cache(0)); assertNull(future.get()); assertThat(thrown.get(), is(equalTo(2))); assertThat(retried.get(), is(equalTo(2))); release.countDown(); }",0
1748,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); <START> assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); <END> assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","public class DummyClass {
    public void createCopyRequest() throws Exception {
        DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity"");
        DocumentReference destination =
                new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome"");
        CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination);
        assertEquals(Arrays.asList(source), copyRequest.getEntityReferences());
        assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination());
        assertEquals(
                Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2));
        assertEquals(RefactoringJobs.COPY, copyRequest.getJobType());
        assertEquals(this.userReference, copyRequest.getUserReference());
        assertFalse(copyRequest.isDeep());
        assertTrue(copyRequest.isUpdateLinks());
        assertFalse(copyRequest.isInteractive());
        assertTrue(copyRequest.isCheckRights());
    }
}",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","public class DummyClass {
    public void createCopyRequest() throws Exception {
        DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity"");
        DocumentReference destination =
                new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome"");
        CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination);
        assertEquals(Arrays.asList(source), copyRequest.getEntityReferences());
        assertEquals(destination.getParent(), copyRequest.getDestination());
        assertEquals(
                Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2));
        assertEquals(RefactoringJobs.COPY, copyRequest.getJobType());
        assertEquals(this.userReference, copyRequest.getUserReference());
        assertFalse(copyRequest.isDeep());
        assertTrue(copyRequest.isUpdateLinks());
        assertFalse(copyRequest.isInteractive());
        assertTrue(copyRequest.isCheckRights());
    }
}","['public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getBaseSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getId(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLocation(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getId(), copyRequest.getId()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getName(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights());', 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); {']",True,0,0,26,40,2,1.0,0.999999995,False,False,False,,,,,,,"public void createCopyRequest() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","public void createCopyRequest() throws Exception { boolean var = false; if (var) var = true; DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { boolean var = false; if (var) var = true; DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","public void createCopyRequest() throws Exception { try { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); } catch (Exception e) { throw e; } }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { try { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); } catch (Exception e) { throw e; } }",,,,,,,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); if (Arrays.asList(source) != copyRequest.getEntityReferences()) { assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); } if (destination.getLastSpaceReference() != copyRequest.getDestination()) { <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> } if (Arrays.asList(RefactoringJobs.GROUP,""copy"") != copyRequest.getId().subList(0,2)) { assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); } if (RefactoringJobs.COPY != copyRequest.getJobType()) { assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); } if (this.userReference != copyRequest.getUserReference()) { assertEquals(this.userReference,copyRequest.getUserReference()); } assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); if (Arrays.asList(source) != copyRequest.getEntityReferences()) { assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); } if (destination.getParent() != copyRequest.getDestination()) { assertEquals(destination.getParent(), copyRequest.getDestination()); } if (Arrays.asList(RefactoringJobs.GROUP, ""copy"") != copyRequest.getId().subList(0, 2)) { assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); } if (RefactoringJobs.COPY != copyRequest.getJobType()) { assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); } if (this.userReference != copyRequest.getUserReference()) { assertEquals(this.userReference, copyRequest.getUserReference()); } assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }","public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference copyRequest = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest destination = requestFactory.createCopyRequest(source, copyRequest); assertEquals(Arrays.asList(source), destination.getEntityReferences()); <START> assertEquals(copyRequest.getLastSpaceReference(), destination.getDestination()); <END> assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), destination.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, destination.getJobType()); assertEquals(this.userReference, destination.getUserReference()); assertFalse(destination.isDeep()); assertTrue(destination.isUpdateLinks()); assertFalse(destination.isInteractive()); assertTrue(destination.isCheckRights()); }",copyRequest.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference copyRequest = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest destination = requestFactory.createCopyRequest(source, copyRequest); assertEquals(Arrays.asList(source), destination.getEntityReferences()); assertEquals(copyRequest.getParent(), destination.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), destination.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, destination.getJobType()); assertEquals(this.userReference, destination.getUserReference()); assertFalse(destination.isDeep()); assertTrue(destination.isUpdateLinks()); assertFalse(destination.isInteractive()); assertTrue(destination.isCheckRights()); }","public void createCopyRequest() throws Exception { DocumentReference pzrof = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference avdci = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest uxpmi = requestFactory.createCopyRequest(pzrof, avdci); assertEquals(Arrays.asList(pzrof), uxpmi.getEntityReferences()); <START> assertEquals(avdci.getLastSpaceReference(), uxpmi.getDestination()); <END> assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), uxpmi.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, uxpmi.getJobType()); assertEquals(this.userReference, uxpmi.getUserReference()); assertFalse(uxpmi.isDeep()); assertTrue(uxpmi.isUpdateLinks()); assertFalse(uxpmi.isInteractive()); assertTrue(uxpmi.isCheckRights()); }",avdci.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference pzrof = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference avdci = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest uxpmi = requestFactory.createCopyRequest(pzrof, avdci); assertEquals(Arrays.asList(pzrof), uxpmi.getEntityReferences()); assertEquals(avdci.getParent(), uxpmi.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), uxpmi.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, uxpmi.getJobType()); assertEquals(this.userReference, uxpmi.getUserReference()); assertFalse(uxpmi.isDeep()); assertTrue(uxpmi.isUpdateLinks()); assertFalse(uxpmi.isInteractive()); assertTrue(uxpmi.isCheckRights()); }",,,,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference ldwel = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(ldwel,destination); assertEquals(Arrays.asList(ldwel),copyRequest.getEntityReferences()); <START>assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination());<END> assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }",destination.getParent() return is more readable in this context I,"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference ldwel = new DocumentReference(""code"", ""Model"", ""Entity""); DocumentReference destination = new DocumentReference(""code"", Arrays.asList(""Model"", ""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(ldwel, destination); assertEquals(Arrays.asList(ldwel), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, ""copy""), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }","1- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
2- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
3- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences());assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
4- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
5- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(),CopyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
6- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
7- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
8- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
9- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""), ""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getLastSpaceReference(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }
10- public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(""code"",""Model"",""Entity""); DocumentReference destination = new DocumentReference(""code"",Arrays.asList(""Model"",""Entity""),""WebHome""); CopyRequest copyRequest = requestFactory.createCopyRequest(source,destination); assertEquals(Arrays.asList(source),copyRequest.getEntityReferences()); assertEquals(destination.getParent(),copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP,""copy""),copyRequest.getId().subList(0,2)); assertEquals(RefactoringJobs.COPY,copyRequest.getJobType()); assertEquals(this.userReference,copyRequest.getUserReference()); if (copyRequest.isDeep()) { assertFalse(copyRequest.isDeep()); } if (!copyRequest.isUpdateLinks()) { assertTrue(copyRequest.isUpdateLinks()); } if (copyRequest.isInteractive()) { assertFalse(copyRequest.isInteractive()); } if (!copyRequest.isCheckRights()) { assertTrue(copyRequest.isCheckRights()); } }",0
1762,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream() <START> .map(Map.Entry<String, String>::getKey).collect(Collectors.toList()); <END> client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public class DummyClass {
    public final void testSessionVariables()
            throws IOException, TajoException, InterruptedException {
        String prefixName = ""key_"";
        String prefixValue = ""val_"";
        List<String> unsetList =
                client.getAllSessionVariables().entrySet().stream()
                        .map(Map.Entry<String, String>::getKey)
                        .collect(Collectors.toList());
        client.unsetSessionVariables(unsetList);
        for (int i = 0; i < 10; i++) {
            String key = prefixName + i;
            String val = prefixValue + i;
            assertEquals(i + 4, client.getAllSessionVariables().size());
            assertFalse(client.getAllSessionVariables().containsKey(key));
            assertFalse(client.existSessionVariable(key));
            Map<String, String> map = Maps.newHashMap();
            map.put(key, val);
            client.updateSessionVariables(map);
            assertEquals(i + 5, client.getAllSessionVariables().size());
            assertTrue(client.getAllSessionVariables().containsKey(key));
            assertTrue(client.existSessionVariable(key));
        }
        int totalSessionVarNum = client.getAllSessionVariables().size();
        for (int i = 0; i < 10; i++) {
            String key = prefixName + i;
            assertTrue(client.getAllSessionVariables().containsKey(key));
            assertTrue(client.existSessionVariable(key));
            client.unsetSessionVariables(Lists.newArrayList(key));
            assertFalse(client.getAllSessionVariables().containsKey(key));
            assertFalse(client.existSessionVariable(key));
        }
        assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size());
    }
}",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public class DummyClass {
    public final void testSessionVariables()
            throws IOException, TajoException, InterruptedException {
        String prefixName = ""key_"";
        String prefixValue = ""val_"";
        List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());
        client.unsetSessionVariables(unsetList);
        for (int i = 0; i < 10; i++) {
            String key = prefixName + i;
            String val = prefixValue + i;
            assertEquals(i + 4, client.getAllSessionVariables().size());
            assertFalse(client.getAllSessionVariables().containsKey(key));
            assertFalse(client.existSessionVariable(key));
            Map<String, String> map = Maps.newHashMap();
            map.put(key, val);
            client.updateSessionVariables(map);
            assertEquals(i + 5, client.getAllSessionVariables().size());
            assertTrue(client.getAllSessionVariables().containsKey(key));
            assertTrue(client.existSessionVariable(key));
        }
        int totalSessionVarNum = client.getAllSessionVariables().size();
        for (int i = 0; i < 10; i++) {
            String key = prefixName + i;
            assertTrue(client.getAllSessionVariables().containsKey(key));
            assertTrue(client.existSessionVariable(key));
            client.unsetSessionVariables(Lists.newArrayList(key));
            assertFalse(client.getAllSessionVariables().containsKey(key));
            assertFalse(client.existSessionVariable(key));
        }
        assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size());
    }
}","['public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Collections.singletonList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Arrays.asList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(unmodifiableList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(LISTS.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(LISTS); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { StringprefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }', 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 3, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }']",True,0,0,122,122,5,1.0,0.999999995,False,False,False,,,,,,,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { boolean var = false; if (var) var = true; String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { boolean var = false; if (var) var = true; String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { try { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); } catch (Exception e) { throw e; } }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { try { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); } catch (Exception e) { throw e; } }",,,,,,,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; if (i + 4 != client.getAllSessionVariables().size()) { assertEquals(i + 4, client.getAllSessionVariables().size()); } assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); if (i + 5 != client.getAllSessionVariables().size()) { assertEquals(i + 5, client.getAllSessionVariables().size()); } assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } if (totalSessionVarNum - 10 != client.getAllSessionVariables().size()) { assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); } }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; if (i + 4 != client.getAllSessionVariables().size()) { assertEquals(i + 4, client.getAllSessionVariables().size()); } assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); if (i + 5 != client.getAllSessionVariables().size()) { assertEquals(i + 5, client.getAllSessionVariables().size()); } assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } if (totalSessionVarNum - 10 != client.getAllSessionVariables().size()) { assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); } }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String val = ""key_""; String i = ""val_""; List<String> prefixValue = client.getAllSessionVariables().entrySet().stream().<START> key(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(prefixValue); for (int unsetList = 0; unsetList < 10; unsetList++) { String map = val + unsetList; String prefixName = i + unsetList; assertEquals(unsetList + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(map)); assertFalse(client.existSessionVariable(map)); Map<String, String> key = Maps.newHashMap(); key.put(map, prefixName); client.updateSessionVariables(key); assertEquals(unsetList + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(map)); assertTrue(client.existSessionVariable(map)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int unsetList = 0; unsetList < 10; unsetList++) { String map = val + unsetList; assertTrue(client.getAllSessionVariables().containsKey(map)); assertTrue(client.existSessionVariable(map)); client.unsetSessionVariables(Lists.newArrayList(map)); assertFalse(client.getAllSessionVariables().containsKey(map)); assertFalse(client.existSessionVariable(map)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String val = ""key_""; String i = ""val_""; List<String> prefixValue = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(prefixValue); for (int unsetList = 0; unsetList < 10; unsetList++) { String map = val + unsetList; String prefixName = i + unsetList; assertEquals(unsetList + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(map)); assertFalse(client.existSessionVariable(map)); Map<String, String> key = Maps.newHashMap(); key.put(map, prefixName); client.updateSessionVariables(key); assertEquals(unsetList + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(map)); assertTrue(client.existSessionVariable(map)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int unsetList = 0; unsetList < 10; unsetList++) { String map = val + unsetList; assertTrue(client.getAllSessionVariables().containsKey(map)); assertTrue(client.existSessionVariable(map)); client.unsetSessionVariables(Lists.newArrayList(map)); assertFalse(client.getAllSessionVariables().containsKey(map)); assertFalse(client.existSessionVariable(map)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String cqcfo = ""key_""; String cbdwm = ""val_""; List<String> dwhpo = client.getAllSessionVariables().entrySet().stream().<START> ssemt(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(dwhpo); for (int wfxrf = 0; wfxrf < 10; wfxrf++) { String rrmno = cqcfo + wfxrf; String usosz = cbdwm + wfxrf; assertEquals(wfxrf + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(rrmno)); assertFalse(client.existSessionVariable(rrmno)); Map<String, String> ssemt = Maps.newHashMap(); ssemt.put(rrmno, usosz); client.updateSessionVariables(ssemt); assertEquals(wfxrf + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(rrmno)); assertTrue(client.existSessionVariable(rrmno)); } int nefyh = client.getAllSessionVariables().size(); for (int wfxrf = 0; wfxrf < 10; wfxrf++) { String rrmno = cqcfo + wfxrf; assertTrue(client.getAllSessionVariables().containsKey(rrmno)); assertTrue(client.existSessionVariable(rrmno)); client.unsetSessionVariables(Lists.newArrayList(rrmno)); assertFalse(client.getAllSessionVariables().containsKey(rrmno)); assertFalse(client.existSessionVariable(rrmno)); } assertEquals(nefyh - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> dwhpo = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String cqcfo = ""key_""; String cbdwm = ""val_""; List<String> dwhpo = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(dwhpo); for (int wfxrf = 0; wfxrf < 10; wfxrf++) { String rrmno = cqcfo + wfxrf; String usosz = cbdwm + wfxrf; assertEquals(wfxrf + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(rrmno)); assertFalse(client.existSessionVariable(rrmno)); Map<String, String> ssemt = Maps.newHashMap(); ssemt.put(rrmno, usosz); client.updateSessionVariables(ssemt); assertEquals(wfxrf + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(rrmno)); assertTrue(client.existSessionVariable(rrmno)); } int nefyh = client.getAllSessionVariables().size(); for (int wfxrf = 0; wfxrf < 10; wfxrf++) { String rrmno = cqcfo + wfxrf; assertTrue(client.getAllSessionVariables().containsKey(rrmno)); assertTrue(client.existSessionVariable(rrmno)); client.unsetSessionVariables(Lists.newArrayList(rrmno)); assertFalse(client.getAllSessionVariables().containsKey(rrmno)); assertFalse(client.existSessionVariable(rrmno)); } assertEquals(nefyh - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixValue = ""val_""; String prefixName = ""key_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixValue = ""val_""; String prefixName = ""key_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String gjepo = ""key_""; String prefixValue = ""val_""; List<String> unsetList = client.getAllSessionVariables().entrySet().stream().<START> map(Map.Entry<String, String>::getKey).<END> collect(Collectors.toList()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = gjepo + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = gjepo + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());,"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String gjepo = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = gjepo + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = gjepo + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }","1- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
2- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
3- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
4- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { StringprefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
5- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
6- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
7- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
8- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); client.getAllSessionVariables().containsKey(key); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }
9- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals(totalSessionVarNumber - 10, client.getAllSessionVariables().size()); }
10- public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = ""key_""; String prefixValue = ""val_""; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; if (!client.getAllSessionVariables().containsKey(key)) { assertTrue(client.getAllSessionVariables().containsKey(key)); } if (!client.existSessionVariable(key)) { assertTrue(client.existSessionVariable(key)); } client.unsetSessionVariables(Lists.newArrayList(key)); if (client.getAllSessionVariables().containsKey(key)) { assertFalse(client.getAllSessionVariables().containsKey(key)); } if (client.existSessionVariable(key)) { assertFalse(client.existSessionVariable(key)); } } assertEquals( totalSessionVarNum - 10, client.getAllSessionVariables().size()); }",1
1806,"void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); <START> String actualErrorMmessage = foreignAchErrorMessages.get(0); <END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMmessage); }","public class DummyClass {
    void testIsUsAchBankForeignFormCanadaBank() {
        achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true));
        pmwVendor.setBankAddressCountry(
                PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA
                        .getPmwCountryOptionAsString());
        boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData);
        assertFalse(actualIsUsBankAccount);
        assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount());
        assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size());
        assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount());
        List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems();
        assertEquals(1, foreignAchItems.size());
        List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages();
        assertEquals(1, foreignAchErrorMessages.size());
        String actualErrorMmessage = foreignAchErrorMessages.get(0);
        assertEquals(
                ""The bank has a country code of Canada. We can only create ACH records for banks""
                    + "" that have a US address"",
                actualErrorMmessage);
    }
}","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }","public class DummyClass {
    void testIsUsAchBankForeignFormCanadaBank() {
        achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true));
        pmwVendor.setBankAddressCountry(
                PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA
                        .getPmwCountryOptionAsString());
        boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData);
        assertFalse(actualIsUsBankAccount);
        assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount());
        assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size());
        assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount());
        List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems();
        assertEquals(1, foreignAchItems.size());
        List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages();
        assertEquals(1, foreignAchErrorMessages.size());
        String actualErrorMessage = foreignAchErrorMessages.get(0);
        assertEquals(
                ""The bank has a country code of Canada. We can only create ACH records for banks""
                    + "" that have a US address"",
                actualErrorMessage);
    }
}","['void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsNP = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsNP); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsDescr = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsoop = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsDescr); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsuation = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsso = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMsg); }', 'void testIsUsAchBankForeignFormCanadaBank() { }']",True,6,0,28,28,4,1.0,0.999999995,False,False,False,"void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); <START> String actualErrorMmessage = foreignAchErrorMessages.get(0); <END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }",,,,"void testIsUsAchBankForeignFormCanadaBank() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); assertFalse(actualIsUsBankAccount); assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }","void testIsUsAchBankForeignFormCanadaBank() { boolean var = false; if (var) var = true; achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); assertFalse(actualIsUsBankAccount); assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { boolean var = false; if (var) var = true; achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }","void testIsUsAchBankForeignFormCanadaBank() { try { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); assertFalse(actualIsUsBankAccount); assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); } catch (Exception e) { throw e; } }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { try { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); } catch (Exception e) { throw e; } }",,,,,,,"void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); assertFalse(actualIsUsBankAccount); if (0 != reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()) { assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); } if (0 != reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()) { assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); } if (1 != reportData.getRecordsWithForeignAchSummary().getRecordCount()) { assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); } List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); if (1 != foreignAchItems.size()) { assertEquals(1,foreignAchItems.size()); } List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); if (1 != foreignAchErrorMessages.size()) { assertEquals(1,foreignAchErrorMessages.size()); } <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> if (""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"" != actualErrorMmessage) { assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); } }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); if (0 != reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()) { assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); } if (0 != reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()) { assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); } if (1 != reportData.getRecordsWithForeignAchSummary().getRecordCount()) { assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); } List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); if (1 != foreignAchItems.size()) { assertEquals(1, foreignAchItems.size()); } List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); if (1 != foreignAchErrorMessages.size()) { assertEquals(1, foreignAchErrorMessages.size()); } String actualErrorMessage = foreignAchErrorMessages.get(0); if (""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"" != actualErrorMessage) { assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); } }","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); <START> assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMmessage = <END> foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean cfyzw = achService.isUsAchBank(pmwVendor, reportData); assertFalse(cfyzw); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> aegzm = reportData.getForeignAchItems(); assertEquals(1, aegzm.size()); List<String> muqfw = aegzm.get(0).getErrorMessages(); <START> assertEquals(1, muqfw.size()); String vaviy = <END> muqfw.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", vaviy); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean cfyzw = achService.isUsAchBank(pmwVendor, reportData); assertFalse(cfyzw); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> aegzm = reportData.getForeignAchItems(); assertEquals(1, aegzm.size()); List<String> muqfw = aegzm.get(0).getErrorMessages(); assertEquals(1, muqfw.size()); String actualErrorMessage = muqfw.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }",,,,"void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); boolean bqhpz = achService.isUsAchBank(pmwVendor,reportData); assertFalse(bqhpz); assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); <START>String actualErrorMmessage = foreignAchErrorMessages.get(0);<END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }","Minor typo in variable name; extra unneeded ""m""","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); boolean bqhpz = achService.isUsAchBank(pmwVendor, reportData); assertFalse(bqhpz); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"", actualErrorMessage); }","1- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
2- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsNP); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
3- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMsg = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMsg); }
4- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsNP = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
5- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorState = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorState); }
6- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsDescr = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
7- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsNP) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
8- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsDescr); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
9- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsso); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }
10- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsoop = achService.isUsAchBank(pmwVendor,reportData); if (actualIsUsBankAccount) { assertFalse(actualIsUsBankAccount); } assertEquals(0,reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0,reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1,reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1,foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1,foreignAchErrorMessages.size()); String actualErrorMmessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks"" + "" that have a US address"",actualErrorMmessage); }",0
1809,"public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); <START> assertFalse(cell.getType() == Cell.EMPTY); <END> }","public class DummyClass {
    public void slightlyOccupiedAABBTest() {
        Level check =
                new Level(
                        emptyPlayer,
                        emptyUnit,
                        new Grid<>(
                                Arrays.asList(
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.EMPTY,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL),
                                3,
                                3));
        CollisionHandler handler = new CollisionHandler(check);
        Cell cell =
                handler.checkLevelAABB(
                        new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0));
        assertFalse(cell.getType() == Cell.EMPTY);
    }
}","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","public class DummyClass {
    public void slightlyOccupiedAABBTest() {
        Level check =
                new Level(
                        emptyPlayer,
                        emptyUnit,
                        new Grid<>(
                                Arrays.asList(
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.EMPTY,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL,
                                        Cell.WALL),
                                3,
                                3));
        CollisionHandler handler = new CollisionHandler(check);
        Cell cell =
                handler.checkLevelAABB(
                        new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0));
        assertNotEquals(cell, Cell.EMPTY);
    }
}","['public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell. EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL""), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL)), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL) 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotNull(cell); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5(), 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL)) 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }', 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL }']",True,0,0,43,46,3,1.0,0.999999995,False,False,False,,,,,,,"public void slightlyOccupiedAABBTest() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); <START>assertFalse(cell.getType() == Cell.EMPTY);<END> }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","public void slightlyOccupiedAABBTest() { boolean var = false; if (var) var = true; Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); <START>assertFalse(cell.getType() == Cell.EMPTY);<END> }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { boolean var = false; if (var) var = true; Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","public void slightlyOccupiedAABBTest() { try { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); <START>assertFalse(cell.getType() == Cell.EMPTY);<END> } catch (Exception e) { throw e; } }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { try { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); if (cell.getType() == Cell.EMPTY) { <START>assertFalse(cell.getType() == Cell.EMPTY);<END> } }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new <START> Point(0, 0)); assertFalse(cell.getType() == <END> Cell.EMPTY); }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","public void slightlyOccupiedAABBTest() { Level slgvh = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler gbufv = new CollisionHandler(slgvh); Cell mvdgi = gbufv.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new <START> Point(0, 0)); assertFalse(mvdgi.getType() == <END> Cell.EMPTY); }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { Level slgvh = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler gbufv = new CollisionHandler(slgvh); Cell mvdgi = gbufv.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(mvdgi, Cell.EMPTY); }",,,,"public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); Level cxrtj = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(cxrtj); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); <START>assertFalse(cell.getType() == Cell.EMPTY);<END> }","assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing","public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); Level cxrtj = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList(Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(cxrtj); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }","1- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertNotEquals(cell, Cell.EMPTY); }
2- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertFalse(cell == Cell.EMPTY); }
3- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertFalse(cell, Cell.EMPTY); }
4- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertTrue(cell.getType() == Cell.EMPTY); }
5- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertFalse(cell); }
6- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertFalse(cell != Cell.EMPTY); }
7- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertNotEquals(cell, Cell.EMPTY); }
8- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertFalse(cell.getType() == Cell.EMPTY);
9- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertNotEquals(cell, Cell.EMPTY);
10- public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer,emptyUnit,new Grid<>(Arrays.asList(Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL,Cell.EMPTY,Cell.WALL,Cell.WALL,Cell.WALL,Cell.WALL),3,3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB(new AABB(new Point(1.5,1.5),new Point(2.5,2.5)),new Point(0,0)); assertTrue(cell.getType() != Cell.EMPTY); }",0
1812,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START> final Map<Resource, Set<Resource>> enumerations = new HashMap<>(); <END> enumerations.put(SUITS, CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS, CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public class DummyClass {
    public void testOneOf() throws Exception {
        final InferenceEngine inferenceEngine = mock(InferenceEngine.class);
        final Map<Resource, Set<Resource>> enumerations = new HashMap<>();
        enumerations.put(SUITS, CARD_SUIT_ENUMERATION);
        when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true);
        when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION);
        enumerations.put(RANKS, CARD_RANK_ENUMERATION);
        when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true);
        when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION);
        final Projection query =
                new Projection(
                        new StatementPattern(
                                new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)),
                        new ProjectionElemList(new ProjectionElem(""s"", ""subject"")));
        query.visit(new OneOfVisitor(conf, inferenceEngine));
        assertTrue(query.getArg() instanceof BindingSetAssignment);
        final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg();
        final Iterable<BindingSet> iterable = bsa.getBindingSets();
        final Iterator<BindingSet> iter = iterable.iterator();
        assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator());
        final Projection query2 =
                new Projection(
                        new StatementPattern(
                                new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)),
                        new ProjectionElemList(new ProjectionElem(""s"", ""subject"")));
        query2.visit(new OneOfVisitor(conf, inferenceEngine));
        assertTrue(query2.getArg() instanceof BindingSetAssignment);
        final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg();
        final Iterable<BindingSet> iterable2 = bsa2.getBindingSets();
        final Iterator<BindingSet> iter2 = iterable2.iterator();
        assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator());
    }
}",this is,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public class DummyClass {
    public void testOneOf() throws Exception {
        final InferenceEngine inferenceEngine = mock(InferenceEngine.class);
        when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true);
        when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION);
        when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true);
        when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION);
        final Projection query =
                new Projection(
                        new StatementPattern(
                                new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)),
                        new ProjectionElemList(new ProjectionElem(""s"", ""subject"")));
        query.visit(new OneOfVisitor(conf, inferenceEngine));
        assertTrue(query.getArg() instanceof BindingSetAssignment);
        final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg();
        final Iterable<BindingSet> iterable = bsa.getBindingSets();
        final Iterator<BindingSet> iter = iterable.iterator();
        assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator());
        final Projection query2 =
                new Projection(
                        new StatementPattern(
                                new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)),
                        new ProjectionElemList(new ProjectionElem(""s"", ""subject"")));
        query2.visit(new OneOfVisitor(conf, inferenceEngine));
        assertTrue(query2.getArg() instanceof BindingSetAssignment);
        final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg();
        final Iterable<BindingSet> iterable2 = bsa2.getBindingSets();
        final Iterator<BindingSet> iter2 = iterable2.iterator();
        assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator());
    }
}","['public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem<>(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine. isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine. isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter3 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMerATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var<>(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator());final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }', 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration( SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }']",True,0,0,189,189,8,1.0,0.999999995,False,False,False,,,,,,,"public void testOneOf() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { boolean var = false; if (var) var = true; final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { boolean var = false; if (var) var = true; final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { try { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); } catch (Exception e) { throw e; } }",this is,"public void testOneOf() throws Exception { try { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { final InferenceEngine query = mock(InferenceEngine.class); <START> final Map<Resource, Set<Resource>> query2 = new HashMap<>(); <END> query2.put(SUITS, CARD_SUIT_ENUMERATION); when(query.isEnumeratedType(SUITS)).thenReturn(true); when(query.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); query2.put(RANKS, CARD_RANK_ENUMERATION); when(query.isEnumeratedType(RANKS)).thenReturn(true); when(query.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection enumerations = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); enumerations.visit(new OneOfVisitor(conf, query)); assertTrue(enumerations.getArg() instanceof BindingSetAssignment); final BindingSetAssignment inferenceEngine = (BindingSetAssignment) enumerations.getArg(); final Iterable<BindingSet> iter = inferenceEngine.getBindingSets(); final Iterator<BindingSet> iter2 = iter.iterator(); assertBindingSet(iter2, CARD_SUIT_ENUMERATION.iterator()); final Projection bsa = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); bsa.visit(new OneOfVisitor(conf, query)); assertTrue(bsa.getArg() instanceof BindingSetAssignment); final BindingSetAssignment iterable = (BindingSetAssignment) bsa.getArg(); final Iterable<BindingSet> bsa2 = iterable.getBindingSets(); final Iterator<BindingSet> iterable2 = bsa2.iterator(); assertBindingSet(iterable2, CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { final InferenceEngine query = mock(InferenceEngine.class); when(query.isEnumeratedType(SUITS)).thenReturn(true); when(query.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(query.isEnumeratedType(RANKS)).thenReturn(true); when(query.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection enumerations = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); enumerations.visit(new OneOfVisitor(conf, query)); assertTrue(enumerations.getArg() instanceof BindingSetAssignment); final BindingSetAssignment inferenceEngine = (BindingSetAssignment) enumerations.getArg(); final Iterable<BindingSet> iter = inferenceEngine.getBindingSets(); final Iterator<BindingSet> iter2 = iter.iterator(); assertBindingSet(iter2, CARD_SUIT_ENUMERATION.iterator()); final Projection bsa = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); bsa.visit(new OneOfVisitor(conf, query)); assertTrue(bsa.getArg() instanceof BindingSetAssignment); final BindingSetAssignment iterable = (BindingSetAssignment) bsa.getArg(); final Iterable<BindingSet> bsa2 = iterable.getBindingSets(); final Iterator<BindingSet> iterable2 = bsa2.iterator(); assertBindingSet(iterable2, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { final InferenceEngine wdqzc = mock(InferenceEngine.class); <START> final Map<Resource, Set<Resource>> sdvrg = new HashMap<>(); <END> sdvrg.put(SUITS, CARD_SUIT_ENUMERATION); when(wdqzc.isEnumeratedType(SUITS)).thenReturn(true); when(wdqzc.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); sdvrg.put(RANKS, CARD_RANK_ENUMERATION); when(wdqzc.isEnumeratedType(RANKS)).thenReturn(true); when(wdqzc.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection uoqrh = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); uoqrh.visit(new OneOfVisitor(conf, wdqzc)); assertTrue(uoqrh.getArg() instanceof BindingSetAssignment); final BindingSetAssignment ldwtg = (BindingSetAssignment) uoqrh.getArg(); final Iterable<BindingSet> ksqhn = ldwtg.getBindingSets(); final Iterator<BindingSet> vwari = ksqhn.iterator(); assertBindingSet(vwari, CARD_SUIT_ENUMERATION.iterator()); final Projection wxmbg = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); wxmbg.visit(new OneOfVisitor(conf, wdqzc)); assertTrue(wxmbg.getArg() instanceof BindingSetAssignment); final BindingSetAssignment gotca = (BindingSetAssignment) wxmbg.getArg(); final Iterable<BindingSet> slxln = gotca.getBindingSets(); final Iterator<BindingSet> hglrg = slxln.iterator(); assertBindingSet(hglrg, CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { final InferenceEngine wdqzc = mock(InferenceEngine.class); when(wdqzc.isEnumeratedType(SUITS)).thenReturn(true); when(wdqzc.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(wdqzc.isEnumeratedType(RANKS)).thenReturn(true); when(wdqzc.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection uoqrh = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); uoqrh.visit(new OneOfVisitor(conf, wdqzc)); assertTrue(uoqrh.getArg() instanceof BindingSetAssignment); final BindingSetAssignment ldwtg = (BindingSetAssignment) uoqrh.getArg(); final Iterable<BindingSet> ksqhn = ldwtg.getBindingSets(); final Iterator<BindingSet> vwari = ksqhn.iterator(); assertBindingSet(vwari, CARD_SUIT_ENUMERATION.iterator()); final Projection wxmbg = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); wxmbg.visit(new OneOfVisitor(conf, wdqzc)); assertTrue(wxmbg.getArg() instanceof BindingSetAssignment); final BindingSetAssignment gotca = (BindingSetAssignment) wxmbg.getArg(); final Iterable<BindingSet> slxln = gotca.getBindingSets(); final Iterator<BindingSet> hglrg = slxln.iterator(); assertBindingSet(hglrg, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> final InferenceEngine inferenceEngine = mock(InferenceEngine.class); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); InferenceEngine ktdeb = mock(InferenceEngine.class); <START>final Map<Resource,Set<Resource>> enumerations = new HashMap<>();<END> enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(ktdeb.isEnumeratedType(SUITS)).thenReturn(true); when(ktdeb.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(ktdeb.isEnumeratedType(RANKS)).thenReturn(true); when(ktdeb.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,ktdeb)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,ktdeb)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }",this is,"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); InferenceEngine ktdeb = mock(InferenceEngine.class); when(ktdeb.isEnumeratedType(SUITS)).thenReturn(true); when(ktdeb.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(ktdeb.isEnumeratedType(RANKS)).thenReturn(true); when(ktdeb.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", SUITS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query.visit(new OneOfVisitor(conf, ktdeb)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""), new Var(""p"", RDF.TYPE), new Var(""o"", RANKS)), new ProjectionElemList(new ProjectionElem(""s"", ""subject""))); query2.visit(new OneOfVisitor(conf, ktdeb)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }","1- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
2- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
3- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> textMap = new HashMap<>(); textMap.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); textMap.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
4- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> texts = new HashMap<>(); texts.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); texts.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
5- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> expected = new HashMap<>(); expected.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); expected.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
6- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> infos = new HashMap<>(); infos.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); infos.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
7- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> data = new HashMap<>(); data.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); data.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
8- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> textMap = new HashMap<>(); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION.iterator()); }
9- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION); }
10- public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); final Map<Resource,Set<Resource>> enumerations = new HashMap<>(); enumerations.put(SUITS,CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS,CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",SUITS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query.getArg() instanceof BindingSetAssignment) { assertTrue(query.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter,CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection(new StatementPattern(new Var(""s""),new Var(""p"",RDF.TYPE),new Var(""o"",RANKS)),new ProjectionElemList(new ProjectionElem(""s"",""subject""))); query2.visit(new OneOfVisitor(conf,inferenceEngine)); if (!query2.getArg() instanceof BindingSetAssignment) { assertTrue(query2.getArg() instanceof BindingSetAssignment); } final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2,CARD_RANK_ENUMERATION. iterator()); }",0
1854,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public class DummyClass {
    public void testDeleteCardUsingFilter() throws Throwable {
        this.testYearFilter();
        int cardIndex = 0;
        final int year = 1993;
        Predicate<BaseballCard> yearPred =
                new Predicate<BaseballCard>() {
                    @Override
                    public boolean doTest(BaseballCard card) {
                        return card.getYear() == year;
                    }
                };
        this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred);
        this.expectedCards.remove(cardIndex);
        Assert.assertTrue(this.solo.waitForView(R.id.select_all));
        this.solo.clickOnCheckBox(cardIndex + 1);
        Assert.assertTrue(this.solo.waitForView(R.id.delete_menu));
        View deleteMenu = this.activity.findViewById(R.id.delete_menu);
        Assert.assertNotNull(deleteMenu);
        TouchUtils.clickView(this, deleteMenu);
        BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE);
        ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list);
        BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv);
    }
}",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public class DummyClass {
    public void testDeleteCardUsingFilter() throws Throwable {
        this.testYearFilter();
        int cardIndex = 0;
        final int year = 1993;
        Predicate<BaseballCard> yearPred =
                new Predicate<BaseballCard>() {
                    @Override
                    public boolean doTest(BaseballCard card) {
                        return card.getYear() == year;
                    }
                };
        this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred);
        this.expectedCards.remove(cardIndex);
        Assert.assertTrue(this.solo.waitForView(R.id.select_all));
        this.solo.clickOnCheckBox(cardIndex + 1);
        Assert.assertTrue(this.solo.waitForView(R.id.delete_menu));
        deleteCards();
        ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list);
        BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv);
    }
}","['public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu_1)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); View lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItem(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); Assert.assertNotNull( lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards(), lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); } {']",True,2,0,186,217,9,1.0,0.999999995,True,True,False,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) var = true; this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) var = true; return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) var = true; this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) var = true; return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { try { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); } catch (Exception e) { throw e; } }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { try { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); } catch (Exception e) { throw e; } }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); if (deleteMenu == null) { Assert.assertNotNull(deleteMenu); } TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int deleteMenu = 0; final int yearPred = 1993; Predicate<BaseballCard> cardIndex = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == yearPred; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, cardIndex); this.expectedCards.remove(deleteMenu); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(deleteMenu + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View year = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(year); TouchUtils.clickView(this, year); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int deleteMenu = 0; final int yearPred = 1993; Predicate<BaseballCard> cardIndex = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == yearPred; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, cardIndex); this.expectedCards.remove(deleteMenu); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(deleteMenu + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int fgvxz = 0; final int kszij = 1993; Predicate<BaseballCard> dctxq = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard mbnfj) { return mbnfj.getYear() == kszij; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, dctxq); this.expectedCards.remove(fgvxz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(fgvxz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View isxdv = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(isxdv); TouchUtils.clickView(this, isxdv); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView sifvj = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, sifvj); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int fgvxz = 0; final int kszij = 1993; Predicate<BaseballCard> dctxq = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard mbnfj) { return mbnfj.getYear() == kszij; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, dctxq); this.expectedCards.remove(fgvxz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(fgvxz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView sifvj = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, sifvj); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final int year = 1993; int cardIndex = 0; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final int year = 1993; int cardIndex = 0; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; int coqbz = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(coqbz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(coqbz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; int coqbz = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(coqbz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(coqbz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","1- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
2- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
3- public void testDeleteCardUsingFilter() throws Throwable { this.checkYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
4- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCardDelete(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
5- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
6- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } }
7- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
8- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv);
9- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); deleteCards();
10- public void testDeleteCardUsingFilter() throws Throwable { this.deleteCard(true); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",0
1883,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); logger.info(""executedLow: {}"", executedLow.getTime().getTime()); logger.info(""executedHigh: {}"", executedHigh.getTime().getTime()); <START> logger.info(""exec difference: {}"", (executedLow.getTime().getTime() - executedHigh.getTime().getTime())); <END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public class DummyClass {
    public void testPrioritizedJobsExecution() throws InterruptedException {
        CountDownAsyncJobListener countDownListener = configureListener(2);
        CommandContext ctxCMD = new CommandContext();
        ctxCMD.setData(""businessKey"", ""low priority"");
        ctxCMD.setData(""priority"", 2);
        Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD);
        CommandContext ctxCMD2 = new CommandContext();
        ctxCMD2.setData(""businessKey"", ""high priority"");
        ctxCMD2.setData(""priority"", 8);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2);
        countDownListener.waitTillCompleted();
        List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext());
        assertEquals(0, inErrorRequests.size());
        List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext());
        assertEquals(0, queuedRequests.size());
        List<RequestInfo> executedRequests =
                executorService.getCompletedRequests(new QueryContext());
        assertEquals(2, executedRequests.size());
        RequestInfo executedHigh = executedRequests.get(1);
        assertNotNull(executedHigh);
        assertEquals(""high priority"", executedHigh.getKey());
        RequestInfo executedLow = executedRequests.get(0);
        assertNotNull(executedLow);
        assertEquals(""low priority"", executedLow.getKey());
        logger.info(""executedLow: {}"", executedLow.getTime().getTime());
        logger.info(""executedHigh: {}"", executedHigh.getTime().getTime());
        logger.info(
                ""exec difference: {}"",
                (executedLow.getTime().getTime() - executedHigh.getTime().getTime()));
        assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime());
    }
}",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public class DummyClass {
    public void testPrioritizedJobsExecution() throws InterruptedException {
        CountDownAsyncJobListener countDownListener = configureListener(2);
        CommandContext ctxCMD = new CommandContext();
        ctxCMD.setData(""businessKey"", ""low priority"");
        ctxCMD.setData(""priority"", 2);
        Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD);
        CommandContext ctxCMD2 = new CommandContext();
        ctxCMD2.setData(""businessKey"", ""high priority"");
        ctxCMD2.setData(""priority"", 8);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2);
        countDownListener.waitTillCompleted();
        List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext());
        assertEquals(0, inErrorRequests.size());
        List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext());
        assertEquals(0, queuedRequests.size());
        List<RequestInfo> executedRequests =
                executorService.getCompletedRequests(new QueryContext());
        assertEquals(2, executedRequests.size());
        RequestInfo executedHigh = executedRequests.get(1);
        assertNotNull(executedHigh);
        assertEquals(""high priority"", executedHigh.getKey());
        RequestInfo executedLow = executedRequests.get(0);
        assertNotNull(executedLow);
        assertEquals(""low priority"", executedLow.getKey());
        assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime());
    }
}","['public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(executedHigh.getTime(), executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime().getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime(), executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertFalse(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); logger.info(""executedLow: {}"", executedLow.getTime()); logger.info(""executedHigh: {}"", executedHigh.getTime().getTime()); }']",True,0,0,223,264,9,1.0,0.999999995,False,False,False,,,,,,,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) var = true; CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) var = true; CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { try { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } catch (Exception e) { throw e; } }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { try { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } catch (Exception e) { throw e; } }",,,,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); if (0 != inErrorRequests.size()) { assertEquals(0,inErrorRequests.size()); } List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); if (0 != queuedRequests.size()) { assertEquals(0,queuedRequests.size()); } List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); if (2 != executedRequests.size()) { assertEquals(2,executedRequests.size()); } RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); if (""high priority"" != executedHigh.getKey()) { assertEquals(""high priority"",executedHigh.getKey()); } RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); if (""low priority"" != executedLow.getKey()) { assertEquals(""low priority"",executedLow.getKey()); } logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); if (0 != inErrorRequests.size()) { assertEquals(0, inErrorRequests.size()); } List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); if (0 != queuedRequests.size()) { assertEquals(0, queuedRequests.size()); } List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); if (2 != executedRequests.size()) { assertEquals(2, executedRequests.size()); } RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); if (""high priority"" != executedHigh.getKey()) { assertEquals(""high priority"", executedHigh.getKey()); } RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); if (""low priority"" != executedLow.getKey()) { assertEquals(""low priority"", executedLow.getKey()); } assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener inErrorRequests = configureListener(2); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""low priority""); ctxCMD2.setData(""priority"", 2); Date queuedRequests = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""high priority""); ctxCMD.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD); inErrorRequests.waitTillCompleted(); List<RequestInfo> executedLow = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, executedLow.size()); List<RequestInfo> countDownListener = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, countDownListener.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo futureDate = executedRequests.get(1); assertNotNull(futureDate); assertEquals(""high priority"", futureDate.getKey()); RequestInfo executedHigh = executedRequests.get(0); assertNotNull(executedHigh); assertEquals(""low priority"", executedHigh.getKey()); logger.info(""futureDate: {}"", executedHigh.getTime().getTime()); logger.info(""futureDate: <START> {}"", futureDate.getTime().getTime()); logger.info(""exec difference: {}"", <END> (executedHigh.getTime().getTime() - futureDate.getTime().getTime())); assertTrue(executedHigh.getTime().getTime() >= futureDate.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener inErrorRequests = configureListener(2); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""low priority""); ctxCMD2.setData(""priority"", 2); Date queuedRequests = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""high priority""); ctxCMD.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD); inErrorRequests.waitTillCompleted(); List<RequestInfo> executedLow = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, executedLow.size()); List<RequestInfo> countDownListener = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, countDownListener.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo futureDate = executedRequests.get(1); assertNotNull(futureDate); assertEquals(""high priority"", futureDate.getKey()); RequestInfo executedHigh = executedRequests.get(0); assertNotNull(executedHigh); assertEquals(""low priority"", executedHigh.getKey()); assertTrue(executedHigh.getTime().getTime() >= futureDate.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener kwkum = configureListener(2); CommandContext bdewn = new CommandContext(); bdewn.setData(""businessKey"", ""low priority""); bdewn.setData(""priority"", 2); Date lrnaq = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, bdewn); CommandContext wqcdw = new CommandContext(); wqcdw.setData(""businessKey"", ""high priority""); wqcdw.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, wqcdw); kwkum.waitTillCompleted(); List<RequestInfo> brkny = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, brkny.size()); List<RequestInfo> hgfbz = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, hgfbz.size()); List<RequestInfo> sjdog = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, sjdog.size()); RequestInfo bqnma = sjdog.get(1); assertNotNull(bqnma); assertEquals(""high priority"", bqnma.getKey()); RequestInfo gkzrr = sjdog.get(0); assertNotNull(gkzrr); assertEquals(""low priority"", gkzrr.getKey()); logger.info(""executedLow: {}"", gkzrr.getTime().getTime()); logger.info(""executedHigh: <START> {}"", bqnma.getTime().getTime()); logger.info(""exec difference: {}"", <END> (gkzrr.getTime().getTime() - bqnma.getTime().getTime())); assertTrue(gkzrr.getTime().getTime() >= bqnma.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener kwkum = configureListener(2); CommandContext bdewn = new CommandContext(); bdewn.setData(""businessKey"", ""low priority""); bdewn.setData(""priority"", 2); Date lrnaq = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, bdewn); CommandContext wqcdw = new CommandContext(); wqcdw.setData(""businessKey"", ""high priority""); wqcdw.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, wqcdw); kwkum.waitTillCompleted(); List<RequestInfo> brkny = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, brkny.size()); List<RequestInfo> hgfbz = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, hgfbz.size()); List<RequestInfo> sjdog = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, sjdog.size()); RequestInfo bqnma = sjdog.get(1); assertNotNull(bqnma); assertEquals(""high priority"", bqnma.getKey()); RequestInfo gkzrr = sjdog.get(0); assertNotNull(gkzrr); assertEquals(""low priority"", gkzrr.getKey()); assertTrue(gkzrr.getTime().getTime() >= bqnma.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CommandContext ctxCMD = new CommandContext(); CountDownAsyncJobListener countDownListener = configureListener(2); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CommandContext ctxCMD = new CommandContext(); CountDownAsyncJobListener countDownListener = configureListener(2); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CountDownAsyncJobListener nhtae = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); nhtae.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CountDownAsyncJobListener nhtae = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); nhtae.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","1- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }
2- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }
3- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }
4- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); }
5- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); assertEquals(executedLow.getTime().getTime(), executedHigh.getTime().getTime()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }
6- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); }
7- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); }
8- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); assertEquals(""executedLow: {}"",executedLow.getTime()); assertEquals(""executedHigh: {}"",executedHigh.getTime()); }
9- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime())); }
10- public void testPrioritizedJobsExecution() throws InterruptedException",0
1949,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); <START> <END> Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","public class DummyClass {
    public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception {
        SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
        Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00"");
        Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00"");
        Cohort cohort = new Cohort(3);
        CohortMembership temp = new CohortMembership(7);
        temp.setVoided(true);
        temp.setEndDate(endDateLater);
        cohort.addMembership(temp);
        temp = new CohortMembership(8);
        temp.setVoided(true);
        cohort.addMembership(temp);
        temp = new CohortMembership(9);
        temp.setEndDate(endDateEarlier);
        cohort.addMembership(temp);
        temp = new CohortMembership(10);
        temp.setVoided(true);
        cohort.addMembership(temp);
        assertTrue(cohort.hasNoActiveMemberships());
    }
}",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","public class DummyClass {
    public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DAY_OF_YEAR, 1);
        Date endDateLater = calendar.getTime();
        calendar.add(Calendar.DAY_OF_YEAR, -2);
        Date endDateEarlier = calendar.getTime();
        Cohort cohort = new Cohort(3);
        CohortMembership temp = new CohortMembership(7);
        temp.setVoided(true);
        temp.setEndDate(endDateLater);
        cohort.addMembership(temp);
        temp = new CohortMembership(8);
        temp.setVoided(true);
        cohort.addMembership(temp);
        temp = new CohortMembership(9);
        temp.setEndDate(endDateEarlier);
        cohort.addMembership(temp);
        temp = new CohortMembership(10);
        temp.setVoided(true);
        cohort.addMembership(temp);
        assertTrue(cohort.hasNoActiveMemberships());
    }
}","['public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.put(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.put(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR,-2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.set(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF-YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime();calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.put(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }', 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.append(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }']",True,0,0,169,185,14,1.0,0.999999995,True,True,False,,,,,,,"<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { boolean var = false; if (var) var = true; SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { boolean var = false; if (var) var = true; Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { try { SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); } catch (Exception e) { throw e; } }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { try { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); } catch (Exception e) { throw e; } }",,,,,,,,,,"<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); if (!cohort.hasNoActiveMemberships()) { assertTrue(cohort.hasNoActiveMemberships()); } }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); if (!cohort.hasNoActiveMemberships()) { assertTrue(cohort.hasNoActiveMemberships()); } }","public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { SimpleDateFormat endDateLater = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date temp = endDateLater.parse(""2007-02-01 00:00:00""); Date cohort = endDateLater.parse(""2100-02-01 <START> <END> 00:00:00""); Cohort endDateEarlier = new Cohort(3); CohortMembership dateFormat = new CohortMembership(7); dateFormat.setVoided(true); dateFormat.setEndDate(cohort); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(8); dateFormat.setVoided(true); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(9); dateFormat.setEndDate(temp); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(10); dateFormat.setVoided(true); endDateEarlier.addMembership(dateFormat); assertTrue(endDateEarlier.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date cohort = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date temp = calendar.getTime(); Cohort endDateEarlier = new Cohort(3); CohortMembership dateFormat = new CohortMembership(7); dateFormat.setVoided(true); dateFormat.setEndDate(cohort); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(8); dateFormat.setVoided(true); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(9); dateFormat.setEndDate(temp); endDateEarlier.addMembership(dateFormat); dateFormat = new CohortMembership(10); dateFormat.setVoided(true); endDateEarlier.addMembership(dateFormat); assertTrue(endDateEarlier.hasNoActiveMemberships()); }","public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { SimpleDateFormat xtciw = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date pujzl = xtciw.parse(""2007-02-01 00:00:00""); Date ehert = xtciw.parse(""2100-02-01 <START> <END> 00:00:00""); Cohort hhpbr = new Cohort(3); CohortMembership ljhvc = new CohortMembership(7); ljhvc.setVoided(true); ljhvc.setEndDate(ehert); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(8); ljhvc.setVoided(true); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(9); ljhvc.setEndDate(pujzl); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(10); ljhvc.setVoided(true); hhpbr.addMembership(ljhvc); assertTrue(hhpbr.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date ehert = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date pujzl = calendar.getTime(); Cohort hhpbr = new Cohort(3); CohortMembership ljhvc = new CohortMembership(7); ljhvc.setVoided(true); ljhvc.setEndDate(ehert); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(8); ljhvc.setVoided(true); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(9); ljhvc.setEndDate(pujzl); hhpbr.addMembership(ljhvc); ljhvc = new CohortMembership(10); ljhvc.setVoided(true); hhpbr.addMembership(ljhvc); assertTrue(hhpbr.hasNoActiveMemberships()); }","<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = dateFormat.parse(""2007-02-01 00:00:00""); Cohort cohort = new Cohort(3); Date endDateLater = dateFormat.parse(""2100-02-01 00:00:00""); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Cohort cohort = new Cohort(3); Date endDateEarlier = calendar.getTime(); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","<START><END> public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); SimpleDateFormat xgviv = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); Date endDateEarlier = xgviv.parse(""2007-02-01 00:00:00""); Date endDateLater = xgviv.parse(""2100-02-01 00:00:00""); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }",this test pass year 2100,"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { Calendar calendar = Calendar.getInstance(); Calendar xgviv = Calendar.getInstance(); xgviv.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = xgviv.getTime(); xgviv.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = xgviv.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }","1- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return new CohortMembership(9.parse(""yyyy-MM-dd HH:mm:ss"")); }
2- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return new CohortMembership(9.parse(""2100-02-01 00:00:00"")); }
3- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return doWithCurrentMemberships(() -> { Date endDateEarlier = DateSerializationUtil.toDateForCurrentCurrentDate(dateLater); return null; }); }
4- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return doWithCurrentMemberships(() -> { Date endDateEarlier = DateSerializationUtil.addCurrentDateWithCurrentCurrentDate(dateLater); return null; }); }
5- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return setMembershipWithVolume(date, false, true); }
6- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return setMembershipWithNeHooks(dateWithCurrentMemberships, false); }
7- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return setMembershipWithVolumeVersion(dateWithCurrentMemberships, false, false, true); }
8- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return setMembershipWithVolume(date, false, false, true); }
9- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return setMembershipWithVolume(date(), false, true); }
10- public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception { return; }",0
1962,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START> System.out.println(errMsg); <END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public class DummyClass {
    public void location_lock_dir_error_03() throws IOException {
        Assume.assumeTrue(negativePidsTreatedAsAlive);
        Location dir = Location.create(tempDir.getRoot().getAbsolutePath());
        LocationLock lock = dir.getLock();
        Assert.assertTrue(lock.canLock());
        Assert.assertFalse(lock.isLocked());
        Assert.assertFalse(lock.isOwned());
        Assert.assertTrue(lock.canObtain());
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) {
            writer.write(Integer.toString(-1234));
            writer.write('\n');
        }
        try {
            lock.canObtain();
            Assert.fail(""Expected the lock file to be considered invalid"");
        } catch (FileException e) {
            String errMsg = e.getMessage();
            Assert.assertNotNull(errMsg);
            System.out.println(errMsg);
            Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database""));
        }
    }
}",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public class DummyClass {
    public void location_lock_dir_error_03() throws IOException {
        Assume.assumeTrue(negativePidsTreatedAsAlive);
        Location dir = Location.create(tempDir.getRoot().getAbsolutePath());
        LocationLock lock = dir.getLock();
        Assert.assertTrue(lock.canLock());
        Assert.assertFalse(lock.isLocked());
        Assert.assertFalse(lock.isOwned());
        Assert.assertTrue(lock.canObtain());
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) {
            writer.write(Integer.toString(-1234));
            writer.write('\n');
        }
        try {
            lock.canObtain();
            Assert.fail(""Expected the lock file to be considered invalid"");
        } catch (FileException e) {
            String errMsg = e.getMessage();
            Assert.assertNotNull(errMsg);
            Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database""));
        }
    }
}","['public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert. assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain(); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234())); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert. assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert. assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""Tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString( -1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatEDAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } }']",True,0,0,54,54,1,1.0,0.999999995,False,False,False,,,,,,,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) var = true; Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) var = true; Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",,,,,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }","public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location writer = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock errMsg = writer.getLock(); Assert.assertTrue(errMsg.canLock()); Assert.assertFalse(errMsg.isLocked()); Assert.assertFalse(errMsg.isOwned()); Assert.assertTrue(errMsg.canObtain()); try (BufferedWriter lock = new BufferedWriter(new FileWriter(writer.getPath(""tdb.errMsg"")))) { lock.write(Integer.toString(-1234)); lock.write('\n'); } try { errMsg.canObtain(); Assert.fail(""Expected the errMsg file to be considered invalid""); } catch (FileException e) { String dir = e.getMessage(); Assert.assertNotNull(dir); <START> System.out.println(dir); <END> Assert.assertTrue(dir.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location writer = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock errMsg = writer.getLock(); Assert.assertTrue(errMsg.canLock()); Assert.assertFalse(errMsg.isLocked()); Assert.assertFalse(errMsg.isOwned()); Assert.assertTrue(errMsg.canObtain()); try (BufferedWriter lock = new BufferedWriter(new FileWriter(writer.getPath(""tdb.errMsg"")))) { lock.write(Integer.toString(-1234)); lock.write('\n'); } try { errMsg.canObtain(); Assert.fail(""Expected the errMsg file to be considered invalid""); } catch (FileException e) { String dir = e.getMessage(); Assert.assertNotNull(dir); Assert.assertTrue(dir.contains(""appear to be for a TDB2 database"")); } }","public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location hvuip = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock noixx = hvuip.getLock(); Assert.assertTrue(noixx.canLock()); Assert.assertFalse(noixx.isLocked()); Assert.assertFalse(noixx.isOwned()); Assert.assertTrue(noixx.canObtain()); try (BufferedWriter joabr = new BufferedWriter(new FileWriter(hvuip.getPath(""tdb.lock"")))) { joabr.write(Integer.toString(-1234)); joabr.write('\n'); } try { noixx.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException rpvnc) { String mnien = rpvnc.getMessage(); Assert.assertNotNull(mnien); <START> System.out.println(mnien); <END> Assert.assertTrue(mnien.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location hvuip = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock noixx = hvuip.getLock(); Assert.assertTrue(noixx.canLock()); Assert.assertFalse(noixx.isLocked()); Assert.assertFalse(noixx.isOwned()); Assert.assertTrue(noixx.canObtain()); try (BufferedWriter joabr = new BufferedWriter(new FileWriter(hvuip.getPath(""tdb.lock"")))) { joabr.write(Integer.toString(-1234)); joabr.write('\n'); } try { noixx.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException rpvnc) { String mnien = rpvnc.getMessage(); Assert.assertNotNull(mnien); Assert.assertTrue(mnien.contains(""appear to be for a TDB2 database"")); } }",,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); Location hbfmf = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = hbfmf.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(hbfmf.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); Location hbfmf = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = hbfmf.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(hbfmf.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","1- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }
2- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); } if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }
3- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
4- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); } }
5- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); } } }
6- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); throw new FileException(errMsg); } }
7- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } } }
8- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } } {
9- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }
10- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); throw new FileException(errMsg); } } }",1
1973,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public class DummyClass {
    public void testDeleteActionForTeamAsFeedbackParticipant() {
        prepareTestData();
        ______TS(""Typical successful case when feedback participant is a team"");
        FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb();
        int questionNumber = 4;
        FeedbackQuestionAttributes feedbackQuestion =
                feedbackQuestionsDb.getFeedbackQuestion(
                        ""First Session"", ""idOfCourse1"", questionNumber);
        String giverEmail = ""Team 1.1</td></div>'\"""";
        String receiverEmail = ""Team 2.1</td></div>'\"""";
        FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb();
        FeedbackResponseAttributes feedbackResponse =
                feedbackResponsesDb.getFeedbackResponse(
                        feedbackQuestion.getId(), giverEmail, receiverEmail);
        FeedbackResponseCommentAttributes feedbackResponseComment =
                dataBundle.feedbackResponseComments.get(""comment1FromTeam1"");
        FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb();
        feedbackResponseComment =
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponse.getId(),
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt);
        assertNotNull(""response comment not found"", feedbackResponseComment);
        StudentAttributes student = dataBundle.students.get(""student1InCourse1"");
        gaeSimulation.loginAsStudent(student.googleId);
        String[] submissionParams =
                new String[] {
                    Const.ParamsNames.COURSE_ID,
                    feedbackResponseComment.courseId,
                    Const.ParamsNames.FEEDBACK_SESSION_NAME,
                    feedbackResponseComment.feedbackSessionName,
                    Const.ParamsNames.FEEDBACK_RESPONSE_ID,
                    feedbackResponseComment.feedbackResponseId,
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,
                    feedbackResponseComment.getId().toString(),
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,
                    feedbackResponseComment.commentText + "" (Edited)"",
                };
        AjaxResult result = getAjaxResult(getAction(submissionParams));
        FeedbackResponseCommentAjaxPageData data =
                (FeedbackResponseCommentAjaxPageData) result.data;
        assertFalse(data.isError);
        assertNull(
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponseComment.feedbackResponseId,
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt));
        assertEquals("""", result.getStatusMessage());
    }
}",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public class DummyClass {
    public void testDeleteActionForTeamAsFeedbackParticipant() {
        FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb();
        int questionNumber = 4;
        FeedbackQuestionAttributes feedbackQuestion =
                feedbackQuestionsDb.getFeedbackQuestion(
                        ""First Session"", ""idOfCourse1"", questionNumber);
        String giverEmail = ""Team 1.1</td></div>'\"""";
        String receiverEmail = ""Team 2.1</td></div>'\"""";
        FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb();
        FeedbackResponseAttributes feedbackResponse =
                feedbackResponsesDb.getFeedbackResponse(
                        feedbackQuestion.getId(), giverEmail, receiverEmail);
        FeedbackResponseCommentAttributes feedbackResponseComment =
                dataBundle.feedbackResponseComments.get(""comment1FromTeam1"");
        FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb();
        feedbackResponseComment =
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponse.getId(),
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt);
        assertNotNull(""response comment not found"", feedbackResponseComment);
        StudentAttributes student = dataBundle.students.get(""student1InCourse1"");
        gaeSimulation.loginAsStudent(student.googleId);
        String[] submissionParams =
                new String[] {
                    Const.ParamsNames.COURSE_ID,
                    feedbackResponseComment.courseId,
                    Const.ParamsNames.FEEDBACK_SESSION_NAME,
                    feedbackResponseComment.feedbackSessionName,
                    Const.ParamsNames.FEEDBACK_RESPONSE_ID,
                    feedbackResponseComment.feedbackResponseId,
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,
                    feedbackResponseComment.getId().toString(),
                };
        AjaxResult result = getAjaxResult(getAction(submissionParams));
        FeedbackResponseCommentAjaxPageData data =
                (FeedbackResponseCommentAjaxPageData) result.data;
        assertFalse(data.isError);
        assertNull(
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponseComment.feedbackResponseId,
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt));
        assertEquals("""", result.getStatusMessage());
    }
}","['public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.delete(FeedbackQuestionsDb.getFeedbackSessionName(), feedbackResponseComment.commentGiver); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); service.delete(FeedbackQuestionsDb.getFeedbackSessionName(), feedbackResponseComment.commentGiver); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); ______TS(""Typical successful case when feedback participant is a team""); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceManager.count(data.getFeedbackSession().getId() + 1); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.remove(FeedbackQuestionsDb.class); serviceUsers.delete(FeedbackQuestionsDb.class); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); service.delete(data); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.delete(student.googleId); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.remove(FeedbackQuestionsLogic.getFeedbackSessionName(feedbackResponseComment.getId())); }']",True,0,0,219,219,15,1.0,0.999999995,False,False,False,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }",,,,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) var = true; prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) var = true; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { try { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); } catch (Exception e) { throw e; } }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { try { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); } catch (Exception e) { throw e; } }",,,,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"", feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); } assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); if ("""" != result.getStatusMessage()) { assertEquals("""",result.getStatusMessage()); } }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); if ("""" != result.getStatusMessage()) { assertEquals("""", result.getStatusMessage()); } }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackResponse = new FeedbackQuestionsDb(); int data = 4; FeedbackQuestionAttributes feedbackResponseCommentsDb = feedbackResponse.getFeedbackQuestion(""First Session"", ""idOfCourse1"", data); String submissionParams = ""Team 1.1</td></div>'\""""; String feedbackResponseComment = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackQuestion = feedbackResponsesDb.getFeedbackResponse(feedbackResponseCommentsDb.getId(), submissionParams, feedbackResponseComment); FeedbackResponseCommentAttributes giverEmail = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb result = new FeedbackResponseCommentsDb(); giverEmail = result.getFeedbackResponseComment(feedbackQuestion.getId(), giverEmail.commentGiver, giverEmail.createdAt); assertNotNull(""response comment not found"", giverEmail); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] receiverEmail = new String[] { Const.ParamsNames.COURSE_ID, giverEmail.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, giverEmail.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, giverEmail.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, giverEmail.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, giverEmail.commentText + "" (Edited)"" }; AjaxResult feedbackQuestionsDb = getAjaxResult(getAction(receiverEmail)); FeedbackResponseCommentAjaxPageData questionNumber = (FeedbackResponseCommentAjaxPageData) feedbackQuestionsDb.questionNumber; assertFalse(questionNumber.isError); assertNull(result.getFeedbackResponseComment(giverEmail.feedbackResponseId, giverEmail.commentGiver, giverEmail.createdAt)); assertEquals("""", feedbackQuestionsDb.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackResponse = new FeedbackQuestionsDb(); int data = 4; FeedbackQuestionAttributes feedbackResponseCommentsDb = feedbackResponse.getFeedbackQuestion(""First Session"", ""idOfCourse1"", data); String submissionParams = ""Team 1.1</td></div>'\""""; String feedbackResponseComment = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackQuestion = feedbackResponsesDb.getFeedbackResponse(feedbackResponseCommentsDb.getId(), submissionParams, feedbackResponseComment); FeedbackResponseCommentAttributes giverEmail = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb result = new FeedbackResponseCommentsDb(); giverEmail = result.getFeedbackResponseComment(feedbackQuestion.getId(), giverEmail.commentGiver, giverEmail.createdAt); assertNotNull(""response comment not found"", giverEmail); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] receiverEmail = new String[] { Const.ParamsNames.COURSE_ID, giverEmail.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, giverEmail.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, giverEmail.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, giverEmail.getId().toString() }; AjaxResult feedbackQuestionsDb = getAjaxResult(getAction(receiverEmail)); FeedbackResponseCommentAjaxPageData questionNumber = (FeedbackResponseCommentAjaxPageData) feedbackQuestionsDb.questionNumber; assertFalse(questionNumber.isError); assertNull(result.getFeedbackResponseComment(giverEmail.feedbackResponseId, giverEmail.commentGiver, giverEmail.createdAt)); assertEquals("""", feedbackQuestionsDb.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb qbkal = new FeedbackQuestionsDb(); int nezhm = 4; FeedbackQuestionAttributes nuiew = qbkal.getFeedbackQuestion(""First Session"", ""idOfCourse1"", nezhm); String eqgdw = ""Team 1.1</td></div>'\""""; String ssntq = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb gutrn = new FeedbackResponsesDb(); FeedbackResponseAttributes lbdav = gutrn.getFeedbackResponse(nuiew.getId(), eqgdw, ssntq); FeedbackResponseCommentAttributes bxipb = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb sssez = new FeedbackResponseCommentsDb(); bxipb = sssez.getFeedbackResponseComment(lbdav.getId(), bxipb.commentGiver, bxipb.createdAt); assertNotNull(""response comment not found"", bxipb); StudentAttributes elzxy = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(elzxy.googleId); String[] mzfcj = new String[] { Const.ParamsNames.COURSE_ID, bxipb.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, bxipb.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, bxipb.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, bxipb.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, bxipb.commentText + "" (Edited)"" }; AjaxResult sbwsz = getAjaxResult(getAction(mzfcj)); FeedbackResponseCommentAjaxPageData zzokx = (FeedbackResponseCommentAjaxPageData) sbwsz.zzokx; assertFalse(zzokx.isError); assertNull(sssez.getFeedbackResponseComment(bxipb.feedbackResponseId, bxipb.commentGiver, bxipb.createdAt)); assertEquals("""", sbwsz.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb qbkal = new FeedbackQuestionsDb(); int nezhm = 4; FeedbackQuestionAttributes nuiew = qbkal.getFeedbackQuestion(""First Session"", ""idOfCourse1"", nezhm); String eqgdw = ""Team 1.1</td></div>'\""""; String ssntq = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb gutrn = new FeedbackResponsesDb(); FeedbackResponseAttributes lbdav = gutrn.getFeedbackResponse(nuiew.getId(), eqgdw, ssntq); FeedbackResponseCommentAttributes bxipb = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb sssez = new FeedbackResponseCommentsDb(); bxipb = sssez.getFeedbackResponseComment(lbdav.getId(), bxipb.commentGiver, bxipb.createdAt); assertNotNull(""response comment not found"", bxipb); StudentAttributes elzxy = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(elzxy.googleId); String[] mzfcj = new String[] { Const.ParamsNames.COURSE_ID, bxipb.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, bxipb.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, bxipb.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, bxipb.getId().toString() }; AjaxResult sbwsz = getAjaxResult(getAction(mzfcj)); FeedbackResponseCommentAjaxPageData zzokx = (FeedbackResponseCommentAjaxPageData) sbwsz.zzokx; assertFalse(zzokx.isError); assertNull(sssez.getFeedbackResponseComment(bxipb.feedbackResponseId, bxipb.commentGiver, bxipb.createdAt)); assertEquals("""", sbwsz.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> int questionNumber = 4; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { int questionNumber = 4; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionsDb kqflt = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = kqflt.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionsDb kqflt = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = kqflt.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","1- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
2- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
3- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
4- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
5- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
6- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
7- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
8- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
9- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }
10- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",0
1992,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); <START> assertTrue( <END> testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }","public class DummyClass {
    public void shouldExecuteTestClassSuccessfully() throws InterruptedException {
        projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS);
        projectExplorer.openItemByPath(PATH_TO_TEST_CLASS);
        editor.waitActiveEditor();
        menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM);
        notifications.waitExpectedMessageOnProgressPanelAndClosed(
                ""Test runner executed successfully."");
        pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne"");
        pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne"");
        Assert.assertTrue(
                pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1);
        Assert.assertTrue(
                pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1);
        String testErrorMessage = pluginConsole.getTestErrorMessage();
        assertTrue(
                testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),
                ""Actual message was: "" + testErrorMessage);
    }
}",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }","public class DummyClass {
    public void shouldExecuteTestClassSuccessfully() throws InterruptedException {
        projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS);
        projectExplorer.openItemByPath(PATH_TO_TEST_CLASS);
        editor.waitActiveEditor();
        menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM);
        notifications.waitExpectedMessageOnProgressPanelAndClosed(
                ""Test runner executed successfully."");
        pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne"");
        pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne"");
        assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1);
        assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1);
        String testErrorMessage = pluginConsole.getTestErrorMessage();
        assertTrue(
                testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),
                ""Actual message was: "" + testErrorMessage);
    }
}","['public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSed).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFAILED(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertEquals(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size(), 1); assertEquals(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size(), 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST(), TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1);assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_test_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testHyphen.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }', 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage);']",True,0,0,40,40,4,1.0,0.999999995,True,True,False,,,,,,,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.<START>assertTrue(<END>pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }","public void shouldExecuteTestClassSuccessfully() throws InterruptedException { boolean var = false; if (var) var = true; projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.<START>assertTrue(<END>pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { boolean var = false; if (var) var = true; projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }","public void shouldExecuteTestClassSuccessfully() throws InterruptedException { try { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.<START>assertTrue(<END>pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); } catch (Exception e) { throw e; } }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { try { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { Assert.<START>assertTrue(<END>pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }",,,,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String <START> gqfhh = <END> pluginConsole.getTestErrorMessage(); assertTrue(gqfhh.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + gqfhh); }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String gqfhh = pluginConsole.getTestErrorMessage(); assertTrue(gqfhh.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + gqfhh); }",,,,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); Assert.<START>assertTrue(<END>pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); String dqxmk = pluginConsole.getTestErrorMessage(); assertTrue(dqxmk.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + dqxmk); }",static import if star,"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); String dqxmk = pluginConsole.getTestErrorMessage(); assertTrue(dqxmk.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + dqxmk); }","1- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
2- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
3- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
4- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), ""Actual message was: "" + testErrorMessage); }
5- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
6- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
7- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSed).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
8- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (adminConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
9- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFAILED(""shouldFailOfAppOne""); if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); } if (pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1) { assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); } String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }
10- public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU,TEST,TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(""Test runner executed successfully.""); pluginConsole.waitMethodMarkedAsPassed(""shouldSuccessOfAppOne""); pluginConsole.waitMethodMarkedAsFailed(""shouldFailOfAppOne""); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() != 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertFalse(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() != 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue(testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE),""Actual message was: "" + testErrorMessage); }",0
2025,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); <START> Assert.assertTrue(query.getQueryReturnValue().getSucceeded()); <END> Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); }","public class DummyClass {
    public void testSuccessfulSessionId() {
        VdcQueryParametersBase params = new VdcQueryParametersBase();
        ;
        params.setHttpSessionId(""good_session_id"");
        ValidateSessionQuery<VdcQueryParametersBase> query =
                spy(new ValidateSessionQuery<VdcQueryParametersBase>(params));
        when(query.getSessionUser(""good_session_id""))
                .thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain""));
        query.Execute();
        Assert.assertTrue(query.getQueryReturnValue().getSucceeded());
        Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser);
        VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue();
        Assert.assertTrue(user.getDomainControler().equals(""myDomain""));
        Assert.assertTrue(user.getUserName().equals(""myUser""));
    }
}",import static Assert,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }","public class DummyClass {
    public void testSuccessfulSessionId() {
        VdcQueryParametersBase params = new VdcQueryParametersBase();
        ;
        params.setHttpSessionId(""good_session_id"");
        ValidateSessionQuery<VdcQueryParametersBase> query =
                spy(new ValidateSessionQuery<VdcQueryParametersBase>(params));
        when(query.getSessionUser(""good_session_id""))
                .thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain""));
        query.Execute();
        assertTrue(query.getQueryReturnValue().getSucceeded());
        assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser);
        VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue();
        assertTrue(user.getDomainControler().equals(""myDomain""));
        assertTrue(user.getUserName().equals(""myUser""));
    }
}","['public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertEquals(user.getDomainControler().equals(""myDomain"")); assertEquals(user.getUserName(), user.getUserName()); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertEquals(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertNotNull(user.getDomainControler()); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertEquals(user.getDomainControler().equals(""myDomain"")); assertEquals(user.getUserName(), ""myUser""); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser (Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();  params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertEquals(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain)); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }', 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertNotNull(user.getDomainControler()); assertEquals(""myDomain"", user.getUserName()); }']",True,0,0,54,54,8,1.0,0.999999995,False,False,False,,,,,,,"public void testSuccessfulSessionId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); <START>Assert.assertTrue(query.getQueryReturnValue().getSucceeded());<END> Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); }",import static Assert,"public void testSuccessfulSessionId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }","public void testSuccessfulSessionId() { boolean var = false; if (var) var = true; VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); <START>Assert.assertTrue(query.getQueryReturnValue().getSucceeded());<END> Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); }",import static Assert,"public void testSuccessfulSessionId() { boolean var = false; if (var) var = true; VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }","public void testSuccessfulSessionId() { try { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); <START>Assert.assertTrue(query.getQueryReturnValue().getSucceeded());<END> Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); } catch (Exception e) { throw e; } }",import static Assert,"public void testSuccessfulSessionId() { try { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); } catch (Exception e) { throw e; } }",,,,,,,,,,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { <START>Assert.assertTrue(query.getQueryReturnValue().getSucceeded());<END> } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { Assert.assertTrue(user.getUserName().equals(""myUser"")); } }",import static Assert,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }","public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", <START> ""myDomain"")); <END> query.Execute(); Assert.assertTrue(query.getQueryReturnValue().getSucceeded()); Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); }",import static Assert,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }","public void testSuccessfulSessionId() { VdcQueryParametersBase beydn = new VdcQueryParametersBase(); ; beydn.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> lbtea = spy(new ValidateSessionQuery<VdcQueryParametersBase>(beydn)); when(lbtea.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", <START> ""myDomain"")); <END> lbtea.Execute(); Assert.assertTrue(lbtea.getQueryReturnValue().getSucceeded()); Assert.assertTrue(lbtea.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser dckfk = (VdcUser) lbtea.getQueryReturnValue().getReturnValue(); Assert.assertTrue(dckfk.getDomainControler().equals(""myDomain"")); Assert.assertTrue(dckfk.getUserName().equals(""myUser"")); }",import static Assert,"public void testSuccessfulSessionId() { VdcQueryParametersBase beydn = new VdcQueryParametersBase(); ; beydn.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> lbtea = spy(new ValidateSessionQuery<VdcQueryParametersBase>(beydn)); when(lbtea.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); lbtea.Execute(); assertTrue(lbtea.getQueryReturnValue().getSucceeded()); assertTrue(lbtea.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser dckfk = (VdcUser) lbtea.getQueryReturnValue().getReturnValue(); assertTrue(dckfk.getDomainControler().equals(""myDomain"")); assertTrue(dckfk.getUserName().equals(""myUser"")); }",,,,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); VdcQueryParametersBase enkah = new VdcQueryParametersBase(); ; enkah.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(enkah)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); <START>Assert.assertTrue(query.getQueryReturnValue().getSucceeded());<END> Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(""myDomain"")); Assert.assertTrue(user.getUserName().equals(""myUser"")); }",import static Assert,"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); VdcQueryParametersBase enkah = new VdcQueryParametersBase(); ; enkah.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(enkah)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(), ""myUser"", ""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(""myDomain"")); assertTrue(user.getUserName().equals(""myUser"")); }","1- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
2- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) {assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
3- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); , params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
4- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!(query.getQueryReturnValue().getReturnValue() instanceof VdcUser)) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
5- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain())); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
6- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser (Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
7- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) {assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
8- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!(query.getQueryReturnValue().getSucceeded())) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
9- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ; params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }
10- public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase(); ); params.setHttpSessionId(""good_session_id""); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(""good_session_id"")).thenReturn(new VdcUser(Guid.NewGuid(),""myUser"",""myDomain"")); query.Execute(); if (!query.getQueryReturnValue().getSucceeded()) { assertTrue(query.getQueryReturnValue().getSucceeded()); } if (!query.getQueryReturnValue().getReturnValue() instanceof VdcUser) { assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); } VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); if (!user.getDomainControler().equals(""myDomain"")) { assertTrue(user.getDomainControler().equals(""myDomain"")); } if (!user.getUserName().equals(""myUser"")) { assertTrue(user.getUserName().equals(""myUser"")); } }",0
2030,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { <START> pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes()); <END> } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }","public class DummyClass {
    public void normalOperationShouldNotReconfigureKafkaConsumer() {
        final PartitionData pd = new PartitionData(null, 100L);
        for (long i = 0; i < 100; ++i) {
            pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes());
        }
        pd.takeEventsToStream(currentTimeMillis(), 1000, 0L);
        assertEquals(100L, pd.getUnconfirmed());
        for (long i = 0; i < 10; ++i) {
            final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L);
            assertEquals(10L, cr.committedCount);
            assertFalse(cr.seekOnKafka);
            assertEquals(90L - i * 10L, pd.getUnconfirmed());
        }
    }
}",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }","public class DummyClass {
    public void normalOperationShouldNotReconfigureKafkaConsumer() {
        final PartitionData pd = new PartitionData(null, 100L);
        for (long i = 0; i < 100; ++i) {
            pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8));
        }
        pd.takeEventsToStream(currentTimeMillis(), 1000, 0L);
        assertEquals(100L, pd.getUnconfirmed());
        for (long i = 0; i < 10; ++i) {
            final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L);
            assertEquals(10L, cr.committedCount);
            assertFalse(cr.seekOnKafka);
            assertEquals(90L - i * 10L, pd.getUnconfirmed());
        }
    }
}","['public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(""UTF-8"")); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertNotNull(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); } assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i"").getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 500L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertTrue(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) {final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } {', 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } {}']",True,0,0,31,31,2,1.0,0.999999995,False,False,False,,,,,,,"public void normalOperationShouldNotReconfigureKafkaConsumer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }","public void normalOperationShouldNotReconfigureKafkaConsumer() { boolean var = false; if (var) var = true; final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { boolean var = false; if (var) var = true; final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }","public void normalOperationShouldNotReconfigureKafkaConsumer() { try { final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L,pd.getUnconfirmed()); } } catch (Exception e) { throw e; } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { try { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } } catch (Exception e) { throw e; } }",,,,,,,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } pd.takeEventsToStream(currentTimeMillis(),1000,0L); if (100L != pd.getUnconfirmed()) { assertEquals(100L,pd.getUnconfirmed()); } for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); if (10L != cr.committedCount) { assertEquals(10L,cr.committedCount); } assertFalse(cr.seekOnKafka); if (90L - i * 10L != pd.getUnconfirmed()) { assertEquals(90L - i * 10L,pd.getUnconfirmed()); } } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); if (100L != pd.getUnconfirmed()) { assertEquals(100L, pd.getUnconfirmed()); } for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); if (10L != cr.committedCount) { assertEquals(10L, cr.committedCount); } assertFalse(cr.seekOnKafka); if (90L - i * 10L != pd.getUnconfirmed()) { assertEquals(90L - i * 10L, pd.getUnconfirmed()); } } }","public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }","public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData i = new PartitionData(null, 100L); for (long cr = 0; cr < 100; ++cr) { <START> i.addEventFromKafka(100L + cr + 1, (""test_"" + cr).getBytes()); <END> } i.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, i.getUnconfirmed()); for (long cr = 0; cr < 10; ++cr) { final PartitionData.CommitResult pd = i.onCommitOffset(110L + cr * 10L); assertEquals(10L, pd.committedCount); assertFalse(pd.seekOnKafka); assertEquals(90L - cr * 10L, i.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData i = new PartitionData(null, 100L); for (long cr = 0; cr < 100; ++cr) { i.addEventFromKafka(100L + cr + 1, (""test_"" + cr).getBytes(UTF_8)); } i.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, i.getUnconfirmed()); for (long cr = 0; cr < 10; ++cr) { final PartitionData.CommitResult pd = i.onCommitOffset(110L + cr * 10L); assertEquals(10L, pd.committedCount); assertFalse(pd.seekOnKafka); assertEquals(90L - cr * 10L, i.getUnconfirmed()); } }","public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData kdnhf = new PartitionData(null, 100L); for (long rwedi = 0; rwedi < 100; ++rwedi) { <START> kdnhf.addEventFromKafka(100L + rwedi + 1, (""test_"" + rwedi).getBytes()); <END> } kdnhf.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, kdnhf.getUnconfirmed()); for (long rwedi = 0; rwedi < 10; ++rwedi) { final PartitionData.CommitResult ibqsf = kdnhf.onCommitOffset(110L + rwedi * 10L); assertEquals(10L, ibqsf.committedCount); assertFalse(ibqsf.seekOnKafka); assertEquals(90L - rwedi * 10L, kdnhf.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData kdnhf = new PartitionData(null, 100L); for (long rwedi = 0; rwedi < 100; ++rwedi) { kdnhf.addEventFromKafka(100L + rwedi + 1, (""test_"" + rwedi).getBytes(UTF_8)); } kdnhf.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, kdnhf.getUnconfirmed()); for (long rwedi = 0; rwedi < 10; ++rwedi) { final PartitionData.CommitResult ibqsf = kdnhf.onCommitOffset(110L + rwedi * 10L); assertEquals(10L, ibqsf.committedCount); assertFalse(ibqsf.seekOnKafka); assertEquals(90L - rwedi * 10L, kdnhf.getUnconfirmed()); } }",,,,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); PartitionData txobc = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { <START>txobc.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes());<END> } txobc.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,txobc.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = txobc.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L,txobc.getUnconfirmed()); } }",UTF-8,"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); PartitionData txobc = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { txobc.addEventFromKafka(100L + i + 1, (""test_"" + i).getBytes(UTF_8)); } txobc.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, txobc.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = txobc.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, txobc.getUnconfirmed()); } }","1- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes()); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
2- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
3- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean needsSeparator = false; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
4- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean isNextTurn = ""test_"" + 1; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes()); isNextTurn = false; } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
5- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean isNextTurn = ""test_"" + i; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes()); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
6- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final byte[] f = ""test_"" + i; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, f).getBytes(f)); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
7- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final byte[] zkBytes = new byte[100L.length]; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes(zkBytes)); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
8- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean needsSeparator = false; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes()); needsSeparator = true; } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
9- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean isNextTurn = ""test_"" + 1; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes()); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); } }
10- public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null,100L); final boolean needsSeparator = false; for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1,(""test_"" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(),1000,0L); assertEquals(100L,pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L,cr.committedCount); if (cr.seekOnKafka) { assertFalse(cr.seekOnKafka); } assertEquals(90L - i * 10L,pd.getUnconfirmed()); if (needsSeparator) { } } }",0
