index,source_code,formatted_source,review_comment,target,formatted_target,predictions,exact_match,exact_match_rank,Pred_Target_Lev_dist,Pred_Source_Lev_dist,source_target_lev_dist,source_target_word_difference,BLEU_score,ROUGE_score,unchanged_highlight,target_code_change_out_of_scope,unchanged_target,DataTypeCFSource,DataTypeCFComment,DataTypeCFTarget,IfElseCFSource,IfElseCFComment,IfElseCFTarget,ExceptionCFSource,ExceptionCFComment,ExceptionCFTarget,DeadCodeCFSource,DeadCodeCFComment,DeadCodeCFTarget,TryNcatchCFSource,TryNcatchCFComment,TryNcatchCFTarget,DataFlowCFSource,DataFlowCFComment,DataFlowCFTarget,EqualAssertCFSource,EqualAssertCFComment,EqualAssertCFTarget,NullAssertCFSource,NullAssertCFComment,NullAssertCFTarget,TrueFalseAssertCFSource,TrueFalseAssertCFComment,TrueFalseAssertCFTarget,ShuffleNamesCFSource,ShuffleNamesCFComment,ShuffleNamesCFTarget,RandomNamesCFSource,RandomNamesCFComment,RandomNamesCFTarget,IndependentSwapCFSource,IndependentSwapCFComment,IndependentSwapCFTarget,defUseBreakCFSource,defUseBreakCFComment,defUseBreakCFTarget,predictions_EqualAssertCF_Mitigation,exact_match_EqualAssertCF_Mitigation
4,"public void put(String key, String value) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); <START> BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); <END> ops.set(value); }","public class DummyClass {
    public void put(String key, String value) {
        Assert.notNull(key, ""'key' must not be null."");
        Assert.notNull(value, ""'value' must not be null."");
        BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key);
        ops.set(value);
    }
}",this.redisTemplate,"public void put(String key, String value) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }","public class DummyClass {
    public void put(String key, String value) {
        Assert.notNull(key, ""'key' must not be null."");
        Assert.notNull(value, ""'value' must not be null."");
        BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key);
        ops.set(value);
    }
}","['public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOperations(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOp(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); BankAccountValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); BoundValueOperation<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); soValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); DigitValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); NPValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); fdValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }', 'public void put(String key, String value) { Assert.notNull(key, ""\'key\' must not be null.""); Assert.notNull(value, ""\'value\' must not be null.""); CasValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }']",True,0,0,31,31,2,1.0,0.999999995,False,False,False,,,,,,,"public void put(String key,String value) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.notNull(key,""'key' must not be null.""); Assert.notNull(value,""'value' must not be null.""); <START>BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key);<END> ops.set(value); }",this.redisTemplate,"public void put(String key, String value) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }","public void put(String key,String value) { boolean var = false; if (var) var = true; Assert.notNull(key,""'key' must not be null.""); Assert.notNull(value,""'value' must not be null.""); <START>BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key);<END> ops.set(value); }",this.redisTemplate,"public void put(String key, String value) { boolean var = false; if (var) var = true; Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }","public void put(String key,String value) { try { Assert.notNull(key,""'key' must not be null.""); Assert.notNull(value,""'value' must not be null.""); <START>BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key);<END> ops.set(value); } catch (Exception e) { throw e; } }",this.redisTemplate,"public void put(String key, String value) { try { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); } catch (Exception e) { throw e; } }",,,,"public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); } <START>BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key);<END> ops.set(value); }",this.redisTemplate,"public void put(String key, String value) { if (key == null) { Assert.notNull(key, ""'key' must not be null.""); } if (value == null) { Assert.notNull(value, ""'value' must not be null.""); } BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }",,,,,,,"public void put(String key, String ops) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(ops, ""'ops' must not be null.""); <START> BoundValueOperations<String, String> value = redisTemplate.boundValueOps(key); <END> value.set(ops); }",this.redisTemplate,"public void put(String key, String ops) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(ops, ""'ops' must not be null.""); BoundValueOperations<String, String> value = this.redisTemplate.boundValueOps(key); value.set(ops); }","public void put(String waykw, String luqkj) { Assert.notNull(waykw, ""'key' must not be null.""); Assert.notNull(luqkj, ""'value' must not be null.""); <START> BoundValueOperations<String, String> pbxek = redisTemplate.boundValueOps(waykw); <END> pbxek.set(luqkj); }",this.redisTemplate,"public void put(String waykw, String luqkj) { Assert.notNull(waykw, ""'key' must not be null.""); Assert.notNull(luqkj, ""'value' must not be null.""); BoundValueOperations<String, String> pbxek = this.redisTemplate.boundValueOps(waykw); pbxek.set(luqkj); }",,,,"public void put(String key,String value) { Assert.notNull(key,""'key' must not be null.""); Assert.notNull(value,""'value' must not be null.""); BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key); <START>BoundValueOperations<String,String> wcirm = redisTemplate.boundValueOps(key);<END> wcirm.set(value); }",this.redisTemplate,"public void put(String key, String value) { Assert.notNull(key, ""'key' must not be null.""); Assert.notNull(value, ""'value' must not be null.""); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); BoundValueOperations<String, String> wcirm = this.redisTemplate.boundValueOps(key); wcirm.set(value); }","1- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String,String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }
2- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }
3- public void put(String key,String value) { if (key == null) { Assert.notNull(key, ""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String,String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }
4- public void put(String key,String value) { if (key == null) { Assert.notNull(key, ""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }
5- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key); ops.set(value); }
6- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); } BoundValueOperations<String,String> ops = redisTemplate.boundValueOps(key); ops.set(value); }
7- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); } }
8- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String,String> ops = this.redisTemplate.boundValueOps(key); ops.set(value);
9- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); } BoundValueOperations<String,String> ops = this.redisTemplate.boundValueOps(key); ops.set(value);
10- public void put(String key,String value) { if (key == null) { Assert.notNull(key,""'key' must not be null.""); } if (value == null) { Assert.notNull(value,""'value' must not be null.""); }BoundValueOperations<String,String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); {",0
12,"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { <START> Objects.requireNonNull(filter, ""filter""); <END> return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","public class DummyClass {
    public static List<BlockMetaData> filterRowGroups(
            List<FilterLevel> levels,
            Filter filter,
            List<BlockMetaData> blocks,
            ParquetFileReader reader) {
        Objects.requireNonNull(filter, ""filter"");
        return filter.accept(new RowGroupFilter(levels, blocks, reader));
    }
}","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","public class DummyClass {
    public static List<BlockMetaData> filterRowGroups(
            List<FilterLevel> levels,
            Filter filter,
            List<BlockMetaData> blocks,
            ParquetFileReader reader) {
        Objects.requireNonNull(filter, ""filter cannot be null"");
        return filter.accept(new RowGroupFilter(levels, blocks, reader));
    }
}","['public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter must not be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter should not be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks(), ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null.""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader())); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter not null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroup(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }', 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter must not be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader())); }']",True,0,0,31,41,5,1.0,0.999999995,False,False,False,,,,,,,"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>Objects.requireNonNull(filter,""filter"");<END> return filter.accept(new RowGroupFilter(levels,blocks,reader)); }","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { boolean var = false; if (var) var = true; <START>Objects.requireNonNull(filter,""filter"");<END> return filter.accept(new RowGroupFilter(levels,blocks,reader)); }","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { boolean var = false; if (var) var = true; Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { try { <START>Objects.requireNonNull(filter,""filter"");<END> return filter.accept(new RowGroupFilter(levels,blocks,reader)); } catch (Exception e) { throw e; } }","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { try { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels, blocks, reader)); } catch (Exception e) { throw e; } }",,,,"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { <START>Objects.requireNonNull(filter,""filter"");<END> } return filter.accept(new RowGroupFilter(levels,blocks,reader)); }","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels, blocks, reader)); }",,,,,,,"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> blocks, Filter filter, List<BlockMetaData> levels, ParquetFileReader reader) <START> { Objects.requireNonNull(filter, <END> ""filter""); return filter.accept(new RowGroupFilter(blocks, levels, reader)); }","suggestion Objects.requireNonNull(filter, ""filter null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> blocks, Filter filter, List<BlockMetaData> levels, ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(blocks, levels, reader)); }","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> uuasq, Filter caltm, List<BlockMetaData> emdss, ParquetFileReader orbnc) <START> { Objects.requireNonNull(caltm, <END> ""filter""); return caltm.accept(new RowGroupFilter(uuasq, emdss, orbnc)); }","suggestion Objects.requireNonNull(caltm, ""caltm null"");","public static List<BlockMetaData> filterRowGroups(List<FilterLevel> uuasq, Filter caltm, List<BlockMetaData> emdss, ParquetFileReader orbnc) { Objects.requireNonNull(caltm, ""filter cannot be null""); return caltm.accept(new RowGroupFilter(uuasq, emdss, orbnc)); }",,,,,,,"1- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
2- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
3- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
4- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { Objects.requireNonNull(filter, ""filter must not be null""); return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
5- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter, List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
6- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels, blocks,reader)); }
7- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { Preconditions.requireNonNull(filter, ""filter cannot be null""); return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
8- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { } (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,blocks,reader)); }
9- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,blocks,reader())); }
10- public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels,Filter filter,List<BlockMetaData> blocks,ParquetFileReader reader) { if (filter == null) { Objects.requireNonNull(filter, ""filter cannot be null""); } return filter.accept(new RowGroupFilter(levels,Blocks,reader)); }",0
22,"public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); <START> this.signature = signature; <END> this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }","public class DummyClass {
    public CertificationRequest(
            CertificationRequestInfo certificationRequestInfo,
            SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,
            byte[] signature) {
        this.certificationRequestInfo =
                requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null"");
        this.signatureAlgorithmIdentifier =
                requireNonNull(
                        signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null"");
        this.signature = signature;
        this.encoded =
                encodeSequence(
                        certificationRequestInfo.getEncoded(),
                        encodeSequence(signatureAlgorithmIdentifier.getEncoded()),
                        encodeBitString(0, signature));
    }
}","Check for null a defensive copy java this.signature = requireNonNull(signature, ""signature is null"").clone();","public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }","public class DummyClass {
    public CertificationRequest(
            CertificationRequestInfo certificationRequestInfo,
            SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,
            byte[] signature) {
        this.certificationRequestInfo =
                requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null"");
        this.signatureAlgorithmIdentifier =
                requireNonNull(
                        signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null"");
        this.signature = requireNonNull(signature, ""signature is null"").clone();
        this.encoded =
                encodeSequence(
                        certificationRequestInfo.getEncoded(),
                        encodeSequence(signatureAlgorithmIdentifier.getEncoded()),
                        encodeBitString(0, signature));
    }
}","['public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null"").clone(); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signatures is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature = null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature() is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signatureSize is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature> is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature string is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature  is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }', 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null"").clone(); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature())); }']",True,0,0,70,71,4,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } <START>this.signature = signature;<END> this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }","Check for null a defensive copy java this.signature = requireNonNull(signature, ""signature is null"").clone();","public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); } if (signature == null) { requireNonNull(signature, ""signature is null""); } this.encoded = encodeSequence(certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }",,,,,,,"public CertificationRequest(CertificationRequestInfo signatureAlgorithmIdentifier, SignatureAlgorithmIdentifier certificationRequestInfo, byte[] signature) { this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""certificationRequestInfo is null""); this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo <START> is null""); this.signature = <END> signature; this.encoded = encodeSequence(signatureAlgorithmIdentifier.getEncoded(), encodeSequence(certificationRequestInfo.getEncoded()), encodeBitString(0, signature)); }","Check for null a defensive copy java this.signature = requireNonNull(signature, ""signature is null"").clone();","public CertificationRequest(CertificationRequestInfo signatureAlgorithmIdentifier, SignatureAlgorithmIdentifier certificationRequestInfo, byte[] signature) { this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, ""certificationRequestInfo is null""); this.certificationRequestInfo = requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(signatureAlgorithmIdentifier.getEncoded(), encodeSequence(certificationRequestInfo.getEncoded()), encodeBitString(0, signature)); }","public CertificationRequest(CertificationRequestInfo vcwnm, SignatureAlgorithmIdentifier rgcum, byte[] arlqt) { this.vcwnm = requireNonNull(vcwnm, ""certificationRequestInfo is null""); this.rgcum = requireNonNull(rgcum, ""signatureAlgorithmIdentifier <START> is null""); this.arlqt = <END> arlqt; this.encoded = encodeSequence(vcwnm.getEncoded(), encodeSequence(rgcum.getEncoded()), encodeBitString(0, arlqt)); }","Check for null a defensive copy java this.arlqt = requireNonNull(arlqt, ""arlqt is null"").clone();","public CertificationRequest(CertificationRequestInfo vcwnm, SignatureAlgorithmIdentifier rgcum, byte[] arlqt) { this.vcwnm = requireNonNull(vcwnm, ""certificationRequestInfo is null""); this.rgcum = requireNonNull(rgcum, ""signatureAlgorithmIdentifier is null""); this.arlqt = requireNonNull(arlqt, ""signature is null"").clone(); this.encoded = encodeSequence(vcwnm.getEncoded(), encodeSequence(rgcum.getEncoded()), encodeBitString(0, arlqt)); }",,,,,,,"1- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
2- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo, ""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
3- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
4- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature is null"").clone(); } this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
5- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null""). clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
6- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature,""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
7- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
8- public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
9- public CertificationRequest(CertificationRequestInfo certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier, ""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }
10- public CertificationRequest(CertificationRequest certificationRequestInfo,SignatureAlgorithmIdentifier signatureAlgorithmIdentifier,byte[] signature) { if (certificationRequestInfo == null) { requireNonNull(certificationRequestInfo,""certificationRequestInfo is null""); } if (signatureAlgorithmIdentifier == null) { requireNonNull(signatureAlgorithmIdentifier,""signatureAlgorithmIdentifier is null""); } this.signature = requireNonNull(signature, ""signature is null"").clone(); this.encoded = encodeSequence(certificationRequestInfo.getEncoded(),encodeSequence(signatureAlgorithmIdentifier.getEncoded()),encodeBitString(0,signature)); }",0
86,"static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); <START> return new Stream.Cons<>(head, () -> tailSupplier.get()); <END> }","public class DummyClass {
    static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) {
        Objects.requireNonNull(tailSupplier, ""tailSupplier is null"");
        return new Stream.Cons<>(head, () -> tailSupplier.get());
    }
}","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }","public class DummyClass {
    static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) {
        Objects.requireNonNull(tailSupplier, ""tailSupplier is null"");
        return new Stream.Cons<>(head, tailSupplier);
    }
}","['static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) {Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen( T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier()); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.S<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return newStream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects. requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head(), tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream< T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }', 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<head, tailSupplier); }']",True,0,0,36,38,4,1.0,0.999999995,False,False,False,,,,,,,"static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(tailSupplier,""tailSupplier is null""); <START>return new Stream.Cons<>(head,() -> tailSupplier.get());<END> }","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }","static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { boolean var = false; if (var) var = true; Objects.requireNonNull(tailSupplier,""tailSupplier is null""); <START>return new Stream.Cons<>(head,() -> tailSupplier.get());<END> }","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { boolean var = false; if (var) var = true; Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }","static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { try { Objects.requireNonNull(tailSupplier,""tailSupplier is null""); <START>return new Stream.Cons<>(head,() -> tailSupplier.get());<END> } catch (Exception e) { throw e; } }","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { try { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); } catch (Exception e) { throw e; } }",,,,"static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,""tailSupplier is null""); } <START>return new Stream.Cons<>(head,() -> tailSupplier.get());<END> }","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }",,,,,,,"static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); <START> return new Stream.Cons<>(head, () -> tailSupplier.get()); <END> }","minor - this simplified java return new Stream.Cons<>(head, tailSupplier);","static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); return new Stream.Cons<>(head, tailSupplier); }","static <T> Stream<T> gen(T liknv, Supplier<Stream<T>> avmjn) { Objects.requireNonNull(avmjn, ""tailSupplier is null""); <START> return new Stream.Cons<>(liknv, () -> avmjn.get()); <END> }","minor - this simplified java return new Stream.Cons<>(liknv, avmjn);","static <T> Stream<T> gen(T liknv, Supplier<Stream<T>> avmjn) { Objects.requireNonNull(avmjn, ""tailSupplier is null""); return new Stream.Cons<>(liknv, avmjn); }",,,,,,,"1- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
2- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier, ""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
3- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,'tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
4- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,(""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
5- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,()+""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
6- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,ultailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
7- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects,requireNonNull(tailSupplier,""tailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
8- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,IComplexNDArraytailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
9- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null) { Objects.requireNonNull(tailSupplier,RealizationtailSupplier is null""); } return new Stream.Cons<>(head, tailSupplier); }
10- static <T> Stream<T> gen(T head,Supplier<Stream<T>> tailSupplier) { if (tailSupplier == null)",0
146,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); <START> if (supportLevel == null) { <END> throw log.unableToDetermineSupportLevel(); } return supportLevel; }","public class DummyClass {
    public SupportLevel getCredentialAcquireSupport(
            Class<? extends Credential> credentialType, String algorithmName)
            throws RealmUnavailableException {
        Assert.checkNotNullParam(""credentialType"", credentialType);
        SupportLevel supportLevel =
                stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName);
        if (supportLevel == null) {
            throw log.unableToDetermineSupportLevel();
        }
        return supportLevel;
    }
}",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","public class DummyClass {
    public SupportLevel getCredentialAcquireSupport(
            Class<? extends Credential> credentialType, String algorithmName)
            throws RealmUnavailableException {
        Assert.checkNotNullParam(""credentialType"", credentialType);
        return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName);
    }
}","['public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SecurityLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLEVEL = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType);-1. securityLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return securityLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName, false); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); OfLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName, false); }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert. checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); return supportLevel; }', 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName; }']",True,1,0,94,143,9,1.0,0.999999995,False,False,False,,,,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, <START> algorithmName); if (!(supportLevel == null)) { } else <END> { throw log.unableToDetermineSupportLevel(); } return supportLevel; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.checkNotNullParam(""credentialType"",credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); <START>if (supportLevel == null) {<END> throw log.unableToDetermineSupportLevel(); } return supportLevel; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { boolean var = false; if (var) var = true; Assert.checkNotNullParam(""credentialType"",credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); <START>if (supportLevel == null) {<END> throw log.unableToDetermineSupportLevel(); } return supportLevel; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { boolean var = false; if (var) var = true; Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { try { Assert.checkNotNullParam(""credentialType"",credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); <START>if (supportLevel == null) {<END> throw log.unableToDetermineSupportLevel(); } return supportLevel; } catch (Exception e) { throw e; } }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { try { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); } catch (Exception e) { throw e; } }",,,,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); } SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); <START>if (supportLevel == null) {<END> throw log.unableToDetermineSupportLevel(); } return supportLevel; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"", credentialType); } return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }",,,,,,,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, <START> algorithmName); if (supportLevel == null) <END> { throw log.unableToDetermineSupportLevel(); } return supportLevel; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> sqzyi, String lndub) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", sqzyi); SupportLevel rbvax = stateRef.get().getCredentialAcquireSupport(sqzyi, <START> lndub); if (rbvax == null) <END> { throw log.unableToDetermineSupportLevel(); } return rbvax; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> sqzyi, String lndub) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", sqzyi); return stateRef.get().getCredentialAcquireSupport(sqzyi, lndub); }",,,,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"",credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); SupportLevel qffpg = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); <START>if (qffpg == null) {<END> throw log.unableToDetermineSupportLevel(); } return qffpg; }",This dropped,"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(""credentialType"", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }","1- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); }
2- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); } return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); }
3- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); } SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); return supportLevel; }
4- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } else { return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); } }
5- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); } SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); return supportLevel == null ? log.unableToDetermineSupportLevel() : supportLevel; }
6- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } else { return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } }
7- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }
8- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); }
9- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null) { Assert.checkNotNullParam(""credentialType"",credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType,algorithmName); } else { return supportLevel; } }
10- public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType,String algorithmName) throws RealmUnavailableException { if (credentialType == null)",0
162,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; <START> this.dlqTopicName = connConfig.dlqTopicName(); <END> }","public class DummyClass {
    DeadLetterQueueReporter(
            KafkaProducer<byte[], byte[]> kafkaProducer,
            SinkConnectorConfig connConfig,
            ConnectorTaskId id,
            ErrorHandlingMetrics errorHandlingMetrics) {
        Objects.requireNonNull(kafkaProducer);
        Objects.requireNonNull(connConfig);
        Objects.requireNonNull(id);
        Objects.requireNonNull(errorHandlingMetrics);
        this.kafkaProducer = kafkaProducer;
        this.connConfig = connConfig;
        this.connectorTaskId = id;
        this.errorHandlingMetrics = errorHandlingMetrics;
        this.dlqTopicName = connConfig.dlqTopicName();
    }
}",trim this? suggestion this.dlqTopicName = connConfig.dlqTopicName().trim();,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }","public class DummyClass {
    DeadLetterQueueReporter(
            KafkaProducer<byte[], byte[]> kafkaProducer,
            SinkConnectorConfig connConfig,
            ConnectorTaskId id,
            ErrorHandlingMetrics errorHandlingMetrics) {
        Objects.requireNonNull(kafkaProducer);
        Objects.requireNonNull(connConfig);
        Objects.requireNonNull(id);
        Objects.requireNonNull(errorHandlingMetrics);
        this.kafkaProducer = kafkaProducer;
        this.connConfig = connConfig;
        this.connectorTaskId = id;
        this.errorHandlingMetrics = errorHandlingMetrics;
        this.dlqTopicName = connConfig.dlqTopicName().trim();
    }
}","['DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName(); }', 'UnLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName.trim(); }', 'privateDeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'CommandLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'EntityQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'NewLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }', 'DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim();']",True,0,0,26,33,2,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"DeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; <START>this.dlqTopicName = connConfig.dlqTopicName();<END> }",trim this? suggestion this.dlqTopicName = connConfig.dlqTopicName().trim();,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }",,,,,,,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> errorHandlingMetrics, SinkConnectorConfig kafkaProducer, ConnectorTaskId connConfig, ErrorHandlingMetrics id) { Objects.requireNonNull(errorHandlingMetrics); Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); this.errorHandlingMetrics = errorHandlingMetrics; this.kafkaProducer = kafkaProducer; this.connectorTaskId = connConfig; this.id = <START> id; this.dlqTopicName = <END> kafkaProducer.dlqTopicName(); }",trim this? suggestion this.dlqTopicName = kafkaProducer.dlqTopicName().trim();,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> errorHandlingMetrics, SinkConnectorConfig kafkaProducer, ConnectorTaskId connConfig, ErrorHandlingMetrics id) { Objects.requireNonNull(errorHandlingMetrics); Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); this.errorHandlingMetrics = errorHandlingMetrics; this.kafkaProducer = kafkaProducer; this.connectorTaskId = connConfig; this.id = id; this.dlqTopicName = kafkaProducer.dlqTopicName().trim(); }","DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> jpany, SinkConnectorConfig rvobi, ConnectorTaskId pkghi, ErrorHandlingMetrics fwixf) { Objects.requireNonNull(jpany); Objects.requireNonNull(rvobi); Objects.requireNonNull(pkghi); Objects.requireNonNull(fwixf); this.jpany = jpany; this.rvobi = rvobi; this.connectorTaskId = pkghi; this.fwixf = <START> fwixf; this.dlqTopicName = <END> rvobi.dlqTopicName(); }",trim this? suggestion this.dlqTopicName = rvobi.dlqTopicName().trim();,"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> jpany, SinkConnectorConfig rvobi, ConnectorTaskId pkghi, ErrorHandlingMetrics fwixf) { Objects.requireNonNull(jpany); Objects.requireNonNull(rvobi); Objects.requireNonNull(pkghi); Objects.requireNonNull(fwixf); this.jpany = jpany; this.rvobi = rvobi; this.connectorTaskId = pkghi; this.fwixf = fwixf; this.dlqTopicName = rvobi.dlqTopicName().trim(); }",,,,,,,"1- DeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
2- privateDeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
3- DeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName(); }
4- UnLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
5- DeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
6- EntityQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
7- NewLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
8- publicDeadLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
9- CommandLetterQueueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }
10- UUID queueReporter(KafkaProducer<byte[],byte[]> kafkaProducer,SinkConnectorConfig connConfig,ConnectorTaskId id,ErrorHandlingMetrics errorHandlingMetrics) { if (kafkaProducer == null) { Objects.requireNonNull(kafkaProducer); } if (connConfig == null) { Objects.requireNonNull(connConfig); } if (id == null) { Objects.requireNonNull(id); } if (errorHandlingMetrics == null) { Objects.requireNonNull(errorHandlingMetrics); } this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }",0
175,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { <START> return new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null, cannot create vertex""), label, address, <END> iconKey); }","public class DummyClass {
    public static OnmsTopologyVertex create(
            String id, String label, String address, String iconKey) {
        return new OnmsTopologyVertex(
                Objects.requireNonNull(id, ""id is null, cannot create vertex""),
                label,
                address,
                iconKey);
    }
}",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }","public class DummyClass {
    public static OnmsTopologyVertex create(
            String id, String label, String address, String iconKey) {
        Objects.requireNonNull(id, ""id is null, cannot create vertex"");
        return new OnmsTopologyVertex(id, label, address, iconKey);
    }
}","['public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""label is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""Label is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""hostname is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""endpoint is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, "" label is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""label is null, cannot create vertex""); return new OnmsTopologyVertex( id, label, address, iconKey); }', 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); Objects.requireNonNull(label, ""label is null, cannot create vertex""); return new OnmsTopologyVertex(ID, label, address, iconKey); }']",True,0,0,90,90,5,1.0,0.999999995,False,False,False,,,,,,,"public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,<END>iconKey); }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }","public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { boolean var = false; if (var) var = true; <START>return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,<END>iconKey); }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { boolean var = false; if (var) var = true; Objects.requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); }","public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { try { <START>return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,<END>iconKey); } catch (Exception e) { throw e; } }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { try { Objects.requireNonNull(id, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(id, label, address, iconKey); } catch (Exception e) { throw e; } }","public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { OnmsTopologyVertex returnValue =  <START> new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null, cannot create vertex""),  label, address, iconKey) <END>; return returnValue; }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); OnmsTopologyVertex returnValue = new OnmsTopologyVertex(id, label, address, iconKey); return returnValue; }","public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { <START>return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,<END>iconKey); }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { if (id == null) { Objects.requireNonNull(id, ""id is null, cannot create vertex""); } return new OnmsTopologyVertex(id, label, address, iconKey); }",,,,,,,"public static OnmsTopologyVertex create(String label, String id, String iconKey, String address) <START> { return new OnmsTopologyVertex(Objects.requireNonNull(label, ""id is null, cannot create vertex""), <END> id, iconKey, address); }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String label, String id, String iconKey, String address) { Objects.requireNonNull(label, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(label, id, iconKey, address); }","public static OnmsTopologyVertex create(String ehdwf, String xekbn, String hjciy, String bojmz) <START> { return new OnmsTopologyVertex(Objects.requireNonNull(ehdwf, ""id is null, cannot create vertex""), <END> xekbn, hjciy, bojmz); }",put Objects.requireNonNull(...) beginning of method? This easier read,"public static OnmsTopologyVertex create(String ehdwf, String xekbn, String hjciy, String bojmz) { Objects.requireNonNull(ehdwf, ""id is null, cannot create vertex""); return new OnmsTopologyVertex(ehdwf, xekbn, hjciy, bojmz); }",,,,,,,"1- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null,cannot create vertex""),label,address,iconKey); }
2- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,iconKey); }
3- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null,cannot create vertex""),label, address,iconKey); }
4- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex( Objects.requireNonNull(id, ""id is null,cannot create vertex""),label,address,iconKey); }
5- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null,cannot create vertex""),label,address, iconKey); }
6- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id, ""id is null,cannot create vertex""),label, address, iconKey); }
7- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label, address,iconKey); }
8- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex( Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address,iconKey); }
9- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label,address, iconKey); }
10- public static OnmsTopologyVertex create(String id,String label,String address,String iconKey) { return new OnmsTopologyVertex(Objects.requireNonNull(id,""id is null,cannot create vertex""),label, address, iconKey); }",0
185,"public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { <START> ArgChecker.notNull(index, ""currency""); <END> ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }","public class DummyClass {
    public ImmutableRatesProviderBuilder overnightIndexCurve(
            OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) {
        ArgChecker.notNull(index, ""currency"");
        ArgChecker.notNull(forwardCurve, ""forwardCurve"");
        ArgChecker.notNull(timeSeries, ""timeSeries"");
        this.indexCurves.put(index, forwardCurve);
        this.timeSeries.put(index, timeSeries);
        return this;
    }
}",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }","public class DummyClass {
    public ImmutableRatesProviderBuilder overnightIndexCurve(
            OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) {
        ArgChecker.notNull(index, ""index"");
        ArgChecker.notNull(forwardCurve, ""forwardCurve"");
        ArgChecker.notNull(timeSeries, ""timeSeries"");
        this.indexCurves.put(index, forwardCurve);
        this.timeSeries.put(index, timeSeries);
        return this;
    }
}","['public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(csrf, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve NetworkGateway, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(Bayes, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, NetworkGateway); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(NetworkGateway, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(vv, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""vv""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""csrf""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }', 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""NetworkGateway""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }']",True,0,0,33,33,2,1.0,0.999999995,False,False,False,,,,,,,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); ArgChecker.notNull(timeSeries,""timeSeries""); this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }","public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { boolean var = false; if (var) var = true; <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); ArgChecker.notNull(timeSeries,""timeSeries""); this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { boolean var = false; if (var) var = true; ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }","public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { try { <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); ArgChecker.notNull(timeSeries,""timeSeries""); this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; } catch (Exception e) { throw e; } }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { try { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; } catch (Exception e) { throw e; } }",,,,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { <START>ArgChecker.notNull(index,""currency"");<END> } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries, ""timeSeries""); } this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }",,,,,,,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex forwardCurve, Curve index, LocalDateDoubleTimeSeries timeSeries) { <START> ArgChecker.notNull(forwardCurve, ""currency""); <END> ArgChecker.notNull(index, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(forwardCurve, index); this.timeSeries.put(forwardCurve, timeSeries); return this; }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex forwardCurve, Curve index, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); ArgChecker.notNull(index, ""forwardCurve""); ArgChecker.notNull(timeSeries, ""timeSeries""); this.indexCurves.put(forwardCurve, index); this.timeSeries.put(forwardCurve, timeSeries); return this; }","public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex mgmmp, Curve hhlco, LocalDateDoubleTimeSeries uasfc) { <START> ArgChecker.notNull(mgmmp, ""currency""); <END> ArgChecker.notNull(hhlco, ""forwardCurve""); ArgChecker.notNull(uasfc, ""timeSeries""); this.indexCurves.put(mgmmp, hhlco); this.uasfc.put(mgmmp, uasfc); return this; }",Argument name,"public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex mgmmp, Curve hhlco, LocalDateDoubleTimeSeries uasfc) { ArgChecker.notNull(mgmmp, ""index""); ArgChecker.notNull(hhlco, ""forwardCurve""); ArgChecker.notNull(uasfc, ""timeSeries""); this.indexCurves.put(mgmmp, hhlco); this.uasfc.put(mgmmp, uasfc); return this; }",,,,,,,"1- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
2- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index,""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
3- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
4- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries, ""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
5- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries, ""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
6- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) {ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
7- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index,(""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
8- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) {ArgChecker.notNull(index,""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
9- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index,""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries, ""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }
10- public ImmutableRatesProviderBuilder overnightIndexCurve(OvernightIndex index,Curve forwardCurve,LocalDateDoubleTimeSeries timeSeries) { if (index == null) { ArgChecker.notNull(index,""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } if (timeSeries == null) { ArgChecker.notNull(timeSeries,""timeSeries""); } this.indexCurves.put(index,forwardCurve); this.timeSeries.put(index,timeSeries); return this; }",0
223,"public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { <START> Assert.notNull(cosmosFactory, ""CosmosDbFactory must not be null!""); <END> Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.cosmosFactory = cosmosFactory; this.cosmosConfig = cosmosConfig; this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosClient(); }","public class DummyClass {
    public ReactiveCosmosTemplate(
            CosmosFactory cosmosFactory,
            CosmosConfig cosmosConfig,
            MappingCosmosConverter mappingCosmosConverter) {
        Assert.notNull(cosmosFactory, ""CosmosDbFactory must not be null!"");
        Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!"");
        Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!"");
        this.cosmosFactory = cosmosFactory;
        this.cosmosConfig = cosmosConfig;
        this.mappingCosmosConverter = mappingCosmosConverter;
        this.cosmosAsyncClient = cosmosFactory.getCosmosClient();
    }
}",Rename -> CosmosDbFactory CosmosFactory,"public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }","public class DummyClass {
    public ReactiveCosmosTemplate(
            CosmosFactory cosmosFactory,
            CosmosConfig cosmosConfig,
            MappingCosmosConverter mappingCosmosConverter) {
        Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!"");
        Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!"");
        Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!"");
        this.mappingCosmosConverter = mappingCosmosConverter;
        this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient();
        this.databaseName = cosmosFactory.getDatabaseName();
        this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor();
        this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled();
    }
}","['public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosconfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.hasQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfiguration.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfigBuilder.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfigBuilder.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient; this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); getSession().close(); }', 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; }']",True,0,0,156,240,14,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { <START>Assert.notNull(cosmosFactory,""CosmosDbFactory must not be null!"");<END> } if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.cosmosFactory = cosmosFactory; this.cosmosConfig = cosmosConfig; this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosClient(); }",Rename -> CosmosDbFactory CosmosFactory,"public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); } if (cosmosConfig == null) { Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }",,,,,,,"public ReactiveCosmosTemplate(CosmosFactory cosmosConfig, CosmosConfig cosmosFactory, MappingCosmosConverter mappingCosmosConverter) <START> { Assert.notNull(cosmosConfig, ""CosmosDbFactory must not be <END> null!""); Assert.notNull(cosmosFactory, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.cosmosConfig = cosmosConfig; this.cosmosFactory = cosmosFactory; this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosConfig.getCosmosClient(); }",Rename -> CosmosDbFactory CosmosFactory,"public ReactiveCosmosTemplate(CosmosFactory cosmosConfig, CosmosConfig cosmosFactory, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosConfig, ""CosmosFactory must not be null!""); Assert.notNull(cosmosFactory, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter, ""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosConfig.getCosmosAsyncClient(); this.databaseName = cosmosConfig.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosFactory.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosFactory.isQueryMetricsEnabled(); }","public ReactiveCosmosTemplate(CosmosFactory wnfth, CosmosConfig qmapx, MappingCosmosConverter dikxo) <START> { Assert.notNull(wnfth, ""CosmosDbFactory must not be <END> null!""); Assert.notNull(qmapx, ""CosmosConfig must not be null!""); Assert.notNull(dikxo, ""MappingCosmosConverter must not be null!""); this.wnfth = wnfth; this.qmapx = qmapx; this.dikxo = dikxo; this.cosmosAsyncClient = wnfth.getCosmosClient(); }",Rename -> CosmosDbFactory CosmosFactory,"public ReactiveCosmosTemplate(CosmosFactory wnfth, CosmosConfig qmapx, MappingCosmosConverter dikxo) { Assert.notNull(wnfth, ""CosmosFactory must not be null!""); Assert.notNull(qmapx, ""CosmosConfig must not be null!""); Assert.notNull(dikxo, ""MappingCosmosConverter must not be null!""); this.dikxo = dikxo; this.cosmosAsyncClient = wnfth.getCosmosAsyncClient(); this.databaseName = wnfth.getDatabaseName(); this.responseDiagnosticsProcessor = qmapx.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = qmapx.isQueryMetricsEnabled(); }",,,,,,,"1- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); } if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
2- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { Assert.notNull(cosmosFactory,""CosmosFactory must not be null!""); } if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
3- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory,""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
4- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory,""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
5- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory,""CosmosFactory must not be null!""); if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
6- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { Assert.notNull(cosmosFactory,""CosmosDbFactory must not be null!""); } if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory; this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
7- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
8- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
9- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, ""CosmosFactory must not be null!""); Assert.notNull(cosmosConfig, ""CosmosConfig must not be null!""); Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }
10- public ReactiveCosmosTemplate(CosmosFactory cosmosFactory,CosmosConfig cosmosConfig,MappingCosmosConverter mappingCosmosConverter) { if (cosmosFactory == null) { Assert.notNull(cosmosFactory, ""CosmosDbFactory must not be null!""); } if (cosmosConfig == null) { Assert.notNull(cosmosConfig,""CosmosConfig must not be null!""); } if (mappingCosmosConverter == null) { Assert.notNull(mappingCosmosConverter,""MappingCosmosConverter must not be null!""); } this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory; this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }",0
225,public Response awaitResponse() throws Exception { <START> return Objects.requireNonNull(remoteFuture).get(); <END> },"public class DummyClass {
    public Response awaitResponse() throws Exception {
        return Objects.requireNonNull(remoteFuture).get();
    }
}",I advantage of requireNonNull(),public Response awaitResponse() throws Exception { return remoteFuture.get(); },"public class DummyClass {
    public Response awaitResponse() throws Exception {
        return remoteFuture.get();
    }
}","['public Response awaitResponse() throws Exception { return remoteFuture; }', 'public Response awaitResponse() throws Exception { return remoteFuture.get(); }', 'public Response awaitResponse() throws Exception { return remoteFuture == null? null : remoteFuture.get(); }', 'public Response awaitResponse() throws Exception { return remoteFuture == null? this.remoteFuture : remoteFuture; }', 'public Response awaitResponse() throws Exception { return remoteFuture == null? ""remoteFuture"" : remoteFuture; }', 'public Response awaitResponse() throws Exception { return remoteFuture!= null? remoteFuture.get() : null; }', 'public Response awaitResponse() throws Exception { return remoteFuture == null? this : remoteFuture; }', 'public Response awaitResponse() throws Exception { return requireNonNull(remoteFuture).get(); }', 'public Response awaitResponse() throws Exception { return remoteFuture.get(); }', 'public Response awaitResponse() throws Exception { return originalFuture; }']",True,1,0,34,50,2,1.0,0.999999995,False,False,False,,,,,,,"public Response awaitResponse() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>return Objects.requireNonNull(remoteFuture).get();<END> }",I advantage of requireNonNull(),"public Response awaitResponse() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return remoteFuture.get(); }",public Response awaitResponse() throws Exception { boolean var = false; if (var) var = true; <START>return Objects.requireNonNull(remoteFuture).get();<END> },I advantage of requireNonNull(),public Response awaitResponse() throws Exception { boolean var = false; if (var) var = true; return remoteFuture.get(); },public Response awaitResponse() throws Exception { try { <START>return Objects.requireNonNull(remoteFuture).get();<END> } catch (Exception e) { throw e; } },I advantage of requireNonNull(),public Response awaitResponse() throws Exception { try { return remoteFuture.get(); } catch (Exception e) { throw e; } },public Response awaitResponse() throws Exception { Response returnValue =  <START> Objects.requireNonNull(remoteFuture).get() <END>; return returnValue; },I advantage of requireNonNull(),public Response awaitResponse() throws Exception { Response returnValue = remoteFuture.get(); return returnValue; },public Response awaitResponse() throws Exception { <START>return Objects.requireNonNull(remoteFuture).get();<END> },I advantage of requireNonNull(),public Response awaitResponse() throws Exception { return remoteFuture.get(); },,,,,,,,,,,,,,,,,,,"1- public Response awaitResponse() throws Exception { return Objects.requireNonNull(remoteFuture).get(); }
2- public Response awaitResponse() throws Exception { return Objects. requireNonNull(remoteFuture).get(); }
3- public Response awaitResponse() throws Exception { return Objects.requireNonNull( remoteFuture).get(); }
4- public Response awaitResponse()() throws Exception { return Objects.requireNonNull(remoteFuture).get(); }
5- public Response awaitResponse() throws Exception { return Objects.notNull(remoteFuture).get(); }
6- public Response awaitResponse() throws Exception { return Objects.isNull(remoteFuture).get(); }
7- public Response awaitResponse() throws Exception } return Objects.requireNonNull(remoteFuture).get(); }
8- public Response awaitResponse() == Exception { return Objects.requireNonNull(remoteFuture).get(); }
9- public Response awaitResponse() throws Exception { return Objects.nonNull(remoteFuture).get(); }
10- public Response awaitResponse() { return Objects.requireNonNull(remoteFuture).get(); }",0
244,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter( query ); <END> assertNotNull(s); assertEquals(StringPool.BLANK, s); }","public class DummyClass {
    public void testInvalidCondition() throws Exception {
        final String query = ""and if(length(user())>0,sleep(10),2)"";
        final String s = SQLUtil.sanitizeParameter(query);
        assertNotNull(s);
        assertEquals(StringPool.BLANK, s);
    }
}",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }","public class DummyClass {
    public void testInvalidCondition() throws Exception {
        final String query = ""and if(length(user())>0,sleep(10),2)"";
        final String s = SQLUtil.sanitizeCondition(query);
        assertNotNull(s);
        assertEquals(StringPool.BLANK, s);
    }
}","['public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0, sleep(10),2)""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s =SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10), 2)""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQL1.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; finalString s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and }(length(user())>0,sleep(10),2)""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }', 'public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2"")""; final String s = SQL.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }']",True,3,0,35,35,2,1.0,0.999999995,False,False,False,,,,,,,"public void testInvalidCondition() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); assertEquals(StringPool.BLANK, <END> s); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); assertNotNull(s); assertEquals(StringPool.BLANK, s); }","public void testInvalidCondition() throws Exception { boolean var = false; if (var) var = true; final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); assertEquals(StringPool.BLANK, <END> s); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { boolean var = false; if (var) var = true; final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); assertNotNull(s); assertEquals(StringPool.BLANK, s); }","public void testInvalidCondition() throws Exception { try { final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); assertEquals(StringPool.BLANK, <END> s); } catch (Exception e) { throw e; } }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { try { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); assertNotNull(s); assertEquals(StringPool.BLANK, s); } catch (Exception e) { throw e; } }",,,,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, <END> s); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }","public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); if (StringPool.BLANK !=  s) { assertEquals(StringPool.BLANK, <END> s); } }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); assertNotNull(s); if (StringPool.BLANK != s) { assertEquals(StringPool.BLANK, s); } }",,,,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); assertEquals(StringPool.BLANK, <END> s); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(query); assertNotNull(s); assertEquals(StringPool.BLANK, s); }","public void testInvalidCondition() throws Exception { final String fdrme = ""and if(length(user())>0,sleep(10),2)""; <START> final String aroog = SQLUtil.sanitizeParameter(fdrme); assertNotNull(aroog); assertEquals(StringPool.BLANK, <END> aroog); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String fdrme = ""and if(length(user())>0,sleep(10),2)""; final String aroog = SQLUtil.sanitizeCondition(fdrme); assertNotNull(aroog); assertEquals(StringPool.BLANK, aroog); }",,,,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; String ogtfe = ""and if(length(user())>0,sleep(10),2)""; <START> final String s = SQLUtil.sanitizeParameter(ogtfe); assertNotNull(s); assertEquals(StringPool.BLANK, <END> s); }",SQL.sanitizeCondition also,"public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; String ogtfe = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeCondition(ogtfe); assertNotNull(s); assertEquals(StringPool.BLANK, s); }","1- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
2- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0, sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
3- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); assertNotNull(s); assertEquals(StringPool.BLANK, s); }
4- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; finalString s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
5- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); assertTrue(s == null); assertNotNull(s); assertEquals(StringPool.BLANK, s); }
6- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10), 2)""; final String s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
7- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameters(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
8- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeHeader(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); }
9- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); assertEquals(StringPool.BLANK, s); }
10- public void testInvalidCondition() throws Exception { final String query = ""and if(length(user())>0,sleep(10),2)""; final String s = SQLUtil.sanitizeParameter(query); if (s == null) { assertNotNull(s); } assertEquals(StringPool.BLANK, s); assertFalse(s.isEmpty()); }",0
297,"public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } <START> return null; <END> }","public class DummyClass {
    public List<Element> previousElementSiblings() {
        if (parentNode == null) {
            return null;
        }
        List<Element> siblings = parent().childElementsList();
        int index = indexInList(this, siblings);
        Validate.notNull(index);
        if (index > 0 && index < siblings.size()) {
            return siblings.subList(0, index);
        }
        return null;
    }
}",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }","public class DummyClass {
    public List<Element> previousElementSiblings() {
        if (parentNode == null) {
            return Collections.emptyList();
        }
        List<Element> siblings = parent().childElementsList();
        int index = indexInList(this, siblings);
        Validate.notNull(index);
        if (index > 0 && index < siblings.size()) {
            return siblings.subList(0, index);
        }
        return Collections.emptyList();
    }
}","['public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.EMPTY_LIST; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }', 'public ArrayList<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return new ArrayList<>(); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.unmodifiableList(index); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.EMPTY_LIST; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.EMPTY_LIST; }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return new ArrayList<Element>(index); }', 'public ImmutableList<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }', 'public List<Element> previousElementSiblings() { if (parentNode == null) { return emptyList; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return emptyList; }']",True,0,0,44,68,2,1.0,0.999999995,False,False,False,"public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } <START> return null; <END> }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }","public List<Element> previousElementSiblings() { if (!(parentNode == null)) { } else { return null; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (!(index > 0 && index < siblings.size())) { } else { return siblings.subList(0, index); } <START> return null; <END> }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (!(parentNode == null)) { } else { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (!(index > 0 && index < siblings.size())) { } else { return siblings.subList(0, index); } return Collections.emptyList(); }","public List<Element> previousElementSiblings() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); if (parentNode == null) { <START>return null;<END> } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return null; }",Empty list instead of null,"public List<Element> previousElementSiblings() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }","public List<Element> previousElementSiblings() { boolean var = false; if (var) var = true; if (parentNode == null) { <START>return null;<END> } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return null; }",Empty list instead of null,"public List<Element> previousElementSiblings() { boolean var = false; if (var) var = true; if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }","public List<Element> previousElementSiblings() { try { if (parentNode == null) { <START>return null;<END> } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return null; } catch (Exception e) { throw e; } }",Empty list instead of null,"public List<Element> previousElementSiblings() { try { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); } catch (Exception e) { throw e; } }",,,,"public List<Element> previousElementSiblings() { if (parentNode == null) { <START>return null;<END> } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return null; }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }",,,,,,,"public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> index = parent().childElementsList(); int siblings = indexInList(this, index); Validate.notNull(siblings); if (siblings > 0 && siblings < index.size()) { return index.subList(0, siblings); } <START> return null; <END> }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> index = parent().childElementsList(); int siblings = indexInList(this, index); Validate.notNull(siblings); if (siblings > 0 && siblings < index.size()) { return index.subList(0, siblings); } return Collections.emptyList(); }","public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> ckmer = parent().childElementsList(); int bshdg = indexInList(this, ckmer); Validate.notNull(bshdg); if (bshdg > 0 && bshdg < ckmer.size()) { return ckmer.subList(0, bshdg); } <START> return null; <END> }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> ckmer = parent().childElementsList(); int bshdg = indexInList(this, ckmer); Validate.notNull(bshdg); if (bshdg > 0 && bshdg < ckmer.size()) { return ckmer.subList(0, bshdg); } return Collections.emptyList(); }",,,,"public List<Element> previousElementSiblings() { if (parentNode == null) { <START>return null;<END> } List<Element> siblings = parent().childElementsList(); List<Element> gbxfc = parent().childElementsList(); int index = indexInList(this,gbxfc); Validate.notNull(index); if (index > 0 && index < gbxfc.size()) { return gbxfc.subList(0,index); } return null; }",Empty list instead of null,"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); List<Element> gbxfc = parent().childElementsList(); int index = indexInList(this, gbxfc); Validate.notNull(index); if (index > 0 && index < gbxfc.size()) { return gbxfc.subList(0, index); } return Collections.emptyList(); }","1- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
2- public List<Element> previousElementSiblings() { if (parentNode == empty) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
3- public List<Element> previousElementSiblings() { if (parentNode == null) { return new ArrayList<>(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
4- public List<Element> previousElementSiblings() { if (parentNode == null) { return new ArrayList<>(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return new ArrayList<>(index); }
5- public List<Element> previousElementSiblings() { if (parentNode == Collections.emptyList()) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
6- public List<Element> previousElementSiblings() { if (parentNode == EmptyList.empty()) { return null; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
7- public List<Element> previousElementSiblings() { if (parentNode == null) { return new ArrayList<Element>(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
8- public List<Element> previousElementSiblings() { if (parentNode == Collections.emptyList()) { return null; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }
9- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); }); }
10- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this,siblings); if (index == null) { Validate.notNull(index); } if (index > 0 && index < siblings.size()) { return siblings.subList(0,index); } return Collections.emptyList(); } {",0
312,"public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START> return false; <END> }","public class DummyClass {
    public boolean matches(ExternalId otherId) {
        ArgChecker.notNull(otherId, ""otherId"");
        switch (searchType) {
            case EXACT:
                return ImmutableSet.of(otherId).equals(externalIds);
            case ALL:
                return ImmutableSet.of(otherId).containsAll(externalIds);
            case ANY:
                return contains(otherId);
            case NONE:
                return contains(otherId) == false;
        }
        return false;
    }
}",a default switch,"public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }","public class DummyClass {
    public boolean matches(ExternalId otherId) {
        ArgChecker.notNull(otherId, ""otherId"");
        switch (searchType) {
            case EXACT:
                return ImmutableSet.of(otherId).equals(externalIds);
            case ALL:
                return ImmutableSet.of(otherId).containsAll(externalIds);
            case ANY:
                return contains(otherId);
            case NONE:
                return contains(otherId) == false;
            default:
                return false;
        }
    }
}","['public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); ArgChecker.notNull(searchType, ""searchType""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId); default: return false; } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId); default: return false; } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return ImmutableSet.of(otherId).equals(externalIds); } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: throw new IllegalStateException(); } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return ImmutableSet.of(searchType).equals(externalIds); } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: throw new IllegalArgumentException(); } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); ArgChecker.isTrue(searchType == EXACT.name()); return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return ImmutableSet.of(otherId).equals(searchType); } }', 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, ""otherId""); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: logger.error(""Unknown search type""); return false; } }']",True,0,0,34,34,1,1.0,0.999999995,True,True,False,,,,,,,"public boolean matches(ExternalId otherId) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(otherId,""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START>return false;<END> }",a default switch,"public boolean matches(ExternalId otherId) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(otherId, ""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }","public boolean matches(ExternalId otherId) { boolean var = false; if (var) var = true; ArgChecker.notNull(otherId,""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START>return false;<END> }",a default switch,"public boolean matches(ExternalId otherId) { boolean var = false; if (var) var = true; ArgChecker.notNull(otherId, ""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }","public boolean matches(ExternalId otherId) { try { ArgChecker.notNull(otherId,""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START>return false;<END> } catch (Exception e) { throw e; } }",a default switch,"public boolean matches(ExternalId otherId) { try { ArgChecker.notNull(otherId, ""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } } catch (Exception e) { throw e; } }",,,,"public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START>return false;<END> }",a default switch,"public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId, ""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }",,,,,,,,,,"public boolean matches(ExternalId dtbpz) { ArgChecker.notNull(dtbpz, ""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(dtbpz).equals(externalIds); case ALL: return ImmutableSet.of(dtbpz).containsAll(externalIds); case ANY: return contains(dtbpz); case NONE: return contains(dtbpz) == false; } <START> return false; <END> }",a default switch,"public boolean matches(ExternalId dtbpz) { ArgChecker.notNull(dtbpz, ""otherId""); switch(searchType) { case EXACT: return ImmutableSet.of(dtbpz).equals(externalIds); case ALL: return ImmutableSet.of(dtbpz).containsAll(externalIds); case ANY: return contains(dtbpz); case NONE: return contains(dtbpz) == false; default: return false; } }",,,,,,,"1- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }
2- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId); default: return false; } }
3- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId, ""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }
4- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId, ""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId); default: return false; } }
5- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }
6- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) != false; default: return false; } }
7- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId); default: return false; } }
8- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,(""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }
9- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; }}
10- public boolean matches(ExternalId otherId) { if (otherId == null) { ArgChecker.notNull(otherId,""otherId""); } switch(searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; }",1
320,"public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { <START> this.showMigrationEvents = notNull(""showMigrationEvents"", showMigrationEvents); <END> return this; }","public class DummyClass {
    public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) {
        this.showMigrationEvents = notNull(""showMigrationEvents"", showMigrationEvents);
        return this;
    }
}",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = showMigrationEvents; return this; },"public class DummyClass {
    public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) {
        this.showMigrationEvents = showMigrationEvents;
        return this;
    }
}","['public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = notNull(""showMigrationEvents"", showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = showMigrationEvents; return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = false; return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = getBoolean(""showMigrationEvents"", showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents =!notNull(""showMigrationEvents"", showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { notNull(""showMigrationEvents"", showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = isMigrationEventsAllowed(showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = isNull(""showMigrationEvents"", showMigrationEvents); return this; }', 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { checkNotNull(""showMigrationEvents"", showMigrationEvents); return this; }']",True,2,0,26,58,3,1.0,0.999999995,False,False,False,,,,,,,"public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>this.showMigrationEvents = notNull(""showMigrationEvents"",showMigrationEvents);<END> return this; }",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,"public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); this.showMigrationEvents = showMigrationEvents; return this; }","public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { boolean var = false; if (var) var = true; <START>this.showMigrationEvents = notNull(""showMigrationEvents"",showMigrationEvents);<END> return this; }",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { boolean var = false; if (var) var = true; this.showMigrationEvents = showMigrationEvents; return this; },"public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { try { <START>this.showMigrationEvents = notNull(""showMigrationEvents"",showMigrationEvents);<END> return this; } catch (Exception e) { throw e; } }",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { try { this.showMigrationEvents = showMigrationEvents; return this; } catch (Exception e) { throw e; } },,,,"<START>public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } <END> return this; }",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = showMigrationEvents; return this; },,,,,,,,,,"public ChangeStreamIterable<TResult> kciyv(final boolean kciyv) { <START> this.kciyv = notNull(""showMigrationEvents"", kciyv); <END> return this; }",Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean,public ChangeStreamIterable<TResult> kciyv(final boolean kciyv) { this.kciyv = kciyv; return this; },,,,,,,"1- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
2- public ChangeStreamIterator<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
3- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if ((""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
4- public ChangeStreamIterable<TResult> showMigrationEvents( final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
5- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (showMigrationEvents == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
6- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) notNull(""showMigrationEvents"", showMigrationEvents); return this; }
7- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents) } return this; }
8- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (showMigrationEvents) { notNull(""showMigrationEvents"", showMigrationEvents); } return this; }
9- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { notNull(""showMigrationEvents"", showMigrationEvents); return this; }
10- public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { if (""showMigrationEvents"" == null) { notNull(""showMigrationEvents"", showMigrationEvents); } return that; }",0
339,"<START> public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { <END> A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }","public class DummyClass {
    public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {
        A.notNull(key, ""key"");
        return cctx.affinity().nodesByPartition(partition(key), topologyVersion());
    }
}","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }","public class DummyClass {
    @Override
    public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {
        A.notNull(key, ""key"");
        return cctx.affinity().nodesByPartition(partition(key), topologyVersion());
    }
}","['@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', 'List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', 'private List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '@Override List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '@Override protected List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', 'protected List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '@Override private List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '} List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }', '@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion); }']",True,0,0,25,25,1,1.0,0.999999995,True,True,False,,,,,,,"<START>public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); A.notNull(key,""key""); return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }","<START>public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {<END> boolean var = false; if (var) var = true; A.notNull(key,""key""); return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { boolean var = false; if (var) var = true; A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }","<START>public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {<END> try { A.notNull(key,""key""); return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); } catch (Exception e) { throw e; } }","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { try { A.notNull(key, ""key""); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); } catch (Exception e) { throw e; } }",,,,"<START>public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) {<END> if (key == null) { A.notNull(key,""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }",,,,,,,,,,"<START> public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K nyila) { <END> A.notNull(nyila, ""key""); return cctx.affinity().nodesByPartition(partition(nyila), topologyVersion()); }","Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList","@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K nyila) { A.notNull(nyila, ""key""); return cctx.affinity().nodesByPartition(partition(nyila), topologyVersion()); }",,,,,,,"1- public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
2- public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key,""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
3- private List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
4- protected List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
5- private List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key,""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
6- public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key,(""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
7- } List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
8- Map<K, Log> mapKeyToPrimaryAndBackupsList(K key) { if (key == null) { A.notNull(key, ""key""); } return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
9- return cctx.affinity().nodesByPartition(partition(key),topologyVersion()); }
10- public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { }",0
343,"public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START> assertNotNull(ex); <END> assertEquals(-1, ex.getStatus()); }","public class DummyClass {
    public void testInvalidCassandraHostsFailsValidation() {
        Configuration config = Configuration.getInstance();
        config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something"");
        BluefloodServiceStarterException ex = null;
        try {
            BluefloodServiceStarter.validateCassandraHosts();
        } catch (BluefloodServiceStarterException e) {
            ex = e;
        }
        assertNotNull(ex);
        assertEquals(-1, ex.getStatus());
    }
}","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }","public class DummyClass {
    public void testInvalidCassandraHostsFailsValidation() {
        Configuration config = Configuration.getInstance();
        config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something"");
        BluefloodServiceStarter.validateCassandraHosts();
    }
}","['public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); BluefloodServiceStarter.run(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); BluefloodServiceStarter.check(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); BluefloodServiceStarter.checkConfiguration(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); BluefloodServiceStarter.assertUp(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter().validateCassandraHosts(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); BluefloodServiceStarter.checkUp(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter::validateCassandraHosts(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.checkCassandraHosts(); }', 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); } {']",True,0,0,152,186,11,1.0,0.999999995,False,False,False,,,,,,,"public void testInvalidCassandraHostsFailsValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START>assertNotNull(ex);<END> assertEquals(-1,ex.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }","public void testInvalidCassandraHostsFailsValidation() { boolean var = false; if (var) var = true; Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START>assertNotNull(ex);<END> assertEquals(-1,ex.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { boolean var = false; if (var) var = true; Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }",,,,,,,"public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } if (ex == null) { <START>assertNotNull(ex);<END> } assertEquals(-1,ex.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START>assertNotNull(ex);<END> if (-1 != ex.getStatus()) { assertEquals(-1,ex.getStatus()); } }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }",,,,"public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START> assertNotNull(ex); <END> assertEquals(-1, ex.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }","public void testInvalidCassandraHostsFailsValidation() { Configuration efjcz = Configuration.getInstance(); efjcz.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarterException eavwd = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException fnnue) { eavwd = fnnue; } <START> assertNotNull(eavwd); <END> assertEquals(-1, eavwd.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration efjcz = Configuration.getInstance(); efjcz.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }",,,,"public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); Configuration hdobc = Configuration.getInstance(); hdobc.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START>assertNotNull(ex);<END> assertEquals(-1,ex.getStatus()); }","@Test(expected = ...), above","public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); Configuration hdobc = Configuration.getInstance(); hdobc.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }","1- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter.validateCassandraHosts(); }
2- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter().validateCassandraHosts(); }
3- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter: BluefloodServiceStarter.validateCassandraHosts(); }
4- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, ""something""); BluefloodServiceStarter.validateCassandraHosts(); }
5- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter::validateCassandraHosts; }
6- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter.checkCassandraHosts(); }
7- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter::validateCassandraHosts(); }
8- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter: BluefloodServiceStarter::validateCassandraHosts; }
9- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter: BluefloodServiceStarter; }
10- public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS,""something""); BluefloodServiceStarter.validateCassandraHosts(); } {",1
459,"public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); <START> cacheConfig = requireNonNull(cacheConfig, ""cacheConfig is null""); <END> this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }","public class DummyClass {
    public RaptorCachingHdfsConfiguration(
            @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration,
            CacheConfig cacheConfig,
            CacheManager cacheManager) {
        this.hiveHdfsConfiguration =
                requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null"");
        this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null"");
        cacheConfig = requireNonNull(cacheConfig, ""cacheConfig is null"");
        this.cacheValidationEnabled = cacheConfig.isValidationEnabled();
    }
}","nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled();","public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }","public class DummyClass {
    public RaptorCachingHdfsConfiguration(
            @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration,
            CacheConfig cacheConfig,
            CacheManager cacheManager) {
        this.hiveHdfsConfiguration =
                requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null"");
        this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null"");
        this.cacheValidationEnabled =
                requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled();
    }
}","['public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null""); this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"")!= null; }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"") || cacheConfig.isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); cacheValidationEnabled = cacheConfig.isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null).isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.configValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); cacheConfig = cacheConfig.isValidationEnabled(); }', 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null""); }']",True,0,0,46,89,3,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"<START>public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { if (hiveHdfsConfiguration == null) { requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""CacheManager is null""); } if (cacheConfig == null) { requireNonNull(cacheConfig, ""cacheConfig is null""); } <END> this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }","nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled();","public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { if (hiveHdfsConfiguration == null) { requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""CacheManager is null""); } if (cacheConfig == null) { requireNonNull(cacheConfig, ""cacheConfig is null""); } }",,,,,,,"public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration cacheManager, CacheConfig cacheConfig, CacheManager hiveHdfsConfiguration) { this.cacheManager = requireNonNull(cacheManager, ""hiveHdfsConfiguration is null""); this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""CacheManager is null""); <START> cacheConfig = requireNonNull(cacheConfig, ""cacheConfig is null""); <END> this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }","nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled();","public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration cacheManager, CacheConfig cacheConfig, CacheManager hiveHdfsConfiguration) { this.cacheManager = requireNonNull(cacheManager, ""hiveHdfsConfiguration is null""); this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }","public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration dacjr, CacheConfig dsppg, CacheManager adxoz) { this.dacjr = requireNonNull(dacjr, ""hiveHdfsConfiguration is null""); this.adxoz = requireNonNull(adxoz, ""CacheManager is null""); <START> dsppg = requireNonNull(dsppg, ""cacheConfig is null""); <END> this.cacheValidationEnabled = dsppg.isValidationEnabled(); }","nit: this.cacheValidationEnabled = requireNonNull(dsppg, ""dsppg is null"").isValidationEnabled();","public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration dacjr, CacheConfig dsppg, CacheManager adxoz) { this.dacjr = requireNonNull(dacjr, ""hiveHdfsConfiguration is null""); this.adxoz = requireNonNull(adxoz, ""CacheManager is null""); this.cacheValidationEnabled = requireNonNull(dsppg, ""cacheConfig is null"").isValidationEnabled(); }",,,,,,,"1- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { if (hiveHdfsConfiguration == null) { requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""CacheManager is null""); } if (cacheConfig == null) { requireNonNull(cacheConfig, ""cacheConfig is null""); } this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"") != null; }
2- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { if (hiveHdfsConfiguration == null) { requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""CacheManager is null""); } if (cacheConfig == null) { requireNonNull(cacheConfig, ""cacheConfig is null""); } this.cacheValidationEnabled = requireNonNull(cacheConfig.isValidationEnabled(); }
3- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { Objects.requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); Objects.requireNonNull(cacheManager, ""CacheManager is null""); Objects.requireNonNull(cacheConfig, ""cacheConfig is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }
4- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { checkState(hiveHdfsConfiguration == null, ""hiveHdfsConfiguration is null""); checkState(cacheManager == null, ""CacheManager is null""); checkState(cacheConfig == null, ""cacheConfig is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }
5- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { Preconditions.checkNotNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); Preconditions.checkNotNull(cacheManager, ""CacheManager is null""); Preconditions.checkNotNull(cacheConfig, ""cacheConfig is null""); this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }
6- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); }
7- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"") .isValidationEnabled(); }
8- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.cacheValidationEnabled = requireNonNull(hiveHdfsConfiguration, ""hiveHdfsConfiguration is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }
9- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"").isValidationEnabled(); this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }
10- public RaptorCachingHdfsConfiguration(@ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.cacheValidationEnabled = requireNonNull(cacheConfig, ""cacheConfig is null"") .isValidationEnabled(); this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }",0
486,"public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START> "") is null.""); <END> return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","public class DummyClass {
    public Function<Solution_, Score<?>> createExtractor() {
        SolutionDescriptor<Solution_> solutionDescriptor =
                constraintConfigurationDescriptor.getSolutionDescriptor();
        MemberAccessor constraintConfigurationMemberAccessor =
                solutionDescriptor.getConstraintConfigurationMemberAccessor();
        return (Solution_ solution) -> {
            Object constraintConfiguration =
                    Objects.requireNonNull(
                            constraintConfigurationMemberAccessor.executeGetter(solution),
                            ""Constraint configuration provider (""
                                    + constraintConfigurationMemberAccessor
                                    + "") is null."");
            return (Score<?>) memberAccessor.executeGetter(constraintConfiguration);
        };
    }
}","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","public class DummyClass {
    public Function<Solution_, Score<?>> createExtractor() {
        SolutionDescriptor<Solution_> solutionDescriptor =
                constraintConfigurationDescriptor.getSolutionDescriptor();
        MemberAccessor constraintConfigurationMemberAccessor =
                solutionDescriptor.getConstraintConfigurationMemberAccessor();
        return (Solution_ solution) -> {
            Object constraintConfiguration =
                    Objects.requireNonNull(
                            constraintConfigurationMemberAccessor.executeGetter(solution),
                            ""Constraint configuration provider (""
                                    + constraintConfigurationMemberAccessor
                                    + "") returns null."");
            return (Score<?>) memberAccessor.executeGetter(constraintConfiguration);
        };
    }
}","['public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returned null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") is null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "")!= null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") return null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") cannot be null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "")"")!= null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "")"").""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") value is null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }', 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") are null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }']",True,0,0,26,32,2,1.0,0.999999995,False,False,False,,,,,,,"public Function<Solution_,Score<?>> createExtractor() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START>"") is null."");<END> return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","public Function<Solution_,Score<?>> createExtractor() { boolean var = false; if (var) var = true; SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START>"") is null."");<END> return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { boolean var = false; if (var) var = true; SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","public Function<Solution_,Score<?>> createExtractor() { try { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START>"") is null."");<END> return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; } catch (Exception e) { throw e; } }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { try { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; } catch (Exception e) { throw e; } }",,,,"public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START>"") is null."");<END> } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }",,,,,,,"public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor solution = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ constraintConfigurationMemberAccessor) -> { Object constraintConfiguration = Objects.requireNonNull(solution.executeGetter(constraintConfigurationMemberAccessor), ""Constraint configuration provider ("" + solution + <START> "") is <END> null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor solution = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ constraintConfigurationMemberAccessor) -> { Object constraintConfiguration = Objects.requireNonNull(solution.executeGetter(constraintConfigurationMemberAccessor), ""Constraint configuration provider ("" + solution + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> wfqzw = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor aonir = wfqzw.getConstraintConfigurationMemberAccessor(); return (Solution_ qhvtp) -> { Object cfqvj = Objects.requireNonNull(aonir.executeGetter(qhvtp), ""Constraint configuration provider ("" + aonir + <START> "") is <END> null.""); return (Score<?>) memberAccessor.executeGetter(cfqvj); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> wfqzw = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor aonir = wfqzw.getConstraintConfigurationMemberAccessor(); return (Solution_ qhvtp) -> { Object cfqvj = Objects.requireNonNull(aonir.executeGetter(qhvtp), ""Constraint configuration provider ("" + aonir + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(cfqvj); }; }",,,,"public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); SolutionDescriptor<Solution_> yapal = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = yapal.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + <START>"") is null."");<END> return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","suggestion "") returns null.""); memberAccessor null, returns null","public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); SolutionDescriptor<Solution_> yapal = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = yapal.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }","1- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
2- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor +"") returned null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
3- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor +"") returns null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
4- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returned null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
5- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") is null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
6- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor +"")"") returns null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
7- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") return null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
8- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + ""] is null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
9- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), ""Constraint configuration provider (({}) is null."", constraintConfigurationMemberAccessor)); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }
10- public Function<Solution_,Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { if (constraintConfigurationMemberAccessor.executeGetter(solution) == null) { Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution),""Constraint configuration provider ("" + constraintConfigurationMemberAccessor + "") returns null.""); } return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }",0
584,"<START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }","public class DummyClass {
    public void testSequenceFlowSupplier() throws Exception {
        final CaseManagementSetChildNodeGraphCommand command =
                new CaseManagementSetChildNodeGraphCommand(
                        parent, candidate, index, originalParent, originalIndex);
        final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();
        final ViewConnector<SequenceFlow> viewConnector = supplier.get();
        assertNotNull(viewConnector);
        assertNotNull(viewConnector.getSourceConnection());
        assertNotNull(viewConnector.getTargetConnection());
        assertNotNull(viewConnector.getBounds());
        assertNotNull(viewConnector.getDefinition());
    }
}",Exception is thrown,"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }","public class DummyClass {
    public void testSequenceFlowSupplier() {
        final CaseManagementSetChildNodeGraphCommand command =
                new CaseManagementSetChildNodeGraphCommand(
                        parent, candidate, index, originalParent, originalIndex);
        final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();
        final ViewConnector<SequenceFlow> viewConnector = supplier.get();
        assertNotNull(viewConnector);
        assertNotNull(viewConnector.getSourceConnection());
        assertNotNull(viewConnector.getTargetConnection());
        assertNotNull(viewConnector.getBounds());
        assertNotNull(viewConnector.getDefinition());
    }
}","['public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull (viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertEquals(viewConnector.getSourceConnection(), viewConnector.getTargetConnection()); assertEquals(viewConnector.getBounds(), viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNull(viewConnector.getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertEquals(viewConnector.getSourceConnection(), viewConnector.getTargetConnection()); assertEquals(viewConnector.getBounds(), viewConnector.getDefinition().getReference()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector. getDefinition()); }', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); {', 'public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); } {']",True,0,0,43,43,2,1.0,0.999999995,False,False,False,,,,,,,"<START>public void testSequenceFlowSupplier() throws Exception {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }",Exception is thrown,"public void testSequenceFlowSupplier() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }","<START>public void testSequenceFlowSupplier() throws Exception {<END> boolean var = false; if (var) var = true; final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }",Exception is thrown,"public void testSequenceFlowSupplier() { boolean var = false; if (var) var = true; final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }","<START>public void testSequenceFlowSupplier() throws Exception {<END> try { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); } catch (Exception e) { throw e; } }",Exception is thrown,"public void testSequenceFlowSupplier() { try { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); } catch (Exception e) { throw e; } }",,,,"<START>public void testSequenceFlowSupplier() throws Exception {<END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }",Exception is thrown,"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }",,,,,,,"<START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand viewConnector = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> command = viewConnector.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> supplier = command.get(); assertNotNull(supplier); assertNotNull(supplier.getSourceConnection()); assertNotNull(supplier.getTargetConnection()); assertNotNull(supplier.getBounds()); assertNotNull(supplier.getDefinition()); }",Exception is thrown,"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand viewConnector = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> command = viewConnector.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> supplier = command.get(); assertNotNull(supplier); assertNotNull(supplier.getSourceConnection()); assertNotNull(supplier.getTargetConnection()); assertNotNull(supplier.getBounds()); assertNotNull(supplier.getDefinition()); }","<START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand yhvin = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> gprvv = yhvin.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> hbzgk = gprvv.get(); assertNotNull(hbzgk); assertNotNull(hbzgk.getSourceConnection()); assertNotNull(hbzgk.getTargetConnection()); assertNotNull(hbzgk.getBounds()); assertNotNull(hbzgk.getDefinition()); }",Exception is thrown,"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand yhvin = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> gprvv = yhvin.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> hbzgk = gprvv.get(); assertNotNull(hbzgk); assertNotNull(hbzgk.getSourceConnection()); assertNotNull(hbzgk.getTargetConnection()); assertNotNull(hbzgk.getBounds()); assertNotNull(hbzgk.getDefinition()); }",,,,"<START>public void testSequenceFlowSupplier() throws Exception {<END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); CaseManagementSetChildNodeGraphCommand xluft = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = xluft.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }",Exception is thrown,"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); CaseManagementSetChildNodeGraphCommand xluft = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = xluft.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }","1- public void testSequenceFlowSupplier() throws Exception { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
2- public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
3- public void testSequenceFlowSupplier() throws InterruptedException { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
4- public void testSequenceFlowSupplier() throws Throwable { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
5- public void testSequenceFlowSupplier() throws IOException { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
6- public void testSequenceFlowSupplier() throws IllegalArgumentException { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
7- public void testSequenceFlowSupplier() throws TException { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
8- public void testSequenceFlowSupplier() throws RuntimeException { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
9- public void testSequenceFlowSupplier() throws (Exception { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }
10- public void testSequenceFlowSupplier() throws } { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,candidate,index,originalParent,originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); if (viewConnector == null) { assertNotNull(viewConnector); } if (viewConnector.getSourceConnection() == null) { assertNotNull(viewConnector.getSourceConnection()); } if (viewConnector.getTargetConnection() == null) { assertNotNull(viewConnector.getTargetConnection()); } if (viewConnector.getBounds() == null) { assertNotNull(viewConnector.getBounds()); } if (viewConnector.getDefinition() == null) { assertNotNull(viewConnector.getDefinition()); } }",0
634,"public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, ""client is null""); <END> this.client = client; }","public class DummyClass {
    public AlluxioHiveMetastore(TableMasterClient client) {
        requireNonNull(client, ""client is null"");
        this.client = client;
    }
}","java this.client = requireNonNull(client, ""client is null"");","public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client, ""client is null""); }","public class DummyClass {
    public AlluxioHiveMetastore(TableMasterClient client) {
        this.client = requireNonNull(client, ""client is null"");
    }
}","['public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client, ""client is null""); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this(requireNonNull(client, ""client is null"")); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this().client = requireNonNull(client, ""client is null""); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this.client =requireNonNull(client, ""client is null""); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client, ""client is null()); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client(), ""client is null""); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(""client is null""); }', 'public AlluxioHiveMetastore(TableMasterClient client) { this(""client is null"", client); }', 'public AlluxioHiveMetastore(TableMasterClient client) {}', 'public AlluxioHiveMetastore(TableMasterClient client)']",True,0,0,53,62,1,1.0,0.999999995,True,True,False,,,,,,,,,,,,,,,,,,,"public AlluxioHiveMetastore(TableMasterClient client) { if (client == null) { <START>requireNonNull(client,""client is null"");<END> } this.client = client; }","java this.client = requireNonNull(client, ""client is null"");","public AlluxioHiveMetastore(TableMasterClient client) { if (client == null) { requireNonNull(client, ""client is null""); } }",,,,,,,,,,"public AlluxioHiveMetastore(TableMasterClient kjnck) { <START> requireNonNull(kjnck, ""client is null""); <END> this.kjnck = kjnck; }","java this.kjnck = requireNonNull(kjnck, ""kjnck is null"");","public AlluxioHiveMetastore(TableMasterClient kjnck) { this.kjnck = requireNonNull(kjnck, ""client is null""); }",,,,,,,"1- public AlluxioHiveMetastore(TableMasterClient client) { requireNonNull(client, ""client is null""); this.client = client; }
2- public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client, ""client is null""); }
3- public AlluxioHiveMetastore(TableMasterClient client) { requireNonNull(client, ""client is null""); this.client = requireNonNull(client, ""client is null""); }
4- public AlluxioHiveMetastore(TableMasterClient client) { checkArgument(client == null, ""client is null""); this.client = client; }
5- public AlluxioHiveMetastore(TableMasterClient client) { checkArgument(client != null, ""client is null""); this.client = client; }
6- public AlluxioHiveMetastore(TableMasterClient client) { checkNotNull(client, ""client is null""); this.client = requireNonNull(client, ""client is null""); }
7- public AlluxioHiveMetastore(TableMasterClient client) { Preconditions.checkNotNull(client, ""client is null""); this.client = client; }
8- public AlluxioHiveMetastore(TableMasterClient client) { if (client == null) this.client = requireNonNull(client, ""client is null""); }
9- public AlluxioHiveMetastore(TableMasterClient client) { if (client == null) { this.client = requireNonNull(client, ""client is null""); } }
10- public AlluxioHiveMetastore(TableMasterClient client) { requireNonNull(client, ""client is null""); this.client = requireNonNull(client, ""client is null()); }",0
644,"<START> private void testUpdateInsertionFeature(String insertion) throws Exception { <END> String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","public class DummyClass {
    private void testUpdateInsertionFeature(String insertion) throws Exception {
        String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature"";
        JsonArray array =
                putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE));
        Assert.assertEquals(1, array.size());
        JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array);
        Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj);
    }
}","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","public class DummyClass {
    private void testUpdateInsertionFeature(String insertion) throws Exception {
        String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature"";
        JsonArray array =
                putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE));
        Assert.assertEquals(1, array.size());
        JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array);
        Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj);
    }
}","['private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert. assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not found value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert. assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(""Renamed Insertion Feature"", array); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array =putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertEquals(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800.feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() +/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }', 'private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getID() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }']",True,0,0,30,30,2,1.0,0.999999995,True,True,False,,,,,,,"<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> boolean var = false; if (var) var = true; String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { boolean var = false; if (var) var = true; String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> try { String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } catch (Exception e) { throw e; } }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { try { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); } catch (Exception e) { throw e; } }",,,,"<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); } }","<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); if (1 != array.size()) { Assert.assertEquals(1,array.size()); } JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); if (1 != array.size()) { Assert.assertEquals(1, array.size()); } JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }",,,,"<START> private void testUpdateInsertionFeature(String array) throws Exception { <END> String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/array/1234567800/feature""; JsonArray insertion = putAndCheck(url, Entity.entity(array, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, insertion.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", insertion); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String array) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/array/1234567800/feature""; JsonArray insertion = putAndCheck(url, Entity.entity(array, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, insertion.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", insertion); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","<START> private void testUpdateInsertionFeature(String uehez) throws Exception { <END> String mxgoq = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray ijblo = putAndCheck(mxgoq, Entity.entity(uehez, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, ijblo.size()); JsonObject fvfae = getObjectNamed(""Renamed Insertion Feature"", ijblo); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", fvfae); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String uehez) throws Exception { String mxgoq = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray ijblo = putAndCheck(mxgoq, Entity.entity(uehez, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, ijblo.size()); JsonObject fvfae = getObjectNamed(""Renamed Insertion Feature"", ijblo); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", fvfae); }",,,,"<START>private void testUpdateInsertionFeature(String insertion) throws Exception {<END> String url = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; String kyvup = ""/ats/program/"" + getSawProgram().getArtId() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(kyvup,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); }","getUuid instead of getArtId,","private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; String kyvup = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(kyvup, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"", array); Assert.assertNotNull(""Did not find value Renamed Insertion Feature"", obj); }","1- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
2- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url, Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
3- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert. assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
4- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if ((""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
5- private void testUpdateInsertionFeature(String insertion) throws EntityException { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
6- private void testUpdateInsertionFeature(String insertion) throws IllegalArgumentException { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
7- private void testUpdateInsertionFeature(String insertion) throws DeploymentException { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
8- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert. assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
9- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"". == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } }
10- private void testUpdateInsertionFeature(String insertion) throws Exception { String url = ""/ats/program/"" + getSawProgram().getUuid() + ""/insertion/1234567800/feature""; JsonArray array = putAndCheck(url,Entity.entity(insertion,MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1,array.size()); JsonObject obj = getObjectNamed(""Renamed Insertion Feature"",array); if (""Did not find value Renamed Insertion Feature"" == null) { Assert.assertNotNull(""Did not find value Renamed Insertion Feature"",obj); } } {",0
658,"<START> public final void setSendTimeoutExpression(Expression sendTimeoutExpression) { <END> Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }","public class DummyClass {
    public final void setSendTimeoutExpression(Expression sendTimeoutExpression) {
        Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null"");
        this.sendTimeoutExpression = sendTimeoutExpression;
    }
}",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }","public class DummyClass {
    public void setSendTimeoutExpression(Expression sendTimeoutExpression) {
        Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null"");
        this.sendTimeoutExpression = sendTimeoutExpression;
    }
}","['public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\' sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' cannot be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sentTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'SendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' should not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression postTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(SendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }', 'public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""\'sendTimeoutExpression\' must not be null""); this.sendTimeoutExpression= sendTimeoutExpression; }']",True,0,0,32,32,1,1.0,0.999999995,False,False,False,,,,,,,"<START>public final void setSendTimeoutExpression(Expression sendTimeoutExpression) {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.notNull(sendTimeoutExpression,""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }","<START>public final void setSendTimeoutExpression(Expression sendTimeoutExpression) {<END> boolean var = false; if (var) var = true; Assert.notNull(sendTimeoutExpression,""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { boolean var = false; if (var) var = true; Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; }","<START>public final void setSendTimeoutExpression(Expression sendTimeoutExpression) {<END> try { Assert.notNull(sendTimeoutExpression,""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; } catch (Exception e) { throw e; } }",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { try { Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); this.sendTimeoutExpression = sendTimeoutExpression; } catch (Exception e) { throw e; } }",,,,"<START>public final void setSendTimeoutExpression(Expression sendTimeoutExpression) {<END> if (sendTimeoutExpression == null) { Assert.notNull(sendTimeoutExpression,""'sendTimeoutExpression' must not be null""); } this.sendTimeoutExpression = sendTimeoutExpression; }",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { if (sendTimeoutExpression == null) { Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' must not be null""); } this.sendTimeoutExpression = sendTimeoutExpression; }",,,,,,,,,,"<START> public final void setSendTimeoutExpression(Expression kbslf) { <END> Assert.notNull(kbslf, ""'sendTimeoutExpression' must not be null""); this.kbslf = kbslf; }",changed mind decided this setter in ctor. I is a justification for a final..,"public void setSendTimeoutExpression(Expression kbslf) { Assert.notNull(kbslf, ""'sendTimeoutExpression' must not be null""); this.kbslf = kbslf; }",,,,,,,"1- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { this.sendTimeoutExpression = sendTimeoutExpression; }
2- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, ""'sendTimeoutExpression' cannot be null""); this.sendTimeoutExpression = sendTimeoutExpression; }
3- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Objects.requireNonNull(sendTimeoutExpression, ""'sendTimeoutExpression' cannot be null""); this.sendTimeoutExpression = sendTimeoutExpression; }
4- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { assert(sendTimeoutExpression == null); this.sendTimeoutExpression = sendTimeoutExpression; }
5- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { mSendTimeoutExpression = sendTimeoutExpression; }
6- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { that.sendTimeoutExpression = sendTimeoutExpression; }
7- public void setSendTimeoutExpression(Expression sendTimeoutExpression) {this.sendTimeoutExpression = sendTimeoutExpression; }
8- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { dosetSendTimeoutExpression(sendTimeoutExpression); }
9- public void setSendTimeoutExpression(Expression sendTimeoutExpression) { }
10- public void setSendTimeoutExpression(Expression sendTimeoutExpression)",0
666,"public void testContrib() throws Exception { <START> deployContrib(""org.nuxeo.ecm.core.api.tests"", ""OSGI-INF/test-pathsegment-contrib.xml""); <END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }","public class DummyClass {
    public void testContrib() throws Exception {
        deployContrib(""org.nuxeo.ecm.core.api.tests"", ""OSGI-INF/test-pathsegment-contrib.xml"");
        applyInlineDeployments();
        PathSegmentService service = Framework.getService(PathSegmentService.class);
        assertNotNull(service);
        DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document"");
        assertEquals(""my-document"", service.generatePathSegment(doc));
    }
}",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }","public class DummyClass {
    public void testContrib() throws Exception {
        pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml"");
        PathSegmentService service = Framework.getService(PathSegmentService.class);
        assertNotNull(service);
        DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document"");
        assertEquals(""my-document"", service.generatePathSegment(doc));
    }
}","['public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My doc""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy. newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""; PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my_document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:osGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests: OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }', 'public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); }']",True,0,0,71,72,4,1.0,0.999999995,False,False,False,,,,,,,"public void testContrib() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }",pushInlineDeployments,"public void testContrib() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }","public void testContrib() throws Exception { boolean var = false; if (var) var = true; <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }",pushInlineDeployments,"public void testContrib() throws Exception { boolean var = false; if (var) var = true; pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }","public void testContrib() throws Exception { try { <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); } catch (Exception e) { throw e; } }",pushInlineDeployments,"public void testContrib() throws Exception { try { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); } catch (Exception e) { throw e; } }",,,,"public void testContrib() throws Exception { <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }","public void testContrib() throws Exception { <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); if (""my-document"" != service.generatePathSegment(doc)) { assertEquals(""my-document"",service.generatePathSegment(doc)); } }",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); if (""my-document"" != service.generatePathSegment(doc)) { assertEquals(""my-document"", service.generatePathSegment(doc)); } }",,,,"public void testContrib() throws Exception { <START> deployContrib(""org.nuxeo.ecm.core.api.tests"", ""OSGI-INF/test-pathsegment-contrib.xml""); <END> applyInlineDeployments(); PathSegmentService doc = Framework.getService(PathSegmentService.class); assertNotNull(doc); DocumentModel service = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", doc.generatePathSegment(service)); }",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService doc = Framework.getService(PathSegmentService.class); assertNotNull(doc); DocumentModel service = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", doc.generatePathSegment(service)); }","public void testContrib() throws Exception { <START> deployContrib(""org.nuxeo.ecm.core.api.tests"", ""OSGI-INF/test-pathsegment-contrib.xml""); <END> applyInlineDeployments(); PathSegmentService yahdf = Framework.getService(PathSegmentService.class); assertNotNull(yahdf); DocumentModel iotis = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", yahdf.generatePathSegment(iotis)); }",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService yahdf = Framework.getService(PathSegmentService.class); assertNotNull(yahdf); DocumentModel iotis = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", yahdf.generatePathSegment(iotis)); }",,,,"public void testContrib() throws Exception { <START>deployContrib(""org.nuxeo.ecm.core.api.tests"",""OSGI-INF/test-pathsegment-contrib.xml"");<END> applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); PathSegmentService yqzsi = Framework.getService(PathSegmentService.class); assertNotNull(yqzsi); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",yqzsi.generatePathSegment(doc)); }",pushInlineDeployments,"public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); PathSegmentService yqzsi = Framework.getService(PathSegmentService.class); assertNotNull(yqzsi); DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", yqzsi.generatePathSegment(doc)); }","1- public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
2- public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My doc""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
3- public void testContrib() throws Exception { pushInlineDeployments( ""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
4- public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"", service.generatePathSegment(doc)); }
5- public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my_document"",service.generatePathSegment(doc)); }
6- public void testContrib() throws Exception { pushInlineDeployments(""org/nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
7- public void testContrib() throws Exception { pushInlineDeployments(true); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
8- public void testContrib() throws Exception { pushInlineDeployments(testInlineDeployments); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
9- public void testContrib() throws Exception { pushInlineDeployments(testInlineDeployments()); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); }
10- public void testContrib() throws Exception { pushInlineDeployments(""org.nuxeo.ecm.core.api.tests:OSGI-INF/test-pathsegment-contrib.xml""); PathSegmentService service = Framework.getService(PathSegmentService.class); if (service == null) { assertNotNull(service); } DocumentModel doc = DocumentModelProxy.newDocumentModel(""My Document""); assertEquals(""my-document"",service.generatePathSegment(doc)); } {",1
700,"public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { <START> Assert.checkNotNullParam(""roleMapper"", roleMapper); <END> assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","public class DummyClass {
    public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) {
        Assert.checkNotNullParam(""roleMapper"", roleMapper);
        assertNotBuilt();
        this.principalDecoder = principalDecoder;
        return this;
    }
}","This ""principalDecoder"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""principalDecoder"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","public class DummyClass {
    public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) {
        Assert.checkNotNullParam(""principalDecoder"", principalDecoder);
        assertNotBuilt();
        this.principalDecoder = principalDecoder;
        return this;
    }
}","['public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""principalDecoder"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert. checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Objects.requireNonNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { assertNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Preconditions.checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.isNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this(); }', 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""principalDecoder"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this;']",True,1,0,38,50,4,1.0,0.999999995,False,False,False,,,,,,,"public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>Assert.checkNotNullParam(""roleMapper"",roleMapper);<END> assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","This ""principalDecoder"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.checkNotNullParam(""principalDecoder"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { boolean var = false; if (var) var = true; <START>Assert.checkNotNullParam(""roleMapper"",roleMapper);<END> assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","This ""principalDecoder"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { boolean var = false; if (var) var = true; Assert.checkNotNullParam(""principalDecoder"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { try { <START>Assert.checkNotNullParam(""roleMapper"",roleMapper);<END> assertNotBuilt(); this.principalDecoder = principalDecoder; return this; } catch (Exception e) { throw e; } }","This ""principalDecoder"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { try { Assert.checkNotNullParam(""principalDecoder"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; } catch (Exception e) { throw e; } }",,,,"public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { if (roleMapper == null) { <START>Assert.checkNotNullParam(""roleMapper"",roleMapper);<END> } assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }","This ""principalDecoder"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { if (principalDecoder == null) { Assert.checkNotNullParam(""principalDecoder"", principalDecoder); } assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }",,,,,,,,,,"public Builder setPrincipalDecoder(PrincipalDecoder ofwxa) { <START> Assert.checkNotNullParam(""roleMapper"", roleMapper); <END> assertNotBuilt(); this.ofwxa = ofwxa; return this; }","This ""ofwxa"", I guess","public Builder setPrincipalDecoder(PrincipalDecoder ofwxa) { Assert.checkNotNullParam(""principalDecoder"", ofwxa); assertNotBuilt(); this.ofwxa = ofwxa; return this; }",,,,,,,"1- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""roleMapper"",roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
2- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""roleMapper"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
3- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""roleMapper"", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
4- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Objects.requireNonNullParam(""roleMapper"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
5- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { assertNotNullParam(""roleMapper"",roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
6- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { assertNotNullParam(""roleMapper"", roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
7- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""roleMapper"", columnMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
8- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Objects.requireNonNullParam(""roleMapper"",roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }
9- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { this.principalDecoder = principalDecoder; return this; }
10- public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(""roleMapper"",roleMapper); assertNotBuilt(); this.principalDecoder = principalDecoder; return this(); }",0
752,public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { <START> this.parentMemoryContext = requireNonNull(parentMemoryContext); <END> },"public class DummyClass {
    public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) {
        this.parentMemoryContext = requireNonNull(parentMemoryContext);
    }
}","requireNonNull(parentMemoryContext, ""parentMemoryContext is null"")","public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }","public class DummyClass {
    public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) {
        this.parentMemoryContext =
                requireNonNull(parentMemoryContext, ""parentMemoryContext is null"");
    }
}","['public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = Objects.requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, "" parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, ""parentMemoryContext is NULL""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = super.requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, ""parentMemorycontext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, ""parentMemory context is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = checkNotNull(parentMemoryContext, ""parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }', 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this(parentMemoryContext, ""parentMemoryContext is null""); }']",True,0,0,53,57,5,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,<START>public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { <END> if (parentMemoryContext == null) { requireNonNull(parentMemoryContext); } },"requireNonNull(parentMemoryContext, ""parentMemoryContext is null"")","public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { if (parentMemoryContext == null) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); } }",,,,,,,,,,public SimpleLocalMemoryContext(AggregatedMemoryContext gwvbg) { <START> this.gwvbg = requireNonNull(gwvbg); <END> },"requireNonNull(gwvbg, ""gwvbg is null"")","public SimpleLocalMemoryContext(AggregatedMemoryContext gwvbg) { this.gwvbg = requireNonNull(gwvbg, ""parentMemoryContext is null""); }",,,,,,,"1- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); }
2- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); this.parentMemoryContext = parentMemoryContext; }
3- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { if (parentMemoryContext == null) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); } }
4- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); super.visitMemoryContext(parentMemoryContext); }
5- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); this.fullMemoryContext = true; }
6- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); super(parentMemoryContext); }
7- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null""); return this; }
8- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { requireNonNull(parentMemoryContext, ""parentMemoryContext is null"");""); }
9- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { checkParentMemoryContext(parentMemoryContext); }
10- public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { super(parentMemoryContext); }",1
824,"public void addVesselCrew(Person p) { <START> addVesselCrew(Objects.requireNonNull(p), false); <END> }","public class DummyClass {
    public void addVesselCrew(Person p) {
        addVesselCrew(Objects.requireNonNull(p), false);
    }
}",this duplicate nonNull check,"public void addVesselCrew(Person p) { addVesselCrew(p, false); }","public class DummyClass {
    public void addVesselCrew(Person p) {
        addVesselCrew(p, false);
    }
}","['public void addVesselCrew(Person p) { addVesselCrew(p, false); }', 'public void addVesselCrew(Person p) { addVesselCrew(p,false); }', 'public void addVesselCrew(Person p) { addVESselCrew(p, false); }', 'public void addVesselCrew(Person p) { add VesselCrew(p, false); }', 'public void addVesselCrew(Person p) {  addVesselCrew(p, false); }', 'public void addVesselCrew(Person p) { addVesselCrew(p); }', 'public void addVesselCrew<Person> p) { addVesselCrew(p, false); }', 'public void addVesselCrew(Person p) { addVesselCrew(p(), false); }', 'public void addVesselCrew(Person p) { addVesselCrew(p, false()); }', 'public void addVesselCrew(Person p) { addVesselCrew(p, false);']",True,0,0,49,50,2,1.0,0.999999995,False,False,False,,,,,,,"public void addVesselCrew(Person p) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>addVesselCrew(Objects.requireNonNull(p),false);<END> }",this duplicate nonNull check,"public void addVesselCrew(Person p) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); addVesselCrew(p, false); }","public void addVesselCrew(Person p) { boolean var = false; if (var) var = true; <START>addVesselCrew(Objects.requireNonNull(p),false);<END> }",this duplicate nonNull check,"public void addVesselCrew(Person p) { boolean var = false; if (var) var = true; addVesselCrew(p, false); }","public void addVesselCrew(Person p) { try { <START>addVesselCrew(Objects.requireNonNull(p),false);<END> } catch (Exception e) { throw e; } }",this duplicate nonNull check,"public void addVesselCrew(Person p) { try { addVesselCrew(p, false); } catch (Exception e) { throw e; } }",,,,<START>public void addVesselCrew(Person p) { <END> if (p == null) { Objects.requireNonNull(p); } },this duplicate nonNull check,"public void addVesselCrew(Person p) { addVesselCrew(p, false); }",,,,,,,,,,"public void addVesselCrew(Person myvdj) { <START> addVesselCrew(Objects.requireNonNull(myvdj), false); <END> }",this duplicate nonNull check,"public void addVesselCrew(Person myvdj) { addVesselCrew(myvdj, false); }",,,,,,,"1- public void addVesselCrew(Person p) { if (p == null) { return; } }
2- public void addVesselCrew(Person p) { if (p == null) { Objects.requireNonNull(p); } }
3- public void addVesselCrew(Person p) { if (p == null) { rrew(p); } }
4- public void addVesselCrew(Person p) { if (p == null) { rrew = p; } }
5- public void addVesselCrew(Person p) { if (p == null) { p = null; } }
6- public void addVesselCrew(Person p) { if (p == null) { } }
7- public void addVesselCrew(Person p) { assert p == null; }
8- public void addVesselCrew(Person p) { assert p != null; }
9- public void addVesselCrew(Person p) { }
10- public",0
838,<START> public void testListAccessCredentials() throws InterruptedException { <END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },"public class DummyClass {
    public void testListAccessCredentials() throws InterruptedException {
        List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials();
        assertNotNull(access);
        assertTrue(access.size() > 0);
    }
}",Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },"public class DummyClass {
    public void testListAccessCredentials() {
        List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials();
        assertNotNull(access);
        assertTrue(access.size() > 0);
    }
}","['public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> accessibleStorage = sharedStorageApi().getAccessCredentials(); assertNotNull(accessibleStorage); assertTrue(accessibleStorage.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(""Access should be empty"", access.size() > 0); }', 'public void testListAccessRequirements() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessUsername() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi.getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size()  > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(Access); assertTrue(access.size() > 0); }', 'public void testListAccessCredential() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }', 'public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } {']",True,0,0,54,54,2,1.0,0.999999995,False,False,False,,,,,,,"<START>public void testListAccessCredentials() throws InterruptedException {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }",Remove InterruptedException signature,"public void testListAccessCredentials() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }",<START>public void testListAccessCredentials() throws InterruptedException {<END> boolean var = false; if (var) var = true; List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { boolean var = false; if (var) var = true; List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); },<START>public void testListAccessCredentials() throws InterruptedException {<END> try { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } catch (Exception e) { throw e; } },Remove InterruptedException signature,public void testListAccessCredentials() { try { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); } catch (Exception e) { throw e; } },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(access.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(access.size() > 0); },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); if (access.size() <= 0) { assertTrue(access.size() > 0); } },,,,<START> public void testListAccessCredentials() throws InterruptedException { <END> List<SharedStorageAccess> jmzfn = sharedStorageApi().getAccessCredentials(); assertNotNull(jmzfn); assertTrue(jmzfn.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> jmzfn = sharedStorageApi().getAccessCredentials(); assertNotNull(jmzfn); assertTrue(jmzfn.size() > 0); },,,,<START>public void testListAccessCredentials() throws InterruptedException {<END> List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); List<SharedStorageAccess> twnfh = sharedStorageApi().getAccessCredentials(); assertNotNull(twnfh); assertTrue(twnfh.size() > 0); },Remove InterruptedException signature,public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); List<SharedStorageAccess> twnfh = sharedStorageApi().getAccessCredentials(); assertNotNull(twnfh); assertTrue(twnfh.size() > 0); },"1- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }
2- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertTrue(access == null); assertNotNull(access); assertTrue(access.size() > 0); }
3- public void testListAccessCredentials() throws InterruptedException { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }
4- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertTrue(access == null); }
5- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertTrue(access != null); assertTrue(access.size() > 0); }
6- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertTrue(access.size() > 0); }
7- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(!access.isEmpty()); }
8- public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); if (access == null) { assertNotNull(access); } assertTrue(access.size() > 0);
9- public void testListAccessCredentials() throws InterruptedException { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertTrue(access == null); }
10- public void testListAccessCredentials() }",0
844,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { <START> requireNonNull(lifespan, ""lifespan is null""); <END> checkState(partitionNumber == 0, ""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null, ""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(lifespan, pages); }","public class DummyClass {
    public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) {
        requireNonNull(lifespan, ""lifespan is null"");
        checkState(partitionNumber == 0, ""Expected partition number to be zero"");
        checkState(
                lifespanCompletionCallback != null,
                ""lifespanCompletionCallback has to be set before starting enqueue data"");
        enqueue(lifespan, pages);
    }
}",Ditto checks. I need duplicate them,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }","public class DummyClass {
    public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) {
        checkState(partitionNumber == 0, ""Expected partition number to be zero"");
        enqueue(lifespan, pages);
    }
}","['public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { enqueue(lifespan, pages); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { verify(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkArgument(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { throw new UnsupportedOperationException(""lifespan is null""); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { throw new UnsupportedOperationException(""lifespanCompletionCallback is not supported""); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { throw new UnsupportedOperationException(""lifespanCompletionCallback is not a set before starting enqueue data""); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { throw new IllegalStateException(""lifespan is null""); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { throw new UnsupportedOperationException(""lifespanCompletionCallback is not null""); }', 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkState(partitionNumber == 0, ""Expected partition number to be zero""); return; }']",True,0,0,193,193,14,1.0,0.999999995,False,False,False,,,,,,,"public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>requireNonNull(lifespan,""lifespan is null"");<END> checkState(partitionNumber == 0,""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null,""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(lifespan,pages); }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }","public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { boolean var = false; if (var) var = true; <START>requireNonNull(lifespan,""lifespan is null"");<END> checkState(partitionNumber == 0,""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null,""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(lifespan,pages); }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { boolean var = false; if (var) var = true; checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }","public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { try { <START>requireNonNull(lifespan,""lifespan is null"");<END> checkState(partitionNumber == 0,""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null,""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(lifespan,pages); } catch (Exception e) { throw e; } }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { try { checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); } catch (Exception e) { throw e; } }",,,,"public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { if (lifespan == null) { <START>requireNonNull(lifespan,""lifespan is null"");<END> } checkState(partitionNumber == 0,""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null,""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(lifespan,pages); }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan, pages); }",,,,,,,"public void enqueue(Lifespan partitionNumber, int pages, List<SerializedPage> lifespan) { <START> requireNonNull(partitionNumber, ""partitionNumber is null""); <END> checkState(pages == 0, ""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null, ""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(partitionNumber, lifespan); }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan partitionNumber, int pages, List<SerializedPage> lifespan) { checkState(pages == 0, ""Expected partition number to be zero""); enqueue(partitionNumber, lifespan); }","public void enqueue(Lifespan zbrfp, int zduxi, List<SerializedPage> okkbb) { <START> requireNonNull(zbrfp, ""lifespan is null""); <END> checkState(zduxi == 0, ""Expected partition number to be zero""); checkState(lifespanCompletionCallback != null, ""lifespanCompletionCallback has to be set before starting enqueue data""); enqueue(zbrfp, okkbb); }",Ditto checks. I need duplicate them,"public void enqueue(Lifespan zbrfp, int zduxi, List<SerializedPage> okkbb) { checkState(zduxi == 0, ""Expected partition number to be zero""); enqueue(zbrfp, okkbb); }",,,,,,,"1- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { requireNonNull(lifespan, ""lifespan is null""); checkState(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
2- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { requireNonNull(lifespan,""lifespan is null""); checkState(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
3- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { if (lifespan == null) { requireNonNull(lifespan, ""lifespan is null""); } checkState(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
4- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { if (lifespan == null) { requireNonNull(lifespan,""lifespan is null""); } checkState(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
5- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { requireNonNull(lifespan, ""lifespan is null""); checkState(partitionNumber == 0, ""Expected partition number to be zero""); enqueue(lifespan,pages); }
6- public void enqueue(Lifespan lifespan,int partitionNumber, List<SerializedPage> pages) { requireNonNull(lifespan, ""lifespan is null""); checkState(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
7- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { requireNonNull(lifespan, ""lifespan is null""); requireNonNull(partitionNumber, ""Expected partition number to be zero""); enqueue(lifespan,pages); }
8- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { requireNonNull(lifespan, ""lifespan is null""); requireNonNull(partitionNumber == 0,""Expected partition number to be zero""); enqueue(lifespan,pages); }
9- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { if (lifespan == null) { requireNonNull(lifespan, ""lifespan is null""); } checkState(partitionNumber == 0,""Expected partition number to be zero""); }
10- public void enqueue(Lifespan lifespan,int partitionNumber,List<SerializedPage> pages) { enqueue(lifespan,pages); }",0
888,"FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = <START> Objects.requireNonNull(wantIds); <END> this.depth = depth; this.clientShallowCommits = Objects .requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = Objects.requireNonNull(clientCapabilities); }","public class DummyClass {
    FetchRequest(
            @NonNull Set<ObjectId> wantIds,
            int depth,
            @NonNull Set<ObjectId> clientShallowCommits,
            long filterBlobLimit,
            @NonNull Set<String> clientCapabilities) {
        this.wantIds = Objects.requireNonNull(wantIds);
        this.depth = depth;
        this.clientShallowCommits = Objects.requireNonNull(clientShallowCommits);
        this.filterBlobLimit = filterBlobLimit;
        this.clientCapabilities = Objects.requireNonNull(clientCapabilities);
    }
}","optional: this more readable ""import static""","FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }","public class DummyClass {
    FetchRequest(
            @NonNull Set<ObjectId> wantIds,
            int depth,
            @NonNull Set<ObjectId> clientShallowCommits,
            long filterBlobLimit,
            @NonNull Set<String> clientCapabilities) {
        this.wantIds = requireNonNull(wantIds);
        this.depth = depth;
        this.clientShallowCommits = requireNonNull(clientShallowCommits);
        this.filterBlobLimit = filterBlobLimit;
        this.clientCapabilities = requireNonNull(clientCapabilities);
    }
}","['FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = Objects.requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = checkNotNull(wantIds); this.depth = depth; this.clientShallowCommits = checkNotNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = checkNotNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds =  requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits =  requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities =  requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = checkNotNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds =  requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits =  requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds =  requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }', 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities);']",True,0,0,43,51,7,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { <START>Objects.requireNonNull(wantIds);<END> } this.depth = depth; if (clientShallowCommits == null) { Objects.requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { Objects.requireNonNull(clientCapabilities); } }","optional: this more readable ""import static""","FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { if (wantIds == null) { requireNonNull(wantIds); } this.depth = depth; if (clientShallowCommits == null) { requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { requireNonNull(clientCapabilities); } }",,,,,,,"FetchRequest(@NonNull Set<ObjectId> depth, int clientShallowCommits, @NonNull Set<ObjectId> filterBlobLimit, long wantIds, @NonNull Set<String> clientCapabilities) { this.depth = <START> <END> Objects.requireNonNull(depth); this.clientShallowCommits = clientShallowCommits; this.filterBlobLimit = Objects.requireNonNull(filterBlobLimit); this.wantIds = wantIds; this.clientCapabilities = Objects.requireNonNull(clientCapabilities); }","optional: this more readable ""import static""","FetchRequest(@NonNull Set<ObjectId> depth, int clientShallowCommits, @NonNull Set<ObjectId> filterBlobLimit, long wantIds, @NonNull Set<String> clientCapabilities) { this.depth = requireNonNull(depth); this.clientShallowCommits = clientShallowCommits; this.filterBlobLimit = requireNonNull(filterBlobLimit); this.wantIds = wantIds; this.clientCapabilities = requireNonNull(clientCapabilities); }","FetchRequest(@NonNull Set<ObjectId> eaplw, int geucm, @NonNull Set<ObjectId> mjiss, long dbsbf, @NonNull Set<String> ubuin) { this.eaplw = <START> <END> Objects.requireNonNull(eaplw); this.geucm = geucm; this.mjiss = Objects.requireNonNull(mjiss); this.dbsbf = dbsbf; this.ubuin = Objects.requireNonNull(ubuin); }","optional: this more readable ""import static""","FetchRequest(@NonNull Set<ObjectId> eaplw, int geucm, @NonNull Set<ObjectId> mjiss, long dbsbf, @NonNull Set<String> ubuin) { this.eaplw = requireNonNull(eaplw); this.geucm = geucm; this.mjiss = requireNonNull(mjiss); this.dbsbf = dbsbf; this.ubuin = requireNonNull(ubuin); }",,,,,,,"1- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { Objects.requireNonNull(wantIds); } this.depth = depth; if (clientShallowCommits == null) { Objects.requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { Objects.requireNonNull(clientCapabilities); } }
2- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { requireNonNull(wantIds); } this.depth = depth; if (clientShallowCommits == null) { requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { Objects.requireNonNull(clientCapabilities); } }
3- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { requireNonNull(wantIds); } this.depth = depth; if (clientShallowCommits == null) { requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { requireNonNull(clientCapabilities); } }
4- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { requireNonNull(wantIds); } this.depth = depth; if (clientShallowCommits == null) { Objects.requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { Objects.requireNonNull(clientCapabilities); } }
5- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { verify(wantIds); } this.depth = depth; if (clientShallowCommits == null) { verify(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { verify(clientCapabilities); } }
6- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { return; } this.depth = depth; if (clientShallowCommits == null) { Objects.requireNonNull(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { Objects.requireNonNull(clientCapabilities); } }
7- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { return; } this.depth = depth; if (clientShallowCommits == null) { return clientShallowCommits; } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { return clientCapabilities; } }
8- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { throw new NullPointerException(); } this.depth = depth; if (clientShallowCommits == null) { throw new NullPointerException(); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { throw new NullPointerException(); } }
9- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { throw new NullPointerException(wantIds); } this.depth = depth; if (clientShallowCommits == null) { throw new NullPointerException(clientShallowCommits); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { checkNotNull(clientCapabilities); } }
10- FetchRequest(@NonNull Set<ObjectId> wantIds,int depth,@NonNull Set<ObjectId> clientShallowCommits,long filterBlobLimit,@NonNull Set<String> clientCapabilities) { if (wantIds == null) { throw new NullPointerException(); } this.depth = depth; if (clientShallowCommits == null) { throw new NullPointerException(); } this.filterBlobLimit = filterBlobLimit; if (clientCapabilities == null) { throw new NullPointerException(clientCapabilities); } }",0
891,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); <START> return normalized.getNameCount() == 1 && normalized.toString().equals(""""); <END> }","public class DummyClass {
    public static boolean isEmpty(Path path) {
        Objects.requireNonNull(path, ""The given path must not be null"");
        Path normalized = path.normalize();
        return normalized.getNameCount() == 1 && normalized.toString().equals("""");
    }
}",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }","public class DummyClass {
    public static boolean isEmpty(Path path) {
        Objects.requireNonNull(path, ""The given path must not be null"");
        Path normalized = path.normalize();
        return normalized.getNameCount() == 1 && normalized.toString().isEmpty();
    }
}","['public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 &&!normalized.toString().isEmpty(); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && FilenameUtils.isNullOrEmpty(normalized.toString()); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && FilenameUtils.isEmpty(normalized.toString()); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && Objects.equals(normalized.toString(), """"); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && FilenameUtils.getBase(normalized.toString()); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 &&!(normalized.toString().isEmpty()); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && FilenameUtils.removeExtension(normalized); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }', 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && FilenameUtils.getBase(normalized); }']",True,0,0,35,35,2,1.0,0.999999995,False,False,False,,,,,,,"public static boolean isEmpty(Path path) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(path,""The given path must not be null""); Path normalized = path.normalize(); <START>return normalized.getNameCount() == 1 && normalized.toString().equals("""");<END> }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }","public static boolean isEmpty(Path path) { boolean var = false; if (var) var = true; Objects.requireNonNull(path,""The given path must not be null""); Path normalized = path.normalize(); <START>return normalized.getNameCount() == 1 && normalized.toString().equals("""");<END> }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { boolean var = false; if (var) var = true; Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }","public static boolean isEmpty(Path path) { try { Objects.requireNonNull(path,""The given path must not be null""); Path normalized = path.normalize(); <START>return normalized.getNameCount() == 1 && normalized.toString().equals("""");<END> } catch (Exception e) { throw e; } }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { try { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); } catch (Exception e) { throw e; } }",,,,"public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); <START>return normalized.getNameCount() == 1 && normalized.toString().equals("""");<END> }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path, ""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }",,,,,,,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); <START> return normalized.getNameCount() == 1 && normalized.toString().equals(""""); <END> }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }","public static boolean isEmpty(Path wuuzc) { Objects.requireNonNull(wuuzc, ""The given path must not be null""); Path mbtqv = wuuzc.normalize(); <START> return mbtqv.getNameCount() == 1 && mbtqv.toString().equals(""""); <END> }",mbtqv.toString().isEmpty() working,"public static boolean isEmpty(Path wuuzc) { Objects.requireNonNull(wuuzc, ""The given path must not be null""); Path mbtqv = wuuzc.normalize(); return mbtqv.getNameCount() == 1 && mbtqv.toString().isEmpty(); }",,,,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path,""The given path must not be null""); Path normalized = path.normalize(); Path wnhmt = path.normalize(); <START>return wnhmt.getNameCount() == 1 && wnhmt.toString().equals("""");<END> }",normalized.toString().isEmpty() working,"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, ""The given path must not be null""); Path normalized = path.normalize(); Path wnhmt = path.normalize(); return wnhmt.getNameCount() == 1 && wnhmt.toString().isEmpty(); }","1- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equals(""""); }
2- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path, ""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equals(""""); }
3- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }
4- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); return normalized.toStringCount() == 1 && normalized.toString().equals(""""); }
5- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equals """"; }
6- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,'The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equals(""""); }
7- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equalsIgnoreCase(""""); }
8- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path,(""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().equals(""""); }
9- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path, ""The given path must not be null""); } Path normalized = path.normalize(); return normalized.toStringCount() == 1 && normalized.toString().equals(""""); }
10- public static boolean isEmpty(Path path) { if (path == null) { Objects.requireNonNull(path, ""The given path must not be null""); } Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }",1
921,"public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); <START> this.cacheManager = requireNonNull(cacheManager, ""cachingFileSystem is null""); <END> this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }","public class DummyClass {
    public CachingInputStream(
            FSDataInputStream inputStream,
            CacheManager cacheManager,
            Path path,
            boolean cacheValidationEnabled) {
        super(inputStream);
        this.inputStream = requireNonNull(inputStream, ""inputStream is null"");
        this.cacheManager = requireNonNull(cacheManager, ""cachingFileSystem is null"");
        this.path = requireNonNull(path, ""path is null"");
        this.cacheValidationEnabled = cacheValidationEnabled;
    }
}",nit: cacheManager is null,"public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""cacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }","public class DummyClass {
    public CachingInputStream(
            FSDataInputStream inputStream,
            CacheManager cacheManager,
            Path path,
            boolean cacheValidationEnabled) {
        super(inputStream);
        this.inputStream = requireNonNull(inputStream, ""inputStream is null"");
        this.cacheManager = requireNonNull(cacheManager, ""cacheManager is null"");
        this.path = requireNonNull(path, ""path is null"");
        this.cacheValidationEnabled = cacheValidationEnabled;
    }
}","['public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""cacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""cachingFileSystem is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, "" cacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""CacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""context is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""either cacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""getCacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""quota is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""keyStore is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }', 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, ""inputStream is null""); this.cacheManager = requireNonNull(cacheManager, ""cacheManager is null""); this.path = requireNonNull(path, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; {']",True,0,0,26,38,2,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"<START>public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }<END>",nit: cacheManager is null,"public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cacheManager is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }",,,,,,,"public CachingInputStream(FSDataInputStream path, CacheManager cacheManager, Path inputStream, boolean cacheValidationEnabled) { super(path); this.path = requireNonNull(path, ""path is null""); <START> this.cacheManager = requireNonNull(cacheManager, ""cachingFileSystem is null""); <END> this.inputStream = requireNonNull(inputStream, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }",nit: cacheManager is null,"public CachingInputStream(FSDataInputStream path, CacheManager cacheManager, Path inputStream, boolean cacheValidationEnabled) { super(path); this.path = requireNonNull(path, ""path is null""); this.cacheManager = requireNonNull(cacheManager, ""cacheManager is null""); this.inputStream = requireNonNull(inputStream, ""path is null""); this.cacheValidationEnabled = cacheValidationEnabled; }","public CachingInputStream(FSDataInputStream uiqzs, CacheManager eaugs, Path fbagf, boolean uaqkh) { super(uiqzs); this.uiqzs = requireNonNull(uiqzs, ""inputStream is null""); <START> this.eaugs = requireNonNull(eaugs, ""cachingFileSystem is null""); <END> this.fbagf = requireNonNull(fbagf, ""path is null""); this.uaqkh = uaqkh; }",nit: eaugs is null,"public CachingInputStream(FSDataInputStream uiqzs, CacheManager eaugs, Path fbagf, boolean uaqkh) { super(uiqzs); this.uiqzs = requireNonNull(uiqzs, ""inputStream is null""); this.eaugs = requireNonNull(eaugs, ""cacheManager is null""); this.fbagf = requireNonNull(fbagf, ""path is null""); this.uaqkh = uaqkh; }",,,,,,,"1- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }
2- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } requireNonNull(cacheValidationEnabled = cacheValidationEnabled; }
3- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""resource is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }
4- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } requireNonNull(cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }
5- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); requireNonNull(inputStream, ""inputStream is null""); if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = cacheValidationEnabled; }
6- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } cacheValidationEnabled = cacheValidationEnabled; }
7- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); if (inputStream == null) { requireNonNull(inputStream, ""inputStream is null""); } if (cacheManager == null) { requireNonNull(cacheManager, ""cachingFileSystem is null""); } if (path == null) { requireNonNull(path, ""path is null""); } this.cacheValidationEnabled = requireNonNull(cacheValidationEnabled); }
8- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.cacheValidationEnabled = requireNonNull(cacheManager, ""cachingFileSystem is null""); }
9- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.cacheValidationEnabled = cacheValidationEnabled; }
10- public CachingInputStream(FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { this(inputStream, cacheManager, path, cacheValidationEnabled); }",0
954,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> }","public class DummyClass {
    public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() {
        List<VdsNetworkInterface> result =
                dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.size() == 0);
    }
}",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public class DummyClass {
    public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() {
        List<VdsNetworkInterface> result =
                dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
}","['public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertFalse(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(!result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertNotNull(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertEquals(0, result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGed_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID(), true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID); assertNotNull(result); assertTrue(result.isEmpty()); }', 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty(), """"); }']",True,0,0,36,36,4,1.0,0.999999995,False,False,False,,,,,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) var = true; List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { boolean var = false; if (var) var = true; List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }","public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { try { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); <START>assertTrue(result.size() == 0);<END> } catch (Exception e) { throw e; } }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { try { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); } catch (Exception e) { throw e; } }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); if (result == null) { assertNotNull(result); } <START>assertTrue(result.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); if (result == null) { assertNotNull(result); } assertTrue(result.isEmpty()); }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); if (result.size() != 0) { <START>assertTrue(result.size() == 0);<END> } }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); if (!result.isEmpty()) { assertTrue(result.isEmpty()); } }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> isyuf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(isyuf); <START> assertTrue(isyuf.size() == 0); <END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> isyuf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(isyuf); assertTrue(isyuf.isEmpty()); }",,,,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); List<VdsNetworkInterface> gmevf = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(gmevf); <START>assertTrue(gmevf.size() == 0);<END> }",isEmpty() instead,"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); List<VdsNetworkInterface> gmevf = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(gmevf); assertTrue(gmevf.isEmpty()); }","1- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); assertTrue(result.isEmpty()); }
2- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertTrue(result == null); assertNotNull(result); }
3- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertTrue(result == null); }
4- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertTrue(result == null || result.isEmpty()); }
5- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); assertTrue(!result.isEmpty()); }
6- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); assertFalse(result.isEmpty()); }
7- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertTrue(result == null, result); }
8- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNull(result); }
9- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); assertNotNull(result); }
10- public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID,UNPRIVILEGED_USER_ID,true); }",0
967,"private void assertGetResult(VM result) { assertNotNull(result); <START> assertTrue(""Vm db generation wasn't loaded as expected"", result.getDbGeneration() == 1); <END> assertEquals(result, existingVm); }","public class DummyClass {
    private void assertGetResult(VM result) {
        assertNotNull(result);
        assertTrue(""Vm db generation wasn't loaded as expected"", result.getDbGeneration() == 1);
        assertEquals(result, existingVm);
    }
}","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); }","public class DummyClass {
    private void assertGetResult(VM result) {
        assertNotNull(result);
        assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration());
        assertEquals(result, existingVm);
    }
}","['private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); assertEquals(existingVm, result); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); assertEquals(1, result, existingVm); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); assertEquals(1, result); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn\'t loaded as expected"", 1, result.getDbGeneration()); assertEquals(1, result.getResult()); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(1, result.getDbGeneration()); assertEquals(result, existingVm); }', 'private void assertGetResult(VM result) { assertNotNull(result); assertEquals(1, result.getDbGeneration()); assertEquals(existingVm, result); }', 'private void assertGetResult(VM result) { assertNotNull(result); }', '}']",True,0,0,39,39,7,1.0,0.999999995,False,False,False,,,,,,,"private void assertGetResult(VM result) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); assertNotNull(result); <START>assertTrue(""Vm db generation wasn't loaded as expected"",result.getDbGeneration() == 1);<END> assertEquals(result,existingVm); }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); assertNotNull(result); assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); }","private void assertGetResult(VM result) { boolean var = false; if (var) var = true; assertNotNull(result); <START>assertTrue(""Vm db generation wasn't loaded as expected"",result.getDbGeneration() == 1);<END> assertEquals(result,existingVm); }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { boolean var = false; if (var) var = true; assertNotNull(result); assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); }","private void assertGetResult(VM result) { try { assertNotNull(result); <START>assertTrue(""Vm db generation wasn't loaded as expected"",result.getDbGeneration() == 1);<END> assertEquals(result,existingVm); } catch (Exception e) { throw e; } }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { try { assertNotNull(result); assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); } catch (Exception e) { throw e; } }",,,,"private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } <START>assertTrue(""Vm db generation wasn't loaded as expected"",result.getDbGeneration() == 1);<END> assertEquals(result,existingVm); }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); assertEquals(result, existingVm); }","private void assertGetResult(VM result) { assertNotNull(result); <START>assertTrue(""Vm db generation wasn't loaded as expected"",result.getDbGeneration() == 1);<END> if (result != existingVm) { assertEquals(result,existingVm); } }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM result) { assertNotNull(result); assertEquals(""Vm db generation wasn't loaded as expected"", 1, result.getDbGeneration()); if (result != existingVm) { assertEquals(result, existingVm); } }",,,,,,,"private void assertGetResult(VM ntcjl) { assertNotNull(ntcjl); <START> assertTrue(""Vm db generation wasn't loaded as expected"", ntcjl.getDbGeneration() == 1); <END> assertEquals(ntcjl, existingVm); }","Wait, this is worse previous version. happened assertEquals()","private void assertGetResult(VM ntcjl) { assertNotNull(ntcjl); assertEquals(""Vm db generation wasn't loaded as expected"", 1, ntcjl.getDbGeneration()); assertEquals(ntcjl, existingVm); }",,,,,,,"1- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(""Vm db generation wasn't loaded as expected"", 0, result.getDbGeneration()); }
2- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(""Vm db generation wasn't loaded as expected"", result.getDbGeneration()); }
3- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(1, result.getDbGeneration()); assertEquals(result,existingVm); }
4- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(1, result.getDbGeneration()); assertEquals(result, existingVm); }
5- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(result, existingVm); }
6- private void assertGetResult(VM result) { if (result == null) { assertNotNull(result); } assertEquals(1, result.getDbGeneration()); }
7- private void assertGetResult(VM result) { assertGetResult(result, existingVm); }
8- private void assertGetResult(VM result) { assertEquals(result, existingVm); }
9- private void assertGetResult(VM result) { assertNotNull(result); }
10- private void assertGetResult(VM result) { }",0
1024,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); <START> WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); <END> Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }","public class DummyClass {
    public Mutex getMutexForHttpSession(final String sessionId) {
        Assert.requireNonBlank(sessionId, ""sessionId"");
        WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);
        Assert.requireNonNull(mutexReference, ""mutexReference"");
        return mutexReference.get();
    }
}",final,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }","public class DummyClass {
    public Mutex getMutexForHttpSession(final String sessionId) {
        Assert.requireNonBlank(sessionId, ""sessionId"");
        final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);
        Assert.requireNonNull(mutexReference, ""mutexReference"");
        return mutexReference.get();
    }
}","['public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert. requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexRef""); return mutexReference.get(); }', 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId"");final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); final Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.isNullOrEmpty(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getNegotiatorForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getHyphenForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex gethorizForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }', 'public Mutex getqueForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }']",True,0,0,31,32,1,1.0,0.999999995,True,True,False,,,,,,,"public Mutex getMutexForHttpSession(final String sessionId) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.requireNonBlank(sessionId,""sessionId""); <START>WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);<END> Assert.requireNonNull(mutexReference,""mutexReference""); return mutexReference.get(); }",final,"public Mutex getMutexForHttpSession(final String sessionId) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }","public Mutex getMutexForHttpSession(final String sessionId) { boolean var = false; if (var) var = true; Assert.requireNonBlank(sessionId,""sessionId""); <START>WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);<END> Assert.requireNonNull(mutexReference,""mutexReference""); return mutexReference.get(); }",final,"public Mutex getMutexForHttpSession(final String sessionId) { boolean var = false; if (var) var = true; Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }","public Mutex getMutexForHttpSession(final String sessionId) { try { Assert.requireNonBlank(sessionId,""sessionId""); <START>WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);<END> Assert.requireNonNull(mutexReference,""mutexReference""); return mutexReference.get(); } catch (Exception e) { throw e; } }",final,"public Mutex getMutexForHttpSession(final String sessionId) { try { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); } catch (Exception e) { throw e; } }",,,,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); <START>WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId);<END> if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }",final,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference, ""mutexReference""); } return mutexReference.get(); }",,,,,,,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); <START> WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); <END> Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }",final,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, ""mutexReference""); return mutexReference.get(); }","public Mutex getMutexForHttpSession(final String torkn) { Assert.requireNonBlank(torkn, ""sessionId""); <START> WeakReference<Mutex> gzbwo = sessionMutexMap.get(torkn); <END> Assert.requireNonNull(gzbwo, ""mutexReference""); return gzbwo.get(); }",final,"public Mutex getMutexForHttpSession(final String torkn) { Assert.requireNonBlank(torkn, ""sessionId""); final WeakReference<Mutex> gzbwo = sessionMutexMap.get(torkn); Assert.requireNonNull(gzbwo, ""mutexReference""); return gzbwo.get(); }",,,,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); <START>WeakReference<Mutex> jpkel = sessionMutexMap.get(sessionId);<END> Assert.requireNonNull(jpkel,""mutexReference""); return jpkel.get(); }",final,"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); WeakReference<Mutex> jpkel = sessionMutexMap.get(sessionId); Assert.requireNonNull(jpkel, ""mutexReference""); return jpkel.get(); }","1- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
2- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); finalWeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
3- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
4- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
5- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final Optional<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
6- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, ""sessionId""); finalWeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
7- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference, ""mutexReference""); } return mutexReference.get(); }
8- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final Supplier<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
9- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final Multimap<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); }
10- public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId,""sessionId""); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); if (mutexReference == null) { Assert.requireNonNull(mutexReference,""mutexReference""); } return mutexReference.get(); } {",0
1026,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { <START> ArgChecker.notNull(index, ""currency""); <END> ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }","public class DummyClass {
    public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) {
        ArgChecker.notNull(index, ""currency"");
        ArgChecker.notNull(forwardCurve, ""forwardCurve"");
        this.indexCurves.put(index, forwardCurve);
        return this;
    }
}",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }","public class DummyClass {
    public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) {
        ArgChecker.notNull(index, ""index"");
        ArgChecker.notNull(forwardCurve, ""forwardCurve"");
        this.indexCurves.put(index, forwardCurve);
        return this;
    }
}","['public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(csrf, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, NetworkGateway); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve PopupWindow) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve NetworkGateway) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(Bayes, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, rator); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(vv, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(NetworkGateway, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }', 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""csrf""); this.indexCurves.put(index, forwardCurve); return this; }']",True,0,0,33,33,2,1.0,0.999999995,False,False,False,,,,,,,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); this.indexCurves.put(index,forwardCurve); return this; }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }","public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { boolean var = false; if (var) var = true; <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); this.indexCurves.put(index,forwardCurve); return this; }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { boolean var = false; if (var) var = true; ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }","public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { try { <START>ArgChecker.notNull(index,""currency"");<END> ArgChecker.notNull(forwardCurve,""forwardCurve""); this.indexCurves.put(index,forwardCurve); return this; } catch (Exception e) { throw e; } }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { try { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; } catch (Exception e) { throw e; } }",,,,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { <START>ArgChecker.notNull(index,""currency"");<END> } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } this.indexCurves.put(index, forwardCurve); return this; }",,,,,,,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { <START> ArgChecker.notNull(index, ""currency""); <END> ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, ""index""); ArgChecker.notNull(forwardCurve, ""forwardCurve""); this.indexCurves.put(index, forwardCurve); return this; }","public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex olyhy, Curve oheqg) { <START> ArgChecker.notNull(olyhy, ""currency""); <END> ArgChecker.notNull(oheqg, ""forwardCurve""); this.indexCurves.put(olyhy, oheqg); return this; }",Argument name is wrong in call arg checker,"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex olyhy, Curve oheqg) { ArgChecker.notNull(olyhy, ""index""); ArgChecker.notNull(oheqg, ""forwardCurve""); this.indexCurves.put(olyhy, oheqg); return this; }",,,,,,,"1- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
2- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index,""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
3- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve, ""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
4- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index,""currency""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
5- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve PopupWindow) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
6- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(vv,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
7- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(NetworkGateway,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
8- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve forwardCurve) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(csrf,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
9- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve NetworkGateway) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }
10- public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index,Curve vv) { if (index == null) { ArgChecker.notNull(index, ""index""); } if (forwardCurve == null) { ArgChecker.notNull(forwardCurve,""forwardCurve""); } this.indexCurves.put(index,forwardCurve); return this; }",0
1043,"<START> public SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { <END> Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }","public class DummyClass {
    public SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) {
        Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null"");
        Assert.notNull(key, ""key cannot be null"");
        this.keySet = Arrays.asList(key);
        this.expectedJwsAlgorithm = expectedJwsAlgorithm;
    }
}",remove public modifier class is package-private,"SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }","public class DummyClass {
    SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) {
        Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null"");
        Assert.notNull(key, ""key cannot be null"");
        this.keySet = Arrays.asList(key);
        this.expectedJwsAlgorithm = expectedJwsAlgorithm;
    }
}","['SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key(), ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet =Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""Key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key()); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.singletonList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keys = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm =expectedJwsAlgorithm; }', 'SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this_expectedJwsAlgorithm = expectedJwsAlgorithm; }', 'SingleKeyJCollaboratorKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }']",True,0,0,33,33,1,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"<START>public SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) {<END> if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }",remove public modifier class is package-private,"SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key, ""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }",,,,,,,"<START> public SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { <END> Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }",remove public modifier class is package-private,"SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(key, ""key cannot be null""); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }","<START> public SingleKeyJWSKeySelector(JWSAlgorithm tarvj, Key miauy) { <END> Assert.notNull(tarvj, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(miauy, ""key cannot be null""); this.keySet = Arrays.asList(miauy); this.tarvj = tarvj; }",remove public modifier class is package-private,"SingleKeyJWSKeySelector(JWSAlgorithm tarvj, Key miauy) { Assert.notNull(tarvj, ""expectedJwsAlgorithm cannot be null""); Assert.notNull(miauy, ""key cannot be null""); this.keySet = Arrays.asList(miauy); this.tarvj = tarvj; }",,,,,,,"1- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
2- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm, ""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
3- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key, ""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
4- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) } Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
5- SingleKeyJCollaboratorKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
6- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,(""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
7- SingleKeyJOSEKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }
8- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null) { Assert.notNull(expectedJwsAlgorithm,""expectedJwsAlgorithm cannot be null""); } if (key == null) { Assert.notNull(key,""key cannot be null""); } this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; {
9- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { if (expectedJwsAlgorithm == null)
10- SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm,Key key) { }",0
1083,"public static Method normalizedValueOf(final String method) { <START> return valueOf(Objects.requireNonNull(method, ""method"").toUpperCase(Locale.ROOT)); <END> }","public class DummyClass {
    public static Method normalizedValueOf(final String method) {
        return valueOf(Objects.requireNonNull(method, ""method"").toUpperCase(Locale.ROOT));
    }
}",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }","public class DummyClass {
    public static Method normalizedValueOf(final String method) {
        return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT));
    }
}","['public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method(), ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf( final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(StringUtils.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(""final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(Args.notNullValue(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf( Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(Arg.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(Args.null(method, ""method"").toUpperCase(Locale.ROOT)); }', 'public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT"")); }']",True,0,0,41,41,2,1.0,0.999999995,False,False,False,,,,,,,"public static Method normalizedValueOf(final String method) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>return valueOf(Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT));<END> }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }","public static Method normalizedValueOf(final String method) { boolean var = false; if (var) var = true; <START>return valueOf(Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT));<END> }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { boolean var = false; if (var) var = true; return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }","public static Method normalizedValueOf(final String method) { try { <START>return valueOf(Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT));<END> } catch (Exception e) { throw e; } }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { try { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); } catch (Exception e) { throw e; } }","public static Method normalizedValueOf(final String method) { Method returnValue =  <START> valueOf(Objects.requireNonNull(method, ""method"").toUpperCase(Locale.ROOT)) <END>; return returnValue; }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { Method returnValue = valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); return returnValue; }","public static Method normalizedValueOf(final String method) { <START>return valueOf(Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT));<END> }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }",,,,,,,,,,"public static Method normalizedValueOf(final String rxsbm) { <START> return valueOf(Objects.requireNonNull(rxsbm, ""method"").toUpperCase(Locale.ROOT)); <END> }",@garydgregory Please Args.notNull for consistency rest of code base,"public static Method normalizedValueOf(final String rxsbm) { return valueOf(Args.notNull(rxsbm, ""method"").toUpperCase(Locale.ROOT)); }",,,,,,,"1- public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method,""method"").toUpperCase(Locale.ROOT)); }
2- public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, ""method"").toUpperCase(Locale.ROOT)); }
3- public static Method normalizedValueOf(final String method) { return valueOf(Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT)); }
4- public static Method normalizedValueOf(final String method) { return valueOf(Objects.requireNonNull(method, ""method"").toUpperCase(Locale.ROOT)); }
5- public static Method normalizedValueOf(final String method) { return valueOf(StringUtils.requireNonNull(method,""method"").toUpperCase(Locale.ROOT)); }
6- public static Method normalizedValueOf(final String method) { return valueOf(StringUtils.requireNonNull(method, ""method"").toUpperCase(Locale.ROOT)); }
7- public static Method normalizedValueOf(final String method) { return valueOf(StringUtils.notNull(method,""method"").toUpperCase(Locale.ROOT)); }
8- public static Method normalizedValueOf(final String method) { return valueOf(Arg.notNull(method,""method"").toUpperCase(Locale.ROOT)); }
9- public static Method normalizedValueOf(final String method) { return valueOf( Objects.requireNonNull(method,""method"").toUpperCase(Locale.ROOT)); }
10- public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method,""method"").toUpperCase(Locale.ROOT))); }",1
1115,"public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); <START> return valueOf(uniqueName.replace('-', '_').toUpperCase(Locale.ENGLISH)); <END> }","public class DummyClass {
    public static AccrualOnDefaultFormula of(String uniqueName) {
        ArgChecker.notNull(uniqueName, ""uniqueName"");
        return valueOf(uniqueName.replace('-', '_').toUpperCase(Locale.ENGLISH));
    }
}","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }","public class DummyClass {
    public static AccrualOnDefaultFormula of(String uniqueName) {
        ArgChecker.notNull(uniqueName, ""uniqueName"");
        String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName);
        if (str.endsWith(""I_S_D_A"")) {
            str = ""ORIGINAL_ISDA"";
        }
        return valueOf(str);
    }
}","['public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); return valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName)); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); final String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); String value = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (value.endsWith(""I_S_D_A"")) { value = ""ORIGINAL_ISDA""; } return valueOf(value); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); Object value = valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName)); if (value.endsWith(""I_S_D_A"")) { value = ""ORIGINAL_ISDA""; } return value; }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); double str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); AccrualOnDefaultFormula ofType = AccrualOnDefaultFormula.valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName)); if (isDA(uniqueName)) { return valueOf(""ORIGINAL_ISDA""); } return valueOf(ofType.toUpperCase(Locale.ENGLISH)); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); AccrualOnDefaultFormula ofType = AccrualOnDefaultFormula.valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName)); if (isDA(uniqueName)) { return valueOf(""ORIGINAL_ISDA""); } return valueOf(ofType); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); AccrualOnDefaultFormula ofType = AccrualOnDefaultFormula.valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName)); if (isDA(uniqueName)) { return valueOf(""ORIGINAL_ISDA""); } return valueOf(createName(uniqueName)); }', 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(quota); }']",True,0,0,87,157,11,1.0,0.999999995,False,False,False,,,,,,,"public static AccrualOnDefaultFormula of(String uniqueName) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(uniqueName,""uniqueName""); <START>return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH));<END> }","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String uniqueName) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }","public static AccrualOnDefaultFormula of(String uniqueName) { boolean var = false; if (var) var = true; ArgChecker.notNull(uniqueName,""uniqueName""); <START>return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH));<END> }","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String uniqueName) { boolean var = false; if (var) var = true; ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }","public static AccrualOnDefaultFormula of(String uniqueName) { try { ArgChecker.notNull(uniqueName,""uniqueName""); <START>return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH));<END> } catch (Exception e) { throw e; } }","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String uniqueName) { try { ArgChecker.notNull(uniqueName, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); } catch (Exception e) { throw e; } }",,,,"public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName,""uniqueName""); } <START>return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH));<END> }","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName, ""uniqueName""); } String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }",,,,,,,,,,"public static AccrualOnDefaultFormula of(String rdbwc) { ArgChecker.notNull(rdbwc, ""uniqueName""); <START> return valueOf(rdbwc.replace('-', '_').toUpperCase(Locale.ENGLISH)); <END> }","Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, rdbwc); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str)","public static AccrualOnDefaultFormula of(String rdbwc) { ArgChecker.notNull(rdbwc, ""uniqueName""); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, rdbwc); if (str.endsWith(""I_S_D_A"")) { str = ""ORIGINAL_ISDA""; } return valueOf(str); }",,,,,,,"1- public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName,""uniqueName""); return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH)); }
2- public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName,""uniqueName""); } return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH)); }
3- public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, ""uniqueName""); return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH)); }
4- public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName, ""uniqueName""); } return valueOf(uniqueName.replace('-','_').toUpperCase(Locale.ENGLISH)); }
5- public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName,""uniqueName""); return valueOf(uniqueName.replace('-','_"").toUpperCase(Locale.ENGLISH)); }
6- public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName,""uniqueName""); return valueOf(uniqueName.replace('-','_"")).toUpperCase(Locale.ENGLISH)); }
7- public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName,""uniqueName""); return valueOf(uniqueName.replace('-','_'"").toUpperCase(Locale.ENGLISH)); }
8- public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName,""uniqueName""); } return valueOf(uniqueName.replace('-','_"").toUpperCase(Locale.ENGLISH)); }
9- public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName,""uniqueName""); } return valueOf(uniqueName.replace('-','_"")).toUpperCase(Locale.ENGLISH)); }
10- public static AccrualOnDefaultFormula of(String uniqueName) { if (uniqueName == null) { ArgChecker.notNull(uniqueName,""uniqueName""); } return valueOf(uniqueName.replace('-','_).toUpperCase(Locale.ENGLISH)); }",0
1122,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType)t); <END> assertNotNull(s[0]); }","public class DummyClass {
    public void arrayType() {
        Type type = parseType(""int[]"");
        assertTrue(type.isArrayType());
        ArrayType arrayType = type.asArrayType();
        final ArrayType[] s = new ArrayType[1];
        type.ifArrayType(t -> s[0] = (ArrayType) t);
        assertNotNull(s[0]);
    }
}",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public class DummyClass {
    public void arrayType() {
        Type type = parseType(""int[]"");
        assertTrue(type.isArrayType());
        ArrayType arrayType = type.asArrayType();
        final ArrayType[] s = new ArrayType[1];
        type.ifArrayType(t -> s[0] = t);
        assertNotNull(s[0]);
    }
}","['public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.assertArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.assertArrayType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = toArrayType(t)); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.setArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.returnType(t -> s[0] = (ArrayType)t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type. ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = T.ArrayType.LIST); assertNotNull(s[0]); }', 'public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = T.ArrayType.IN; assertNotNull(s[0]); }']",True,0,0,26,37,2,1.0,0.999999995,False,False,False,,,,,,,"public void arrayType() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { boolean var = false; if (var) var = true; Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { boolean var = false; if (var) var = true; Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { try { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); } catch (Exception e) { throw e; } }",Huh? point is a cast necessary,"public void arrayType() { try { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); } catch (Exception e) { throw e; } }",,,,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); if (s[0] == null) { assertNotNull(s[0]); } }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); if (s[0] == null) { assertNotNull(s[0]); } }",,,,"public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); if (!type.isArrayType()) { assertTrue(type.isArrayType()); } ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void type() { Type s = parseType(""int[]""); assertTrue(s.isArrayType()); ArrayType type = s.asArrayType(); final ArrayType[] arrayType = new ArrayType[1]; <START> s.ifArrayType(t -> arrayType[0] = (ArrayType) <END> t); assertNotNull(arrayType[0]); }",Huh? point is a cast necessary,"public void type() { Type s = parseType(""int[]""); assertTrue(s.isArrayType()); ArrayType type = s.asArrayType(); final ArrayType[] arrayType = new ArrayType[1]; s.ifArrayType(t -> arrayType[0] = t); assertNotNull(arrayType[0]); }","public void zjsph() { Type sdjzm = parseType(""int[]""); assertTrue(sdjzm.isArrayType()); ArrayType zjsph = sdjzm.asArrayType(); final ArrayType[] cjtcp = new ArrayType[1]; <START> sdjzm.ifArrayType(rlzdi -> cjtcp[0] = (ArrayType) <END> rlzdi); assertNotNull(cjtcp[0]); }",Huh? point is a cast necessary,"public void zjsph() { Type sdjzm = parseType(""int[]""); assertTrue(sdjzm.isArrayType()); ArrayType zjsph = sdjzm.asArrayType(); final ArrayType[] cjtcp = new ArrayType[1]; sdjzm.ifArrayType(rlzdi -> cjtcp[0] = rlzdi); assertNotNull(cjtcp[0]); }","public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); final ArrayType[] s = new ArrayType[1]; ArrayType arrayType = type.asArrayType(); <START> type.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); final ArrayType[] s = new ArrayType[1]; ArrayType arrayType = type.asArrayType(); type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","public void arrayType() { Type type = parseType(""int[]""); Type usfiv = parseType(""int[]""); assertTrue(usfiv.isArrayType()); ArrayType arrayType = usfiv.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> usfiv.ifArrayType(t -> s[0] = (ArrayType) <END> t); assertNotNull(s[0]); }",Huh? point is a cast necessary,"public void arrayType() { Type type = parseType(""int[]""); Type usfiv = parseType(""int[]""); assertTrue(usfiv.isArrayType()); ArrayType arrayType = usfiv.asArrayType(); final ArrayType[] s = new ArrayType[1]; usfiv.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }","1- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); if (s[0] == null) { assertNotNull(s[0]); } }
2- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) != null) { type.ifArrayType(t -> s[0] = (ArrayType) t); } else if (type.isArrayType()) { ArrayType arrayType = (ArrayType) type; if (s[0] == null) { assertNotNull(s[0]); } } else { type.ifArrayType(t -> s[0] = (ArrayType) t); } }
3- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) == null) { assertNotNull(s[0]); } } else if (type.isArrayType()) { ArrayType arrayType = (ArrayType) type; if (s[0] == null) { assertNotNull(s[0]); } } else { type.ifArrayType(t -> s[0] = (ArrayType) t); } if (s[0] == null) { assertNotNull(s[0]); } }
4- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) == null) { assertNotNull(s[0]); } } else if (type.isArrayType()) { ArrayType arrayType = (ArrayType) type; if (s[0] == null) { assertNotNull(s[0]); } } else { throw new NullPointerException(""Array type is arrayType""); } if (s[0] == null) { assertNotNull(s[0]); } }
5- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) != null) { type.ifArrayType(t -> s[0] = (ArrayType) t); } else if (type.isArrayType()) { type.ifArrayType(t -> s[0] = (ArrayType) t); } else { throw new NullPointerException(""Array type is arrayType""); } if (s[0] == null) { assertNotNull(s[0]); } }
6- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) == null) { assertNotNull(s[0]); } } else if (type.ifArrayType(t -> s[0] = (ArrayType) t) == null) { assertNotNull(s[0]); } }
7- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) == null) { assertNotNull(s[0]); } } else if (type.isArrayType()) { ArrayType arrayType = (ArrayType) type; if (s[0] == null) { assertNotNull(s[0]); } } else { type.ifArrayType(t -> s[0] = (ArrayType) t); } }
8- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); assertNotNull(s[0]); }
9- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; if (type.ifArrayType(t -> s[0] = (ArrayType) t) != null) { throw new AssertionError(""Array type is not supported.""); } if (s[0] == null) { assertNotNull(s[0]); } }
10- public void arrayType() { Type type = parseType(""int[]""); assertTrue(type.isArrayType()); final ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = (ArrayType) t); if (s[0] == null) { assertNotNull(s[0]); } }",0
1176,"public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); <START> requireNonNull(expression, ""expression can't be null""); <END> this.expression = expression; }","public class DummyClass {
    public ProcessorExpressionRoute(String expression, Processor processor) {
        super(processor);
        requireNonNull(expression, ""expression can't be null"");
        this.expression = expression;
    }
}","this returns expression, combine this line next","public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expression can't be null""); }","public class DummyClass {
    public ProcessorExpressionRoute(String expression, Processor processor) {
        super(processor);
        this.expression = requireNonNull(expression, ""expression can't be null"");
    }
}","['public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expression can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expression can\'t be null""); return expression; }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expr can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""Expression can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = Objects.requireNonNull(expression, ""expression can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""processor can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""m expression can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression =  requireNonNull(expression, ""expression can\'t be null""); }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expression can\'t be null""); return this; }', 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = expression; }']",True,0,0,58,74,1,1.0,0.999999995,True,True,False,,,,,,,,,,,,,,,,,,,"public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); if (expression == null) { <START>requireNonNull(expression,""expression can't be null"");<END> } this.expression = expression; }","this returns expression, combine this line next","public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); if (expression == null) { requireNonNull(expression, ""expression can't be null""); } }",,,,,,,"public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); <START> requireNonNull(expression, ""expression can't be null""); <END> this.expression = expression; }","this returns expression, combine this line next","public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, ""expression can't be null""); }","public ProcessorExpressionRoute(String nowkl, Processor xydyb) { super(xydyb); <START> requireNonNull(nowkl, ""expression can't be null""); <END> this.nowkl = nowkl; }","this returns nowkl, combine this line next","public ProcessorExpressionRoute(String nowkl, Processor xydyb) { super(xydyb); this.nowkl = requireNonNull(nowkl, ""expression can't be null""); }",,,,,,,"1- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); if (expression == null) { requireNonNull(expression, ""expression can't be null""); } this.expression = expression; }
2- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); requireNonNull(expression, ""expression can't be null""); this.expression = expression; }
3- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); if (expression == null) { requireNonNull(expression,""expression can't be null""); } this.expression = expression; }
4- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); requireNonNull(expression,""expression can't be null""); this.expression = expression; }
5- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); verify(expression == null) { requireNonNull(expression, ""expression can't be null""); } this.expression = expression; }
6- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); Preconditions.checkNotNull(expression, ""expression can't be null""); this.expression = expression; }
7- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); checkArgument(expression == null, ""expression can't be null""); this.expression = expression; }
8- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); Preconditions. requireNonNull(expression, ""expression can't be null""); this.expression = expression; }
9- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); verify(expression == null, ""expression can't be null""); this.expression = expression; }
10- public ProcessorExpressionRoute(String expression,Processor processor) { super(processor); if (expression == null) { requireNonNull(expression, ""expression can'tBe null""); } this.expression = expression; }",0
1260,"<START> public void convert_skip_null_abstract() throws IOException { <END> Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","public class DummyClass {
    public void convert_skip_null_abstract() throws IOException {
        Result sourceDataset =
                minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET);
        addDescription(sourceDataset, ""null"");
        addDescription(sourceDataset, ABSTRACT);
        DataSetReference metadata = converter.convert(sourceDataset);
        assertNotNull(metadata);
        assertEquals(ABSTRACT, metadata.getDescription());
    }
}",Exception is thrown,"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","public class DummyClass {
    public void convert_skip_null_abstract() {
        Result sourceDataset =
                minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET);
        addDescription(sourceDataset, ""null"");
        addDescription(sourceDataset, ABSTRACT);
        DataSetReference metadata = converter.convert(sourceDataset);
        assertNotNull(metadata);
        assertEquals(ABSTRACT, metadata.getDescription());
    }
}","['public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_ skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_ abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT; DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE(DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,(""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription( sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT""); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }', 'public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata().getDescription()); }', 'public void convert_skip_null_abstract()']",True,0,0,45,45,2,1.0,0.999999995,False,False,False,,,,,,,"<START>public void convert_skip_null_abstract() throws IOException {<END> boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT,metadata.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","<START>public void convert_skip_null_abstract() throws IOException {<END> boolean var = false; if (var) var = true; Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT,metadata.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { boolean var = false; if (var) var = true; Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","<START>public void convert_skip_null_abstract() throws IOException {<END> try { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT,metadata.getDescription()); } catch (Exception e) { throw e; } }",Exception is thrown,"public void convert_skip_null_abstract() { try { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); } catch (Exception e) { throw e; } }",,,,"<START>public void convert_skip_null_abstract() throws IOException {<END> Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT, metadata.getDescription()); }","<START>public void convert_skip_null_abstract() throws IOException {<END> Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); if (ABSTRACT != metadata.getDescription()) { assertEquals(ABSTRACT,metadata.getDescription()); } }",Exception is thrown,"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); if (ABSTRACT != metadata.getDescription()) { assertEquals(ABSTRACT, metadata.getDescription()); } }",,,,"<START> public void convert_skip_null_abstract() throws IOException { <END> Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","<START> public void convert_skip_null_abstract() throws IOException { <END> Result issdp = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(issdp, ""null""); addDescription(issdp, ABSTRACT); DataSetReference sgrtv = converter.convert(issdp); assertNotNull(sgrtv); assertEquals(ABSTRACT, sgrtv.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { Result issdp = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(issdp, ""null""); addDescription(issdp, ABSTRACT); DataSetReference sgrtv = converter.convert(issdp); assertNotNull(sgrtv); assertEquals(ABSTRACT, sgrtv.getDescription()); }",,,,"<START>public void convert_skip_null_abstract() throws IOException {<END> Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); Result rcrcr = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(rcrcr,""null""); addDescription(rcrcr,ABSTRACT); DataSetReference metadata = converter.convert(rcrcr); assertNotNull(metadata); assertEquals(ABSTRACT,metadata.getDescription()); }",Exception is thrown,"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); Result rcrcr = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(rcrcr, ""null""); addDescription(rcrcr, ABSTRACT); DataSetReference metadata = converter.convert(rcrcr); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }","1- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
2- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, ""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
3- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,(""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
4- public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
5- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,null); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
6- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); }
7- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription()); {
8- public void convert_skip_null_abstract() throws IOException { Result sourceDataset = minimalEntityBuilder(ID,InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset,""null""); addDescription(sourceDataset,ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); if (metadata == null) { assertNotNull(metadata); } assertEquals(ABSTRACT,metadata.getDescription); }
9- public void convert_skip_null_abstract() throws IOException }
10- public void convert_skip_null_abstract()",0
1363,"public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START> if (includeRuntimes) { <END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; }","public class DummyClass {
    public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes)
            throws ServerException {
        requireNonNull(namespace, ""Required non-null namespace"");
        final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace);
        if (includeRuntimes) {
            for (WorkspaceImpl workspace : workspaces) {
                normalizeState(workspace);
            }
        } else {
            for (WorkspaceImpl workspace : workspaces) {
                workspace.setStatus(runtimes.getStatus(workspace.getId()));
            }
        }
        return workspaces;
    }
}","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }","public class DummyClass {
    public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes)
            throws ServerException {
        requireNonNull(namespace, ""Required non-null namespace"");
        final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace);
        for (WorkspaceImpl workspace : workspaces) {
            normalizeState(workspace, includeRuntimes);
        }
        return workspaces;
    }
}","['public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for(WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } = workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace()); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspace; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, Boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); for (WorkspaceImpl workspace : workspaceDao.getByNamespace(namespace)) { normalizeState(workspace, includeRuntimes); } return workspaces; }', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces;}', 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; } {']",True,0,0,156,156,7,1.0,0.999999995,False,False,False,,,,"public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START> if (!(includeRuntimes)) { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } else { <END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } return workspaces; }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }","public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(namespace,""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START>if (includeRuntimes) {<END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }","public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { boolean var = false; if (var) var = true; requireNonNull(namespace,""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START>if (includeRuntimes) {<END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { boolean var = false; if (var) var = true; requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }","public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { try { requireNonNull(namespace,""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START>if (includeRuntimes) {<END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; } catch (Exception e) { throw e; } }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { try { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; } catch (Exception e) { throw e; } }",,,,"public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START>if (includeRuntimes) {<END> for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace, ""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }",,,,,,,"public List<WorkspaceImpl> getByNamespace(String includeRuntimes, boolean workspaces) throws ServerException { requireNonNull(includeRuntimes, ""Required non-null includeRuntimes""); final List<WorkspaceImpl> namespace = workspaceDao.getByNamespace(includeRuntimes); <START> if (workspaces) { <END> for (WorkspaceImpl workspace : namespace) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : namespace) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return namespace; }","logic if rewrite code for (WorkspaceImpl workspace : namespace) { normalizeState(workspace, namespace); }","public List<WorkspaceImpl> getByNamespace(String includeRuntimes, boolean workspaces) throws ServerException { requireNonNull(includeRuntimes, ""Required non-null includeRuntimes""); final List<WorkspaceImpl> namespace = workspaceDao.getByNamespace(includeRuntimes); for (WorkspaceImpl workspace : namespace) { normalizeState(workspace, workspaces); } return namespace; }","public List<WorkspaceImpl> getByNamespace(String mpskg, boolean mfzyc) throws ServerException { requireNonNull(mpskg, ""Required non-null namespace""); final List<WorkspaceImpl> wphdq = workspaceDao.getByNamespace(mpskg); <START> if (mfzyc) { <END> for (WorkspaceImpl typdn : wphdq) { normalizeState(typdn); } } else { for (WorkspaceImpl typdn : wphdq) { typdn.setStatus(runtimes.getStatus(typdn.getId())); } } return wphdq; }","logic if rewrite code for (WorkspaceImpl typdn : wphdq) { normalizeState(typdn, mfzyc); }","public List<WorkspaceImpl> getByNamespace(String mpskg, boolean mfzyc) throws ServerException { requireNonNull(mpskg, ""Required non-null namespace""); final List<WorkspaceImpl> wphdq = workspaceDao.getByNamespace(mpskg); for (WorkspaceImpl typdn : wphdq) { normalizeState(typdn, mfzyc); } return wphdq; }",,,,"public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { requireNonNull(namespace,""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); List<WorkspaceImpl> nbtvf = workspaceDao.getByNamespace(namespace); <START>if (includeRuntimes) {<END> for (WorkspaceImpl workspace : nbtvf) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : nbtvf) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return nbtvf; }","logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }","public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, ""Required non-null namespace""); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); List<WorkspaceImpl> nbtvf = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : nbtvf) { normalizeState(workspace, includeRuntimes); } return nbtvf; }","1- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }
2- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace, ""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }
3- public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }
4- public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace, ""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }
5- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; } {
6- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); return processContext(namespace, includeRuntimes); }
7- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); return processInContext(namespace, includeRuntimes); }
8- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); } final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }<START>
9- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null) { requireNonNull(namespace,""Required non-null namespace""); return processLocation(namespace, includeRuntimes); }
10- public List<WorkspaceImpl> getByNamespace(String namespace,boolean includeRuntimes) throws ServerException { if (namespace == null)",1
1408,"public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { <START> this.sslContext = sslContext; <END> this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }","public class DummyClass {
    public HiveMetastoreClientFactory(
            Optional<SSLContext> sslContext,
            Optional<HostAndPort> socksProxy,
            Duration timeout,
            HiveMetastoreAuthentication metastoreAuthentication) {
        this.sslContext = sslContext;
        this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null"");
        this.timeoutMillis = toIntExact(timeout.toMillis());
        this.metastoreAuthentication =
                requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null"");
    }
}",requireNN,"public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, ""sslContext is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }","public class DummyClass {
    public HiveMetastoreClientFactory(
            Optional<SSLContext> sslContext,
            Optional<HostAndPort> socksProxy,
            Duration timeout,
            HiveMetastoreAuthentication metastoreAuthentication) {
        this.sslContext = requireNonNull(sslContext, ""sslContext is null"");
        this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null"");
        this.timeoutMillis = toIntExact(timeout.toMillis());
        this.metastoreAuthentication =
                requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null"");
    }
}","['public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, ""sslContext is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, ""socksProxy is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, ""sslContextsProxy is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull( sslContext, ""sslContext is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull( sslContext, ""sslContextsProxy is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(curr, ""sslContext is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull( sslContext, ""sslContext""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull( sslContext, "" sslContext is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, ""keyStore is null""); this.socksProxy = requireNonNull(socksProxy, ""socksProxy is null""); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }', 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication)']",True,0,0,57,64,3,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { <START>this.sslContext = sslContext;<END> if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }",requireNN,"public HiveMetastoreClientFactory(Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { if (sslContext == null) { requireNonNull(sslContext, ""sslContext is null""); } if (socksProxy == null) { requireNonNull(socksProxy, ""socksProxy is null""); } this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); } }",,,,,,,"public HiveMetastoreClientFactory(Optional<SSLContext> timeout, Optional<HostAndPort> sslContext, Duration socksProxy, HiveMetastoreAuthentication metastoreAuthentication) { <START> this.timeout = timeout; <END> this.sslContext = requireNonNull(sslContext, ""sslContext is null""); this.timeoutMillis = toIntExact(socksProxy.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }",requireNN,"public HiveMetastoreClientFactory(Optional<SSLContext> timeout, Optional<HostAndPort> sslContext, Duration socksProxy, HiveMetastoreAuthentication metastoreAuthentication) { this.timeout = requireNonNull(timeout, ""socksProxy is null""); this.sslContext = requireNonNull(sslContext, ""sslContext is null""); this.timeoutMillis = toIntExact(socksProxy.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, ""metastoreAuthentication is null""); }","public HiveMetastoreClientFactory(Optional<SSLContext> oynor, Optional<HostAndPort> ivnoz, Duration iozhk, HiveMetastoreAuthentication hbpie) { <START> this.oynor = oynor; <END> this.ivnoz = requireNonNull(ivnoz, ""socksProxy is null""); this.timeoutMillis = toIntExact(iozhk.toMillis()); this.hbpie = requireNonNull(hbpie, ""metastoreAuthentication is null""); }",requireNN,"public HiveMetastoreClientFactory(Optional<SSLContext> oynor, Optional<HostAndPort> ivnoz, Duration iozhk, HiveMetastoreAuthentication hbpie) { this.oynor = requireNonNull(oynor, ""sslContext is null""); this.ivnoz = requireNonNull(ivnoz, ""socksProxy is null""); this.timeoutMillis = toIntExact(iozhk.toMillis()); this.hbpie = requireNonNull(hbpie, ""metastoreAuthentication is null""); }",,,,,,,"1- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
2- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = sslContext; if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
3- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy, ""socksProxy is null""); } this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
4- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
5- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = sslContext; if (socksProxy == null) { requireNonNull(socksProxy, ""socksProxy is null""); } this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
6- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } if (timeout != null) { this.sslContext = sslContext; } this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
7- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
8- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); if (metastoreAuthentication == null) { requireNonNull(metastoreAuthentication,""metastoreAuthentication is null""); } }
9- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { this( sslContext, socksProxy, timeout, metastoreAuthentication); }
10- public HiveMetastoreClientFactory(Optional<SSLContext> sslContext,Optional<HostAndPort> socksProxy,Duration timeout,HiveMetastoreAuthentication metastoreAuthentication) { if (socksProxy == null) { requireNonNull(socksProxy,""socksProxy is null""); } this.sslContext = sslContext; this.timeoutMillis = toIntExact(timeout.toMillis()); }",0
1468,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, <START> Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); <END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public class DummyClass {
    public void testGetPermittedStorageDomains() {
        List<StorageDomain> result =
                dao.getPermittedStorageDomainsByStoragePool(
                        EXISTING_USER_ID,
                        ActionGroup.CONFIGURE_VM_STORAGE,
                        Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));
        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(result.get(0).getId(), existingDomain.getId());
    }
}",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public class DummyClass {
    public void testGetPermittedStorageDomains() {
        List<StorageDomain> result =
                dao.getPermittedStorageDomainsByStoragePool(
                        EXISTING_USER_ID,
                        ActionGroup.CONFIGURE_VM_STORAGE,
                        new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d""));
        assertNotNull(result);
        assertFalse(result.isEmpty());
        assertEquals(result.get(0).getId(), existingDomain.getId());
    }
}","['public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-mm09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, final Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,.Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105ed"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE,MOUNT_ID); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertTrue(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId); }', 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, null); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }']",True,0,0,45,46,3,1.0,0.999999995,False,False,False,,,,,,,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { boolean var = false; if (var) var = true; List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { boolean var = false; if (var) var = true; List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { try { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); } catch (Exception e) { throw e; } }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { try { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); } catch (Exception e) { throw e; } }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }","public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); assertFalse(result.isEmpty()); if (result.get(0).getId() != existingDomain.getId()) { assertEquals(result.get(0).getId(),existingDomain.getId()); } }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); assertFalse(result.isEmpty()); if (result.get(0).getId() != existingDomain.getId()) { assertEquals(result.get(0).getId(), existingDomain.getId()); } }","public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(result); if (result.isEmpty()) { assertFalse(result.isEmpty()); } assertEquals(result.get(0).getId(), existingDomain.getId()); }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> ympjw = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, <START> ActionGroup.CONFIGURE_VM_STORAGE, <END> Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(ympjw); assertFalse(ympjw.isEmpty()); assertEquals(ympjw.get(0).getId(), existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> ympjw = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(ympjw); assertFalse(ympjw.isEmpty()); assertEquals(ympjw.get(0).getId(), existingDomain.getId()); }",,,,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,<START>Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d""));<END> List<StorageDomain> kkleh = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,Guid.createGuidFromString(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(kkleh); assertFalse(kkleh.isEmpty()); assertEquals(kkleh.get(0).getId(),existingDomain.getId()); }",new Guid(String) - this literal null,"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); List<StorageDomain> kkleh = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); assertNotNull(kkleh); assertFalse(kkleh.isEmpty()); assertEquals(kkleh.get(0).getId(), existingDomain.getId()); }","1- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
2- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE,new Guid(""6d849ebf-755f-4552-ad09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
3- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-mm09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
4- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-"");09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
5- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-so09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
6- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-.09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
7- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552- a09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
8- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-fd09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
9- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-vv09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }
10- public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID,ActionGroup.CONFIGURE_VM_STORAGE, new Guid(""6d849ebf-755f-4552-f09-9a090cda105d"")); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(),existingDomain.getId()); }",0
1503,"public void testSchemaTypePromotion() throws Exception { <START> LOG.debug(""########## testSchemaTypePromotion ##############""); <END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }","public class DummyClass {
    public void testSchemaTypePromotion() throws Exception {
        LOG.debug(""########## testSchemaTypePromotion ##############"");
        InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8""));
        Schema schema =
                CSVUtil.inferSchema(
                        ""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build());
        Assert.assertNotNull(schema.getField(""long""));
        Assert.assertNotNull(schema.getField(""nullable_double""));
        Assert.assertNotNull(schema.getField(""nullable_double2""));
        Assert.assertNotNull(schema.getField(""string""));
        Assert.assertEquals(
                ""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema());
        Assert.assertEquals(
                ""Should infer a double (third row is decimal)"",
                nullable(Schema.Type.DOUBLE),
                schema.getField(""nullable_double"").schema());
        Assert.assertEquals(
                ""Should infer a double (second row is decimal)"",
                nullable(Schema.Type.DOUBLE),
                schema.getField(""nullable_double2"").schema());
        Assert.assertEquals(
                ""Should infer a nullable string (third row is string)"",
                schema(Schema.Type.STRING),
                schema.getField(""string"").schema());
        LOG.debug(""########## END typePromotion ############"");
    }
}","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }","public class DummyClass {
    public void testSchemaTypePromotion() throws Exception {
        InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8""));
        Schema schema =
                CSVUtil.inferSchema(
                        ""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build());
        Assert.assertNotNull(schema.getField(""long""));
        Assert.assertNotNull(schema.getField(""nullable_double""));
        Assert.assertNotNull(schema.getField(""nullable_double2""));
        Assert.assertNotNull(schema.getField(""string""));
        Assert.assertEquals(
                ""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema());
        Assert.assertEquals(
                ""Should infer a double (third row is decimal)"",
                nullable(Schema.Type.DOUBLE),
                schema.getField(""nullable_double"").schema());
        Assert.assertEquals(
                ""Should infer a double (second row is decimal)"",
                nullable(Schema.Type.DOUBLE),
                schema.getField(""nullable_double2"").schema());
        Assert.assertEquals(
                ""Should infer a nullable string (third row is string)"",
                schema(Schema.Type.STRING),
                schema.getField(""string"").schema());
    }
}","['public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); LOG.trace(""########## END typePromotion ############""); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); return; }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); throw new RuntimeException(""Test schema must be set to \'false\'""); }', 'public void testSchemaTypePromotion() throws Exception {InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); throw new RuntimeException(""Test schema must be boolean: \'false\'""); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); throw new RuntimeException(""Test schema must be thrown for given configuration.""); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }); }', 'public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); throw new RuntimeException(""Test schema must be not ##############""); }']",True,1,0,90,146,6,1.0,0.999999995,False,False,False,,,,,,,"public void testSchemaTypePromotion() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); <START>LOG.debug(""########## testSchemaTypePromotion ##############"");<END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }","public void testSchemaTypePromotion() throws Exception { boolean var = false; if (var) var = true; <START>LOG.debug(""########## testSchemaTypePromotion ##############"");<END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { boolean var = false; if (var) var = true; InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }","public void testSchemaTypePromotion() throws Exception { try { <START>LOG.debug(""########## testSchemaTypePromotion ##############"");<END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); } catch (Exception e) { throw e; } }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { try { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); } catch (Exception e) { throw e; } }",,,,"public void testSchemaTypePromotion() throws Exception { <START>LOG.debug(""########## testSchemaTypePromotion ##############"");<END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", stream, new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }",,,,,,,"public void testSchemaTypePromotion() throws Exception { <START> LOG.debug(""########## testSchemaTypePromotion ##############""); <END> InputStream schema = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema stream = CSVUtil.inferSchema(""TestRecord"", schema, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(stream.getField(""long"")); Assert.assertNotNull(stream.getField(""nullable_double"")); Assert.assertNotNull(stream.getField(""nullable_double2"")); Assert.assertNotNull(stream.getField(""string"")); Assert.assertEquals(""Should infer a long"", stream(Schema.Type.LONG), stream.getField(""long"").stream()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), stream.getField(""nullable_double"").stream()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), stream.getField(""nullable_double2"").stream()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", stream(Schema.Type.STRING), stream.getField(""string"").stream()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { InputStream schema = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema stream = CSVUtil.inferSchema(""TestRecord"", schema, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(stream.getField(""long"")); Assert.assertNotNull(stream.getField(""nullable_double"")); Assert.assertNotNull(stream.getField(""nullable_double2"")); Assert.assertNotNull(stream.getField(""string"")); Assert.assertEquals(""Should infer a long"", stream(Schema.Type.LONG), stream.getField(""long"").stream()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), stream.getField(""nullable_double"").stream()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), stream.getField(""nullable_double2"").stream()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", stream(Schema.Type.STRING), stream.getField(""string"").stream()); }","public void testSchemaTypePromotion() throws Exception { <START> LOG.debug(""########## testSchemaTypePromotion ##############""); <END> InputStream eajln = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema wkoar = CSVUtil.inferSchema(""TestRecord"", eajln, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(wkoar.getField(""long"")); Assert.assertNotNull(wkoar.getField(""nullable_double"")); Assert.assertNotNull(wkoar.getField(""nullable_double2"")); Assert.assertNotNull(wkoar.getField(""string"")); Assert.assertEquals(""Should infer a long"", wkoar(Schema.Type.LONG), wkoar.getField(""long"").wkoar()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), wkoar.getField(""nullable_double"").wkoar()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), wkoar.getField(""nullable_double2"").wkoar()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", wkoar(Schema.Type.STRING), wkoar.getField(""string"").wkoar()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { InputStream eajln = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema wkoar = CSVUtil.inferSchema(""TestRecord"", eajln, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(wkoar.getField(""long"")); Assert.assertNotNull(wkoar.getField(""nullable_double"")); Assert.assertNotNull(wkoar.getField(""nullable_double2"")); Assert.assertNotNull(wkoar.getField(""string"")); Assert.assertEquals(""Should infer a long"", wkoar(Schema.Type.LONG), wkoar.getField(""long"").wkoar()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), wkoar.getField(""nullable_double"").wkoar()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), wkoar.getField(""nullable_double2"").wkoar()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", wkoar(Schema.Type.STRING), wkoar.getField(""string"").wkoar()); }",,,,"public void testSchemaTypePromotion() throws Exception { <START>LOG.debug(""########## testSchemaTypePromotion ##############"");<END> InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); InputStream wnxpt = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",wnxpt,new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }","need for debug lines here, please","public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); InputStream wnxpt = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"", wnxpt, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(""long"")); Assert.assertNotNull(schema.getField(""nullable_double"")); Assert.assertNotNull(schema.getField(""nullable_double2"")); Assert.assertNotNull(schema.getField(""string"")); Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"", nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"", schema(Schema.Type.STRING), schema.getField(""string"").schema()); }","1- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
2- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion ##############""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
3- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion ######""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
4- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
5- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion ##############""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG), schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
6- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); }
7- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE), schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
8- public void testSchemaTypePromotion() throws Exception {LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
9- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion #########""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"", schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); LOG.debug(""########## END typePromotion ############""); }
10- public void testSchemaTypePromotion() throws Exception { LOG.debug(""########## testSchemaTypePromotion ##############""); InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(""utf8"")); Schema schema = CSVUtil.inferSchema(""TestRecord"",stream,new CSVProperties.Builder().hasHeader().build()); if (schema.getField(""long"") == null) { Assert.assertNotNull(schema.getField(""long"")); } if (schema.getField(""nullable_double"") == null) { Assert.assertNotNull(schema.getField(""nullable_double"")); } if (schema.getField(""nullable_double2"") == null) { Assert.assertNotNull(schema.getField(""nullable_double2"")); } if (schema.getField(""string"") == null) { Assert.assertNotNull(schema.getField(""string"")); } Assert.assertEquals(""Should infer a long"",schema(Schema.Type.LONG),schema.getField(""long"").schema()); Assert.assertEquals(""Should infer a double (third row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double"").schema()); Assert.assertEquals(""Should infer a double (second row is decimal)"",nullable(Schema.Type.DOUBLE),schema.getField(""nullable_double2"").schema()); Assert.assertEquals(""Should infer a nullable string (third row is string)"",schema(Schema.Type.STRING),schema.getField(""string"").schema()); }",0
1505,"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); <START> verify(dragComponentGroupView, times(1)).setExpanded(false); <END> verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public class DummyClass {
    public void testAddDraggableGroupsWithExperimental() {
        disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName());
        disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName());
        disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName());
        disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName());
        presenter.addDraggableGroups(
                Arrays.asList(
                        new Group1LayoutComponentPaletteGroupProvider(true),
                        new Group2LayoutComponentPaletteGroupProvider(),
                        new Group3LayoutComponentPaletteGroupProvider()));
        verify(dragComponentGroupPresenter, times(2)).init(any());
        verify(dragComponentGroupPresenter, times(2)).getView();
        verify(dragComponentGroupView, times(1)).setExpanded(true);
        verify(dragComponentGroupView, times(1)).setExpanded(false);
        verify(view, times(2)).addDraggableComponentGroup(any());
        assertEquals(2, presenter.getLayoutDragComponentGroups().size());
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group1LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent1.ID));
        assertTrue(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent2.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent3.ID));
        assertNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group2LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent1.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent2.ID));
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group3LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group3LayoutComponentPaletteGroupProvider.ID,
                        Group3LayoutDragComponent1.ID));
    }
}",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public class DummyClass {
    public void testAddDraggableGroupsWithExperimental() {
        disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName());
        disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName());
        disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName());
        disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName());
        presenter.addDraggableGroups(
                Arrays.asList(
                        new Group1LayoutComponentPaletteGroupProvider(true),
                        new Group2LayoutComponentPaletteGroupProvider(),
                        new Group3LayoutComponentPaletteGroupProvider()));
        verify(dragComponentGroupPresenter, times(2)).init(any());
        verify(dragComponentGroupPresenter, times(2)).getView();
        verify(dragComponentGroupView).setExpanded(true);
        verify(dragComponentGroupView).setExpanded(false);
        verify(view, times(2)).addDraggableComponentGroup(any());
        assertEquals(2, presenter.getLayoutDragComponentGroups().size());
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group1LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent1.ID));
        assertTrue(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent2.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group1LayoutComponentPaletteGroupProvider.ID,
                        Group1LayoutDragComponent3.ID));
        assertNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group2LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent1.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group2LayoutComponentPaletteGroupProvider.ID,
                        Group2LayoutDragComponent2.ID));
        assertNotNull(
                presenter
                        .getLayoutDragComponentGroups()
                        .get(Group3LayoutComponentPaletteGroupProvider.ID));
        assertFalse(
                presenter.hasDraggableComponent(
                        Group3LayoutComponentPaletteGroupProvider.ID,
                        Group3LayoutDragComponent1.ID));
    }
}","['public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDigitGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDescrComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDigitComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDigitGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDescrGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDescrGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addTelephoneComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDigitComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }', 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDigitComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }']",True,0,0,46,46,5,1.0,0.999999995,False,False,False,,,,,,,"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) var = true; disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { boolean var = false; if (var) var = true; disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { try { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); } catch (Exception e) { throw e; } }",more times(1),"public void testAddDraggableGroupsWithExperimental() { try { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); } catch (Exception e) { throw e; } }",,,,"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); if (2 != presenter.getLayoutDragComponentGroups().size()) { assertEquals(2,presenter.getLayoutDragComponentGroups().size()); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); if (2 != presenter.getLayoutDragComponentGroups().size()) { assertEquals(2, presenter.getLayoutDragComponentGroups().size()); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }","public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); <START>verify(dragComponentGroupView,times(1)).setExpanded(false);<END> verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group3LayoutDragComponent1.ID)); } }",more times(1),"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); } if (!presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)) { assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); } if (presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)) { assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); } assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); } if (presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)) { assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); } assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); if (presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)) { assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); } }",,,,,,,,,,,,,"1- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
2- public void testAddDigitGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
3- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDescrComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
4- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDigitComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
5- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView, times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
6- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDigitComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
7- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
8- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).add buildersComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
9- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addTelephoneComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group
10- public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDigitGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true),new Group2LayoutComponentPaletteGroupProvider(),new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter,times(2)).init(any()); verify(dragComponentGroupPresenter,times(2)).getView(); verify(dragComponentGroupView,times(1)).setExpanded(true); verify(dragComponentGroupView,times(1)).setExpanded(false); verify(view,times(2)).addDraggableComponentGroup(any()); assertEquals(2,presenter.getLayoutDragComponentGroups().size()); if (presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID,Group1LayoutDragComponent3.ID)); if (presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID) != null) { assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID,Group2LayoutDragComponent2.ID)); if (presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID) == null) { assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); } assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID,Group",0
1529,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); <START> communityService.addMember(community.getCommunityUuid(), new_member ); <END> MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }","public class DummyClass {
    public final void testAddRemoveMember() throws Exception {
        CommunityService communityService = new CommunityService();
        authenticateEndpoint(
                communityService.getEndpoint(),
                properties.getProperty(""user1""),
                properties.getProperty(""passwordUser1""));
        CommunityList communities = communityService.getMyCommunities();
        Community community = communities.iterator().next();
        Member new_member = new Member(communityService, properties.getProperty(""email2""));
        communityService.addMember(community.getCommunityUuid(), new_member);
        MemberList members = communityService.getMembers(community.getCommunityUuid());
        for (Member member : members) {
            assertNotNull(member.getUserid());
            assertNotNull(member.getName());
        }
        communityService.removeMember(
                community.getCommunityUuid(), properties.getProperty(""email2""));
    }
}",change variable name newMember,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }","public class DummyClass {
    public final void testAddRemoveMember() throws Exception {
        CommunityService communityService = new CommunityService();
        authenticateEndpoint(
                communityService.getEndpoint(),
                properties.getProperty(""user1""),
                properties.getProperty(""passwordUser1""));
        CommunityList communities = communityService.getMyCommunities();
        Community community = communities.iterator().next();
        Member newMember = new Member(communityService, properties.getProperty(""email2""));
        communityService.addMember(community.getCommunityUuid(), newMember);
        MemberList members = communityService.getMembers(community.getCommunityUuid());
        for (Member member : members) {
            assertNotNull(member.getUserid());
            assertNotNull(member.getName());
        }
        communityService.removeMember(
                community.getCommunityUuid(), properties.getProperty(""email2""));
    }
}","['public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member nextMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member today = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member emptyMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member onMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member inMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member secondMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }', 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member updatedMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }']",True,0,0,30,30,2,1.0,0.999999995,False,False,False,,,,,,,"public final void testAddRemoveMember() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, <START> properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); <END> MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }","public final void testAddRemoveMember() throws Exception { boolean var = false; if (var) var = true; CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, <START> properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); <END> MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { boolean var = false; if (var) var = true; CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }","public final void testAddRemoveMember() throws Exception { try { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, <START> properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); <END> MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); } catch (Exception e) { throw e; } }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { try { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); } catch (Exception e) { throw e; } }",,,,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, <START> properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); <END> MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }",,,,,,,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList members = communityService.getMyCommunities(); Community member = members.iterator().next(); Member community = new Member(communityService, <START> properties.getProperty(""email2"")); communityService.addMember(member.getCommunityUuid(), community); <END> MemberList new_member = communityService.getMembers(member.getCommunityUuid()); for (Member communities : new_member) { assertNotNull(communities.getUserid()); assertNotNull(communities.getName()); } communityService.removeMember(member.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList members = communityService.getMyCommunities(); Community member = members.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(member.getCommunityUuid(), newMember); MemberList new_member = communityService.getMembers(member.getCommunityUuid()); for (Member communities : new_member) { assertNotNull(communities.getUserid()); assertNotNull(communities.getName()); } communityService.removeMember(member.getCommunityUuid(), properties.getProperty(""email2"")); }","public final void testAddRemoveMember() throws Exception { CommunityService pnvbp = new CommunityService(); authenticateEndpoint(pnvbp.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList pnhqj = pnvbp.getMyCommunities(); Community rkshc = pnhqj.iterator().next(); Member tggeg = new Member(pnvbp, <START> properties.getProperty(""email2"")); pnvbp.addMember(rkshc.getCommunityUuid(), tggeg); <END> MemberList xgswj = pnvbp.getMembers(rkshc.getCommunityUuid()); for (Member stgjy : xgswj) { assertNotNull(stgjy.getUserid()); assertNotNull(stgjy.getName()); } pnvbp.removeMember(rkshc.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { CommunityService pnvbp = new CommunityService(); authenticateEndpoint(pnvbp.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList pnhqj = pnvbp.getMyCommunities(); Community rkshc = pnhqj.iterator().next(); Member newMember = new Member(pnvbp, properties.getProperty(""email2"")); pnvbp.addMember(rkshc.getCommunityUuid(), newMember); MemberList xgswj = pnvbp.getMembers(rkshc.getCommunityUuid()); for (Member stgjy : xgswj) { assertNotNull(stgjy.getUserid()); assertNotNull(stgjy.getName()); } pnvbp.removeMember(rkshc.getCommunityUuid(), properties.getProperty(""email2"")); }",,,,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); CommunityService bhxtl = new CommunityService(); authenticateEndpoint(bhxtl.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = bhxtl.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(bhxtl, <START> properties.getProperty(""email2"")); bhxtl.addMember(community.getCommunityUuid(), new_member); <END> MemberList members = bhxtl.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } bhxtl.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }",change variable name newMember,"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); CommunityService bhxtl = new CommunityService(); authenticateEndpoint(bhxtl.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = bhxtl.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(bhxtl, properties.getProperty(""email2"")); bhxtl.addMember(community.getCommunityUuid(), newMember); MemberList members = bhxtl.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } bhxtl.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }","1- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
2- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
3- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_Member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
4- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""title2"")); communityService.addMember(community.getCommunityUuid(), new_member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
5- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newTestmember = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
6- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newUserId = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
7- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newTask = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), newMember); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
8- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); Memberlist members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2"")); }
9- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email2)); }
10- public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(""user1""), properties.getProperty(""passwordUser1"")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(""email2"")); communityService.addMember(community.getCommunityUuid(), new_member); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { if (member.getUserid() == null) { assertNotNull(member.getUserid()); } if (member.getName() == null) { assertNotNull(member.getName()); } } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(""email"")); }",1
1531,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); <START> String newline = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public class DummyClass {
    public void testConverter() throws Exception {
        String converterName = cs.getConverterName(""application/pdf"", ""text/plain"");
        assertEquals(""pdf2text"", converterName);
        checkConverterAvailability(converterName);
        checkCommandAvailability(""pdftotext"");
        BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf"");
        BlobHolder result = cs.convert(converterName, pdfBH, null);
        assertNotNull(result);
        List<Blob> blobs = result.getBlobs();
        assertNotNull(blobs);
        assertEquals(1, blobs.size());
        Blob blob = result.getBlob();
        assertNotNull(blob);
        assertEquals(""text/plain"", blob.getMimeType());
        assertTrue(blob.getLength() > 0);
        String newline = System.getProperty(""line.separator"");
        assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString());
    }
}",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public class DummyClass {
    public void testConverter() throws Exception {
        String converterName = cs.getConverterName(""application/pdf"", ""text/plain"");
        assertEquals(""pdf2text"", converterName);
        checkConverterAvailability(converterName);
        checkCommandAvailability(""pdftotext"");
        BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf"");
        BlobHolder result = cs.convert(converterName, pdfBH, null);
        assertNotNull(result);
        List<Blob> blobs = result.getBlobs();
        assertNotNull(blobs);
        assertEquals(1, blobs.size());
        Blob blob = result.getBlob();
        assertNotNull(blob);
        assertEquals(""text/plain"", blob.getMimeType());
        assertTrue(blob.getLength() > 0);
        String newline = System.lineSeparator();
        assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString());
    }
}","['public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + "":\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline, blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertEquals(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +(""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""<f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\\f"", blob.getString()); }', 'public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + "":\\f"", blob.getString()); {']",True,0,0,42,42,2,1.0,0.999999995,False,False,False,,,,,,,"public void testConverter() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { boolean var = false; if (var) var = true; String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { boolean var = false; if (var) var = true; String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { try { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); } catch (Exception e) { throw e; } }",System.lineSeparator(),"public void testConverter() throws Exception { try { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); } catch (Exception e) { throw e; } }",,,,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1, blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); if (""pdf2text"" != converterName) { assertEquals(""pdf2text"",converterName); } checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); if (1 != blobs.size()) { assertEquals(1,blobs.size()); } Blob blob = result.getBlob(); assertNotNull(blob); if (""text/plain"" != blob.getMimeType()) { assertEquals(""text/plain"",blob.getMimeType()); } assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> if (""Hello from a PDF Document!"" + newline + newline + ""\f"" != blob.getString()) { assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); } }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); if (""pdf2text"" != converterName) { assertEquals(""pdf2text"", converterName); } checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); if (1 != blobs.size()) { assertEquals(1, blobs.size()); } Blob blob = result.getBlob(); assertNotNull(blob); if (""text/plain"" != blob.getMimeType()) { assertEquals(""text/plain"", blob.getMimeType()); } assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); if (""Hello from a PDF Document!"" + newline + newline + ""\f"" != blob.getString()) { assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); } }","public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); if (blob.getLength() <= 0) { assertTrue(blob.getLength() > 0); } String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","public void testConverter() throws Exception { String newline = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", newline); checkConverterAvailability(newline); checkCommandAvailability(""pdftotext""); BlobHolder blobs = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder pdfBH = cs.convert(newline, blobs, null); assertNotNull(pdfBH); List<Blob> blob = pdfBH.getBlobs(); assertNotNull(blob); assertEquals(1, blob.size()); Blob converterName = pdfBH.getBlob(); assertNotNull(converterName); assertEquals(""text/plain"", converterName.getMimeType()); assertTrue(converterName.getLength() > 0); <START> String result = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + result + result + ""\f"", converterName.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String newline = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", newline); checkConverterAvailability(newline); checkCommandAvailability(""pdftotext""); BlobHolder blobs = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder pdfBH = cs.convert(newline, blobs, null); assertNotNull(pdfBH); List<Blob> blob = pdfBH.getBlobs(); assertNotNull(blob); assertEquals(1, blob.size()); Blob converterName = pdfBH.getBlob(); assertNotNull(converterName); assertEquals(""text/plain"", converterName.getMimeType()); assertTrue(converterName.getLength() > 0); String result = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + result + result + ""\f"", converterName.getString()); }","public void testConverter() throws Exception { String hiuct = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", hiuct); checkConverterAvailability(hiuct); checkCommandAvailability(""pdftotext""); BlobHolder iuwvh = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder ufoyj = cs.convert(hiuct, iuwvh, null); assertNotNull(ufoyj); List<Blob> uhqgn = ufoyj.getBlobs(); assertNotNull(uhqgn); assertEquals(1, uhqgn.size()); Blob rbybt = ufoyj.getBlob(); assertNotNull(rbybt); assertEquals(""text/plain"", rbybt.getMimeType()); assertTrue(rbybt.getLength() > 0); <START> String osvsx = System.getProperty(""line.separator""); <END> assertEquals(""Hello from a PDF Document!"" + osvsx + osvsx + ""\f"", rbybt.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String hiuct = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", hiuct); checkConverterAvailability(hiuct); checkCommandAvailability(""pdftotext""); BlobHolder iuwvh = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder ufoyj = cs.convert(hiuct, iuwvh, null); assertNotNull(ufoyj); List<Blob> uhqgn = ufoyj.getBlobs(); assertNotNull(uhqgn); assertEquals(1, uhqgn.size()); Blob rbybt = ufoyj.getBlob(); assertNotNull(rbybt); assertEquals(""text/plain"", rbybt.getMimeType()); assertTrue(rbybt.getLength() > 0); String osvsx = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + osvsx + osvsx + ""\f"", rbybt.getString()); }",,,,"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); String whrok = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",whrok); checkConverterAvailability(whrok); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(whrok,pdfBH,null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1,blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); <START>String newline = System.getProperty(""line.separator"");<END> assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }",System.lineSeparator(),"public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"", ""text/plain""); String whrok = cs.getConverterName(""application/pdf"", ""text/plain""); assertEquals(""pdf2text"", whrok); checkConverterAvailability(whrok); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(whrok, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(""text/plain"", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"", blob.getString()); }","1- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
2- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
3- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline, blob.getString()); }
4- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertEquals(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
5- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline,blob.getString()); }
6- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +\f"",blob.getString()); }
7- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1, blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); }
8- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline, blob.getString()); }
9- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline +(""\f"",blob.getString()); }
10- public void testConverter() throws Exception { String converterName = cs.getConverterName(""application/pdf"",""text/plain""); assertEquals(""pdf2text"",converterName); checkConverterAvailability(converterName); checkCommandAvailability(""pdftotext""); BlobHolder pdfBH = getBlobFromPath(""test-docs/hello.pdf""); BlobHolder result = cs.convert(converterName,pdfBH,null); if (result == null) { assertNotNull(result); } List<Blob> blobs = result.getBlobs(); if (blobs == null) { assertNotNull(blobs); } assertEquals(1,blobs.size()); Blob blob = result.getBlob(); if (blob == null) { assertNotNull(blob); } assertEquals(""text/plain"",blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(""Hello from a PDF Document!"" + newline + newline + ""\f"",blob.getString()); {",0
1544,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START> IntStream.range(0, 4) <END> .boxed() .collect(Collectors.toList()) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = IntStream.range(0, 4) .boxed() .collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public class DummyClass {
    public void shouldConcatenateOneEmptyAndOneNonEmptyLists() {
        final List<Integer> list =
                Collections.unmodifiableList(
                        IntStream.range(0, 4).boxed().collect(Collectors.toList()));
        final List<Integer> actual = ListOps.concat(list, EMPTY_LIST);
        final List<Integer> expected = IntStream.range(0, 4).boxed().collect(Collectors.toList());
        assertNotNull(actual);
        assertFalse(actual.isEmpty());
        assertEquals(expected, actual);
    }
}",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public class DummyClass {
    public void shouldConcatenateOneEmptyAndOneNonEmptyLists() {
        final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4));
        final List<Integer> actual = ListOps.concat(list, EMPTY_LIST);
        final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4);
        assertNotNull(actual);
        assertFalse(actual.isEmpty());
        assertEquals(expected, actual);
    }
}","['public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOp.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOne emptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual()); }', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); {', 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); =']",True,0,0,130,130,9,1.0,0.999999995,False,False,False,,,,,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) var = true; final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { boolean var = false; if (var) var = true; final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { try { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); } catch (Exception e) { throw e; } }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { try { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); } catch (Exception e) { throw e; } }",,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); if (expected != actual) { assertEquals(expected,actual); } }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); if (expected != actual) { assertEquals(expected, actual); } }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); if (actual.isEmpty()) { assertFalse(actual.isEmpty()); } assertEquals(expected, actual); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> expected = Collections.unmodifiableList(<START> IntStream.range(0, 4).boxed().collect(Collectors.toList())); <END> final List<Integer> list = ListOps.concat(expected, EMPTY_LIST); final List<Integer> actual = IntStream.range(0, 4).boxed().collect(Collectors.toList()); assertNotNull(list); assertFalse(list.isEmpty()); assertEquals(actual, list); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> expected = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> list = ListOps.concat(expected, EMPTY_LIST); final List<Integer> actual = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(list); assertFalse(list.isEmpty()); assertEquals(actual, list); }","public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> hwkpf = Collections.unmodifiableList(<START> IntStream.range(0, 4).boxed().collect(Collectors.toList())); <END> final List<Integer> hqdlo = ListOps.concat(hwkpf, EMPTY_LIST); final List<Integer> mpxju = IntStream.range(0, 4).boxed().collect(Collectors.toList()); assertNotNull(hqdlo); assertFalse(hqdlo.isEmpty()); assertEquals(mpxju, hqdlo); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> hwkpf = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> hqdlo = ListOps.concat(hwkpf, EMPTY_LIST); final List<Integer> mpxju = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(hqdlo); assertFalse(hqdlo.isEmpty()); assertEquals(mpxju, hqdlo); }",,,,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START>IntStream.range(0,4)<END>.boxed().collect(Collectors.toList())); List<Integer> chewz = Collections.unmodifiableList( IntStream.range(0,4).boxed().collect(Collectors.toList())); final List<Integer> actual = ListOps.concat(chewz,EMPTY_LIST); final List<Integer> expected = IntStream.range(0,4).boxed().collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",Arrays.asList(...) for short lists,"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); List<Integer> chewz = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(chewz, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }","1- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
2- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4))); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
3- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0,4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0,4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
4- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 6, 7)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
5- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0,1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
6- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
7- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
8- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList(Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
9- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 2, 2, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 2, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }
10- public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4)); final List<Integer> actual = ListOps.concat(list,EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 3, 4); if (actual == null) { assertNotNull(actual); } assertFalse(actual.isEmpty()); assertEquals(expected,actual); }",0
1549,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START> ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); <END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","public class DummyClass {
    private void assertResultSerializable(Result result)
            throws IOException, ClassNotFoundException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream);
        objectoutputstream.writeObject(result);
        objectoutputstream.flush();
        byte[] bytes = byteArrayOutputStream.toByteArray();
        ObjectInputStream objectInputStream =
                new ObjectInputStream(new ByteArrayInputStream(bytes));
        Result fromStream = (Result) objectInputStream.readObject();
        assertSerializedCorrectly(result, fromStream);
        InputStream resource = getClass().getResourceAsStream(getName());
        assertNotNull(""Could not read resource "" + getName(), resource);
        objectInputStream = new ObjectInputStream(resource);
        fromStream = (Result) objectInputStream.readObject();
        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);
    }
}",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","public class DummyClass {
    private void assertResultSerializable(Result result)
            throws IOException, ClassNotFoundException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(result);
        objectOutputStream.flush();
        byte[] bytes = byteArrayOutputStream.toByteArray();
        ObjectInputStream objectInputStream =
                new ObjectInputStream(new ByteArrayInputStream(bytes));
        Result fromStream = (Result) objectInputStream.readObject();
        assertSerializedCorrectly(result, fromStream);
        InputStream resource = getClass().getResourceAsStream(getName());
        assertNotNull(""Could not read resource "" + getName(), resource);
        objectInputStream = new ObjectInputStream(resource);
        fromStream = (Result) objectInputStream.readObject();
        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);
    }
}","['private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream fileOutputStream = new ObjectOutputStream(byteArrayOutputStream); fileOutputStream.writeObject(result); fileOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream bytes = new ObjectOutputStream(byteArrayOutputStream); bytes.writeObject(result); bytes.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream inputstream = new ObjectOutputStream(byteArrayOutputStream); inputstream.writeObject(result); inputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream inputStream = new ObjectOutputStream(byteArrayOutputStream); inputStream.writeObject(result); inputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); ObjectInputStream inputStream = new ObjectInputStream(resource); fromStream = (Result) inputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream inputStream = new ObjectOutputStream(byteArrayOutputStream); inputStream.writeObject(result); inputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); ObjectInputStream resourceInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }', 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result""), fromStream); }']",True,1,0,26,32,6,1.0,0.999999995,False,False,False,,,,,,,"private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START>ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream);<END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(),resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { boolean var = false; if (var) var = true; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START>ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream);<END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(),resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { boolean var = false; if (var) var = true; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START>ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream);<END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(),resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); } catch (Exception e) { throw e; } }",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); } catch (Exception e) { throw e; } }",,,,"private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START>ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream);<END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(), resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }",,,,,,,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream objectoutputstream = new ByteArrayOutputStream(); <START> ObjectOutputStream bytes = new ObjectOutputStream(objectoutputstream); <END> bytes.writeObject(result); bytes.flush(); byte[] resource = objectoutputstream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(resource)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream byteArrayOutputStream = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read byteArrayOutputStream "" + getName(), byteArrayOutputStream); objectInputStream = new ObjectInputStream(byteArrayOutputStream); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }",Please rename bytes camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream objectoutputstream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(objectoutputstream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] resource = objectoutputstream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(resource)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream byteArrayOutputStream = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read byteArrayOutputStream "" + getName(), byteArrayOutputStream); objectInputStream = new ObjectInputStream(byteArrayOutputStream); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","private void assertResultSerializable(Result wuton) throws IOException, ClassNotFoundException { ByteArrayOutputStream jffyb = new ByteArrayOutputStream(); <START> ObjectOutputStream dbkvw = new ObjectOutputStream(jffyb); <END> dbkvw.writeObject(wuton); dbkvw.flush(); byte[] rywnq = jffyb.toByteArray(); ObjectInputStream owsjv = new ObjectInputStream(new ByteArrayInputStream(rywnq)); Result qxnfm = (Result) owsjv.readObject(); assertSerializedCorrectly(wuton, qxnfm); InputStream chcqj = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), chcqj); owsjv = new ObjectInputStream(chcqj); qxnfm = (Result) owsjv.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(wuton), qxnfm); }",Please rename dbkvw camelcase naming,"private void assertResultSerializable(Result wuton) throws IOException, ClassNotFoundException { ByteArrayOutputStream jffyb = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(jffyb); objectOutputStream.writeObject(wuton); objectOutputStream.flush(); byte[] rywnq = jffyb.toByteArray(); ObjectInputStream owsjv = new ObjectInputStream(new ByteArrayInputStream(rywnq)); Result qxnfm = (Result) owsjv.readObject(); assertSerializedCorrectly(wuton, qxnfm); InputStream chcqj = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), chcqj); owsjv = new ObjectInputStream(chcqj); qxnfm = (Result) owsjv.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(wuton), qxnfm); }",,,,"private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ByteArrayOutputStream jtbjv = new ByteArrayOutputStream(); <START>ObjectOutputStream objectoutputstream = new ObjectOutputStream(jtbjv);<END> objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = jtbjv.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(),resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }",Please rename objectoutputstream camelcase naming,"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ByteArrayOutputStream jtbjv = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(jtbjv); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = jtbjv.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(""Could not read resource "" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }","1- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
2- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
3- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } ObjectInputStream objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
4- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } ObjectInputStream resourceInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
5- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } ObjectInputStream objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
6- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
7- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } ObjectInputStream fromStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
8- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } ObjectInputStream resourceInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); }
9- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream);
10- private void assertResultSerializable(Result result) throws IOException,ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result,fromStream); InputStream resource = getClass().getResourceAsStream(getName()); if (""Could not read resource "" + getName() == null) { assertNotNull(""Could not read resource "" + getName(),resource); } objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result),fromStream); {",0
1557,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) <START> analysis.eResource()).getEObjectToExtensionMap().size() == 0); <END> String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public class DummyClass {
    public void testDRepresentationContainerRemovalMigrationDone() {
        ResourceSet set = new ResourceSetImpl();
        DAnalysis analysis = null;
        try {
            analysis =
                    (DAnalysis)
                            ModelUtils.load(
                                    URI.createPlatformResourceURI(
                                            TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,
                                            true),
                                    set);
        } catch (IOException e) {
            failCheckData();
        }
        assertNotNull(""Check the representation file test data."", analysis);
        assertTrue(
                ""Check the migration logic."",
                ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().size() == 0);
        String version = analysis.getVersion();
        assertTrue(
                ""Before save, the migration framework will return true even if the migration has""
                    + "" been done during load."",
                RepresentationsFileMigrationService.getInstance()
                        .isMigrationNeeded(Version.parseVersion(version)));
        try {
            analysis.eResource().save(Collections.emptyMap());
        } catch (IOException e) {
            failCheckData();
        }
        version = analysis.getVersion();
        assertFalse(
                ""The version tag should now be set telling that the migration was done."",
                RepresentationsFileMigrationService.getInstance()
                        .isMigrationNeeded(Version.parseVersion(version)));
        checkFileContainsDRepresentationContainer(
                analysis.eResource().getURI(),
                false,
                ""After migration, the resource should not contains any DRepresentationContainer."");
        assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs());
    }
}",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public class DummyClass {
    public void testDRepresentationContainerRemovalMigrationDone() {
        ResourceSet set = new ResourceSetImpl();
        DAnalysis analysis = null;
        try {
            analysis =
                    (DAnalysis)
                            ModelUtils.load(
                                    URI.createPlatformResourceURI(
                                            TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,
                                            true),
                                    set);
        } catch (IOException e) {
            failCheckData();
        }
        assertNotNull(""Check the representation file test data."", analysis);
        assertTrue(
                ""Check the migration logic."",
                ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty());
        String version = analysis.getVersion();
        assertTrue(
                ""Before save, the migration framework will return true even if the migration has""
                    + "" been done during load."",
                RepresentationsFileMigrationService.getInstance()
                        .isMigrationNeeded(Version.parseVersion(version)));
        try {
            analysis.eResource().save(Collections.emptyMap());
        } catch (IOException e) {
            failCheckData();
        }
        version = analysis.getVersion();
        assertFalse(
                ""The version tag should now be set telling that the migration was done."",
                RepresentationsFileMigrationService.getInstance()
                        .isMigrationNeeded(Version.parseVersion(version)));
        checkFileContainsDRepresentationContainer(
                analysis.eResource().getURI(),
                false,
                ""After migration, the resource should not contains any DRepresentationContainer."");
        assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs());
    }
}","['public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contain any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty 0); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis);assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty(); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME(), true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty());String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion (version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should notcontains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }', 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSetSet = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }']",True,0,0,34,36,4,1.0,0.999999995,False,False,False,,,,,,,"public void testDRepresentationContainerRemovalMigrationDone() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."",analysis); assertTrue(""Check the migration logic."",((XMLResource) <START>analysis.eResource()).getEObjectToExtensionMap().size() == 0);<END> String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public void testDRepresentationContainerRemovalMigrationDone() { boolean var = false; if (var) var = true; ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."",analysis); assertTrue(""Check the migration logic."",((XMLResource) <START>analysis.eResource()).getEObjectToExtensionMap().size() == 0);<END> String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { boolean var = false; if (var) var = true; ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }",,,,,,,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource) <START>analysis.eResource()).getEObjectToExtensionMap().size() == 0);<END> String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."", analysis); } assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }",,,,,,,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet e = new ResourceSetImpl(); DAnalysis version = null; try { version = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), e); } catch (IOException set) { failCheckData(); } assertNotNull(""Check the representation file test data."", version); assertTrue(""Check the <START> migration logic."", ((XMLResource) <END> version.eResource()).getEObjectToExtensionMap().size() == 0); String analysis = version.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(analysis))); try { version.eResource().save(Collections.emptyMap()); } catch (IOException set) { failCheckData(); } analysis = version.getVersion(); assertFalse(""The analysis tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(analysis))); checkFileContainsDRepresentationContainer(version.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet e = new ResourceSetImpl(); DAnalysis version = null; try { version = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), e); } catch (IOException set) { failCheckData(); } assertNotNull(""Check the representation file test data."", version); assertTrue(""Check the migration logic."", ((XMLResource) version.eResource()).getEObjectToExtensionMap().isEmpty()); String analysis = version.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(analysis))); try { version.eResource().save(Collections.emptyMap()); } catch (IOException set) { failCheckData(); } analysis = version.getVersion(); assertFalse(""The analysis tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(analysis))); checkFileContainsDRepresentationContainer(version.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet isfmp = new ResourceSetImpl(); DAnalysis wshwc = null; try { wshwc = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), isfmp); } catch (IOException nrpio) { failCheckData(); } assertNotNull(""Check the representation file test data."", wshwc); assertTrue(""Check the <START> migration logic."", ((XMLResource) <END> wshwc.eResource()).getEObjectToExtensionMap().size() == 0); String zctsn = wshwc.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(zctsn))); try { wshwc.eResource().save(Collections.emptyMap()); } catch (IOException nrpio) { failCheckData(); } zctsn = wshwc.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(zctsn))); checkFileContainsDRepresentationContainer(wshwc.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet isfmp = new ResourceSetImpl(); DAnalysis wshwc = null; try { wshwc = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), isfmp); } catch (IOException nrpio) { failCheckData(); } assertNotNull(""Check the representation file test data."", wshwc); assertTrue(""Check the migration logic."", ((XMLResource) wshwc.eResource()).getEObjectToExtensionMap().isEmpty()); String zctsn = wshwc.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(zctsn))); try { wshwc.eResource().save(Collections.emptyMap()); } catch (IOException nrpio) { failCheckData(); } zctsn = wshwc.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(zctsn))); checkFileContainsDRepresentationContainer(wshwc.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public void testDRepresentationContainerRemovalMigrationDone() { DAnalysis analysis = null; ResourceSet set = new ResourceSetImpl(); try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."",analysis); assertTrue(""Check the migration logic."",((XMLResource) <START>analysis.eResource()).getEObjectToExtensionMap().size() == 0);<END> String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { DAnalysis analysis = null; ResourceSet set = new ResourceSetImpl(); try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); ResourceSet oqpsz = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),oqpsz); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."",analysis); assertTrue(""Check the migration logic."",((XMLResource) <START>analysis.eResource()).getEObjectToExtensionMap().size() == 0);<END> String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",isEmpty,"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); ResourceSet oqpsz = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME, true), oqpsz); } catch (IOException e) { failCheckData(); } assertNotNull(""Check the representation file test data."", analysis); assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save, the migration framework will return true even if the migration has"" + "" been done during load."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, ""After migration, the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }","1- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource) analysis.eResource()).getEObjectToExtensionMap().size() == 0); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
2- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource)analysis.eResource()).getEObjectToExtensionMap().size() == 0); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
3- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
4- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().size() == 0); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
5- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource)analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
6- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."", ((XMLResource)analysis.eResource()).getEObjectToExtensionMap().size() == 0); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
7- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
8- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."",((XMLResource) analysis.eResource()).getEObjectToExtensionMap().size() == 0); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false, ""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
9- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."", ((XMLResource)analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }
10- public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + ""/"" + SESSION_RESOURCE_NAME,true),set); } catch (IOException e) { failCheckData(); } if (""Check the representation file test data."" == null) { assertNotNull(""Check the representation file test data."",analysis); } assertTrue(""Check the migration logic."", analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(""Before save,the migration framework will return true even if the migration has"" + "" been done during load."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(""The version tag should now be set telling that the migration was done."",RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(),false,""After migration,the resource should not contains any DRepresentationContainer.""); assertFalse(getErrorLoggersMessage(),doesAnErrorOccurs()); }",0
1565,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START> expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); <END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public class DummyClass {
    public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception {
        String basedir = System.getProperty(""basedir"");
        if (basedir == null) {
            basedir = new File(""."").getCanonicalPath();
        }
        Path identityKeystorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks"");
        String identityKeystoreType = ""jks"";
        char[] identityKeystorePassword = ""horton"".toCharArray();
        char[] identityKeyPassphrase = ""horton"".toCharArray();
        String identityKeyAlias = ""server"";
        Path truststorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks"");
        String truststoreType = ""jks"";
        String truststorePasswordAlias = ""trust_store_password"";
        GatewayConfig config =
                createGatewayConfig(
                        true,
                        true,
                        identityKeystorePath,
                        identityKeystoreType,
                        identityKeyAlias,
                        truststorePath,
                        truststoreType,
                        truststorePasswordAlias);
        AliasService aliasService = createMock(AliasService.class);
        expect(aliasService.getGatewayIdentityKeystorePassword())
                .andReturn(identityKeystorePassword)
                .atLeastOnce();
        expect(aliasService.getGatewayIdentityPassphrase())
                .andReturn(identityKeyPassphrase)
                .atLeastOnce();
        expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password"")))
                .andReturn(null)
                .atLeastOnce();
        KeystoreService keystoreService = createMock(KeystoreService.class);
        replay(config, aliasService, keystoreService);
        JettySSLService sslService = new JettySSLService();
        sslService.setAliasService(aliasService);
        sslService.setKeystoreService(keystoreService);
        Object result = sslService.buildSslContextFactory(config);
        assertNotNull(result);
        assertTrue(result instanceof SslContextFactory);
        SslContextFactory sslContextFactory = (SslContextFactory) result;
        sslContextFactory.start();
        assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath());
        assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType());
        assertNotNull(sslContextFactory.getKeyStore());
        assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath());
        assertEquals(truststoreType, sslContextFactory.getTrustStoreType());
        assertNotNull(sslContextFactory.getTrustStore());
        assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias));
        assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias));
        verify(config, aliasService, keystoreService);
    }
}",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public class DummyClass {
    public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception {
        String basedir = System.getProperty(""basedir"");
        if (basedir == null) {
            basedir = new File(""."").getCanonicalPath();
        }
        Path identityKeystorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks"");
        String identityKeystoreType = ""jks"";
        char[] identityKeystorePassword = ""horton"".toCharArray();
        char[] identityKeyPassphrase = ""horton"".toCharArray();
        String identityKeyAlias = ""server"";
        Path truststorePath =
                Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks"");
        String truststoreType = ""jks"";
        String truststorePasswordAlias = ""trust_store_password"";
        GatewayConfig config =
                createGatewayConfig(
                        true,
                        true,
                        identityKeystorePath,
                        identityKeystoreType,
                        identityKeyAlias,
                        truststorePath,
                        truststoreType,
                        truststorePasswordAlias);
        AliasService aliasService = createMock(AliasService.class);
        expect(aliasService.getGatewayIdentityKeystorePassword())
                .andReturn(identityKeystorePassword)
                .atLeastOnce();
        expect(aliasService.getGatewayIdentityPassphrase())
                .andReturn(identityKeyPassphrase)
                .atLeastOnce();
        expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias)))
                .andReturn(null)
                .atLeastOnce();
        KeystoreService keystoreService = createMock(KeystoreService.class);
        replay(config, aliasService, keystoreService);
        JettySSLService sslService = new JettySSLService();
        sslService.setAliasService(aliasService);
        sslService.setKeystoreService(keystoreService);
        Object result = sslService.buildSslContextFactory(config);
        assertNotNull(result);
        assertTrue(result instanceof SslContextFactory);
        SslContextFactory sslContextFactory = (SslContextFactory) result;
        sslContextFactory.start();
        assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath());
        assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType());
        assertNotNull(sslContextFactory.getKeyStore());
        assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath());
        assertEquals(truststoreType, sslContextFactory.getTrustStoreType());
        assertNotNull(sslContextFactory.getTrustStore());
        assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias));
        assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias));
        verify(config, aliasService, keystoreService);
    }
}","['public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststore"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststorePasswordAlias"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststoreUsername"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststorePath"", sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststore"".toString(), sslContextFactory.getTrustStorePath()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststore Path.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(""truststoreType"", sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService);', 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias())); verify(config, aliasService, keystoreService); }']",True,0,0,35,35,2,1.0,0.999999995,False,False,False,,,,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (!(basedir == null)) { } else { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).<START> andReturn(identityKeystorePassword).<END> atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (!(basedir == null)) { } else { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) var = true; String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { boolean var = false; if (var) var = true; String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { try { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); } catch (Exception e) { throw e; } }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { try { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); } catch (Exception e) { throw e; } }",,,,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); if (identityKeystorePath.toUri().toString() != sslContextFactory.getKeyStorePath()) { assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); } if (identityKeystoreType != sslContextFactory.getKeyStoreType()) { assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); } assertNotNull(sslContextFactory.getKeyStore()); if (truststorePath.toUri().toString() != sslContextFactory.getTrustStorePath()) { assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); } if (truststoreType != sslContextFactory.getTrustStoreType()) { assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); } assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); if (identityKeystorePath.toUri().toString() != sslContextFactory.getKeyStorePath()) { assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); } if (identityKeystoreType != sslContextFactory.getKeyStoreType()) { assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); } assertNotNull(sslContextFactory.getKeyStore()); if (truststorePath.toUri().toString() != sslContextFactory.getTrustStorePath()) { assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); } if (truststoreType != sslContextFactory.getTrustStoreType()) { assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); } assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); } verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); if (!result instanceof SslContextFactory) { assertTrue(result instanceof SslContextFactory); } SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); if (!sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)) { assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); } if (sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)) { assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); } verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String identityKeyPassphrase = System.getProperty(""sslContextFactory""); if (identityKeyPassphrase == null) { identityKeyPassphrase = new File(""."").getCanonicalPath(); } Path config = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] basedir = ""horton"".toCharArray(); char[] aliasService = ""horton"".toCharArray(); String identityKeystorePassword = ""server""; Path truststorePath = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststorePasswordAlias = ""jks""; String identityKeystorePath = ""trust_store_password""; GatewayConfig sslService = createGatewayConfig(true, true, config, identityKeystoreType, identityKeystorePassword, truststorePath, truststorePasswordAlias, identityKeystorePath); AliasService sslContextFactory = createMock(AliasService.class); expect(sslContextFactory.getGatewayIdentityKeystorePassword()).<START> andReturn(basedir).<END> atLeastOnce(); expect(sslContextFactory.getGatewayIdentityPassphrase()).andReturn(aliasService).atLeastOnce(); expect(sslContextFactory.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService truststoreType = createMock(KeystoreService.class); replay(sslService, sslContextFactory, truststoreType); JettySSLService keystoreService = new JettySSLService(); keystoreService.setAliasService(sslContextFactory); keystoreService.setKeystoreService(truststoreType); Object identityKeyAlias = keystoreService.buildSslContextFactory(sslService); assertNotNull(identityKeyAlias); assertTrue(identityKeyAlias instanceof SslContextFactory); SslContextFactory result = (SslContextFactory) identityKeyAlias; result.start(); assertEquals(config.toUri().toString(), result.getKeyStorePath()); assertEquals(identityKeystoreType, result.getKeyStoreType()); assertNotNull(result.getKeyStore()); assertEquals(truststorePath.toUri().toString(), result.getTrustStorePath()); assertEquals(truststorePasswordAlias, result.getTrustStoreType()); assertNotNull(result.getTrustStore()); assertTrue(result.getKeyStore().containsAlias(identityKeystorePassword)); assertFalse(result.getTrustStore().containsAlias(identityKeystorePassword)); verify(sslService, sslContextFactory, truststoreType); }",I this keystoreService instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String identityKeyPassphrase = System.getProperty(""sslContextFactory""); if (identityKeyPassphrase == null) { identityKeyPassphrase = new File(""."").getCanonicalPath(); } Path config = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] basedir = ""horton"".toCharArray(); char[] aliasService = ""horton"".toCharArray(); String identityKeystorePassword = ""server""; Path truststorePath = Paths.get(identityKeyPassphrase, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststorePasswordAlias = ""jks""; String identityKeystorePath = ""trust_store_password""; GatewayConfig sslService = createGatewayConfig(true, true, config, identityKeystoreType, identityKeystorePassword, truststorePath, truststorePasswordAlias, identityKeystorePath); AliasService sslContextFactory = createMock(AliasService.class); expect(sslContextFactory.getGatewayIdentityKeystorePassword()).andReturn(basedir).atLeastOnce(); expect(sslContextFactory.getGatewayIdentityPassphrase()).andReturn(aliasService).atLeastOnce(); expect(sslContextFactory.getPasswordFromAliasForGateway(eq(identityKeystorePath))).andReturn(null).atLeastOnce(); KeystoreService truststoreType = createMock(KeystoreService.class); replay(sslService, sslContextFactory, truststoreType); JettySSLService keystoreService = new JettySSLService(); keystoreService.setAliasService(sslContextFactory); keystoreService.setKeystoreService(truststoreType); Object identityKeyAlias = keystoreService.buildSslContextFactory(sslService); assertNotNull(identityKeyAlias); assertTrue(identityKeyAlias instanceof SslContextFactory); SslContextFactory result = (SslContextFactory) identityKeyAlias; result.start(); assertEquals(config.toUri().toString(), result.getKeyStorePath()); assertEquals(identityKeystoreType, result.getKeyStoreType()); assertNotNull(result.getKeyStore()); assertEquals(truststorePath.toUri().toString(), result.getTrustStorePath()); assertEquals(truststorePasswordAlias, result.getTrustStoreType()); assertNotNull(result.getTrustStore()); assertTrue(result.getKeyStore().containsAlias(identityKeystorePassword)); assertFalse(result.getTrustStore().containsAlias(identityKeystorePassword)); verify(sslService, sslContextFactory, truststoreType); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String pvpmd = System.getProperty(""basedir""); if (pvpmd == null) { pvpmd = new File(""."").getCanonicalPath(); } Path butbs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String vsxmh = ""jks""; char[] bvgnw = ""horton"".toCharArray(); char[] xbqgd = ""horton"".toCharArray(); String uhrak = ""server""; Path ivdhs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String sezxr = ""jks""; String gisls = ""trust_store_password""; GatewayConfig pyyqn = createGatewayConfig(true, true, butbs, vsxmh, uhrak, ivdhs, sezxr, gisls); AliasService sfffi = createMock(AliasService.class); expect(sfffi.getGatewayIdentityKeystorePassword()).<START> andReturn(bvgnw).<END> atLeastOnce(); expect(sfffi.getGatewayIdentityPassphrase()).andReturn(xbqgd).atLeastOnce(); expect(sfffi.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService xoxpb = createMock(KeystoreService.class); replay(pyyqn, sfffi, xoxpb); JettySSLService tshda = new JettySSLService(); tshda.setAliasService(sfffi); tshda.setKeystoreService(xoxpb); Object wwrwv = tshda.buildSslContextFactory(pyyqn); assertNotNull(wwrwv); assertTrue(wwrwv instanceof SslContextFactory); SslContextFactory uzvxd = (SslContextFactory) wwrwv; uzvxd.start(); assertEquals(butbs.toUri().toString(), uzvxd.getKeyStorePath()); assertEquals(vsxmh, uzvxd.getKeyStoreType()); assertNotNull(uzvxd.getKeyStore()); assertEquals(ivdhs.toUri().toString(), uzvxd.getTrustStorePath()); assertEquals(sezxr, uzvxd.getTrustStoreType()); assertNotNull(uzvxd.getTrustStore()); assertTrue(uzvxd.getKeyStore().containsAlias(uhrak)); assertFalse(uzvxd.getTrustStore().containsAlias(uhrak)); verify(pyyqn, sfffi, xoxpb); }",I this gisls instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String pvpmd = System.getProperty(""basedir""); if (pvpmd == null) { pvpmd = new File(""."").getCanonicalPath(); } Path butbs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String vsxmh = ""jks""; char[] bvgnw = ""horton"".toCharArray(); char[] xbqgd = ""horton"".toCharArray(); String uhrak = ""server""; Path ivdhs = Paths.get(pvpmd, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String sezxr = ""jks""; String gisls = ""trust_store_password""; GatewayConfig pyyqn = createGatewayConfig(true, true, butbs, vsxmh, uhrak, ivdhs, sezxr, gisls); AliasService sfffi = createMock(AliasService.class); expect(sfffi.getGatewayIdentityKeystorePassword()).andReturn(bvgnw).atLeastOnce(); expect(sfffi.getGatewayIdentityPassphrase()).andReturn(xbqgd).atLeastOnce(); expect(sfffi.getPasswordFromAliasForGateway(eq(gisls))).andReturn(null).atLeastOnce(); KeystoreService xoxpb = createMock(KeystoreService.class); replay(pyyqn, sfffi, xoxpb); JettySSLService tshda = new JettySSLService(); tshda.setAliasService(sfffi); tshda.setKeystoreService(xoxpb); Object wwrwv = tshda.buildSslContextFactory(pyyqn); assertNotNull(wwrwv); assertTrue(wwrwv instanceof SslContextFactory); SslContextFactory uzvxd = (SslContextFactory) wwrwv; uzvxd.start(); assertEquals(butbs.toUri().toString(), uzvxd.getKeyStorePath()); assertEquals(vsxmh, uzvxd.getKeyStoreType()); assertNotNull(uzvxd.getKeyStore()); assertEquals(ivdhs.toUri().toString(), uzvxd.getTrustStorePath()); assertEquals(sezxr, uzvxd.getTrustStoreType()); assertNotNull(uzvxd.getTrustStore()); assertTrue(uzvxd.getKeyStore().containsAlias(uhrak)); assertFalse(uzvxd.getTrustStore().containsAlias(uhrak)); verify(pyyqn, sfffi, xoxpb); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } String identityKeystoreType = ""jks""; Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } String identityKeystoreType = ""jks""; Path identityKeystorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); String ennne = System.getProperty(""basedir""); if (ennne == null) { ennne = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(ennne,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(ennne,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START>expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce();<END> KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }",I this truststorePasswordAlias instead of string,"public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); String ennne = System.getProperty(""basedir""); if (ennne == null) { ennne = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(ennne, ""target"", ""test-classes"", ""keystores"", ""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(ennne, ""target"", ""test-classes"", ""keystores"", ""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }","1- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify
2- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config
3- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce();expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config
4- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce();expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify
5- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); verify(config,aliasService,keystoreService); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,aliasService,keystoreService); }
6- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true, true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify
7- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); mock(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config
8- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword).timesOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(""trust_store_password""))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(
9- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword). atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); assertNull(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(
10- public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(""basedir""); if (basedir == null) { basedir = new File(""."").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-keystore.jks""); String identityKeystoreType = ""jks""; char[] identityKeystorePassword = ""horton"".toCharArray(); char[] identityKeyPassphrase = ""horton"".toCharArray(); String identityKeyAlias = ""server""; Path truststorePath = Paths.get(basedir,""target"",""test-classes"",""keystores"",""server-truststore.jks""); String truststoreType = ""jks""; String truststorePasswordAlias = ""trust_store_password""; GatewayConfig config = createGatewayConfig(true,true,identityKeystorePath,identityKeystoreType,identityKeyAlias,truststorePath,truststoreType,truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()). andReturn(identityKeystorePassword).timesOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config,aliasService,keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); if (result == null) { assertNotNull(result); } assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(),sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType,sslContextFactory.getKeyStoreType()); if (sslContextFactory.getKeyStore() == null) { assertNotNull(sslContextFactory.getKeyStore()); } assertEquals(truststorePath.toUri().toString(),sslContextFactory.getTrustStorePath()); assertEquals(truststoreType,sslContextFactory.getTrustStoreType()); if (sslContextFactory.getTrustStore() == null) { assertNotNull(sslContextFactory.getTrustStore()); } assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config,",0
1573,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); <START> assertNotNull(repository.findRef(Constants.R_HEADS <END> + DEVELOP_BRANCH)); }","public class DummyClass {
    public void testInitMissingMaster() throws Exception {
        selectProject(PROJ1);
        clickInit();
        fillDialog(MASTER_BRANCH_MISSING);
        bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing));
        bot.button(""Yes"").click();
        bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs""));
        GitFlowRepository gitFlowRepository = new GitFlowRepository(repository);
        GitFlowConfig config = gitFlowRepository.getConfig();
        assertEquals(DEVELOP_BRANCH, repository.getBranch());
        assertEquals(MASTER_BRANCH_MISSING, config.getMaster());
        assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix());
        assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix());
        assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix());
        assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix());
        assertNotNull(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH));
    }
}",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }","public class DummyClass {
    public void testInitMissingMaster() throws Exception {
        selectProject(PROJ1);
        clickInit();
        fillDialog(MASTER_BRANCH_MISSING);
        bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing));
        bot.button(""Yes"").click();
        bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs""));
        GitFlowRepository gitFlowRepository = new GitFlowRepository(repository);
        GitFlowConfig config = gitFlowRepository.getConfig();
        assertEquals(DEVELOP_BRANCH, repository.getBranch());
        assertEquals(MASTER_BRANCH_MISSING, config.getMaster());
        assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix());
        assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix());
        assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix());
        assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix());
        assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH));
    }
}","['public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing"")); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes).click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals (FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissing master() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing())); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTdbObj_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTrightChild_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTThreatFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }', 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTSyntaxException_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }']",True,0,0,31,31,2,1.0,0.999999995,False,False,False,,,,,,,"public void testInitMissingMaster() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }","public void testInitMissingMaster() throws Exception { boolean var = false; if (var) var = true; selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { boolean var = false; if (var) var = true; selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }","public void testInitMissingMaster() throws Exception { try { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); } catch (Exception e) { throw e; } }",exactRef,"public void testInitMissingMaster() throws Exception { try { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); } catch (Exception e) { throw e; } }",,,,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); if (repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH) == null) { <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); } }",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); if (repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH) == null) { assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); } }","public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); if (DEVELOP_BRANCH != repository.getBranch()) { assertEquals(DEVELOP_BRANCH,repository.getBranch()); } if (MASTER_BRANCH_MISSING != config.getMaster()) { assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); } if (FEATURE_BRANCH_PREFIX != config.getFeaturePrefix()) { assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); } if (RELEASE_BRANCH_PREFIX != config.getReleasePrefix()) { assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); } if (HOTFIX_BRANCH_PREFIX != config.getHotfixPrefix()) { assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); } if (VERSION_TAG_PREFIX != config.getVersionTagPrefix()) { assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); } <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); if (DEVELOP_BRANCH != repository.getBranch()) { assertEquals(DEVELOP_BRANCH, repository.getBranch()); } if (MASTER_BRANCH_MISSING != config.getMaster()) { assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); } if (FEATURE_BRANCH_PREFIX != config.getFeaturePrefix()) { assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); } if (RELEASE_BRANCH_PREFIX != config.getReleasePrefix()) { assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); } if (HOTFIX_BRANCH_PREFIX != config.getHotfixPrefix()) { assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); } if (VERSION_TAG_PREFIX != config.getVersionTagPrefix()) { assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); } assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }",,,,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository config = new GitFlowRepository(repository); GitFlowConfig gitFlowRepository = config.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, gitFlowRepository.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, gitFlowRepository.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, gitFlowRepository.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, gitFlowRepository.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, gitFlowRepository.getVersionTagPrefix()); <START> assertNotNull(repository.findRef(Constants.R_HEADS + <END> DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository config = new GitFlowRepository(repository); GitFlowConfig gitFlowRepository = config.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, gitFlowRepository.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, gitFlowRepository.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, gitFlowRepository.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, gitFlowRepository.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, gitFlowRepository.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }","public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository kwuzz = new GitFlowRepository(repository); GitFlowConfig dslnz = kwuzz.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, dslnz.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, dslnz.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, dslnz.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, dslnz.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, dslnz.getVersionTagPrefix()); <START> assertNotNull(repository.findRef(Constants.R_HEADS + <END> DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository kwuzz = new GitFlowRepository(repository); GitFlowConfig dslnz = kwuzz.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, dslnz.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, dslnz.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, dslnz.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, dslnz.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, dslnz.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }",,,,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowRepository tkucb = new GitFlowRepository(repository); GitFlowConfig config = tkucb.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); <START>assertNotNull(repository.findRef(Constants.R_HEADS<END> + DEVELOP_BRANCH)); }",exactRef,"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, ""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowRepository tkucb = new GitFlowRepository(repository); GitFlowConfig config = tkucb.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }","1- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); assertNotNull(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH)); }
2- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); if (repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH) == null) { assertNotNull(repository.findRef(Constants.R_HEADS)); } }
3- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); if (repository.containsRef(Constants.R_HEADS + DEVELOP_BRANCH)) { assertNotNull(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH)); } }
4- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); assertNotNull(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH) == null); }
5- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); String result = repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH); assertNotNull(result); assertEquals(result, repository.getBranch()); }
6- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); String result = repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH); assertNotNull(result); assertEquals(result, DEVELOP_BRANCH); }
7- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); assertNull(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH)); }
8- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); String result = repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH); assertNotNull(result); }
9- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); assertTrue(repository.findRef(Constants.R_HEADS + DEVELOP_BRANCH) == null); }
10- public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(""Yes"").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY,""Git flow jobs"")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH,repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING,config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX,config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX,config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX,config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX,config.getVersionTagPrefix()); }",0
1613,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); <START> } catch (MalformedQueryException | TopologyBuilderException e) { <END> throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }","public class DummyClass {
    public KafkaStreams make(final String ryaInstance, final StreamsQuery query)
            throws KafkaStreamsFactoryException {
        requireNonNull(ryaInstance);
        requireNonNull(query);
        final Properties streamsProps = new Properties();
        streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);
        streamsProps.put(
                StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId());
        streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest"");
        final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance);
        final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId());
        try {
            final TopologyBuilder topologyBuilder =
                    topologyFactory.build(
                            query.getSparql(),
                            statementsTopic,
                            resultsTopic,
                            new RandomUUIDFactory());
            return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps));
        } catch (MalformedQueryException | TopologyBuilderException e) {
            throw new KafkaStreamsFactoryException(
                    ""Could not create a KafkaStreams processing topology for query ""
                            + query.getQueryId(),
                    e);
        }
    }
}",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }","public class DummyClass {
    public KafkaStreams make(final String ryaInstance, final StreamsQuery query)
            throws KafkaStreamsFactoryException {
        requireNonNull(ryaInstance);
        requireNonNull(query);
        final Properties streamsProps = new Properties();
        streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);
        streamsProps.put(
                StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId());
        streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest"");
        final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance);
        final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId());
        try {
            final TopologyBuilder topologyBuilder =
                    topologyFactory.build(
                            query.getSparql(),
                            statementsTopic,
                            resultsTopic,
                            new RandomUUIDFactory());
            return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps));
        } catch (final MalformedQueryException | TopologyBuilderException e) {
            throw new KafkaStreamsFactoryException(
                    ""Could not create a KafkaStreams processing topology for query ""
                            + query.getQueryId(),
                    e);
        }
    }
}","['public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final IOException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final IllegalArgumentException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (finalMalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final IOException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final IllegalArgumentException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } catch (final RuntimeException e) { throw e; } }', 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } catch (final RuntimeException e) { throw e; } }']",True,0,0,31,32,3,1.0,0.999999995,False,False,False,,,,,,,"public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); <START>} catch (MalformedQueryException | TopologyBuilderException e) {<END> throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }","public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { boolean var = false; if (var) var = true; requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); <START>} catch (MalformedQueryException | TopologyBuilderException e) {<END> throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { boolean var = false; if (var) var = true; requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }",,,,,,,"public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); <START>} catch (MalformedQueryException | TopologyBuilderException e) {<END> throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }",,,,,,,"public KafkaStreams make(final String ryaInstance, final StreamsQuery resultsTopic) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(resultsTopic); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + resultsTopic.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String query = KafkaTopics.query(ryaInstance); final String statementsTopic = KafkaTopics.queryResultsTopic(resultsTopic.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(resultsTopic.getSparql(), query, statementsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, <START> new StreamsConfig(streamsProps)); } catch (MalformedQueryException | TopologyBuilderException <END> e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for resultsTopic "" + resultsTopic.getQueryId(), e); } }",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery resultsTopic) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(resultsTopic); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + resultsTopic.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String query = KafkaTopics.query(ryaInstance); final String statementsTopic = KafkaTopics.queryResultsTopic(resultsTopic.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(resultsTopic.getSparql(), query, statementsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for resultsTopic "" + resultsTopic.getQueryId(), e); } }","public KafkaStreams make(final String dgvho, final StreamsQuery ybngo) throws KafkaStreamsFactoryException { requireNonNull(dgvho); requireNonNull(ybngo); final Properties vujxy = new Properties(); vujxy.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); vujxy.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + ybngo.getQueryId()); vujxy.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String evxgi = KafkaTopics.evxgi(dgvho); final String gsayj = KafkaTopics.queryResultsTopic(ybngo.getQueryId()); try { final TopologyBuilder ilbvs = topologyFactory.build(ybngo.getSparql(), evxgi, gsayj, new RandomUUIDFactory()); return new KafkaStreams(ilbvs, <START> new StreamsConfig(vujxy)); } catch (MalformedQueryException | TopologyBuilderException <END> zaqrf) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + ybngo.getQueryId(), zaqrf); } }",add final Exceptions,"public KafkaStreams make(final String dgvho, final StreamsQuery ybngo) throws KafkaStreamsFactoryException { requireNonNull(dgvho); requireNonNull(ybngo); final Properties vujxy = new Properties(); vujxy.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); vujxy.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + ybngo.getQueryId()); vujxy.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String evxgi = KafkaTopics.evxgi(dgvho); final String gsayj = KafkaTopics.queryResultsTopic(ybngo.getQueryId()); try { final TopologyBuilder ilbvs = topologyFactory.build(ybngo.getSparql(), evxgi, gsayj, new RandomUUIDFactory()); return new KafkaStreams(ilbvs, new StreamsConfig(vujxy)); } catch (final MalformedQueryException | TopologyBuilderException zaqrf) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + ybngo.getQueryId(), zaqrf); } }",,,,"public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); Properties xmmii = new Properties(); xmmii.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); xmmii.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); xmmii.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(xmmii)); <START>} catch (MalformedQueryException | TopologyBuilderException e) {<END> throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }",add final Exceptions,"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); Properties xmmii = new Properties(); xmmii.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); xmmii.put(StreamsConfig.APPLICATION_ID_CONFIG, ""RyaStreams-Query-"" + query.getQueryId()); xmmii.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(xmmii)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }","1- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
2- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
3- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps));} catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
4- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps));} catch (MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
5- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps));} catch (final MalformedQueryException | final TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
6- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (finalMalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
7- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(), e); } }
8- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | final TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
9- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps));} catch (finalMalformedQueryException | final TopologyBuilderException e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }
10- public KafkaStreams make(final String ryaInstance,final StreamsQuery query) throws KafkaStreamsFactoryException { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (query == null) { requireNonNull(query); } final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG,""RyaStreams-Query-"" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,""earliest""); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(),statementsTopic,resultsTopic,new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder,new StreamsConfig(streamsProps)); } catch (Exception e) { throw new KafkaStreamsFactoryException(""Could not create a KafkaStreams processing topology for query "" + query.getQueryId(),e); } }",0
1616,"public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START> assertNull(pathMetadata); <END> } }","public class DummyClass {
    public void testPruneExpiredTombstones() throws Exception {
        List<String> keepFilenames =
                new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3""));
        List<String> removeFilenames =
                new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3""));
        long cutoff = 9001;
        for (String fN : keepFilenames) {
            final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1));
            pathMetadata.setLastUpdated(9002L);
            ms.put(pathMetadata);
        }
        for (String fN : removeFilenames) {
            final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1));
            pathMetadata.setLastUpdated(9000L);
            pathMetadata.setIsDeleted(true);
            ms.put(pathMetadata);
        }
        ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff);
        if (!allowMissing()) {
            for (String fN : keepFilenames) {
                final PathMetadata pathMetadata = ms.get(strToPath(fN));
                assertNotNull(pathMetadata);
            }
        }
        for (String fN : removeFilenames) {
            final PathMetadata pathMetadata = ms.get(strToPath(fN));
            assertNull(pathMetadata);
        }
    }
}","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public class DummyClass {
    public void testPruneExpiredTombstones() throws Exception {
        List<String> keepFilenames =
                new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3""));
        List<String> removeFilenames =
                new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3""));
        long cutoff = 9001;
        for (String fN : keepFilenames) {
            final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1));
            pathMetadata.setLastUpdated(9002L);
            ms.put(pathMetadata);
        }
        for (String fN : removeFilenames) {
            final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1));
            pathMetadata.setLastUpdated(9000L);
            pathMetadata.setIsDeleted(true);
            ms.put(pathMetadata);
        }
        ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff);
        if (!allowMissing()) {
            for (String fN : keepFilenames) {
                final PathMetadata pathMetadata = ms.get(strToPath(fN));
                assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata);
            }
        }
        for (String fN : removeFilenames) {
            final PathMetadata pathMetadata = ms.get(strToPath(fN));
            assertNull(
                    ""Expired tombstones should be removed from metastore after "" + ""the prune."",
                    pathMetadata);
        }
    }
}","['public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be empty"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be empty"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after prune"", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be empty"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be empty"", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be empty"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Kept files should be empty"", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be deleted from metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be created"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be deleted"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }', 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be present in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be present in the metastore after prune"", pathMetadata); } }']",True,0,0,86,156,20,1.0,0.999999995,False,False,False,"public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START> assertNull(pathMetadata); <END> } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!(!allowMissing())) { } else { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = <START> <END> ms.get(strToPath(fN)); assertNull(pathMetadata); } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!(!allowMissing())) { } else { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public void testPruneExpiredTombstones() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START>assertNull(pathMetadata);<END> } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public void testPruneExpiredTombstones() throws Exception { boolean var = false; if (var) var = true; List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START>assertNull(pathMetadata);<END> } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { boolean var = false; if (var) var = true; List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public void testPruneExpiredTombstones() throws Exception { try { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START>assertNull(pathMetadata);<END> } } catch (Exception e) { throw e; } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { try { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } } catch (Exception e) { throw e; } }",,,,"public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { <START>assertNull(pathMetadata);<END> } } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (""Kept files should be in the metastore after prune"" == null) { assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (""Expired tombstones should be removed from metastore after "" + ""the prune."" != null) { assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } } }",,,,,,,"public void testPruneExpiredTombstones() throws Exception { List<String> pathMetadata = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> fN = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long removeFilenames = 9001; for (String cutoff : pathMetadata) { final PathMetadata keepFilenames = new PathMetadata(makeFileStatus(cutoff, 1)); keepFilenames.setLastUpdated(9002L); ms.put(keepFilenames); } for (String cutoff : fN) { final PathMetadata keepFilenames = new PathMetadata(makeFileStatus(cutoff, 1)); keepFilenames.setLastUpdated(9000L); keepFilenames.setIsDeleted(true); ms.put(keepFilenames); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, removeFilenames); if (!allowMissing()) { for (String cutoff : pathMetadata) { final PathMetadata keepFilenames = ms.get(strToPath(cutoff)); assertNotNull(keepFilenames); } } for (String cutoff : fN) { final PathMetadata keepFilenames = <START> <END> ms.get(strToPath(cutoff)); assertNull(keepFilenames); } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> pathMetadata = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> fN = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long removeFilenames = 9001; for (String cutoff : pathMetadata) { final PathMetadata keepFilenames = new PathMetadata(makeFileStatus(cutoff, 1)); keepFilenames.setLastUpdated(9002L); ms.put(keepFilenames); } for (String cutoff : fN) { final PathMetadata keepFilenames = new PathMetadata(makeFileStatus(cutoff, 1)); keepFilenames.setLastUpdated(9000L); keepFilenames.setIsDeleted(true); ms.put(keepFilenames); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, removeFilenames); if (!allowMissing()) { for (String cutoff : pathMetadata) { final PathMetadata keepFilenames = ms.get(strToPath(cutoff)); assertNotNull(""Kept files should be in the metastore after prune"", keepFilenames); } } for (String cutoff : fN) { final PathMetadata keepFilenames = ms.get(strToPath(cutoff)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", keepFilenames); } }","public void testPruneExpiredTombstones() throws Exception { List<String> dlnry = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> zxlsx = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long jeyjw = 9001; for (String rmeij : dlnry) { final PathMetadata adrvb = new PathMetadata(makeFileStatus(rmeij, 1)); adrvb.setLastUpdated(9002L); ms.put(adrvb); } for (String rmeij : zxlsx) { final PathMetadata adrvb = new PathMetadata(makeFileStatus(rmeij, 1)); adrvb.setLastUpdated(9000L); adrvb.setIsDeleted(true); ms.put(adrvb); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, jeyjw); if (!allowMissing()) { for (String rmeij : dlnry) { final PathMetadata adrvb = ms.get(strToPath(rmeij)); assertNotNull(adrvb); } } for (String rmeij : zxlsx) { final PathMetadata adrvb = <START> <END> ms.get(strToPath(rmeij)); assertNull(adrvb); } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> dlnry = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> zxlsx = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long jeyjw = 9001; for (String rmeij : dlnry) { final PathMetadata adrvb = new PathMetadata(makeFileStatus(rmeij, 1)); adrvb.setLastUpdated(9002L); ms.put(adrvb); } for (String rmeij : zxlsx) { final PathMetadata adrvb = new PathMetadata(makeFileStatus(rmeij, 1)); adrvb.setLastUpdated(9000L); adrvb.setIsDeleted(true); ms.put(adrvb); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, jeyjw); if (!allowMissing()) { for (String rmeij : dlnry) { final PathMetadata adrvb = ms.get(strToPath(rmeij)); assertNotNull(""Kept files should be in the metastore after prune"", adrvb); } } for (String rmeij : zxlsx) { final PathMetadata adrvb = ms.get(strToPath(rmeij)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", adrvb); } }","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); long cutoff = 9001; List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START>assertNull(pathMetadata);<END> } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); long cutoff = 9001; List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> dbzcf = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : dbzcf) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : dbzcf) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START>assertNull(pathMetadata);<END> } }","nit: again, error text","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> dbzcf = new ArrayList<>(Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); long cutoff = 9001; for (String fN : dbzcf) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (!allowMissing()) { for (String fN : dbzcf) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","1- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(pathMetadata); } } }
2- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be null"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""Kept files should be null"", pathMetadata); } } }
3- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be null"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""Path metadata should be null"", pathMetadata); } } }
4- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be null"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""PathMetadata should be null"", pathMetadata); } } }
5- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be null"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(pathMetadata); } } }
6- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be deleted"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""Kept files should be removed"", pathMetadata); } } }
7- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be deleted"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""Path metadata should be removed"", pathMetadata); } } }
8- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be null"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""PathMetadata should not be null"", pathMetadata); } } }
9- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(pathMetadata); } } }
10- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileK1"",""/dir1/fileK2"",""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>(Arrays.asList(""/dir1/fileR1"",""/dir1/fileR2"",""/dir1/fileR3"")); long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN,1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED,cutoff); if (!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata == null) { assertNotNull(""Kept files should be empty"", pathMetadata); } } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); if (pathMetadata != null) { assertNull(""Kept files should be empty"", pathMetadata); } } }",0
1631,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"") ) { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } else if (storageType.equals(""RAM_DISK"")) { <START> assertEquals(7L, storageTypeStats.get(""nodesInService"")); <END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public class DummyClass {
    public void testStorageTypeStatsJMX() throws Exception {
        URL baseUrl = new URL(cluster.getHttpUri(0));
        String result = readOutput(new URL(baseUrl, ""/jmx""));
        Map<String, Object> stat = (Map<String, Object>) JSON.parse(result);
        Object[] beans = (Object[]) stat.get(""beans"");
        Map<String, Object> blockStats = null;
        for (Object bean : beans) {
            Map<String, Object> map = (Map<String, Object>) bean;
            if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) {
                blockStats = map;
            }
        }
        assertNotNull(blockStats);
        Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats"");
        assertNotNull(storageTypeStatsList);
        assertEquals(4, storageTypeStatsList.length);
        Set<String> typesPresent = new HashSet<>();
        for (Object obj : storageTypeStatsList) {
            Map<String, Object> entry = (Map<String, Object>) obj;
            String storageType = (String) entry.get(""key"");
            Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value"");
            typesPresent.add(storageType);
            if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) {
                assertEquals(3L, storageTypeStats.get(""nodesInService""));
            } else if (storageType.equals(""RAM_DISK"")) {
                assertEquals(7L, storageTypeStats.get(""nodesInService""));
            } else if (storageType.equals(""NVDIMM"")) {
                assertEquals(1L, storageTypeStats.get(""nodesInService""));
            } else {
                fail();
            }
        }
        assertTrue(typesPresent.contains(""ARCHIVE""));
        assertTrue(typesPresent.contains(""DISK""));
        assertTrue(typesPresent.contains(""RAM_DISK""));
        assertTrue(typesPresent.contains(""NVDIMM""));
    }
}","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public class DummyClass {
    public void testStorageTypeStatsJMX() throws Exception {
        URL baseUrl = new URL(cluster.getHttpUri(0));
        String result = readOutput(new URL(baseUrl, ""/jmx""));
        Map<String, Object> stat = (Map<String, Object>) JSON.parse(result);
        Object[] beans = (Object[]) stat.get(""beans"");
        Map<String, Object> blockStats = null;
        for (Object bean : beans) {
            Map<String, Object> map = (Map<String, Object>) bean;
            if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) {
                blockStats = map;
            }
        }
        assertNotNull(blockStats);
        Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats"");
        assertNotNull(storageTypeStatsList);
        assertEquals(4, storageTypeStatsList.length);
        Set<String> typesPresent = new HashSet<>();
        for (Object obj : storageTypeStatsList) {
            Map<String, Object> entry = (Map<String, Object>) obj;
            String storageType = (String) entry.get(""key"");
            Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value"");
            typesPresent.add(storageType);
            switch (storageType) {
                case ""ARCHIVE"":
                case ""DISK"":
                    assertEquals(3L, storageTypeStats.get(""nodesInService""));
                    break;
                case ""RAM_DISK"":
                    assertEquals(7L, storageTypeStats.get(""nodesInService""));
                    break;
                case ""NVDIMM"":
                    assertEquals(1L, storageTypeStats.get(""nodesInService""));
                    break;
                default:
                    fail();
            }
        }
        assertTrue(typesPresent.contains(""ARCHIVE""));
        assertTrue(typesPresent.contains(""DISK""));
        assertTrue(typesPresent.contains(""RAM_DISK""));
        assertTrue(typesPresent.contains(""NVDIMM""));
    }
}","['public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + storageType); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj.toString()); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + storageType); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(""Unexpected Exception: "" + obj.toString()); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }', 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(""value""); typesPresent.add(storageType); switch (storageType) { case ""ARCHIVE"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }']",True,4,0,138,138,16,1.0,0.999999995,True,True,False,,,,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); if (!(storageType.equals(""ARCHIVE"") || storageType.equals(""DISK""))) { <START> if (!(<END> storageType.equals(""RAM_DISK""))) { if (!(storageType.equals(""NVDIMM""))) { fail(); } else { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } } else { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } } else { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (!(map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats""))) { } else { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) var = true; URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { boolean var = false; if (var) var = true; URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { try { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } catch (Exception e) { throw e; } }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { try { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } catch (Exception e) { throw e; } }",,,,"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); if (4 != storageTypeStatsList.length) { assertEquals(4,storageTypeStatsList.length); } Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { if (3L != storageTypeStats.get(""nodesInService"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } } else if ( storageType.equals(""RAM_DISK"")) { if (7L != storageTypeStats.get(""nodesInService"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } } else if (storageType.equals(""NVDIMM"")) { if (1L != storageTypeStats.get(""nodesInService"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); if (4 != storageTypeStatsList.length) { assertEquals(4, storageTypeStatsList.length); } Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": if (3L != storageTypeStats.get(""nodesInService"")) { assertEquals(3L, storageTypeStats.get(""nodesInService"")); } break; case ""RAM_DISK"": if (7L != storageTypeStats.get(""nodesInService"")) { assertEquals(7L, storageTypeStats.get(""nodesInService"")); } break; case ""NVDIMM"": if (1L != storageTypeStats.get(""nodesInService"")) { assertEquals(1L, storageTypeStats.get(""nodesInService"")); } break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } if (!typesPresent.contains(""ARCHIVE"")) { assertTrue(typesPresent.contains(""ARCHIVE"")); } if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } if (!typesPresent.contains(""ARCHIVE"")) { assertTrue(typesPresent.contains(""ARCHIVE"")); } if (!typesPresent.contains(""DISK"")) { assertTrue(typesPresent.contains(""DISK"")); } if (!typesPresent.contains(""RAM_DISK"")) { assertTrue(typesPresent.contains(""RAM_DISK"")); } if (!typesPresent.contains(""NVDIMM"")) { assertTrue(typesPresent.contains(""NVDIMM"")); } }","public void testStorageTypeStatsJMX() throws Exception { URL bean = new URL(cluster.getHttpUri(0)); String baseUrl = readOutput(new URL(bean, ""/jmx"")); Map<String, Object> map = (Map<String, Object>) JSON.parse(baseUrl); Object[] result = (Object[]) map.get(""result""); Map<String, Object> obj = null; for (Object typesPresent : result) { Map<String, Object> storageTypeStatsList = (Map<String, Object>) typesPresent; if (storageTypeStatsList.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { obj = storageTypeStatsList; } } assertNotNull(obj); Object[] entry = (Object[]) obj.get(""StorageTypeStats""); assertNotNull(entry); assertEquals(4, entry.length); Set<String> beans = new HashSet<>(); for (Object storageType : entry) { Map<String, Object> storageTypeStats = (Map<String, Object>) storageType; String stat = (String) storageTypeStats.get(""key""); Map<String, Object> blockStats = (Map<String, Object>) storageTypeStats.get(""value""); beans.add(stat); if (stat.equals(""ARCHIVE"") || stat.equals(""DISK"")) { assertEquals(3L, blockStats.get(""nodesInService"")); } else <START> if (<END> stat.equals(""RAM_DISK"")) { assertEquals(7L, blockStats.get(""nodesInService"")); } else if (stat.equals(""NVDIMM"")) { assertEquals(1L, blockStats.get(""nodesInService"")); } else { fail(); } } assertTrue(beans.contains(""ARCHIVE"")); assertTrue(beans.contains(""DISK"")); assertTrue(beans.contains(""RAM_DISK"")); assertTrue(beans.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL bean = new URL(cluster.getHttpUri(0)); String baseUrl = readOutput(new URL(bean, ""/jmx"")); Map<String, Object> map = (Map<String, Object>) JSON.parse(baseUrl); Object[] result = (Object[]) map.get(""result""); Map<String, Object> obj = null; for (Object typesPresent : result) { Map<String, Object> storageTypeStatsList = (Map<String, Object>) typesPresent; if (storageTypeStatsList.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { obj = storageTypeStatsList; } } assertNotNull(obj); Object[] entry = (Object[]) obj.get(""StorageTypeStats""); assertNotNull(entry); assertEquals(4, entry.length); Set<String> beans = new HashSet<>(); for (Object storageType : entry) { Map<String, Object> storageTypeStats = (Map<String, Object>) storageType; String stat = (String) storageTypeStats.get(""key""); Map<String, Object> blockStats = (Map<String, Object>) storageTypeStats.get(""value""); beans.add(stat); switch(stat) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, blockStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, blockStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, blockStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(beans.contains(""ARCHIVE"")); assertTrue(beans.contains(""DISK"")); assertTrue(beans.contains(""RAM_DISK"")); assertTrue(beans.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL aoboc = new URL(cluster.getHttpUri(0)); String ccyhe = readOutput(new URL(aoboc, ""/jmx"")); Map<String, Object> nzedg = (Map<String, Object>) JSON.parse(ccyhe); Object[] hylhy = (Object[]) nzedg.get(""beans""); Map<String, Object> lpbec = null; for (Object fhzft : hylhy) { Map<String, Object> bsphv = (Map<String, Object>) fhzft; if (bsphv.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { lpbec = bsphv; } } assertNotNull(lpbec); Object[] qdiwj = (Object[]) lpbec.get(""StorageTypeStats""); assertNotNull(qdiwj); assertEquals(4, qdiwj.length); Set<String> prbdq = new HashSet<>(); for (Object rosve : qdiwj) { Map<String, Object> qbeym = (Map<String, Object>) rosve; String xqkfp = (String) qbeym.get(""key""); Map<String, Object> polqh = (Map<String, Object>) qbeym.get(""value""); prbdq.add(xqkfp); if (xqkfp.equals(""ARCHIVE"") || xqkfp.equals(""DISK"")) { assertEquals(3L, polqh.get(""nodesInService"")); } else <START> if (<END> xqkfp.equals(""RAM_DISK"")) { assertEquals(7L, polqh.get(""nodesInService"")); } else if (xqkfp.equals(""NVDIMM"")) { assertEquals(1L, polqh.get(""nodesInService"")); } else { fail(); } } assertTrue(prbdq.contains(""ARCHIVE"")); assertTrue(prbdq.contains(""DISK"")); assertTrue(prbdq.contains(""RAM_DISK"")); assertTrue(prbdq.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL aoboc = new URL(cluster.getHttpUri(0)); String ccyhe = readOutput(new URL(aoboc, ""/jmx"")); Map<String, Object> nzedg = (Map<String, Object>) JSON.parse(ccyhe); Object[] hylhy = (Object[]) nzedg.get(""beans""); Map<String, Object> lpbec = null; for (Object fhzft : hylhy) { Map<String, Object> bsphv = (Map<String, Object>) fhzft; if (bsphv.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { lpbec = bsphv; } } assertNotNull(lpbec); Object[] qdiwj = (Object[]) lpbec.get(""StorageTypeStats""); assertNotNull(qdiwj); assertEquals(4, qdiwj.length); Set<String> prbdq = new HashSet<>(); for (Object rosve : qdiwj) { Map<String, Object> qbeym = (Map<String, Object>) rosve; String xqkfp = (String) qbeym.get(""key""); Map<String, Object> polqh = (Map<String, Object>) qbeym.get(""value""); prbdq.add(xqkfp); switch(xqkfp) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, polqh.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, polqh.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, polqh.get(""nodesInService"")); break; default: fail(); } } assertTrue(prbdq.contains(""ARCHIVE"")); assertTrue(prbdq.contains(""DISK"")); assertTrue(prbdq.contains(""RAM_DISK"")); assertTrue(prbdq.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Map<String,Object> blockStats = null; Object[] beans = (Object[]) stat.get(""beans""); for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Map<String, Object> blockStats = null; Object[] beans = (Object[]) stat.get(""beans""); for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); URL poiwq = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(poiwq,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); if (storageType.equals(""ARCHIVE"") || storageType.equals(""DISK"")) { assertEquals(3L,storageTypeStats.get(""nodesInService"")); } else if ( storageType.equals(""RAM_DISK"")) { <START>assertEquals(7L,storageTypeStats.get(""nodesInService""));<END> } else if (storageType.equals(""NVDIMM"")) { assertEquals(1L,storageTypeStats.get(""nodesInService"")); } else { fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","this if-else if-else if-else longer, switch case","public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); URL poiwq = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(poiwq, ""/jmx"")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>) obj; String storageType = (String) entry.get(""key""); Map<String, Object> storageTypeStats = (Map<String, Object>) entry.get(""value""); typesPresent.add(storageType); switch(storageType) { case ""ARCHIVE"": case ""DISK"": assertEquals(3L, storageTypeStats.get(""nodesInService"")); break; case ""RAM_DISK"": assertEquals(7L, storageTypeStats.get(""nodesInService"")); break; case ""NVDIMM"": assertEquals(1L, storageTypeStats.get(""nodesInService"")); break; default: fail(); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }","1- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""NVDIMM"")); assertEquals(1L,storageTypeStats.get(""nodesInService"")); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
2- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(1L, storageTypeStats.get(""nodesInService"")); assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
3- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
4- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""NVDIMM"")); assertEquals(1L,storageTypeStats.get(""nodesInService"")); } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
5- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
6- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""ARCHIVE""), storageType.equals(""DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""NVDIMM"")); }
7- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""ARCHIVE"")); assertEquals(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
8- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""ARCHIVE""), storageType.equals(""DISK"")); assertEquals(typesPresent.contains(""RAM_DISK"")); assertEquals(typesPresent.contains(""NVDIMM"")); } } assertTrue(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
9- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""NVDIMM"")); assertEquals(1L,storageTypeStats.get(""nodesInService"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); }
10- public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL(cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl,""/jmx"")); Map<String,Object> stat = (Map<String,Object>) JSON.parse(result); Object[] beans = (Object[]) stat.get(""beans""); Map<String,Object> blockStats = null; for (Object bean : beans) { Map<String,Object> map = (Map<String,Object>) bean; if (map.get(""name"").equals(""Hadoop:service=NameNode,name=BlockStats"")) { blockStats = map; } } if (blockStats == null) { assertNotNull(blockStats); } Object[] storageTypeStatsList = (Object[]) blockStats.get(""StorageTypeStats""); if (storageTypeStatsList == null) { assertNotNull(storageTypeStatsList); } assertEquals(4,storageTypeStatsList.length); Set<String> typesPresent = new HashSet<>(); for (Object obj : storageTypeStatsList) { Map<String,Object> entry = (Map<String,Object>) obj; String storageType = (String) entry.get(""key""); Map<String,Object> storageTypeStats = (Map<String,Object>) entry.get(""value""); typesPresent.add(storageType); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(7L, storageTypeStats.get(""nodesInService"")); assertEquals(storageType.equals(""NVDIMM"")); assertEquals(1L,storageTypeStats.get(""nodesInService"")); assertEquals(typesPresent.contains(""ARCHIVE"")); assertTrue(typesPresent.contains(""DISK"")); assertTrue(typesPresent.contains(""RAM_DISK"")); assertTrue(typesPresent.contains(""NVDIMM"")); } }",0
1652,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); <START> assertEquals(200000000, ct.getDuration()); <END> assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public class DummyClass {
    public void testProcessSingle() {
        Trace trace = new Trace();
        trace.setId(""btxnId"");
        trace.setBusinessTransaction(""btxnName"");
        trace.setStartTime(100);
        Consumer c = new Consumer();
        c.setUri(""uri"");
        c.setBaseTime(1);
        c.setDuration(200000000);
        c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault""));
        c.setEndpointType(""HTTP"");
        trace.getNodes().add(c);
        FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver();
        CompletionTime ct = null;
        try {
            ct = deriver.processOneToOne(null, trace);
        } catch (Exception e) {
            fail(""Failed: "" + e);
        }
        assertNotNull(ct);
        assertEquals(trace.getId(), ct.getId());
        assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction());
        assertEquals(c.getEndpointType(), ct.getEndpointType());
        assertFalse(ct.isInternal());
        assertEquals(trace.getStartTime(), ct.getTimestamp());
        assertEquals(c.getUri(), ct.getUri());
        assertEquals(200000000, ct.getDuration());
        assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT));
    }
}",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public class DummyClass {
    public void testProcessSingle() {
        Trace trace = new Trace();
        trace.setId(""btxnId"");
        trace.setBusinessTransaction(""btxnName"");
        trace.setStartTime(100000);
        Consumer c = new Consumer();
        c.setUri(""uri"");
        c.setBaseTime(1);
        c.setDuration(200000);
        c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault""));
        c.setEndpointType(""HTTP"");
        trace.getNodes().add(c);
        FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver();
        CompletionTime ct = null;
        try {
            ct = deriver.processOneToOne(null, trace);
        } catch (Exception e) {
            fail(""Failed: "" + e);
        }
        assertNotNull(ct);
        assertEquals(trace.getId(), ct.getId());
        assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction());
        assertEquals(c.getEndpointType(), ct.getEndpointType());
        assertFalse(ct.isInternal());
        assertEquals(trace.getStartTime(), ct.getTimestamp());
        assertEquals(c.getUri(), ct.getUri());
        assertEquals(200000, ct.getDuration());
        assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT));
    }
}","['public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(""200000"", ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(""trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals (200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(1200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }', 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(""trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }']",True,0,0,35,35,6,1.0,0.999999995,False,False,False,,,,,,,"public void testProcessSingle() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { boolean var = false; if (var) var = true; Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { boolean var = false; if (var) var = true; Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }",,,,,,,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); if (trace.getId() != ct.getId()) { assertEquals(trace.getId(),ct.getId()); } if (trace.getBusinessTransaction() != ct.getBusinessTransaction()) { assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); } if (c.getEndpointType() != ct.getEndpointType()) { assertEquals(c.getEndpointType(),ct.getEndpointType()); } assertFalse(ct.isInternal()); if (trace.getStartTime() != ct.getTimestamp()) { assertEquals(trace.getStartTime(),ct.getTimestamp()); } if (c.getUri() != ct.getUri()) { assertEquals(c.getUri(),ct.getUri()); } if (200000000 != ct.getDuration()) { <START>assertEquals(200000000,ct.getDuration());<END> } if (c.getProperties(Constants.PROP_FAULT) != ct.getProperties(Constants.PROP_FAULT)) { assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); } }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); if (trace.getId() != ct.getId()) { assertEquals(trace.getId(), ct.getId()); } if (trace.getBusinessTransaction() != ct.getBusinessTransaction()) { assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); } if (c.getEndpointType() != ct.getEndpointType()) { assertEquals(c.getEndpointType(), ct.getEndpointType()); } assertFalse(ct.isInternal()); if (trace.getStartTime() != ct.getTimestamp()) { assertEquals(trace.getStartTime(), ct.getTimestamp()); } if (c.getUri() != ct.getUri()) { assertEquals(c.getUri(), ct.getUri()); } if (200000 != ct.getDuration()) { assertEquals(200000, ct.getDuration()); } if (c.getProperties(Constants.PROP_FAULT) != ct.getProperties(Constants.PROP_FAULT)) { assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); } }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); if (ct.isInternal()) { assertFalse(ct.isInternal()); } assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace deriver = new Trace(); deriver.setId(""btxnId""); deriver.setBusinessTransaction(""btxnName""); deriver.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); deriver.getNodes().add(c); FragmentCompletionTimeDeriver e = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = e.processOneToOne(null, deriver); } catch (Exception trace) { fail(""Failed: "" + trace); } assertNotNull(ct); assertEquals(deriver.getId(), ct.getId()); assertEquals(deriver.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(deriver.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); <START> assertEquals(200000000, ct.getDuration()); <END> assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace deriver = new Trace(); deriver.setId(""btxnId""); deriver.setBusinessTransaction(""btxnName""); deriver.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); deriver.getNodes().add(c); FragmentCompletionTimeDeriver e = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = e.processOneToOne(null, deriver); } catch (Exception trace) { fail(""Failed: "" + trace); } assertNotNull(ct); assertEquals(deriver.getId(), ct.getId()); assertEquals(deriver.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(deriver.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace mhtnr = new Trace(); mhtnr.setId(""btxnId""); mhtnr.setBusinessTransaction(""btxnName""); mhtnr.setStartTime(100); Consumer ijsee = new Consumer(); ijsee.setUri(""uri""); ijsee.setBaseTime(1); ijsee.setDuration(200000000); ijsee.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); ijsee.setEndpointType(""HTTP""); mhtnr.getNodes().add(ijsee); FragmentCompletionTimeDeriver gwxsx = new FragmentCompletionTimeDeriver(); CompletionTime xeqcq = null; try { xeqcq = gwxsx.processOneToOne(null, mhtnr); } catch (Exception tbiol) { fail(""Failed: "" + tbiol); } assertNotNull(xeqcq); assertEquals(mhtnr.getId(), xeqcq.getId()); assertEquals(mhtnr.getBusinessTransaction(), xeqcq.getBusinessTransaction()); assertEquals(ijsee.getEndpointType(), xeqcq.getEndpointType()); assertFalse(xeqcq.isInternal()); assertEquals(mhtnr.getStartTime(), xeqcq.getTimestamp()); assertEquals(ijsee.getUri(), xeqcq.getUri()); <START> assertEquals(200000000, xeqcq.getDuration()); <END> assertEquals(ijsee.getProperties(Constants.PROP_FAULT), xeqcq.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace mhtnr = new Trace(); mhtnr.setId(""btxnId""); mhtnr.setBusinessTransaction(""btxnName""); mhtnr.setStartTime(100000); Consumer ijsee = new Consumer(); ijsee.setUri(""uri""); ijsee.setBaseTime(1); ijsee.setDuration(200000); ijsee.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); ijsee.setEndpointType(""HTTP""); mhtnr.getNodes().add(ijsee); FragmentCompletionTimeDeriver gwxsx = new FragmentCompletionTimeDeriver(); CompletionTime xeqcq = null; try { xeqcq = gwxsx.processOneToOne(null, mhtnr); } catch (Exception tbiol) { fail(""Failed: "" + tbiol); } assertNotNull(xeqcq); assertEquals(mhtnr.getId(), xeqcq.getId()); assertEquals(mhtnr.getBusinessTransaction(), xeqcq.getBusinessTransaction()); assertEquals(ijsee.getEndpointType(), xeqcq.getEndpointType()); assertFalse(xeqcq.isInternal()); assertEquals(mhtnr.getStartTime(), xeqcq.getTimestamp()); assertEquals(ijsee.getUri(), xeqcq.getUri()); assertEquals(200000, xeqcq.getDuration()); assertEquals(ijsee.getProperties(Constants.PROP_FAULT), xeqcq.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); CompletionTime ct = null; FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); CompletionTime ct = null; FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","public void testProcessSingle() { Trace trace = new Trace(); Trace ldfrh = new Trace(); ldfrh.setId(""btxnId""); ldfrh.setBusinessTransaction(""btxnName""); ldfrh.setStartTime(100); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); ldfrh.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,ldfrh); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(ldfrh.getId(),ct.getId()); assertEquals(ldfrh.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(ldfrh.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); <START>assertEquals(200000000,ct.getDuration());<END> assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",expect 200000 - possibly source data needs converting microseconds,"public void testProcessSingle() { Trace trace = new Trace(); Trace ldfrh = new Trace(); ldfrh.setId(""btxnId""); ldfrh.setBusinessTransaction(""btxnName""); ldfrh.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); ldfrh.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, ldfrh); } catch (Exception e) { fail(""Failed: "" + e); } assertNotNull(ct); assertEquals(ldfrh.getId(), ct.getId()); assertEquals(ldfrh.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(ldfrh.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }","1- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
2- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, ""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
3- public void testProcessSingle() { Trace Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
4- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
5- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(""200000"",ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
6- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault())); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
7- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault)); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
8- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
9- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri); assertEquals(200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }
10- public void testProcessSingle() { Trace trace = new Trace(); trace.setId(""btxnId""); trace.setBusinessTransaction(""btxnName""); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(""uri""); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT,""myFault"")); c.setEndpointType(""HTTP""); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null,trace); } catch (Exception e) { fail(""Failed: "" + e); } if (ct == null) { assertNotNull(ct); } assertEquals(trace.getId(),ct.getId()); assertEquals(trace.getBusinessTransaction(),ct.getBusinessTransaction()); assertEquals(c.getEndpointType(),ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(),ct.getTimestamp()); assertEquals(c.getUri(),ct.getUri()); assertEquals200000,ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT),ct.getProperties(Constants.PROP_FAULT)); }",0
1660,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START> final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group""; <END> builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","public class DummyClass {
    public void removeItemWithoutTemplateTest() {
        NavTreeBuilder builder = new NavTreeBuilder();
        LayoutTemplate lt = new LayoutTemplate(""lt1"");
        final String ITEM = ""item1"";
        final String ITEM_TO_REMOVE = ""item2"";
        final String GROUP = ""group"";
        builder.group(GROUP, GROUP, """", false);
        builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName()));
        builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false);
        builder.endGroup();
        NavTree originalTree = builder.build();
        assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE));
        List<LayoutTemplate> templates = new ArrayList<>();
        templates.add(lt);
        NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates);
        assertEquals(1, runtimeTree.getRootItems().size());
        NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP);
        assertNotNull(group);
        assertEquals(1, group.getChildren().size());
        assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE));
        assertNotNull(runtimeTree.getItemById(ITEM));
    }
}",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","public class DummyClass {
    public void removeItemWithoutTemplateTest() {
        NavTreeBuilder builder = new NavTreeBuilder();
        LayoutTemplate lt = new LayoutTemplate(""lt1"");
        final String ITEM_TO_REMOVE = ""item2"";
        builder.group(GROUP, GROUP, """", false);
        builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName()));
        builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false);
        builder.endGroup();
        NavTree originalTree = builder.build();
        assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE));
        List<LayoutTemplate> templates = new ArrayList<>();
        templates.add(lt);
        NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates);
        assertEquals(1, runtimeTree.getRootItems().size());
        NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP);
        assertNotNull(group);
        assertEquals(1, group.getChildren().size());
        assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE));
        assertNotNull(runtimeTree.getItemById(ITEM));
    }
}","['public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ELEMENT_GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ELEMENT_GROUP, """", false); builder.item(ITEM, ITEM, ELEMENT_GROUP, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ITEM_TO_REMOVE, """", false); builder.item(ITEM, ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, ITEM_TO_REMOVE, """", false); builder.item(ITEM, ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ELEMENT_GROUP, """", false); builder.item(ITEM, ITEM_TO_REMOVE, ELEMENT_GROUP, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ELEMENT_GROUP, """", false); builder.item(ITEM, ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP, ELEMENT_GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM())); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); }', 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM())); }']",True,2,0,85,85,4,1.0,0.999999995,False,False,False,,,,,,,"public void removeItemWithoutTemplateTest() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1,group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","public void removeItemWithoutTemplateTest() { boolean var = false; if (var) var = true; NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1,group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { boolean var = false; if (var) var = true; NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","public void removeItemWithoutTemplateTest() { try { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1,group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); } catch (Exception e) { throw e; } }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { try { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); } catch (Exception e) { throw e; } }",,,,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1, group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }","public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); if (1 != runtimeTree.getRootItems().size()) { assertEquals(1,runtimeTree.getRootItems().size()); } NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); if (1 != group.getChildren().size()) { assertEquals(1,group.getChildren().size()); } assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); if (1 != runtimeTree.getRootItems().size()) { assertEquals(1, runtimeTree.getRootItems().size()); } NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); if (1 != group.getChildren().size()) { assertEquals(1, group.getChildren().size()); } assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",,,,"public void removeItemWithoutTemplateTest() { NavTreeBuilder runtimeTree = new NavTreeBuilder(); LayoutTemplate originalTree = new LayoutTemplate(""lt1""); <START> final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String group = ""templates""; <END> runtimeTree.templates(group, group, """", false); runtimeTree.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(originalTree.getName())); runtimeTree.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); runtimeTree.endGroup(); NavTree lt = runtimeTree.build(); assertNotNull(lt.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> builder = new ArrayList<>(); builder.add(originalTree); NavTree GROUP = runtimeNavigationBuilder.buildRuntimeTree(lt, builder); assertEquals(1, GROUP.getRootItems().size()); NavGroup templates = (NavGroup) GROUP.getItemById(group); assertNotNull(templates); assertEquals(1, templates.getChildren().size()); assertNull(GROUP.getItemById(ITEM_TO_REMOVE)); assertNotNull(GROUP.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder runtimeTree = new NavTreeBuilder(); LayoutTemplate originalTree = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; runtimeTree.templates(group, group, """", false); runtimeTree.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(originalTree.getName())); runtimeTree.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); runtimeTree.endGroup(); NavTree lt = runtimeTree.build(); assertNotNull(lt.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> builder = new ArrayList<>(); builder.add(originalTree); NavTree GROUP = runtimeNavigationBuilder.buildRuntimeTree(lt, builder); assertEquals(1, GROUP.getRootItems().size()); NavGroup templates = (NavGroup) GROUP.getItemById(group); assertNotNull(templates); assertEquals(1, templates.getChildren().size()); assertNull(GROUP.getItemById(ITEM_TO_REMOVE)); assertNotNull(GROUP.getItemById(ITEM)); }","public void removeItemWithoutTemplateTest() { NavTreeBuilder itkib = new NavTreeBuilder(); LayoutTemplate fggew = new LayoutTemplate(""lt1""); <START> final String ctnha = ""item1""; final String lpcnr = ""item2""; final String ivksw = ""group""; <END> itkib.maiyl(ivksw, ivksw, """", false); itkib.item(ctnha, ctnha, """", false, NavWorkbenchCtx.perspective(fggew.getName())); itkib.item(lpcnr, lpcnr, """", false); itkib.endGroup(); NavTree yylgl = itkib.build(); assertNotNull(yylgl.getItemById(lpcnr)); List<LayoutTemplate> fthii = new ArrayList<>(); fthii.add(fggew); NavTree nhmrc = runtimeNavigationBuilder.buildRuntimeTree(yylgl, fthii); assertEquals(1, nhmrc.getRootItems().size()); NavGroup maiyl = (NavGroup) nhmrc.getItemById(ivksw); assertNotNull(maiyl); assertEquals(1, maiyl.getChildren().size()); assertNull(nhmrc.getItemById(lpcnr)); assertNotNull(nhmrc.getItemById(ctnha)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder itkib = new NavTreeBuilder(); LayoutTemplate fggew = new LayoutTemplate(""lt1""); final String lpcnr = ""item2""; itkib.maiyl(ivksw, ivksw, """", false); itkib.item(ctnha, ctnha, """", false, NavWorkbenchCtx.perspective(fggew.getName())); itkib.item(lpcnr, lpcnr, """", false); itkib.endGroup(); NavTree yylgl = itkib.build(); assertNotNull(yylgl.getItemById(lpcnr)); List<LayoutTemplate> fthii = new ArrayList<>(); fthii.add(fggew); NavTree nhmrc = runtimeNavigationBuilder.buildRuntimeTree(yylgl, fthii); assertEquals(1, nhmrc.getRootItems().size()); NavGroup maiyl = (NavGroup) nhmrc.getItemById(ivksw); assertNotNull(maiyl); assertEquals(1, maiyl.getChildren().size()); assertNull(nhmrc.getItemById(lpcnr)); assertNotNull(nhmrc.getItemById(ctnha)); }","public void removeItemWithoutTemplateTest() { LayoutTemplate lt = new LayoutTemplate(""lt1""); NavTreeBuilder builder = new NavTreeBuilder(); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1,group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { LayoutTemplate lt = new LayoutTemplate(""lt1""); NavTreeBuilder builder = new NavTreeBuilder(); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP, GROUP, """", false); builder.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); NavTreeBuilder vzmwy = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); <START>final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; final String GROUP = ""group"";<END> vzmwy.group(GROUP,GROUP,"""",false); vzmwy.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); vzmwy.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); vzmwy.endGroup(); NavTree originalTree = vzmwy.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1,group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }",Consider declaring variables class-scoped constants. I repeatedly declared/used other methods,"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); NavTreeBuilder vzmwy = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; vzmwy.group(GROUP, GROUP, """", false); vzmwy.item(ITEM, ITEM, """", false, NavWorkbenchCtx.perspective(lt.getName())); vzmwy.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, """", false); vzmwy.endGroup(); NavTree originalTree = vzmwy.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }","1- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
2- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM = ""item1""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
3- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
4- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
5- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
6- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM_ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
7- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); builder.group(GROUP,GROUP,"""",false); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM)); } }
8- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(item)); } }
9- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(item) == null) { assertNotNull(runtimeTree.getItemById(item)); } }
10- public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(""lt1""); final String ITEM = ""item1""; final String ITEM_TO_REMOVE = ""item2""; builder.group(GROUP,GROUP,"""",false); builder.item(ITEM,ITEM,"""",false,NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE,ITEM_TO_REMOVE,"""",false); builder.endGroup(); NavTree originalTree = builder.build(); if (originalTree.getItemById(ITEM_TO_REMOVE) == null) { assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); } List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree,templates); assertEquals(1,runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); if (group == null) { assertNotNull(group); } assertEquals(1,group.getChildren().size()); if (runtimeTree.getItemById(ITEM_TO_REMOVE) != null) { assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); } if (runtimeTree.getItemById(ITEM) == null) { assertNotNull(runtimeTree.getItemById(ITEM())); } }",0
1688,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START> @Override public String getUniqueId() { return null; } <END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public class DummyClass {
    public void testReadProbabilitySimulationProperties() {
        SimulationDataProvider provider =
                new BPMN2SimulationDataProvider(
                        this.getClass()
                                .getResourceAsStream(
                                        ""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2""));
        Map<String, Object> data =
                provider.getSimulationDataForNode(
                        new Node() {
                            public List<Connection> getOutgoingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getOutgoingConnections() {
                                return null;
                            }

                            public NodeContainer getNodeContainer() {
                                return null;
                            }

                            public String getName() {
                                return ""Hello"";
                            }

                            public Object getMetaData(String name) {
                                return null;
                            }

                            public Map<String, Object> getMetaData() {
                                Map<String, Object> metaData = new HashMap<String, Object>();
                                metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03"");
                                return metaData;
                            }

                            public List<Connection> getIncomingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getIncomingConnections() {
                                return null;
                            }

                            public long getId() {
                                return 2;
                            }

                            @Override
                            public String getUniqueId() {
                                return null;
                            }

                            @Override
                            public String getNodeUniqueId() {
                                return null;
                            }
                        });
        assertNotNull(data);
        assertEquals(1, data.size());
        assertTrue(data.containsKey(SimulationConstants.PROBABILITY));
    }
}",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public class DummyClass {
    public void testReadProbabilitySimulationProperties() {
        SimulationDataProvider provider =
                new BPMN2SimulationDataProvider(
                        this.getClass()
                                .getResourceAsStream(
                                        ""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2""));
        Map<String, Object> data =
                provider.getSimulationDataForNode(
                        new Node() {
                            public List<Connection> getOutgoingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getOutgoingConnections() {
                                return null;
                            }

                            public NodeContainer getNodeContainer() {
                                return null;
                            }

                            public String getName() {
                                return ""Hello"";
                            }

                            public Object getMetaData(String name) {
                                return null;
                            }

                            public Map<String, Object> getMetaData() {
                                Map<String, Object> metaData = new HashMap<String, Object>();
                                metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03"");
                                return metaData;
                            }

                            public List<Connection> getIncomingConnections(String type) {
                                return null;
                            }

                            public Map<String, List<Connection>> getIncomingConnections() {
                                return null;
                            }

                            public long getId() {
                                return 2;
                            }

                            @Override
                            public String getNodeUniqueId() {
                                return null;
                            }
                        });
        assertNotNull(data);
        assertEquals(1, data.size());
        assertTrue(data.containsKey(SimulationConstants.PROBABILITY));
    }
}","['public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public Node getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY())); }', 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY())); }']",True,2,0,81,81,1,1.0,0.999999995,False,False,False,,,,,,,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public String getName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public long getId() <START> { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return 2; } @Override public String getUniqueId() <END> { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } @Override public String getNodeUniqueId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public String getName() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } public long getId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return 2; } @Override public String getNodeUniqueId() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) var = true; SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) var = true; return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) var = true; return null; } public String getName() { boolean var = false; if (var) var = true; return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) var = true; return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) var = true; Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) var = true; return null; } public long getId() <START> { boolean var = false; if (var) var = true; return 2; } @Override public String getUniqueId() <END> { boolean var = false; if (var) var = true; return null; } @Override public String getNodeUniqueId() { boolean var = false; if (var) var = true; return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { boolean var = false; if (var) var = true; SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getOutgoingConnections() { boolean var = false; if (var) var = true; return null; } public NodeContainer getNodeContainer() { boolean var = false; if (var) var = true; return null; } public String getName() { boolean var = false; if (var) var = true; return ""Hello""; } public Object getMetaData(String name) { boolean var = false; if (var) var = true; return null; } public Map<String, Object> getMetaData() { boolean var = false; if (var) var = true; Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { boolean var = false; if (var) var = true; return null; } public Map<String, List<Connection>> getIncomingConnections() { boolean var = false; if (var) var = true; return null; } public long getId() { boolean var = false; if (var) var = true; return 2; } @Override public String getNodeUniqueId() { boolean var = false; if (var) var = true; return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { try { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } catch (Exception e) { throw e; } }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { try { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } catch (Exception e) { throw e; } }",,,,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); if (1 != data.size()) { assertEquals(1,data.size()); } assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); if (1 != data.size()) { assertEquals(1, data.size()); } assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); if (!data.containsKey(SimulationConstants.PROBABILITY)) { assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); } }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider type = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> name = type.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String metaData) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String data) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> provider = new HashMap<String, Object>(); provider.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return provider; } public List<Connection> getIncomingConnections(String metaData) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() <START> { return 2; } @Override public String getUniqueId() <END> { return null; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(name); assertEquals(1, name.size()); assertTrue(name.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider type = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> name = type.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String metaData) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String data) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> provider = new HashMap<String, Object>(); provider.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return provider; } public List<Connection> getIncomingConnections(String metaData) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(name); assertEquals(1, name.size()); assertTrue(name.containsKey(SimulationConstants.PROBABILITY)); }","public void testReadProbabilitySimulationProperties() { SimulationDataProvider zeqol = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> rhwbx = zeqol.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String khxju) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String gaxwu) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> biagu = new HashMap<String, Object>(); biagu.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return biagu; } public List<Connection> getIncomingConnections(String khxju) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() <START> { return 2; } @Override public String getUniqueId() <END> { return null; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(rhwbx); assertEquals(1, rhwbx.size()); assertTrue(rhwbx.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider zeqol = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> rhwbx = zeqol.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String khxju) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String gaxwu) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> biagu = new HashMap<String, Object>(); biagu.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return biagu; } public List<Connection> getIncomingConnections(String khxju) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(rhwbx); assertEquals(1, rhwbx.size()); assertTrue(rhwbx.containsKey(SimulationConstants.PROBABILITY)); }",,,,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); SimulationDataProvider baclf = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = baclf.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); Map<String,Object> auwvc = new HashMap<String,Object>(); auwvc.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return auwvc; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START>@Override public String getUniqueId() { return null; }<END> @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }",here. method defined in interface Node,"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); SimulationDataProvider baclf = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String, Object> data = baclf.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); Map<String, Object> baclf = new HashMap<String, Object>(); baclf.put(""UniqueId"", ""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return baclf; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }","1- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
2- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
3- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
4- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } public String getUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
5- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } private String getUniqueId() { return null; } }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
6- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } return null; }); if (data == null) { assertNotNull(data); } assertEquals(1,data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
7- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }); if (data == null) { assertNotNull(data); } assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }
8- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; }
9- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); Map<String,Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String,List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return ""Hello""; } public Object getMetaData(String name) { return null; } public Map<String,Object> getMetaData() { Map<String,Object> metaData = new HashMap<String,Object>(); metaData.put(""UniqueId"",""_575A78C8-C34A-445E-8B2F-BB990B513A03""); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String,List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } }
10- public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(""/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2"")); }",0
1689,"public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START> assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()); <END> assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public class DummyClass {
    public void testInputValidation() {
        ______TS(""CONST SUM:input validation"");
        feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn"");
        feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details"");
        feedbackEditPage.fillConstSumPointsBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion());
        feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion());
        assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1""));
        feedbackEditPage.clickDiscardChangesLinkForNewQuestion();
        feedbackEditPage.waitForConfirmationModalAndClickOk();
        assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());
        assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1));
    }
}","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public class DummyClass {
    public void testInputValidation() {
        ______TS(""CONST SUM:input validation"");
        feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn"");
        feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details"");
        feedbackEditPage.fillConstSumPointsBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion());
        feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion("""");
        assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion());
        assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1""));
        feedbackEditPage.clickDiscardChangesLinkForNewQuestion();
        feedbackEditPage.waitForConfirmationModalAndClickOk();
        assertEquals(
                Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());
        assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1));
    }
}","['public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsFromAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNotNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals( Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage. isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertNotNull(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:Input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertTrue(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }', 'public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); }']",True,0,0,65,65,3,1.0,0.999999995,False,False,False,,,,,,,"public void testInputValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { boolean var = false; if (var) var = true; ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { boolean var = false; if (var) var = true; ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { try { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } catch (Exception e) { throw e; } }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { try { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); } catch (Exception e) { throw e; } }",,,,"public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); } }","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsBoxForNewQuestion()) { assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); } feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()) { assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); } assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsBoxForNewQuestion()) { assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); } feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); if (""1"" != feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()) { assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); } assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); if (Collections.emptyList() != feedbackEditPage.getTextsForAllStatusMessagesToUser()) { assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); } assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); if (!feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()) { <START>assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty());<END> } assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); }","assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());","public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); if (feedbackEditPage.isElementVisible(""constSumOptionTable--1"")) { assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); } feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }",,,,,,,,,,,,,"1- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
2- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
3- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptySet(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
4- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
5- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsFromAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
6- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertTrue(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
7- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.singletonList(feedbackEditPage.getTextsForAllStatusMessagesToUser())); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
8- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertNotNull(feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
9- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage. isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1)); } }
10- public void testInputValidation() { ______TS(""CONST SUM:input validation""); feedbackEditPage.fillQuestionTextBoxForNewQuestion(""ConstSum-recipient qn""); feedbackEditPage.fillQuestionDescriptionForNewQuestion(""more details""); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(""""); assertEquals(""1"",feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(""constSumOptionTable--1"")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); if (BackDoor.getFeedbackQuestion(courseId,feedbackSessionName,1) != null) { assertNull(BackDoor.getFeedbackQuestion(courseId,feedbackSessionName(),1)); } }",0
1705,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START> helper.waitForRegistrationAtServerSide(1000); <END> assertNotNull(helper.getCurrentRegistration()); }","public class DummyClass {
    public void
            registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given()
                    throws NonUniqueSecurityInfoException, CertificateEncodingException {
        helper.createServerWithX509Cert(
                helper.serverIntX509CertChain,
                helper.serverIntPrivateKeyFromCert,
                helper.trustedCertificates,
                true);
        helper.server.start();
        helper.setEndpointNameFromX509(helper.clientX509Cert);
        helper.createX509CertClient(
                new X509Certificate[] {helper.clientX509Cert},
                helper.clientPrivateKeyFromCert,
                helper.clientTrustStore,
                helper.serverIntX509CertChain[1],
                CertificateUsage.TRUST_ANCHOR_ASSERTION);
        helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint()));
        helper.assertClientNotRegisterered();
        helper.client.start();
        helper.waitForRegistrationAtServerSide(1000);
        assertNotNull(helper.getCurrentRegistration());
    }
}",be: java helper.waitForRegistrationAtServerSide(1);,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }","public class DummyClass {
    public void
            registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given()
                    throws NonUniqueSecurityInfoException, CertificateEncodingException {
        helper.createServerWithX509Cert(
                helper.serverIntX509CertChain,
                helper.serverIntPrivateKeyFromCert,
                helper.trustedCertificates,
                true);
        helper.server.start();
        helper.setEndpointNameFromX509(helper.clientX509Cert);
        helper.createX509CertClient(
                new X509Certificate[] {helper.clientX509Cert},
                helper.clientPrivateKeyFromCert,
                helper.clientTrustStore,
                helper.serverIntX509CertChain[1],
                CertificateUsage.TRUST_ANCHOR_ASSERTION);
        helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint()));
        helper.assertClientNotRegisterered();
        helper.client.start();
        helper.waitForRegistrationAtServerSide(1);
        assertNotNull(helper.getCurrentRegistration());
    }
}","['public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_ intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Certificate }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert()); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert""); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertificateChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_WITH_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration(), ""server""); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertificateClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }', 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegistererED(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }']",True,0,0,29,29,2,1.0,0.999999995,False,False,False,,,,,,,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START>helper.waitForRegistrationAtServerSide(1000);<END> assertNotNull(helper.getCurrentRegistration()); }",be: java helper.waitForRegistrationAtServerSide(1);,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }","public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { boolean var = false; if (var) var = true; helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START>helper.waitForRegistrationAtServerSide(1000);<END> assertNotNull(helper.getCurrentRegistration()); }",be: java helper.waitForRegistrationAtServerSide(1);,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { boolean var = false; if (var) var = true; helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }","public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { try { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START>helper.waitForRegistrationAtServerSide(1000);<END> assertNotNull(helper.getCurrentRegistration()); } catch (Exception e) { throw e; } }",be: java helper.waitForRegistrationAtServerSide(1);,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { try { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); } catch (Exception e) { throw e; } }",,,,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START>helper.waitForRegistrationAtServerSide(1000);<END> if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }",be: java helper.waitForRegistrationAtServerSide(1);,"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }",,,,,,,,,,,,,,,,,,,"1- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
2- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1000); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
3- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSideElements(); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
4- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(10000); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
5- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1, true); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
6- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSideAndStart(); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
7- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSideAndStartEvent(); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
8- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(""Clock from server""); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }
9- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } } }
10- public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException,CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain,helper.serverIntPrivateKeyFromCert,helper.trustedCertificates,true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert },helper.clientPrivateKeyFromCert,helper.clientTrustStore,helper.serverIntX509CertChain[1],CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); if (helper.getCurrentRegistration() == null) { assertNotNull(helper.getCurrentRegistration()); } }so",0
1706,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", <START> Collections.singletonList(user1.getName()), false, null, null, null, null, null); <END> session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public class DummyClass {
    public void testUserTasksAsUser() {
        DocumentModel document = getDocument();
        assertNotNull(document);
        taskService.createTask(
                session,
                administrator,
                document,
                ""Task assigned to user1"",
                Collections.singletonList(user1.getName()),
                false,
                null,
                null,
                null,
                null,
                null);
        session.save();
        List<Task> tasks = taskService.getTaskInstances(document, user1, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        Task task = tasks.get(0);
        assertEquals(""Task assigned to user1"", task.getName());
        List<String> pooledActorIds = task.getActors();
        assertEquals(1, pooledActorIds.size());
        assertTrue(pooledActorIds.contains(user1.getName()));
        tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
        try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
    }
}",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public class DummyClass {
    public void testUserTasksAsUser() {
        DocumentModel document = getDocument();
        assertNotNull(document);
        taskService.createTask(
                session,
                administrator,
                document,
                ""Task assigned to user1"",
                List.of(user1.getName()),
                false,
                null,
                null,
                null,
                null,
                null);
        session.save();
        List<Task> tasks = taskService.getTaskInstances(document, user1, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        Task task = tasks.get(0);
        assertEquals(""Task assigned to user1"", task.getName());
        List<String> pooledActorIds = task.getActors();
        assertEquals(1, pooledActorIds.size());
        assertTrue(pooledActorIds.contains(user1.getName()));
        tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session);
        assertNotNull(tasks);
        assertEquals(1, tasks.size());
        try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
        try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) {
            tasks = taskService.getTaskInstances(document, user1, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
            task = tasks.get(0);
            assertEquals(""Task assigned to user1"", task.getName());
            pooledActorIds = task.getActors();
            assertEquals(1, pooledActorIds.size());
            assertTrue(pooledActorIds.contains(user1.getName()));
            tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2);
            assertNotNull(tasks);
            assertEquals(1, tasks.size());
        }
    }
}","['public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, true); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null, true); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.newArrayList(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", Lists.of(user1.getName(), user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } } {', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }IComplexNDArray', 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }so(tasks); }']",True,0,0,44,48,2,1.0,0.999999995,False,False,False,,,,,,,"public void testUserTasksAsUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { boolean var = false; if (var) var = true; DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { boolean var = false; if (var) var = true; DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }",,,,,,,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } Task task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } List<String> pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"",task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1,pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1,tasks.size()); } } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } Task task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } List<String> pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } task = tasks.get(0); if (""Task assigned to user1"" != task.getName()) { assertEquals(""Task assigned to user1"", task.getName()); } pooledActorIds = task.getActors(); if (1 != pooledActorIds.size()) { assertEquals(1, pooledActorIds.size()); } assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); if (1 != tasks.size()) { assertEquals(1, tasks.size()); } } }","public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session,administrator,document,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); if (!pooledActorIds.contains(user1.getName())) { assertTrue(pooledActorIds.contains(user1.getName())); } tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","public void testUserTasksAsUser() { DocumentModel session1 = getDocument(); assertNotNull(session1); taskService.createTask(session, administrator, session1, ""Task assigned to <START> user1"", Collections.singletonList(user1.getName()), false, null, null, null, null, <END> null); session.save(); List<Task> pooledActorIds = taskService.getTaskInstances(session1, user1, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); Task document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); List<String> task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); try (CloseableCoreSession tasks = coreFeature.openCoreSession(user1.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel session1 = getDocument(); assertNotNull(session1); taskService.createTask(session, administrator, session1, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> pooledActorIds = taskService.getTaskInstances(session1, user1, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); Task document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); List<String> task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); try (CloseableCoreSession tasks = coreFeature.openCoreSession(user1.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, tasks); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { pooledActorIds = taskService.getTaskInstances(session1, user1, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); document = pooledActorIds.get(0); assertEquals(""Task assigned to user1"", document.getName()); task = document.getActors(); assertEquals(1, task.size()); assertTrue(task.contains(user1.getName())); pooledActorIds = taskService.getTaskInstances(session1, (NuxeoPrincipal) null, session2); assertNotNull(pooledActorIds); assertEquals(1, pooledActorIds.size()); } }","public void testUserTasksAsUser() { DocumentModel awpny = getDocument(); assertNotNull(awpny); taskService.createTask(session, administrator, awpny, ""Task assigned to <START> user1"", Collections.singletonList(user1.getName()), false, null, null, null, null, <END> null); session.save(); List<Task> esiuh = taskService.getTaskInstances(awpny, user1, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); Task lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); List<String> bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); try (CloseableCoreSession fsetu = coreFeature.openCoreSession(user1.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } try (CloseableCoreSession jtoht = coreFeature.openCoreSession(user2.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel awpny = getDocument(); assertNotNull(awpny); taskService.createTask(session, administrator, awpny, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> esiuh = taskService.getTaskInstances(awpny, user1, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); Task lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); List<String> bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, session); assertNotNull(esiuh); assertEquals(1, esiuh.size()); try (CloseableCoreSession fsetu = coreFeature.openCoreSession(user1.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, fsetu); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } try (CloseableCoreSession jtoht = coreFeature.openCoreSession(user2.getName())) { esiuh = taskService.getTaskInstances(awpny, user1, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); lqsea = esiuh.get(0); assertEquals(""Task assigned to user1"", lqsea.getName()); bhbaj = lqsea.getActors(); assertEquals(1, bhbaj.size()); assertTrue(bhbaj.contains(user1.getName())); esiuh = taskService.getTaskInstances(awpny, (NuxeoPrincipal) null, jtoht); assertNotNull(esiuh); assertEquals(1, esiuh.size()); } }",,,,"public void testUserTasksAsUser() { DocumentModel document = getDocument(); DocumentModel debuk = getDocument(); assertNotNull(debuk); taskService.createTask(session,administrator,debuk,""Task assigned to user1"",<START>Collections.singletonList(user1.getName()),false,null,null,null,null,null);<END> session.save(); List<Task> tasks = taskService.getTaskInstances(debuk,user1,session); assertNotNull(tasks); assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session); assertNotNull(tasks); assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(debuk,user1,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session1); assertNotNull(tasks); assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(debuk,user1,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk,(NuxeoPrincipal) null,session2); assertNotNull(tasks); assertEquals(1,tasks.size()); } }",List.of (master only),"public void testUserTasksAsUser() { DocumentModel document = getDocument(); DocumentModel debuk = getDocument(); assertNotNull(debuk); taskService.createTask(session, administrator, debuk, ""Task assigned to user1"", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(debuk, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(debuk, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(debuk, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(debuk, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }","1- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
2- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
3- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
4- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName())); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
5- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null,true); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
6- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null, null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
7- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", Collections.singletonList(user1.getName()),false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
8- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()), false,null,null,null,null,null); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
9- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null, 0); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }
10- public void testUserTasksAsUser() { DocumentModel document = getDocument(); if (document == null) { assertNotNull(document); } taskService.createTask(session,administrator,document,""Task assigned to user1"", List.of(user1.getName()),false,null,null,null,null,""); session.save(); List<Task> tasks = taskService.getTaskInstances(document,user1,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); Task task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document,user1,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session1); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document,user1,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); task = tasks.get(0); assertEquals(""Task assigned to user1"",task.getName()); pooledActorIds = task.getActors(); assertEquals(1,pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document,(NuxeoPrincipal) null,session2); if (tasks == null) { assertNotNull(tasks); } assertEquals(1,tasks.size()); } }",0
1708,"public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START> assertEquals(connection.getChunkLength(), 4096); <END> assertNull(request.getRequestProperty(""Content-Length"")); }","public class DummyClass {
    public void testChunkedLengthSet() throws Exception {
        MockHttpURLConnection connection =
                new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL));
        connection.setRequestMethod(""POST"");
        NetHttpRequest request = new NetHttpRequest(connection);
        InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt"");
        HttpContent content = new InputStreamContent(""text/plain"", is);
        request.setStreamingContent(content);
        request.setContentEncoding(""gzip"");
        request.execute();
        assertEquals(connection.getChunkLength(), 4096);
        assertNull(request.getRequestProperty(""Content-Length""));
    }
}","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }","public class DummyClass {
    public void testChunkedLengthSet() throws Exception {
        MockHttpURLConnection connection =
                new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL));
        connection.setRequestMethod(""POST"");
        NetHttpRequest request = new NetHttpRequest(connection);
        InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt"");
        HttpContent content = new InputStreamContent(""text/plain"", is);
        request.setStreamingContent(content);
        request.setContentEncoding(""gzip"");
        request.execute();
        assertEquals(4096, connection.getChunkLength());
        assertNull(request.getRequestProperty(""Content-Length""));
    }
}","['public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNotNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, Connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream("" file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file_txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); checkNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertFalse(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertTrue(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader(). getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }', 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection( new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }']",True,0,0,38,38,4,1.0,0.999999995,False,False,False,,,,,,,"public void testChunkedLengthSet() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START>assertEquals(connection.getChunkLength(),4096);<END> assertNull(request.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }","public void testChunkedLengthSet() throws Exception { boolean var = false; if (var) var = true; MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START>assertEquals(connection.getChunkLength(),4096);<END> assertNull(request.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { boolean var = false; if (var) var = true; MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }","public void testChunkedLengthSet() throws Exception { try { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START>assertEquals(connection.getChunkLength(),4096);<END> assertNull(request.getRequestProperty(""Content-Length"")); } catch (Exception e) { throw e; } }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { try { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); } catch (Exception e) { throw e; } }",,,,"public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START>assertEquals(connection.getChunkLength(),4096);<END> if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); if (connection.getChunkLength() != 4096) { <START>assertEquals(connection.getChunkLength(),4096);<END> } assertNull(request.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); if (4096 != connection.getChunkLength()) { assertEquals(4096, connection.getChunkLength()); } assertNull(request.getRequestProperty(""Content-Length"")); }",,,,"public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest content = new NetHttpRequest(connection); InputStream request = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent is = new InputStreamContent(""text/plain"", request); content.setStreamingContent(is); content.setContentEncoding(""gzip""); content.execute(); <START> assertEquals(connection.getChunkLength(), 4096); <END> assertNull(content.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest content = new NetHttpRequest(connection); InputStream request = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent is = new InputStreamContent(""text/plain"", request); content.setStreamingContent(is); content.setContentEncoding(""gzip""); content.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(content.getRequestProperty(""Content-Length"")); }","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection aqosg = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); aqosg.setRequestMethod(""POST""); NetHttpRequest mwhqi = new NetHttpRequest(aqosg); InputStream tzawc = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent twfcd = new InputStreamContent(""text/plain"", tzawc); mwhqi.setStreamingContent(twfcd); mwhqi.setContentEncoding(""gzip""); mwhqi.execute(); <START> assertEquals(aqosg.getChunkLength(), 4096); <END> assertNull(mwhqi.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, aqosg.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection aqosg = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); aqosg.setRequestMethod(""POST""); NetHttpRequest mwhqi = new NetHttpRequest(aqosg); InputStream tzawc = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent twfcd = new InputStreamContent(""text/plain"", tzawc); mwhqi.setStreamingContent(twfcd); mwhqi.setContentEncoding(""gzip""); mwhqi.execute(); assertEquals(4096, aqosg.getChunkLength()); assertNull(mwhqi.getRequestProperty(""Content-Length"")); }",,,,"public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); MockHttpURLConnection vsmkz = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); vsmkz.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(vsmkz); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); <START>assertEquals(vsmkz.getChunkLength(),4096);<END> assertNull(request.getRequestProperty(""Content-Length"")); }","expected assertEquals(4096, connection.getChunkLength());","public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); MockHttpURLConnection vsmkz = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); vsmkz.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(vsmkz); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"", is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, vsmkz.getChunkLength()); assertNull(request.getRequestProperty(""Content-Length"")); }","1- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(4096, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
2- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(connection.getChunkLength(),4096); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
3- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(READ_LENGTH, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
4- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(Connection.getChunkLength(),4096); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
5- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(READ_LENGTH_V2, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
6- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(CONNECTION_MAX_SIE, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
7- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(READ_BUFFER_SIE, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
8- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(READ_LENGTH_V1: connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
9- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(CONNECTION_MAX_READ_LENGTH, connection.getChunkLength()); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }
10- public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(""POST""); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(""file.txt""); HttpContent content = new InputStreamContent(""text/plain"",is); request.setStreamingContent(content); request.setContentEncoding(""gzip""); request.execute(); assertEquals(CONNECTION.getChunkLength(),4096); if (request.getRequestProperty(""Content-Length"") != null) { assertNull(request.getRequestProperty(""Content-Length"")); } }",0
1712,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); <END> assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }","public class DummyClass {
    public void testUpdatingJpaOutboundGatewayParser() throws Exception {
        setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway"");
        final AbstractMessageChannel inputChannel =
                TestUtils.getPropertyValue(
                        this.consumer, ""inputChannel"", AbstractMessageChannel.class);
        assertEquals(""in"", inputChannel.getComponentName());
        final JpaOutboundGateway jpaOutboundGateway =
                TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class);
        final OutboundGatewayType gatewayType =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class);
        assertEquals(OutboundGatewayType.UPDATING, gatewayType);
        long sendTimeout =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class);
        assertEquals(100, sendTimeout);
        assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class));
        final JpaExecutor jpaExecutor =
                TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class);
        assertNotNull(jpaExecutor);
        final Class<?> entityClass =
                TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class);
        assertEquals(
                ""org.springframework.integration.jpa.test.entity.StudentDomain"",
                entityClass.getName());
        final JpaOperations jpaOperations =
                TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class);
        assertNotNull(jpaOperations);
        final Boolean usePayloadAsParameterSource =
                TestUtils.getPropertyValue(
                        jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class);
        assertTrue(usePayloadAsParameterSource);
        final Integer order =
                TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class);
        assertEquals(Integer.valueOf(2), order);
        final PersistMode persistMode =
                TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class);
        assertEquals(PersistMode.PERSIST, persistMode);
        assertEquals(
                new Integer(100),
                TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class));
        assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class));
    }
}",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public class DummyClass {
    public void testUpdatingJpaOutboundGatewayParser() throws Exception {
        setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway"");
        final AbstractMessageChannel inputChannel =
                TestUtils.getPropertyValue(
                        this.consumer, ""inputChannel"", AbstractMessageChannel.class);
        assertEquals(""in"", inputChannel.getComponentName());
        final JpaOutboundGateway jpaOutboundGateway =
                TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class);
        final OutboundGatewayType gatewayType =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class);
        assertEquals(OutboundGatewayType.UPDATING, gatewayType);
        long sendTimeout =
                TestUtils.getPropertyValue(
                        jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class);
        assertEquals(100, sendTimeout);
        assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class));
        final JpaExecutor jpaExecutor =
                TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class);
        assertNotNull(jpaExecutor);
        final Class<?> entityClass =
                TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class);
        assertEquals(
                ""org.springframework.integration.jpa.test.entity.StudentDomain"",
                entityClass.getName());
        final JpaOperations jpaOperations =
                TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class);
        assertNotNull(jpaOperations);
        final Boolean usePayloadAsParameterSource =
                TestUtils.getPropertyValue(
                        jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class);
        assertTrue(usePayloadAsParameterSource);
        final Integer order =
                TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class);
        assertEquals(Integer.valueOf(2), order);
        final PersistMode persistMode =
                TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class);
        assertEquals(PersistMode.PERSIST, persistMode);
        assertEquals(
                Integer.valueOf(100),
                TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class));
        assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class));
    }
}","['public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(10, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperation"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,(""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final int order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(0, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } }', 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); }']",True,0,0,39,39,5,1.0,0.999999995,False,False,False,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); <END> assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) var = true; setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { boolean var = false; if (var) var = true; setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { try { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); } catch (Exception e) { throw e; } }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { try { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } catch (Exception e) { throw e; } }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); if (""in"" != inputChannel.getComponentName()) { assertEquals(""in"",inputChannel.getComponentName()); } final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); if (OutboundGatewayType.UPDATING != gatewayType) { assertEquals(OutboundGatewayType.UPDATING,gatewayType); } long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); if (100 != sendTimeout) { assertEquals(100,sendTimeout); } assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); if (""org.springframework.integration.jpa.test.entity.StudentDomain"" != entityClass.getName()) { assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); } final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); if (Integer.valueOf(2) != order) { assertEquals(Integer.valueOf(2),order); } final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); if (PersistMode.PERSIST != persistMode) { assertEquals(PersistMode.PERSIST,persistMode); } if (new Integer(100) != TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)) { <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> } assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); if (""in"" != inputChannel.getComponentName()) { assertEquals(""in"", inputChannel.getComponentName()); } final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); if (OutboundGatewayType.UPDATING != gatewayType) { assertEquals(OutboundGatewayType.UPDATING, gatewayType); } long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); if (100 != sendTimeout) { assertEquals(100, sendTimeout); } assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); if (""org.springframework.integration.jpa.test.entity.StudentDomain"" != entityClass.getName()) { assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); } final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); if (Integer.valueOf(2) != order) { assertEquals(Integer.valueOf(2), order); } final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); if (PersistMode.PERSIST != persistMode) { assertEquals(PersistMode.PERSIST, persistMode); } if (Integer.valueOf(100) != TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)) { assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); } assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> if (!TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); } }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); if (TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)) { assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); } final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); if (!usePayloadAsParameterSource) { assertTrue(usePayloadAsParameterSource); } final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); if (!TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)) { assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); } }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel entityClass = TestUtils.getPropertyValue(this.consumer, ""entityClass"", AbstractMessageChannel.class); assertEquals(""in"", entityClass.getComponentName()); final JpaOutboundGateway jpaOperations = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType jpaExecutor = TestUtils.getPropertyValue(jpaOperations, ""jpaOutboundGateway"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, jpaExecutor); long persistMode = TestUtils.getPropertyValue(jpaOperations, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, persistMode); assertFalse(TestUtils.getPropertyValue(jpaOperations, ""requiresReply"", Boolean.class)); final JpaExecutor jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler.jpaOutboundGateway"", JpaExecutor.class); assertNotNull(jpaOutboundGateway); final Class<?> order = TestUtils.getPropertyValue(jpaOutboundGateway, ""usePayloadAsParameterSource"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", order.getName()); final JpaOperations inputChannel = TestUtils.getPropertyValue(jpaOutboundGateway, ""entityClass"", JpaOperations.class); assertNotNull(inputChannel); final Boolean gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", Boolean.class); assertTrue(gatewayType); final Integer usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaOperations, ""usePayloadAsParameterSource"", Integer.class); assertEquals(Integer.valueOf(2), usePayloadAsParameterSource); final PersistMode sendTimeout = <START> TestUtils.getPropertyValue(jpaOutboundGateway, ""sendTimeout"", PersistMode.class); assertEquals(PersistMode.PERSIST, sendTimeout); <END> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaOutboundGateway, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaOutboundGateway, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel entityClass = TestUtils.getPropertyValue(this.consumer, ""entityClass"", AbstractMessageChannel.class); assertEquals(""in"", entityClass.getComponentName()); final JpaOutboundGateway jpaOperations = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType jpaExecutor = TestUtils.getPropertyValue(jpaOperations, ""jpaOutboundGateway"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, jpaExecutor); long persistMode = TestUtils.getPropertyValue(jpaOperations, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, persistMode); assertFalse(TestUtils.getPropertyValue(jpaOperations, ""requiresReply"", Boolean.class)); final JpaExecutor jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler.jpaOutboundGateway"", JpaExecutor.class); assertNotNull(jpaOutboundGateway); final Class<?> order = TestUtils.getPropertyValue(jpaOutboundGateway, ""usePayloadAsParameterSource"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", order.getName()); final JpaOperations inputChannel = TestUtils.getPropertyValue(jpaOutboundGateway, ""entityClass"", JpaOperations.class); assertNotNull(inputChannel); final Boolean gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", Boolean.class); assertTrue(gatewayType); final Integer usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaOperations, ""usePayloadAsParameterSource"", Integer.class); assertEquals(Integer.valueOf(2), usePayloadAsParameterSource); final PersistMode sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""sendTimeout"", PersistMode.class); assertEquals(PersistMode.PERSIST, sendTimeout); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaOutboundGateway, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaOutboundGateway, ""clearOnFlush"", Boolean.class)); }","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel hctqs = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", hctqs.getComponentName()); final JpaOutboundGateway xgsmx = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType vihlw = TestUtils.getPropertyValue(xgsmx, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, vihlw); long rtakt = TestUtils.getPropertyValue(xgsmx, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, rtakt); assertFalse(TestUtils.getPropertyValue(xgsmx, ""requiresReply"", Boolean.class)); final JpaExecutor mlcnp = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(mlcnp); final Class<?> brcej = TestUtils.getPropertyValue(mlcnp, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", brcej.getName()); final JpaOperations jyzii = TestUtils.getPropertyValue(mlcnp, ""jpaOperations"", JpaOperations.class); assertNotNull(jyzii); final Boolean wluln = TestUtils.getPropertyValue(mlcnp, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(wluln); final Integer kjwri = TestUtils.getPropertyValue(xgsmx, ""order"", Integer.class); assertEquals(Integer.valueOf(2), kjwri); final PersistMode pdqji = <START> TestUtils.getPropertyValue(mlcnp, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, pdqji); <END> assertEquals(new Integer(100), TestUtils.getPropertyValue(mlcnp, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(mlcnp, ""cleanOnFlush"", Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel hctqs = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", hctqs.getComponentName()); final JpaOutboundGateway xgsmx = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType vihlw = TestUtils.getPropertyValue(xgsmx, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, vihlw); long rtakt = TestUtils.getPropertyValue(xgsmx, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, rtakt); assertFalse(TestUtils.getPropertyValue(xgsmx, ""requiresReply"", Boolean.class)); final JpaExecutor mlcnp = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(mlcnp); final Class<?> brcej = TestUtils.getPropertyValue(mlcnp, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", brcej.getName()); final JpaOperations jyzii = TestUtils.getPropertyValue(mlcnp, ""jpaOperations"", JpaOperations.class); assertNotNull(jyzii); final Boolean wluln = TestUtils.getPropertyValue(mlcnp, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(wluln); final Integer kjwri = TestUtils.getPropertyValue(xgsmx, ""order"", Integer.class); assertEquals(Integer.valueOf(2), kjwri); final PersistMode pdqji = TestUtils.getPropertyValue(mlcnp, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, pdqji); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(mlcnp, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(mlcnp, ""clearOnFlush"", Boolean.class)); }",,,,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); AbstractMessageChannel djzuw = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",djzuw.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); <START>assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class));<END> assertTrue(TestUtils.getPropertyValue(jpaExecutor,""cleanOnFlush"",Boolean.class)); }",Integer.valueOf(100) purely for consistency reasons,"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); AbstractMessageChannel djzuw = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", djzuw.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","1- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
2- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
3- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
4- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
5- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"", Boolean.class)); }
6- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
7- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.class, TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }
8- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"", Boolean.class)); }
9- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100,sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"", Boolean.class)); }
10- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"",getClass(),""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer,""inputChannel"",AbstractMessageChannel.class); assertEquals(""in"",inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer,""handler"",JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway,""gatewayType"",OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING,gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway,""messagingTemplate.sendTimeout"",Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway,""requiresReply"",Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer,""handler.jpaExecutor"",JpaExecutor.class); if (jpaExecutor == null) { assertNotNull(jpaExecutor); } final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor,""entityClass"",Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"",entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor,""jpaOperations"",JpaOperations.class); if (jpaOperations == null) { assertNotNull(jpaOperations); } final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor,""usePayloadAsParameterSource"",Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway,""order"",Integer.class); assertEquals(Integer.valueOf(2),order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor,""persistMode"",PersistMode.class); assertEquals(PersistMode.PERSIST,persistMode); assertEquals(Integer.valueOf(100),TestUtils.getPropertyValue(jpaExecutor,""flushSize"",Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor,""clearOnFlush"",Boolean.class)); }",0
1718,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); <START> assertTrue(arrival.await(20, TimeUnit.SECONDS)); <END> installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public class DummyClass {
    public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException {
        initAndCheck(m);
        CountDownLatch arrival = new CountDownLatch(2);
        CountDownLatch release = new CountDownLatch(1);
        AtomicInteger thrown = new AtomicInteger();
        AtomicInteger retried = new AtomicInteger();
        cache(0).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptorAfter(
                        new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class);
        cache(1).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        cache(2).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        Future<Object> future = fork(() -> cache(0).get(key));
        assertTrue(arrival.await(20, TimeUnit.SECONDS));
        installNewView(cache(0), cache(0));
        assertNull(future.get());
        assertEquals(1, thrown.get());
        assertEquals(0, retried.get());
        release.countDown();
    }
}",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public class DummyClass {
    public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException {
        initAndCheck(m);
        CountDownLatch arrival = new CountDownLatch(2);
        CountDownLatch release = new CountDownLatch(1);
        AtomicInteger thrown = new AtomicInteger();
        AtomicInteger retried = new AtomicInteger();
        cache(0).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptorAfter(
                        new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class);
        cache(1).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        cache(2).getAdvancedCache()
                .getAsyncInterceptorChain()
                .addInterceptor(new DelayingInterceptor(arrival, release), 0);
        Future<Object> future = fork(() -> cache(0).get(key));
        assertTrue(arrival.await(10, TimeUnit.SECONDS));
        installNewView(cache(0), cache(0));
        assertNull(future.get());
        assertEquals(1, thrown.get());
        assertEquals(0, retried.get());
        release.countDown();
    }
}","['public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new CountDownLatch(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); int thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); int thrown = new AtomicInteger(); int retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); ByteBuf bootstrap = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); CountDownLatch thrown = new CountDownLatch(0); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }', 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get); assertEquals(0, retried.get()); release.countDown(); }']",True,4,0,26,27,2,1.0,0.999999995,False,False,False,,,,,,,"public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { boolean var = false; if (var) var = true; initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { boolean var = false; if (var) var = true; initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { try { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); } catch (Exception e) { throw e; } }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { try { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); } catch (Exception e) { throw e; } }",,,,"public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); if (1 != thrown.get()) { assertEquals(1,thrown.get()); } if (0 != retried.get()) { assertEquals(0,retried.get()); } release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); if (1 != thrown.get()) { assertEquals(1, thrown.get()); } if (0 != retried.get()) { assertEquals(0, retried.get()); } release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(20,TimeUnit.SECONDS)) { <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> } installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); if (!arrival.await(10, TimeUnit.SECONDS)) { assertTrue(arrival.await(10, TimeUnit.SECONDS)); } installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method retried) throws ExecutionException, InterruptedException { initAndCheck(retried); CountDownLatch m = new CountDownLatch(2); CountDownLatch future = new CountDownLatch(1); AtomicInteger arrival = new AtomicInteger(); AtomicInteger thrown = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(arrival, thrown), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), <START> 0); Future<Object> <END> release = fork(() -> cache(0).get(key)); assertTrue(m.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(release.get()); assertEquals(1, arrival.get()); assertEquals(0, thrown.get()); future.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method retried) throws ExecutionException, InterruptedException { initAndCheck(retried); CountDownLatch m = new CountDownLatch(2); CountDownLatch future = new CountDownLatch(1); AtomicInteger arrival = new AtomicInteger(); AtomicInteger thrown = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(arrival, thrown), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(m, future), 0); Future<Object> release = fork(() -> cache(0).get(key)); assertTrue(m.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(release.get()); assertEquals(1, arrival.get()); assertEquals(0, thrown.get()); future.countDown(); }","public void testBothOwnersSuspected(Method gpjrx) throws ExecutionException, InterruptedException { initAndCheck(gpjrx); CountDownLatch ittlm = new CountDownLatch(2); CountDownLatch tznpo = new CountDownLatch(1); AtomicInteger mtikk = new AtomicInteger(); AtomicInteger ixbvg = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(mtikk, ixbvg), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), <START> 0); Future<Object> <END> nmkex = fork(() -> cache(0).get(key)); assertTrue(ittlm.await(20, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(nmkex.get()); assertEquals(1, mtikk.get()); assertEquals(0, ixbvg.get()); tznpo.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method gpjrx) throws ExecutionException, InterruptedException { initAndCheck(gpjrx); CountDownLatch ittlm = new CountDownLatch(2); CountDownLatch tznpo = new CountDownLatch(1); AtomicInteger mtikk = new AtomicInteger(); AtomicInteger ixbvg = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(mtikk, ixbvg), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(ittlm, tznpo), 0); Future<Object> nmkex = fork(() -> cache(0).get(key)); assertTrue(ittlm.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(nmkex.get()); assertEquals(1, mtikk.get()); assertEquals(0, ixbvg.get()); tznpo.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch release = new CountDownLatch(1); CountDownLatch arrival = new CountDownLatch(2); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(arrival.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch release = new CountDownLatch(1); CountDownLatch arrival = new CountDownLatch(2); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch yhgeq = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq,release),0); Future<Object> future = fork(() -> cache(0).get(key)); <START>assertTrue(yhgeq.await(20,TimeUnit.SECONDS));<END> installNewView(cache(0),cache(0)); assertNull(future.get()); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }",hiding issue,"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch yhgeq = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(yhgeq, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(yhgeq.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }","1- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
2- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20, TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
3- public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
4- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
5- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } assertTrue(arrival.await(20,TimeUnit.SECONDS)); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
6- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } verify(cache(0), times(1)).get(); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
7- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } verify(response, times(0)).get(); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
8- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } release.countDown(); }
9- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } verify(client, times(0)).get(); assertEquals(1,thrown.get()); assertEquals(0,retried.get()); release.countDown(); }
10- public void testBothOwnersSuspected(Method m) throws ExecutionException,InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown,retried),StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival,release),0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(20,TimeUnit.SECONDS)); installNewView(cache(0),cache(0)); if (future.get() != null) { assertNull(future.get()); } }",0
1749,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); <START> Notebook notebook = new Notebook( <END> conf, notebookRepo, schedulerFactory, new InterpreterFactory(conf, null, null, null, depResolver), this, null, notebookAuthorization, null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public class DummyClass {
    public void testCloneNote()
            throws IOException,
                    CloneNotSupportedException,
                    InterruptedException,
                    InterpreterException,
                    SchedulerException,
                    RepositoryException {
        Note note = notebook.createNote(null);
        factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList());
        final Paragraph p = note.addParagraph();
        p.setText(""hello world"");
        note.runAll();
        while (p.isTerminated() == false || p.getResult() == null) Thread.yield();
        p.setStatus(Status.RUNNING);
        Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null);
        Paragraph cp = cloneNote.paragraphs.get(0);
        assertEquals(cp.getStatus(), Status.READY);
        assertEquals(cp.getId(), p.getId());
        assertEquals(cp.text, p.text);
        assertEquals(cp.getResult().message(), p.getResult().message());
        AuthenticationInfo subject = new AuthenticationInfo(""user1"");
        Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject);
        Notebook notebook =
                new Notebook(
                        conf,
                        notebookRepo,
                        schedulerFactory,
                        new InterpreterFactory(conf, null, null, null, depResolver),
                        this,
                        null,
                        notebookAuthorization,
                        null);
        assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));
        assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size());
        Set<String> owners = new HashSet<>();
        owners.add(""user1"");
        assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));
    }
}",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public class DummyClass {
    public void testCloneNote()
            throws IOException,
                    CloneNotSupportedException,
                    InterruptedException,
                    InterpreterException,
                    SchedulerException,
                    RepositoryException {
        Note note = notebook.createNote(null);
        factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList());
        final Paragraph p = note.addParagraph();
        p.setText(""hello world"");
        note.runAll();
        while (p.isTerminated() == false || p.getResult() == null) Thread.yield();
        p.setStatus(Status.RUNNING);
        Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null);
        Paragraph cp = cloneNote.paragraphs.get(0);
        assertEquals(cp.getStatus(), Status.READY);
        assertEquals(cp.getId(), p.getId());
        assertEquals(cp.text, p.text);
        assertEquals(cp.getResult().message(), p.getResult().message());
        AuthenticationInfo subject = new AuthenticationInfo(""user1"");
        Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject);
        assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));
        assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size());
        Set<String> owners = new HashSet<>();
        owners.add(""user1"");
        assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));
    }
}","['public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); Notebook notebook = notebook.getNotebookAuthorization(); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); getNotebook(); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); getNotebook().setBoolean(true); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); Notebook notebook = notebook.getNotebookAuthorization(); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); getNotebook().setBoolean(true); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); Notebook notebook = notebook.getNotebookAuthorization(); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote1.getId())); }', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); getNotebook(); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));', 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); }']",True,0,0,148,201,11,1.0,0.999999995,False,False,False,,,,,,,"public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { boolean var = false; if (var) var = true; Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { boolean var = false; if (var) var = true; Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { try { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } catch (Exception e) { throw e; } }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { try { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } catch (Exception e) { throw e; } }",,,,"public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); if (cp.getStatus() != Status.READY) { assertEquals(cp.getStatus(),Status.READY); } if (cp.getId() != p.getId()) { assertEquals(cp.getId(),p.getId()); } if (cp.text != p.text) { assertEquals(cp.text,p.text); } if (cp.getResult().message() != p.getResult().message()) { assertEquals(cp.getResult().message(),p.getResult().message()); } AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); if (1 != notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()) { assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); } Set<String> owners = new HashSet<>(); owners.add(""user1""); if (owners != notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())) { assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); if (cp.getStatus() != Status.READY) { assertEquals(cp.getStatus(), Status.READY); } if (cp.getId() != p.getId()) { assertEquals(cp.getId(), p.getId()); } if (cp.text != p.text) { assertEquals(cp.text, p.text); } if (cp.getResult().message() != p.getResult().message()) { assertEquals(cp.getResult().message(), p.getResult().message()); } AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); if (1 != notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()) { assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); } Set<String> owners = new HashSet<>(); owners.add(""user1""); if (owners != notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())) { assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } }",,,,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note notebook = note.createNote(null); factory.setInterpreters(notebook.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph cloneNote = notebook.addParagraph(); cloneNote.setText(""hello world""); notebook.runAll(); while (cloneNote.isTerminated() == false || cloneNote.getResult() == null) Thread.yield(); cloneNote.setStatus(Status.RUNNING); Note owners = note.owners(notebook.getId(), ""clone note"", null); Paragraph cloneNote2 = owners.paragraphs.get(0); assertEquals(cloneNote2.getStatus(), Status.READY); assertEquals(cloneNote2.getId(), cloneNote.getId()); assertEquals(cloneNote2.text, cloneNote.text); assertEquals(cloneNote2.getResult().message(), cloneNote.getResult().message()); AuthenticationInfo cp = new AuthenticationInfo(""user1""); Note subject = <START> note.owners(notebook.getId(), ""clone note2"", cp); <END> Notebook note = new Notebook(conf, notebookRepo, schedulerFactory, new InterpreterFactory(conf, null, null, null, depResolver), this, null, notebookAuthorization, null); assertNotNull(note.getNotebookAuthorization().getOwners(subject.getId())); assertEquals(1, note.getNotebookAuthorization().getOwners(subject.getId()).size()); Set<String> p = new HashSet<>(); p.add(""user1""); assertEquals(p, note.getNotebookAuthorization().getOwners(subject.getId())); }",note instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note notebook = note.createNote(null); factory.setInterpreters(notebook.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph cloneNote = notebook.addParagraph(); cloneNote.setText(""hello world""); notebook.runAll(); while (cloneNote.isTerminated() == false || cloneNote.getResult() == null) Thread.yield(); cloneNote.setStatus(Status.RUNNING); Note owners = note.owners(notebook.getId(), ""clone note"", null); Paragraph cloneNote2 = owners.paragraphs.get(0); assertEquals(cloneNote2.getStatus(), Status.READY); assertEquals(cloneNote2.getId(), cloneNote.getId()); assertEquals(cloneNote2.text, cloneNote.text); assertEquals(cloneNote2.getResult().message(), cloneNote.getResult().message()); AuthenticationInfo cp = new AuthenticationInfo(""user1""); Note subject = note.owners(notebook.getId(), ""clone note2"", cp); assertNotNull(note.getNotebookAuthorization().getOwners(subject.getId())); assertEquals(1, note.getNotebookAuthorization().getOwners(subject.getId()).size()); Set<String> p = new HashSet<>(); p.add(""user1""); assertEquals(p, note.getNotebookAuthorization().getOwners(subject.getId())); }","public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note jpnyq = kblcu.createNote(null); factory.setInterpreters(jpnyq.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph estxm = jpnyq.addParagraph(); estxm.setText(""hello world""); jpnyq.runAll(); while (estxm.isTerminated() == false || estxm.getResult() == null) Thread.yield(); estxm.setStatus(Status.RUNNING); Note lvyzv = kblcu.lvyzv(jpnyq.getId(), ""clone note"", null); Paragraph rntzt = lvyzv.paragraphs.get(0); assertEquals(rntzt.getStatus(), Status.READY); assertEquals(rntzt.getId(), estxm.getId()); assertEquals(rntzt.text, estxm.text); assertEquals(rntzt.getResult().message(), estxm.getResult().message()); AuthenticationInfo chqte = new AuthenticationInfo(""user1""); Note bpncl = <START> kblcu.lvyzv(jpnyq.getId(), ""clone note2"", chqte); <END> Notebook kblcu = new Notebook(conf, notebookRepo, schedulerFactory, new InterpreterFactory(conf, null, null, null, depResolver), this, null, notebookAuthorization, null); assertNotNull(kblcu.getNotebookAuthorization().getOwners(bpncl.getId())); assertEquals(1, kblcu.getNotebookAuthorization().getOwners(bpncl.getId()).size()); Set<String> tkkci = new HashSet<>(); tkkci.add(""user1""); assertEquals(tkkci, kblcu.getNotebookAuthorization().getOwners(bpncl.getId())); }",kblcu instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note jpnyq = kblcu.createNote(null); factory.setInterpreters(jpnyq.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph estxm = jpnyq.addParagraph(); estxm.setText(""hello world""); jpnyq.runAll(); while (estxm.isTerminated() == false || estxm.getResult() == null) Thread.yield(); estxm.setStatus(Status.RUNNING); Note lvyzv = kblcu.lvyzv(jpnyq.getId(), ""clone note"", null); Paragraph rntzt = lvyzv.paragraphs.get(0); assertEquals(rntzt.getStatus(), Status.READY); assertEquals(rntzt.getId(), estxm.getId()); assertEquals(rntzt.text, estxm.text); assertEquals(rntzt.getResult().message(), estxm.getResult().message()); AuthenticationInfo chqte = new AuthenticationInfo(""user1""); Note bpncl = kblcu.lvyzv(jpnyq.getId(), ""clone note2"", chqte); assertNotNull(kblcu.getNotebookAuthorization().getOwners(bpncl.getId())); assertEquals(1, kblcu.getNotebookAuthorization().getOwners(bpncl.getId()).size()); Set<String> tkkci = new HashSet<>(); tkkci.add(""user1""); assertEquals(tkkci, kblcu.getNotebookAuthorization().getOwners(bpncl.getId())); }","public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); Note xmnmc = notebook.createNote(null); factory.setInterpreters(xmnmc.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = xmnmc.addParagraph(); p.setText(""hello world""); xmnmc.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(xmnmc.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(xmnmc.getId(),""clone note2"",subject); <START>Notebook notebook = new Notebook(<END>conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }",notebook instance,"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); Note xmnmc = notebook.createNote(null); factory.setInterpreters(xmnmc.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = xmnmc.addParagraph(); p.setText(""hello world""); xmnmc.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(xmnmc.getId(), ""clone note"", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(xmnmc.getId(), ""clone note2"", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }","1- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
2- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization, null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
3- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null, notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
4- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); getNotebook notebook().setBoolean(true); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
5- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException, SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
6- public void testCloneNote() throws IOException,CloneNotSupportedException, InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
7- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
8- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote.getId())); }
9- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); addNotebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }
10- public void testCloneNote() throws IOException,CloneNotSupportedException,InterruptedException,InterpreterException,SchedulerException,RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(),factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(""hello world""); note.runAll(); while (p.isTerminated() == false || p.getResult() == null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(),""clone note"",null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(),Status.READY); assertEquals(cp.getId(),p.getId()); assertEquals(cp.text,p.text); assertEquals(cp.getResult().message(),p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(""user1""); Note cloneNote2 = notebook.cloneNote(note.getId(),""clone note2"",subject); Notebook notebook = new Notebook(conf,notebookRepo,schedulerFactory,new InterpreterFactory(conf,null,null,null,depResolver),this,null,notebookAuthorization,null); if (notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()) == null) { assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); } assertEquals(1,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(""user1""); assertEquals(owners,notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()));",0
1755,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); <START> ; <END> diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","public class DummyClass {
    public Object execute(final ExecutionEvent event) throws ExecutionException {
        final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event);
        if (!(activeEditor instanceof AgeDiagramEditor)) {
            throw new RuntimeException(""Unexpected editor: "" + activeEditor);
        }
        final List<DiagramElement> selectedDiagramElements =
                AgeHandlerUtil.getSelectedDiagramElements(event);
        if (selectedDiagramElements.size() == 0) {
            throw new RuntimeException(""No element selected"");
        }
        final DiagramElement selectedElement = selectedDiagramElements.get(0);
        final Object bo = selectedElement.getBusinessObject();
        final DiagramService diagramService =
                Objects.requireNonNull(
                        Adapters.adapt(activeEditor, DiagramService.class),
                        ""Unable to retrieve diagram service"");
        final ComponentImplementation ci =
                Objects.requireNonNull(
                        getComponentImplementation(bo),
                        ""Unable to retrieve component implementation"");
        ;
        diagramService.openOrCreateDiagramForBusinessObject(ci);
        return null;
    }
}",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","public class DummyClass {
    public Object execute(final ExecutionEvent event) throws ExecutionException {
        final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event);
        if (!(activeEditor instanceof AgeDiagramEditor)) {
            throw new RuntimeException(""Unexpected editor: "" + activeEditor);
        }
        final List<DiagramElement> selectedDiagramElements =
                AgeHandlerUtil.getSelectedDiagramElements(event);
        if (selectedDiagramElements.size() == 0) {
            throw new RuntimeException(""No element selected"");
        }
        final DiagramElement selectedElement = selectedDiagramElements.get(0);
        final Object bo = selectedElement.getBusinessObject();
        final DiagramService diagramService =
                Objects.requireNonNull(
                        Adapters.adapt(activeEditor, DiagramService.class),
                        ""Unable to retrieve diagram service"");
        final ComponentImplementation ci =
                Objects.requireNonNull(
                        getComponentImplementation(bo),
                        ""Unable to retrieve component implementation"");
        diagramService.openOrCreateDiagramForBusinessObject(ci);
        return null;
    }
}","['public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(DiagramService.class, ""Unable to retrieve diagram service""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(activeEditor, DiagramService.class); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramElement diagramElement = diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramElement diagramElement = null; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(WizardMessages.PreviewView_DiagramService_FROM_MINUTE); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramElement diagramElement = selectedDiagramElements.get(0); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(WizardMessages.PreviewView_DiagramService_FROM_NAME); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(WizardEgo.class, ""Unable to retrieve diagram service""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }', 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); DiagramService diagramService = Objects.requireNonNull(PeersService.class, ""Unable to retrieve diagram service""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }']",True,0,0,28,28,1,1.0,0.999999995,True,True,False,,,,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(!(activeEditor instanceof AgeDiagramEditor))) { } else { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (!(selectedDiagramElements.size() == 0)) { } else { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve <START> component <END> implementation""); ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(!(activeEditor instanceof AgeDiagramEditor))) { } else { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (!(selectedDiagramElements.size() == 0)) { } else { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","public Object execute(final ExecutionEvent event) throws ExecutionException { boolean var = false<START>;<END> if (var) throw new RuntimeException(""Unexpected condition encountered""); final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","public Object execute(final ExecutionEvent event) throws ExecutionException { boolean var = false<START>;<END> if (var) var = true; final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { boolean var = false; if (var) var = true; final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","public Object execute(final ExecutionEvent event) throws ExecutionException { try { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event)<START>;<END> if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; } catch (Exception e) { throw e; } }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { try { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; } catch (Exception e) { throw e; } }",,,,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event)<START>;<END> if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor, DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), ""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); } diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",,,,,,,"public Object execute(final ExecutionEvent ci) throws ExecutionException { final IEditorPart bo = HandlerUtil.getActiveEditor(ci); if (!(bo instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + bo); } final List<DiagramElement> diagramService = AgeHandlerUtil.getSelectedDiagramElements(ci); if (diagramService.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = diagramService.get(0); final Object activeEditor = selectedElement.getBusinessObject(); final DiagramService event = Objects.requireNonNull(Adapters.adapt(bo, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation selectedDiagramElements = Objects.requireNonNull(getComponentImplementation(activeEditor), ""Unable to retrieve <START> component <END> implementation""); ; event.openOrCreateDiagramForBusinessObject(selectedDiagramElements); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent ci) throws ExecutionException { final IEditorPart bo = HandlerUtil.getActiveEditor(ci); if (!(bo instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + bo); } final List<DiagramElement> diagramService = AgeHandlerUtil.getSelectedDiagramElements(ci); if (diagramService.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = diagramService.get(0); final Object activeEditor = selectedElement.getBusinessObject(); final DiagramService event = Objects.requireNonNull(Adapters.adapt(bo, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation selectedDiagramElements = Objects.requireNonNull(getComponentImplementation(activeEditor), ""Unable to retrieve component implementation""); event.openOrCreateDiagramForBusinessObject(selectedDiagramElements); return null; }","public Object execute(final ExecutionEvent rwsfr) throws ExecutionException { final IEditorPart eejxq = HandlerUtil.getActiveEditor(rwsfr); if (!(eejxq instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + eejxq); } final List<DiagramElement> hkrcu = AgeHandlerUtil.getSelectedDiagramElements(rwsfr); if (hkrcu.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement udhsy = hkrcu.get(0); final Object kjlkh = udhsy.getBusinessObject(); final DiagramService sjabd = Objects.requireNonNull(Adapters.adapt(eejxq, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ucqiq = Objects.requireNonNull(getComponentImplementation(kjlkh), ""Unable to retrieve <START> component <END> implementation""); ; sjabd.openOrCreateDiagramForBusinessObject(ucqiq); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent rwsfr) throws ExecutionException { final IEditorPart eejxq = HandlerUtil.getActiveEditor(rwsfr); if (!(eejxq instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + eejxq); } final List<DiagramElement> hkrcu = AgeHandlerUtil.getSelectedDiagramElements(rwsfr); if (hkrcu.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement udhsy = hkrcu.get(0); final Object kjlkh = udhsy.getBusinessObject(); final DiagramService sjabd = Objects.requireNonNull(Adapters.adapt(eejxq, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ucqiq = Objects.requireNonNull(getComponentImplementation(kjlkh), ""Unable to retrieve component implementation""); sjabd.openOrCreateDiagramForBusinessObject(ucqiq); return null; }",,,,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event)<START>;<END> IEditorPart ztbvq = HandlerUtil.getActiveEditor(event); if (!(ztbvq instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + ztbvq); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(ztbvq,DiagramService.class),""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }",Extra semicolon,"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); IEditorPart ztbvq = HandlerUtil.getActiveEditor(event); if (!(ztbvq instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + ztbvq); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(ztbvq, DiagramService.class), ""Unable to retrieve diagram service""); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }","1- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
2- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class), ""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
3- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } ""; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
4- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo), ""Unable to retrieve component implementation""); } ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
5- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); }  = diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
6- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } <>(); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
7- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } (); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
8- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagramService""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } ; diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
9- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } : diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }
10- public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(""Unexpected editor: "" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(""No element selected""); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); if (Adapters.adapt(activeEditor,DiagramService.class) == null) { Objects.requireNonNull(Adapters.adapt(activeEditor,DiagramService.class),""Unable to retrieve diagram service""); } if (getComponentImplementation(bo) == null) { Objects.requireNonNull(getComponentImplementation(bo),""Unable to retrieve component implementation""); } .openOrCreateDiagramForBusinessObject(ci); return null; }",0
1763,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { <START> this.httpRequest = (HttpRequest) httpRequest; <END> } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }","public class DummyClass {
    public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) {
        Assert.notNull(application, ""application argument cannot be null."");
        Assert.notNull(httpRequest, ""httpRequest argument cannot be null."");
        this.application = application;
        if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) {
            this.httpRequest = (HttpRequest) httpRequest;
        } else {
            Assert.isInstanceOf(
                    com.stormpath.sdk.impl.http.ServletHttpRequest.class,
                    httpRequest,
                    ""The specified httpRequest argument must be an instance of ""
                            + HttpRequest.class.getName()
                            + "" or ""
                            + ServletHttpRequest.class.getName());
            this.httpRequest = (ServletHttpRequest) httpRequest;
        }
    }
}",unnecessary casting,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }","public class DummyClass {
    public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) {
        Assert.notNull(application, ""application argument cannot be null."");
        Assert.notNull(httpRequest, ""httpRequest argument cannot be null."");
        this.application = application;
        if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) {
            this.httpRequest = httpRequest;
        } else {
            Assert.isInstanceOf(
                    com.stormpath.sdk.impl.http.ServletHttpRequest.class,
                    httpRequest,
                    ""The specified httpRequest argument must be an instance of ""
                            + HttpRequest.class.getName()
                            + "" or ""
                            + ServletHttpRequest.class.getName());
            this.httpRequest = httpRequest;
        }
    }
}","['public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = request; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest instanceof HttpRequest)) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.HTTP.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = dto; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = token; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""bootclasspath argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = MDC; } }', 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; }']",True,0,0,61,61,2,1.0,0.999999995,False,False,False,,,,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (!(HttpRequest.class.isAssignableFrom(httpRequest.getClass()))) { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } else { <START> this.httpRequest = (HttpRequest) httpRequest; <END> } }",unnecessary casting,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (!(HttpRequest.class.isAssignableFrom(httpRequest.getClass()))) { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } else { this.httpRequest = httpRequest; } }",,,,,,,,,,,,,"public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { <START>this.httpRequest = (HttpRequest) httpRequest;<END> } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }",unnecessary casting,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { if (application == null) { Assert.notNull(application, ""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }",,,,,,,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { <START> this.httpRequest = (HttpRequest) httpRequest; <END> } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }",unnecessary casting,"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, ""application argument cannot be null.""); Assert.notNull(httpRequest, ""httpRequest argument cannot be null.""); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }","public DefaultApiRequestAuthenticator(Application jficb, HttpRequest hyxvu) { Assert.notNull(jficb, ""application argument cannot be null.""); Assert.notNull(hyxvu, ""httpRequest argument cannot be null.""); this.jficb = jficb; if (HttpRequest.class.isAssignableFrom(hyxvu.getClass())) { <START> this.hyxvu = (HttpRequest) hyxvu; <END> } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, hyxvu, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.hyxvu = (ServletHttpRequest) hyxvu; } }",unnecessary casting,"public DefaultApiRequestAuthenticator(Application jficb, HttpRequest hyxvu) { Assert.notNull(jficb, ""application argument cannot be null.""); Assert.notNull(hyxvu, ""httpRequest argument cannot be null.""); this.jficb = jficb; if (HttpRequest.class.isAssignableFrom(hyxvu.getClass())) { this.hyxvu = hyxvu; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, hyxvu, ""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.hyxvu = hyxvu; } }",,,,,,,"1- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
2- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); } }
3- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
4- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) {this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
5- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.HTTP.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
6- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,"" httpRequest argument cannot be null.""); } this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = (HttpRequest) httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
7- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; try { this.httpRequest = (HttpRequest) httpRequest; } catch (IllegalArgumentException e) { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }
8- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; try { this.httpRequest = (HttpRequest) httpRequest; } catch (IllegalArgumentException e) { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); } }
9- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class,httpRequest,""The specified httpRequest argument must be an instance of "" + HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName()); this.httpRequest = (HttpRequest) httpRequest; }
10- public DefaultApiRequestAuthenticator(Application application,HttpRequest httpRequest) { if (application == null) { Assert.notNull(application,""application argument cannot be null.""); } if (httpRequest == null) { Assert.notNull(httpRequest,""httpRequest argument cannot be null.""); } this.application = application; this.httpRequest = (HttpRequest) httpRequest; }",0
1768,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START> realmModel.setPasswordPolicy(PasswordPolicy.parse(session, LengthPasswordPolicyProviderFactory.ID)); <END> Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }","public class DummyClass {
    public void testLength() {
        testingClient
                .server(""passwordPolicy"")
                .run(
                        session -> {
                            RealmModel realmModel = session.getContext().getRealm();
                            PasswordPolicyManagerProvider policyManager =
                                    session.getProvider(PasswordPolicyManagerProvider.class);
                            realmModel.setPasswordPolicy(
                                    PasswordPolicy.parse(
                                            session, LengthPasswordPolicyProviderFactory.ID));
                            Assert.assertEquals(
                                    ""invalidPasswordMinLengthMessage"",
                                    policyManager.validate(""jdoe"", ""1234567"").getMessage());
                            Assert.assertArrayEquals(
                                    new Object[] {8},
                                    policyManager.validate(""jdoe"", ""1234567"").getParameters());
                            assertNull(policyManager.validate(""jdoe"", ""12345678""));
                            realmModel.setPasswordPolicy(
                                    PasswordPolicy.parse(session, ""length(4)""));
                            Assert.assertEquals(
                                    ""invalidPasswordMinLengthMessage"",
                                    policyManager.validate(""jdoe"", ""123"").getMessage());
                            Assert.assertArrayEquals(
                                    new Object[] {4},
                                    policyManager.validate(""jdoe"", ""123"").getParameters());
                            assertNull(policyManager.validate(""jdoe"", ""1234""));
                        });
    }
}",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }","public class DummyClass {
    public void testLength() {
        testingClient
                .server(""passwordPolicy"")
                .run(
                        session -> {
                            RealmModel realmModel = session.getContext().getRealm();
                            PasswordPolicyManagerProvider policyManager =
                                    session.getProvider(PasswordPolicyManagerProvider.class);
                            realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length""));
                            Assert.assertEquals(
                                    ""invalidPasswordMinLengthMessage"",
                                    policyManager.validate(""jdoe"", ""1234567"").getMessage());
                            Assert.assertArrayEquals(
                                    new Object[] {8},
                                    policyManager.validate(""jdoe"", ""1234567"").getParameters());
                            assertNull(policyManager.validate(""jdoe"", ""12345678""));
                            realmModel.setPasswordPolicy(
                                    PasswordPolicy.parse(session, ""length(4)""));
                            Assert.assertEquals(
                                    ""invalidPasswordMinLengthMessage"",
                                    policyManager.validate(""jdoe"", ""123"").getMessage());
                            Assert.assertArrayEquals(
                                    new Object[] {4},
                                    policyManager.validate(""jdoe"", ""123"").getParameters());
                            assertNull(policyManager.validate(""jdoe"", ""1234""));
                        });
    }
}","['public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""ID"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geode.data.required.Length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""name"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""id"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geoserver.password.required.Length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geoserver.password.Policy.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geode.required.value.requiredString"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geode.data.required.Length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); })); }', 'public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""org.apache.geoserver.password.required.Length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); })); }']",True,4,0,58,60,2,1.0,0.999999995,False,False,False,,,,,,,"public void testLength() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"",""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); assertNull(policyManager.validate(""jdoe"",""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }","public void testLength() { boolean var = false; if (var) var = true; testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"",""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); assertNull(policyManager.validate(""jdoe"",""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { boolean var = false; if (var) var = true; testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }","public void testLength() { try { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"",""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); assertNull(policyManager.validate(""jdoe"",""1234"")); }); } catch (Exception e) { throw e; } }",Please remove this. Tests intent a string a constant here,"public void testLength() { try { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); } catch (Exception e) { throw e; } }",,,,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); if (policyManager.validate(""jdoe"", ""12345678"") != null) { assertNull(policyManager.validate(""jdoe"", ""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); if (policyManager.validate(""jdoe"", ""1234"") != null) { assertNull(policyManager.validate(""jdoe"", ""1234"")); } }); }","public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> if (""invalidPasswordMinLengthMessage"" != policyManager.validate(""jdoe"",""1234567"").getMessage()) { Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); } if (new Object[] { 8 } != policyManager.validate(""jdoe"",""1234567"").getParameters()) { Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); } assertNull(policyManager.validate(""jdoe"",""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); if (""invalidPasswordMinLengthMessage"" != policyManager.validate(""jdoe"",""123"").getMessage()) { Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); } if (new Object[] { 4 } != policyManager.validate(""jdoe"",""123"").getParameters()) { Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); } assertNull(policyManager.validate(""jdoe"",""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); if (""invalidPasswordMinLengthMessage"" != policyManager.validate(""jdoe"", ""1234567"").getMessage()) { Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); } if (new Object[] { 8 } != policyManager.validate(""jdoe"", ""1234567"").getParameters()) { Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); } assertNull(policyManager.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); if (""invalidPasswordMinLengthMessage"" != policyManager.validate(""jdoe"", ""123"").getMessage()) { Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); } if (new Object[] { 4 } != policyManager.validate(""jdoe"", ""123"").getParameters()) { Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); } assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }",,,,"public void testLength() { testingClient.server(""passwordPolicy"").run(policyManager -> { RealmModel realmModel = policyManager.getContext().getRealm(); PasswordPolicyManagerProvider <START> session = <END> policyManager.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(policyManager, LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"", session.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, session.validate(""jdoe"", ""1234567"").getParameters()); assertNull(session.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(policyManager, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", session.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, session.validate(""jdoe"", ""123"").getParameters()); assertNull(session.validate(""jdoe"", ""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(policyManager -> { RealmModel realmModel = policyManager.getContext().getRealm(); PasswordPolicyManagerProvider session = policyManager.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(policyManager, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", session.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, session.validate(""jdoe"", ""1234567"").getParameters()); assertNull(session.validate(""jdoe"", ""12345678"")); realmModel.setPasswordPolicy(PasswordPolicy.parse(policyManager, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", session.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, session.validate(""jdoe"", ""123"").getParameters()); assertNull(session.validate(""jdoe"", ""1234"")); }); }","public void testLength() { testingClient.server(""passwordPolicy"").run(ndubm -> { RealmModel grlhr = ndubm.getContext().getRealm(); PasswordPolicyManagerProvider <START> nwjye = <END> ndubm.getProvider(PasswordPolicyManagerProvider.class); grlhr.setPasswordPolicy(PasswordPolicy.parse(ndubm, LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"", nwjye.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, nwjye.validate(""jdoe"", ""1234567"").getParameters()); assertNull(nwjye.validate(""jdoe"", ""12345678"")); grlhr.setPasswordPolicy(PasswordPolicy.parse(ndubm, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", nwjye.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, nwjye.validate(""jdoe"", ""123"").getParameters()); assertNull(nwjye.validate(""jdoe"", ""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(ndubm -> { RealmModel grlhr = ndubm.getContext().getRealm(); PasswordPolicyManagerProvider nwjye = ndubm.getProvider(PasswordPolicyManagerProvider.class); grlhr.setPasswordPolicy(PasswordPolicy.parse(ndubm, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", nwjye.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, nwjye.validate(""jdoe"", ""1234567"").getParameters()); assertNull(nwjye.validate(""jdoe"", ""12345678"")); grlhr.setPasswordPolicy(PasswordPolicy.parse(ndubm, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", nwjye.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, nwjye.validate(""jdoe"", ""123"").getParameters()); assertNull(nwjye.validate(""jdoe"", ""1234"")); }); }",,,,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); RealmModel xlcua = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START>xlcua.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID));<END> Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"",""12345678"")); xlcua.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); assertNull(policyManager.validate(""jdoe"",""1234"")); }); }",Please remove this. Tests intent a string a constant here,"public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); RealmModel xlcua = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); xlcua.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 }, policyManager.validate(""jdoe"", ""1234567"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""12345678"")); xlcua.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"", policyManager.validate(""jdoe"", ""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 }, policyManager.validate(""jdoe"", ""123"").getParameters()); assertNull(policyManager.validate(""jdoe"", ""1234"")); }); }","1- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
2- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
3- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
4- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length2"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
5- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class);realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
6- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length-8"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
7- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class);realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
8- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, ""length-1"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234"")); } }); }
9- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234())); } }); }
10- public void testLength() { testingClient.server(""passwordPolicy"").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session,LengthPasswordPolicyProviderFactory.ID)); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""1234567"").getMessage()); Assert.assertArrayEquals(new Object[] { 8 },policyManager.validate(""jdoe"",""1234567"").getParameters()); if (policyManager.validate(""jdoe"",""12345678"") != null) { assertNull(policyManager.validate(""jdoe"",""12345678"")); } realmModel.setPasswordPolicy(PasswordPolicy.parse(session,""length(4)"")); Assert.assertEquals(""invalidPasswordMinLengthMessage"",policyManager.validate(""jdoe"",""123"").getMessage()); Assert.assertArrayEquals(new Object[] { 4 },policyManager.validate(""jdoe"",""123"").getParameters()); if (policyManager.validate(""jdoe"",""1234"") != null) { assertNull(policyManager.validate(""jdoe"",""1234)); } }); }",0
1776,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); <START> System.out.println(""json:"" + json); <END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }","public class DummyClass {
    public void testDoPost() throws IOException, ServletException {
        when(request.getParameter(""connectionName"")).thenReturn(""test-db-name"");
        when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
        when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
        when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
        when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
        when(request.getParameter(""databasePassword""))
                .thenReturn(testDbConfig.getDatabasePassword());
        when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        when(response.getWriter()).thenReturn(pw);
        SUT.doPost(request, response);
        String result = sw.getBuffer().toString().trim();
        assertNotNull(result);
        assertFalse(result.isEmpty(), ""Valid response Message expected!"");
        ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
        System.out.println(""json:"" + json);
        ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
        Assert.assertNotNull(savedConnections);
        int len = savedConnections.size();
        Assert.assertEquals(len, 1);
    }
}",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }","public class DummyClass {
    public void testDoPost() throws IOException, ServletException {
        when(request.getParameter(""connectionName"")).thenReturn(""test-db-name"");
        when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME);
        when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost());
        when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort());
        when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser());
        when(request.getParameter(""databasePassword""))
                .thenReturn(testDbConfig.getDatabasePassword());
        when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName());
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        when(response.getWriter()).thenReturn(pw);
        SUT.doPost(request, response);
        String result = sw.getBuffer().toString().trim();
        assertNotNull(result);
        assertFalse(result.isEmpty(), ""Valid response Message expected!"");
        ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class);
        ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections"");
        Assert.assertNotNull(savedConnections);
        int len = savedConnections.size();
        Assert.assertEquals(len, 1);
    }
}","['public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); assertNotNull(json); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); Assert.assertNotNull(json); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len,1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when( request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); Assert.assertEquals(len, 100); }', 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty()); }']",True,0,0,50,62,2,1.0,0.999999995,False,False,False,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); <START> System.out.println(""json:"" + json); <END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }",,,,"public void testDoPost() throws IOException,ServletException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len,1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }","public void testDoPost() throws IOException,ServletException { boolean var = false; if (var) var = true; when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len,1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { boolean var = false; if (var) var = true; when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }","public void testDoPost() throws IOException,ServletException { try { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len,1); } catch (Exception e) { throw e; } }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { try { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); } catch (Exception e) { throw e; } }",,,,"public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len, 1); }","public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); if (len != 1) { Assert.assertEquals(len,1); } }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); if (len != 1) { Assert.assertEquals(len, 1); } }",,,,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter json = new StringWriter(); PrintWriter sw = new PrintWriter(json); when(response.getWriter()).thenReturn(sw); SUT.doPost(request, response); String savedConnections = json.getBuffer().toString().trim(); assertNotNull(savedConnections); assertFalse(savedConnections.isEmpty(), ""Valid response Message expected!""); ObjectNode result = ParsingUtilities.mapper.readValue(savedConnections, <START> ObjectNode.class); System.out.println(""result:"" + <END> result); ArrayNode len = (ArrayNode) result.get(""len""); Assert.assertNotNull(len); int pw = len.size(); Assert.assertEquals(pw, 1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter json = new StringWriter(); PrintWriter sw = new PrintWriter(json); when(response.getWriter()).thenReturn(sw); SUT.doPost(request, response); String savedConnections = json.getBuffer().toString().trim(); assertNotNull(savedConnections); assertFalse(savedConnections.isEmpty(), ""Valid response Message expected!""); ObjectNode result = ParsingUtilities.mapper.readValue(savedConnections, ObjectNode.class); ArrayNode len = (ArrayNode) result.get(""len""); Assert.assertNotNull(len); int pw = len.size(); Assert.assertEquals(pw, 1); }","public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter domip = new StringWriter(); PrintWriter qffgx = new PrintWriter(domip); when(response.getWriter()).thenReturn(qffgx); SUT.doPost(request, response); String kccel = domip.getBuffer().toString().trim(); assertNotNull(kccel); assertFalse(kccel.isEmpty(), ""Valid response Message expected!""); ObjectNode urbdz = ParsingUtilities.mapper.readValue(kccel, <START> ObjectNode.class); System.out.println(""json:"" + <END> urbdz); ArrayNode dpycu = (ArrayNode) urbdz.get(""savedConnections""); Assert.assertNotNull(dpycu); int oslfg = dpycu.size(); Assert.assertEquals(oslfg, 1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter domip = new StringWriter(); PrintWriter qffgx = new PrintWriter(domip); when(response.getWriter()).thenReturn(qffgx); SUT.doPost(request, response); String kccel = domip.getBuffer().toString().trim(); assertNotNull(kccel); assertFalse(kccel.isEmpty(), ""Valid response Message expected!""); ObjectNode urbdz = ParsingUtilities.mapper.readValue(kccel, ObjectNode.class); ArrayNode dpycu = (ArrayNode) urbdz.get(""savedConnections""); Assert.assertNotNull(dpycu); int oslfg = dpycu.size(); Assert.assertEquals(oslfg, 1); }",,,,"public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); StringWriter xgpcf = new StringWriter(); PrintWriter pw = new PrintWriter(xgpcf); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = xgpcf.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); <START>System.out.println(""json:"" + json);<END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len,1); }",This a debugging print removed,"public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); StringWriter xgpcf = new StringWriter(); PrintWriter pw = new PrintWriter(xgpcf); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = xgpcf.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }","1- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
2- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
3- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) {Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
4- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { assertThat(savedConnections).clear(); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
5- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert. assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
6- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when( request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
7- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
8- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(""testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { Assert.assertNotNull(savedConnections); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
9- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); if (savedConnections == null) { assertThat(savedConnections).empty(); } int len = savedConnections.size(); Assert.assertEquals(len,1); }
10- public void testDoPost() throws IOException,ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request,response); String result = sw.getBuffer().toString().trim(); if (result == null) { assertNotNull(result); } assertFalse(result.isEmpty(),""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result,ObjectNode.class); }",0
1798,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false, NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START> assertNotNull(newFrame); <END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public class DummyClass {
    public void testAlreadyCompressedFrame() {
        EmbeddedChannel encoderChannel =
                new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false, NEVER_SKIP));
        byte[] payload = new byte[300];
        random.nextBytes(payload);
        BinaryWebSocketFrame frame =
                new BinaryWebSocketFrame(
                        true,
                        WebSocketExtension.RSV3 | WebSocketExtension.RSV1,
                        Unpooled.wrappedBuffer(payload));
        encoderChannel.writeOutbound(frame);
        BinaryWebSocketFrame newFrame = encoderChannel.readOutbound();
        assertNotNull(newFrame);
        assertNotNull(newFrame.content());
        assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv());
        assertEquals(300, newFrame.content().readableBytes());
        byte[] finalPayload = new byte[300];
        newFrame.content().readBytes(finalPayload);
        assertArrayEquals(finalPayload, payload);
        newFrame.release();
    }
}",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public class DummyClass {
    public void testAlreadyCompressedFrame() {
        EmbeddedChannel encoderChannel =
                new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false));
        byte[] payload = new byte[300];
        random.nextBytes(payload);
        BinaryWebSocketFrame frame =
                new BinaryWebSocketFrame(
                        true,
                        WebSocketExtension.RSV3 | WebSocketExtension.RSV1,
                        Unpooled.wrappedBuffer(payload));
        assertTrue(encoderChannel.writeOutbound(frame));
        BinaryWebSocketFrame newFrame = encoderChannel.readOutbound();
        assertNotNull(newFrame);
        assertNotNull(newFrame.content());
        assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv());
        assertEquals(300, newFrame.content().readableBytes());
        byte[] finalPayload = new byte[300];
        newFrame.content().readBytes(finalPayload);
        assertArrayEquals(finalPayload, payload);
        newFrame.release();
    }
}","['public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertEquals(encoderChannel.writeOutbound(frame), 1); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertEquals(encoderChannel.writeOutbound(frame), 0); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertEquals(encoderChannel.writeOutbound(frame), 2); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertEquals(encoderChannel.writeOutbound(frame), 3); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertNotNull(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); {', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); } {', 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); } }']",True,0,0,50,50,5,1.0,0.999999995,True,True,False,,,,,,,"public void testAlreadyCompressedFrame() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public void testAlreadyCompressedFrame() { boolean var = false; if (var) var = true; EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { boolean var = false; if (var) var = true; EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public void testAlreadyCompressedFrame() { try { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); } catch (Exception e) { throw e; } }",this removed,"public void testAlreadyCompressedFrame() { try { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); } catch (Exception e) { throw e; } }",,,,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { <START>assertNotNull(newFrame);<END> } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); if (WebSocketExtension.RSV3 | WebSocketExtension.RSV1 != newFrame.rsv()) { assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); } if (300 != newFrame.content().readableBytes()) { assertEquals(300,newFrame.content().readableBytes()); } byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); if (finalPayload != payload) { assertArrayEquals(finalPayload,payload); } newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); if (WebSocketExtension.RSV3 | WebSocketExtension.RSV1 != newFrame.rsv()) { assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); } if (300 != newFrame.content().readableBytes()) { assertEquals(300, newFrame.content().readableBytes()); } byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); if (finalPayload != payload) { assertArrayEquals(finalPayload, payload); } newFrame.release(); }",,,,"public void testAlreadyCompressedFrame() { EmbeddedChannel finalPayload = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false, NEVER_SKIP)); byte[] encoderChannel = new byte[300]; random.nextBytes(encoderChannel); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(encoderChannel)); finalPayload.writeOutbound(frame); BinaryWebSocketFrame newFrame = <START> finalPayload.readOutbound(); <END> assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] payload = new byte[300]; newFrame.content().readBytes(payload); assertArrayEquals(payload, encoderChannel); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel finalPayload = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] encoderChannel = new byte[300]; random.nextBytes(encoderChannel); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(encoderChannel)); assertTrue(finalPayload.writeOutbound(frame)); BinaryWebSocketFrame newFrame = finalPayload.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] payload = new byte[300]; newFrame.content().readBytes(payload); assertArrayEquals(payload, encoderChannel); newFrame.release(); }","public void testAlreadyCompressedFrame() { EmbeddedChannel ilbey = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false, NEVER_SKIP)); byte[] enxxm = new byte[300]; random.nextBytes(enxxm); BinaryWebSocketFrame azefi = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(enxxm)); ilbey.writeOutbound(azefi); BinaryWebSocketFrame sawqw = <START> ilbey.readOutbound(); <END> assertNotNull(sawqw); assertNotNull(sawqw.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, sawqw.rsv()); assertEquals(300, sawqw.content().readableBytes()); byte[] tgqgk = new byte[300]; sawqw.content().readBytes(tgqgk); assertArrayEquals(tgqgk, enxxm); sawqw.release(); }",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel ilbey = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] enxxm = new byte[300]; random.nextBytes(enxxm); BinaryWebSocketFrame azefi = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(enxxm)); assertTrue(ilbey.writeOutbound(azefi)); BinaryWebSocketFrame sawqw = ilbey.readOutbound(); assertNotNull(sawqw); assertNotNull(sawqw.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, sawqw.rsv()); assertEquals(300, sawqw.content().readableBytes()); byte[] tgqgk = new byte[300]; sawqw.content().readBytes(tgqgk); assertArrayEquals(tgqgk, enxxm); sawqw.release(); }","public void testAlreadyCompressedFrame() { byte[] payload = new byte[300]; EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { byte[] payload = new byte[300]; EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); EmbeddedChannel cknyy = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false,NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); cknyy.writeOutbound(frame); BinaryWebSocketFrame newFrame = cknyy.readOutbound(); <START>assertNotNull(newFrame);<END> assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",this removed,"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); EmbeddedChannel cknyy = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(cknyy.writeOutbound(frame)); BinaryWebSocketFrame newFrame = cknyy.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }","1- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
2- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } assertTrue(newFrame.content() == null); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
3- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
4- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } assertTrue(newFrame.content() == null); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
5- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertTrue(newFrame.content() == null); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
6- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }
7- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }
8- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } assertTrue(newFrame.content() == null); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }
9- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals( finalPayload,payload); newFrame.release(); }
10- public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9,15,false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true,WebSocketExtension.RSV3 | WebSocketExtension.RSV1,Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); if (newFrame == null) { assertNotNull(newFrame); } if (newFrame.content() == null) { assertNotNull(newFrame.content()); } assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1,newFrame.rsv()); assertEquals(300,newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes( finalPayload); assertArrayEquals(finalPayload,payload); newFrame.release(); }",0
1813,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null, Arrays.asList(trace1, trace2)); } catch (Exception e1) { <START> fail(""Failed to store: "" + e1); <END> } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }","public class DummyClass {
    public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() {
        Trace trace1 = new Trace();
        trace1.setId(""1_2ip2pasync"");
        trace1.setStartTime(System.currentTimeMillis() - 60000);
        Consumer c1 = new Consumer();
        c1.setUri(""testuri"");
        c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS));
        trace1.getNodes().add(c1);
        Producer p1 = new Producer();
        p1.setUri(""testuri2"");
        p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        p1.addInteractionCorrelationId(""cid1_2ip2pasync"");
        c1.getNodes().add(p1);
        Trace trace2 = new Trace();
        trace2.setId(""2_2ip2pasync"");
        trace2.setStartTime(trace1.getStartTime() + 500);
        Consumer c2 = new Consumer();
        c2.setUri(""testuri2"");
        c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS));
        c2.addInteractionCorrelationId(""cid1_2ip2pasync"");
        trace2.getNodes().add(c2);
        try {
            publisher.publish(null, Arrays.asList(trace1, trace2));
        } catch (Exception e1) {
            fail(""Failed to store: "" + e1);
        }
        Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2);
        Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1);
        List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria());
        assertNotNull(times);
        assertEquals(1, times.size());
        assertEquals(4500, times.get(0).getDuration());
    }
}",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }","public class DummyClass {
    public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception {
        Trace trace1 = new Trace();
        trace1.setId(""1_2ip2pasync"");
        trace1.setStartTime(System.currentTimeMillis() - 60000);
        Consumer c1 = new Consumer();
        c1.setUri(""testuri"");
        c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS));
        trace1.getNodes().add(c1);
        Producer p1 = new Producer();
        p1.setUri(""testuri2"");
        p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        p1.addInteractionCorrelationId(""cid1_2ip2pasync"");
        c1.getNodes().add(p1);
        Trace trace2 = new Trace();
        trace2.setId(""2_2ip2pasync"");
        trace2.setStartTime(trace1.getStartTime() + 500);
        Consumer c2 = new Consumer();
        c2.setUri(""testuri2"");
        c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS));
        c2.addInteractionCorrelationId(""cid1_2ip2pasync"");
        trace2.getNodes().add(c2);
        publisher.publish(null, Arrays.asList(trace1, trace2));
        Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2);
        Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1);
        List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria());
        assertNotNull(times);
        assertEquals(1, times.size());
        assertEquals(4500, times.get(0).getDuration());
    }
}","['public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception{ Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(10, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(5, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws InterruptedException { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }', 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(10, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }']",True,0,0,107,108,11,1.0,0.999999995,False,False,False,,,,,,,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null,Arrays.asList(trace1,trace2)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }","public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { boolean var = false; if (var) var = true; Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null,Arrays.asList(trace1,trace2)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { boolean var = false; if (var) var = true; Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }",,,,,,,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null,Arrays.asList(trace1,trace2)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }","public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null,Arrays.asList(trace1,trace2)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); if (1 != times.size()) { assertEquals(1,times.size()); } if (4500 != times.get(0).getDuration()) { assertEquals(4500,times.get(0).getDuration()); } }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); if (1 != times.size()) { assertEquals(1, times.size()); } if (4500 != times.get(0).getDuration()) { assertEquals(4500, times.get(0).getDuration()); } }",,,,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace e1 = new Trace(); e1.setId(""1_2ip2pasync""); e1.setStartTime(System.currentTimeMillis() - 60000); Consumer p1 = new Consumer(); p1.setUri(""testuri""); p1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); e1.getNodes().add(p1); Producer trace2 = new Producer(); trace2.setUri(""testuri2""); trace2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.addInteractionCorrelationId(""cid1_2ip2pasync""); p1.getNodes().add(trace2); Trace c2 = new Trace(); c2.setId(""2_2ip2pasync""); c2.setStartTime(e1.getStartTime() + 500); Consumer c1 = new Consumer(); c1.setUri(""testuri2""); c1.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c1.addInteractionCorrelationId(""cid1_2ip2pasync""); c2.getNodes().add(c1); try { publisher.publish(null, Arrays.asList(e1, c2)); } catch (Exception times) { <START> fail(""Failed to store: "" + times); <END> } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> trace1 = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(trace1); assertEquals(1, trace1.size()); assertEquals(4500, trace1.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace e1 = new Trace(); e1.setId(""1_2ip2pasync""); e1.setStartTime(System.currentTimeMillis() - 60000); Consumer p1 = new Consumer(); p1.setUri(""testuri""); p1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); e1.getNodes().add(p1); Producer trace2 = new Producer(); trace2.setUri(""testuri2""); trace2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.addInteractionCorrelationId(""cid1_2ip2pasync""); p1.getNodes().add(trace2); Trace c2 = new Trace(); c2.setId(""2_2ip2pasync""); c2.setStartTime(e1.getStartTime() + 500); Consumer c1 = new Consumer(); c1.setUri(""testuri2""); c1.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c1.addInteractionCorrelationId(""cid1_2ip2pasync""); c2.getNodes().add(c1); publisher.publish(null, Arrays.asList(e1, c2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> trace1 = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(trace1); assertEquals(1, trace1.size()); assertEquals(4500, trace1.get(0).getDuration()); }","public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace pdyai = new Trace(); pdyai.setId(""1_2ip2pasync""); pdyai.setStartTime(System.currentTimeMillis() - 60000); Consumer zqcbg = new Consumer(); zqcbg.setUri(""testuri""); zqcbg.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); pdyai.getNodes().add(zqcbg); Producer jbhcq = new Producer(); jbhcq.setUri(""testuri2""); jbhcq.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jbhcq.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jbhcq.addInteractionCorrelationId(""cid1_2ip2pasync""); zqcbg.getNodes().add(jbhcq); Trace lfxfb = new Trace(); lfxfb.setId(""2_2ip2pasync""); lfxfb.setStartTime(pdyai.getStartTime() + 500); Consumer lmtxg = new Consumer(); lmtxg.setUri(""testuri2""); lmtxg.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); lmtxg.addInteractionCorrelationId(""cid1_2ip2pasync""); lfxfb.getNodes().add(lmtxg); try { publisher.publish(null, Arrays.asList(pdyai, lfxfb)); } catch (Exception fwnmt) { <START> fail(""Failed to store: "" + fwnmt); <END> } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> tbipn = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(tbipn); assertEquals(1, tbipn.size()); assertEquals(4500, tbipn.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace pdyai = new Trace(); pdyai.setId(""1_2ip2pasync""); pdyai.setStartTime(System.currentTimeMillis() - 60000); Consumer zqcbg = new Consumer(); zqcbg.setUri(""testuri""); zqcbg.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); pdyai.getNodes().add(zqcbg); Producer jbhcq = new Producer(); jbhcq.setUri(""testuri2""); jbhcq.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jbhcq.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jbhcq.addInteractionCorrelationId(""cid1_2ip2pasync""); zqcbg.getNodes().add(jbhcq); Trace lfxfb = new Trace(); lfxfb.setId(""2_2ip2pasync""); lfxfb.setStartTime(pdyai.getStartTime() + 500); Consumer lmtxg = new Consumer(); lmtxg.setUri(""testuri2""); lmtxg.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); lmtxg.addInteractionCorrelationId(""cid1_2ip2pasync""); lfxfb.getNodes().add(lmtxg); publisher.publish(null, Arrays.asList(pdyai, lfxfb)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> tbipn = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(tbipn); assertEquals(1, tbipn.size()); assertEquals(4500, tbipn.get(0).getDuration()); }",,,,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace trace1 = new Trace(); Trace mhdmk = new Trace(); mhdmk.setId(""1_2ip2pasync""); mhdmk.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); mhdmk.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(mhdmk.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); try { publisher.publish(null,Arrays.asList(mhdmk,trace2)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); Trace mhdmk = new Trace(); mhdmk.setId(""1_2ip2pasync""); mhdmk.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); mhdmk.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(mhdmk.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(mhdmk, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }","1- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
2- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
3- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(600,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
4- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
5- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
6- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
7- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
8- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
9- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }
10- public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception{ Trace trace1 = new Trace(); trace1.setId(""1_2ip2pasync""); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(""testuri2""); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(""cid1_2ip2pasync""); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(""2_2ip2pasync""); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(""cid1_2ip2pasync""); trace2.getNodes().add(c2); publisher.publish(null,Arrays.asList(trace1,trace2)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(4500,times.get(0).getDuration()); }",0
1827,"public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); Assert.assertEquals(new Version(1, 2), new Version(""1.2"")); Assert.assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); Assert.assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); <START> Assert.assertNotNull(new Version()); <END> Assert.assertNotEquals(""foo"", new Version()); Assert.assertNotEquals(1.0d, new Version()); }","public class DummyClass {
    public void equals() {
        Assert.assertEquals(new Version(), new Version());
        Assert.assertEquals(new Version(1, 2), new Version(1, 2));
        Assert.assertEquals(new Version(1, 2), new Version(""1.2""));
        Assert.assertEquals(new Version(1, 2, 3), new Version(""1.2.3""));
        Assert.assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4""));
        Assert.assertNotNull(new Version());
        Assert.assertNotEquals(""foo"", new Version());
        Assert.assertNotEquals(1.0d, new Version());
    }
}",change static import,"public void equals() { assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }","public class DummyClass {
    public void equals() {
        assertEquals(new Version(), new Version());
        assertEquals(new Version(1, 2), new Version(1, 2));
        assertEquals(new Version(1, 2), new Version(""1.2""));
        assertEquals(new Version(1, 2, 3), new Version(""1.2.3""));
        assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4""));
        assertNotNull(new Version());
        assertNotEquals(""foo"", new Version());
        assertNotEquals(1.0d, new Version());
    }
}","['public void equals() { assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { Assert.assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); Assert.assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { Assert.assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); {', 'public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); Assert.assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); {', 'public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); Assert.assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version());', 'public void equals() { assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }', 'public void equals() { }']",True,0,0,61,82,8,1.0,0.999999995,False,False,False,,,,,,,"public void equals() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); <START>Assert.assertNotNull(new Version());<END> Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); }",change static import,"public void equals() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }","public void equals() { boolean var = false; if (var) var = true; Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); <START>Assert.assertNotNull(new Version());<END> Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); }",change static import,"public void equals() { boolean var = false; if (var) var = true; assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }","public void equals() { try { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); <START>Assert.assertNotNull(new Version());<END> Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); } catch (Exception e) { throw e; } }",change static import,"public void equals() { try { assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); } catch (Exception e) { throw e; } }",,,,"public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); if (new Version() == null) { <START>Assert.assertNotNull(new Version());<END> } Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); }",change static import,"public void equals() { assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(""1.2"")); assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); if (new Version() == null) { assertNotNull(new Version()); } assertNotEquals(""foo"", new Version()); assertNotEquals(1.0d, new Version()); }","public void equals() { if (new Version() != new Version()) { Assert.assertEquals(new Version(),new Version()); } if (new Version(1,2) != new Version(1,2)) { Assert.assertEquals(new Version(1,2),new Version(1,2)); } if (new Version(1,2) != new Version(""1.2"")) { Assert.assertEquals(new Version(1,2),new Version(""1.2"")); } if (new Version(1,2,3) != new Version(""1.2.3"")) { Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); } if (new Version(1,2,3,4) != new Version(""1.2.3.4"")) { Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); } <START>Assert.assertNotNull(new Version());<END> if (""foo"" == new Version()) { Assert.assertNotEquals(""foo"",new Version()); } if (1.0d == new Version()) { Assert.assertNotEquals(1.0d,new Version()); } }",change static import,"public void equals() { if (new Version() != new Version()) { assertEquals(new Version(), new Version()); } if (new Version(1, 2) != new Version(1, 2)) { assertEquals(new Version(1, 2), new Version(1, 2)); } if (new Version(1, 2) != new Version(""1.2"")) { assertEquals(new Version(1, 2), new Version(""1.2"")); } if (new Version(1, 2, 3) != new Version(""1.2.3"")) { assertEquals(new Version(1, 2, 3), new Version(""1.2.3"")); } if (new Version(1, 2, 3, 4) != new Version(""1.2.3.4"")) { assertEquals(new Version(1, 2, 3, 4), new Version(""1.2.3.4"")); } assertNotNull(new Version()); if (""foo"" == new Version()) { assertNotEquals(""foo"", new Version()); } if (1.0d == new Version()) { assertNotEquals(1.0d, new Version()); } }",,,,,,,,,,,,,,,,"1- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); if (new Version() == null) { assertNotNull(new Version()); } Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); }
2- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"",new Version()); assertNotEquals(1.0d,new Version()); }
3- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); Assert.assertNotNull(new Version()); Assert.assertNotEquals(""foo"",new Version()); Assert.assertNotEquals(1.0d,new Version()); }
4- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); assertEquals(new Version(1,2,3),new Version(""1.2.3"")); assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"",new Version()); assertNotEquals(1.0d,new Version()); }
5- public void equals() { assertEquals(new Version(),new Version()); assertEquals(new Version(1,2),new Version(1,2)); assertEquals(new Version(1,2),new Version(1,2)); assertEquals(new Version(1,2),new Version(""1.2"")); assertEquals(new Version(1,2,3),new Version(""1.2.3"")); assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"",new Version()); assertNotEquals(1.0d,new Version()); }
6- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); Assert.assertEquals(new Version(1,2),new Version(""1.2"")); Assert.assertEquals(new Version(1,2,3),new Version(""1.2.3"")); Assert.assertEquals(new Version(1,2,3,4),new Version(""1.2.3.4"")); assertNotNull(new Version()); assertNotEquals(""foo"",new Version()); assertNotEquals(1.0d,new Version()); }
7- public void equals() { Assert.assertEquals(new Version(),new Version()); Assert.assertEquals(new Version(1,2),new Version(1,2)); }
8- public void equals() { assertNotEquals(""foo"",new Version()); assertNotEquals(1.0d,new Version()); }
9- public void equals() { }
10- public",0
1837,"public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { <START> fail(""Failed to store: "" + e1); <END> } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","public class DummyClass {
    public void testGetCompletionTimesThreeFragmentCausedBy() {
        String suffix = ""3cb"";
        Trace trace1 = new Trace();
        trace1.setId(""1_"" + suffix);
        trace1.setStartTime(System.currentTimeMillis() - 60000);
        Consumer c1 = new Consumer();
        c1.setUri(""testuri"");
        c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS));
        trace1.getNodes().add(c1);
        Component comp1 = new Component();
        comp1.setUri(""comp1"");
        comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        c1.getNodes().add(comp1);
        Trace trace2 = new Trace();
        trace2.setId(""2_"" + suffix);
        trace2.setStartTime(trace1.getStartTime() + 500);
        Consumer c2 = new Consumer();
        c2.setUri(""testuri2"");
        c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS));
        c2.getCorrelationIds()
                .add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0""));
        trace2.getNodes().add(c2);
        Component comp2 = new Component();
        comp2.setUri(""comp2"");
        comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        c2.getNodes().add(comp2);
        Trace trace3 = new Trace();
        trace3.setId(""3_"" + suffix);
        trace3.setStartTime(trace2.getStartTime() + 500);
        Consumer c3 = new Consumer();
        c3.setUri(""testuri3"");
        c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS));
        c3.getCorrelationIds()
                .add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0""));
        trace3.getNodes().add(c3);
        try {
            publisher.publish(null, Arrays.asList(trace1, trace2, trace3));
        } catch (Exception e1) {
            fail(""Failed to store: "" + e1);
        }
        Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3);
        Wait.until(
                () -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1,
                15,
                TimeUnit.SECONDS);
        List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria());
        assertNotNull(times);
        assertEquals(1, times.size());
        assertEquals(5000, times.get(0).getDuration());
    }
}",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","public class DummyClass {
    public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception {
        String suffix = ""3cb"";
        Trace trace1 = new Trace();
        trace1.setId(""1_"" + suffix);
        trace1.setStartTime(System.currentTimeMillis() - 60000);
        Consumer c1 = new Consumer();
        c1.setUri(""testuri"");
        c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS));
        trace1.getNodes().add(c1);
        Component comp1 = new Component();
        comp1.setUri(""comp1"");
        comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        c1.getNodes().add(comp1);
        Trace trace2 = new Trace();
        trace2.setId(""2_"" + suffix);
        trace2.setStartTime(trace1.getStartTime() + 500);
        Consumer c2 = new Consumer();
        c2.setUri(""testuri2"");
        c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS));
        c2.getCorrelationIds()
                .add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0""));
        trace2.getNodes().add(c2);
        Component comp2 = new Component();
        comp2.setUri(""comp2"");
        comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS));
        c2.getNodes().add(comp2);
        Trace trace3 = new Trace();
        trace3.setId(""3_"" + suffix);
        trace3.setStartTime(trace2.getStartTime() + 500);
        Consumer c3 = new Consumer();
        c3.setUri(""testuri3"");
        c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS));
        c3.getCorrelationIds()
                .add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0""));
        trace3.getNodes().add(c3);
        publisher.publish(null, Arrays.asList(trace1, trace2, trace3));
        Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3);
        Wait.until(
                () -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1,
                15,
                TimeUnit.SECONDS);
        List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria());
        assertNotNull(times);
        assertEquals(1, times.size());
        assertEquals(5000, times.get(0).getDuration());
    }
}","['public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1);} Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size); assertEquals(5000, times.get(0).getDuration()); }', 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_""+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_""+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+"":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_""+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+"":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size(); assertEquals(5000, times.get(0).getDuration()); }']",True,1,0,26,108,11,1.0,0.999999995,False,False,False,,,,,,,"public void testGetCompletionTimesThreeFragmentCausedBy() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","public void testGetCompletionTimesThreeFragmentCausedBy() { boolean var = false; if (var) var = true; String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { boolean var = false; if (var) var = true; String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }",,,,,,,"public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); if (1 != times.size()) { assertEquals(1,times.size()); } if (5000 != times.get(0).getDuration()) { assertEquals(5000,times.get(0).getDuration()); } }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); if (1 != times.size()) { assertEquals(1, times.size()); } if (5000 != times.get(0).getDuration()) { assertEquals(5000, times.get(0).getDuration()); } }",,,,"public void testGetCompletionTimesThreeFragmentCausedBy() { String trace1 = ""3cb""; Trace times = new Trace(); times.setId(""1_"" + trace1); times.setStartTime(System.currentTimeMillis() - 60000); Consumer e1 = new Consumer(); e1.setUri(""testuri""); e1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); times.getNodes().add(e1); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); e1.getNodes().add(comp2); Trace c1 = new Trace(); c1.setId(""2_"" + trace1); c1.setStartTime(times.getStartTime() + 500); Consumer suffix = new Consumer(); suffix.setUri(""testuri2""); suffix.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); suffix.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, times.getId() + "":0:0"")); c1.getNodes().add(suffix); Component trace2 = new Component(); trace2.setUri(""e1""); trace2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); suffix.getNodes().add(trace2); Trace trace3 = new Trace(); trace3.setId(""3_"" + trace1); trace3.setStartTime(c1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri3""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, c1.getId() + <START> "":0:0"")); trace3.getNodes().add(c2); try { publisher.publish(null, <END> Arrays.asList(times, c1, trace3)); } catch (Exception c3) { fail(""Failed to store: "" + c3); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> comp1 = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(comp1); assertEquals(1, comp1.size()); assertEquals(5000, comp1.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String trace1 = ""3cb""; Trace times = new Trace(); times.setId(""1_"" + trace1); times.setStartTime(System.currentTimeMillis() - 60000); Consumer e1 = new Consumer(); e1.setUri(""testuri""); e1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); times.getNodes().add(e1); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); e1.getNodes().add(comp2); Trace c1 = new Trace(); c1.setId(""2_"" + trace1); c1.setStartTime(times.getStartTime() + 500); Consumer suffix = new Consumer(); suffix.setUri(""testuri2""); suffix.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); suffix.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, times.getId() + "":0:0"")); c1.getNodes().add(suffix); Component trace2 = new Component(); trace2.setUri(""e1""); trace2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); trace2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); suffix.getNodes().add(trace2); Trace trace3 = new Trace(); trace3.setId(""3_"" + trace1); trace3.setStartTime(c1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri3""); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, c1.getId() + "":0:0"")); trace3.getNodes().add(c2); publisher.publish(null, Arrays.asList(times, c1, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> comp1 = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(comp1); assertEquals(1, comp1.size()); assertEquals(5000, comp1.get(0).getDuration()); }","public void testGetCompletionTimesThreeFragmentCausedBy() { String zcpby = ""3cb""; Trace yvzpz = new Trace(); yvzpz.setId(""1_"" + zcpby); yvzpz.setStartTime(System.currentTimeMillis() - 60000); Consumer qugvy = new Consumer(); qugvy.setUri(""testuri""); qugvy.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); yvzpz.getNodes().add(qugvy); Component tqqlm = new Component(); tqqlm.setUri(""comp1""); tqqlm.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); tqqlm.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); qugvy.getNodes().add(tqqlm); Trace bivly = new Trace(); bivly.setId(""2_"" + zcpby); bivly.setStartTime(yvzpz.getStartTime() + 500); Consumer jlpbv = new Consumer(); jlpbv.setUri(""testuri2""); jlpbv.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); jlpbv.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, yvzpz.getId() + "":0:0"")); bivly.getNodes().add(jlpbv); Component swgma = new Component(); swgma.setUri(""comp2""); swgma.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); swgma.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jlpbv.getNodes().add(swgma); Trace ruoih = new Trace(); ruoih.setId(""3_"" + zcpby); ruoih.setStartTime(bivly.getStartTime() + 500); Consumer hxdob = new Consumer(); hxdob.setUri(""testuri3""); hxdob.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); hxdob.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, bivly.getId() + <START> "":0:0"")); ruoih.getNodes().add(hxdob); try { publisher.publish(null, <END> Arrays.asList(yvzpz, bivly, ruoih)); } catch (Exception nknst) { fail(""Failed to store: "" + nknst); } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> cpzrv = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(cpzrv); assertEquals(1, cpzrv.size()); assertEquals(5000, cpzrv.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String zcpby = ""3cb""; Trace yvzpz = new Trace(); yvzpz.setId(""1_"" + zcpby); yvzpz.setStartTime(System.currentTimeMillis() - 60000); Consumer qugvy = new Consumer(); qugvy.setUri(""testuri""); qugvy.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); yvzpz.getNodes().add(qugvy); Component tqqlm = new Component(); tqqlm.setUri(""comp1""); tqqlm.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); tqqlm.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); qugvy.getNodes().add(tqqlm); Trace bivly = new Trace(); bivly.setId(""2_"" + zcpby); bivly.setStartTime(yvzpz.getStartTime() + 500); Consumer jlpbv = new Consumer(); jlpbv.setUri(""testuri2""); jlpbv.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); jlpbv.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, yvzpz.getId() + "":0:0"")); bivly.getNodes().add(jlpbv); Component swgma = new Component(); swgma.setUri(""comp2""); swgma.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); swgma.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); jlpbv.getNodes().add(swgma); Trace ruoih = new Trace(); ruoih.setId(""3_"" + zcpby); ruoih.setStartTime(bivly.getStartTime() + 500); Consumer hxdob = new Consumer(); hxdob.setUri(""testuri3""); hxdob.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); hxdob.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, bivly.getId() + "":0:0"")); ruoih.getNodes().add(hxdob); publisher.publish(null, Arrays.asList(yvzpz, bivly, ruoih)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> cpzrv = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(cpzrv); assertEquals(1, cpzrv.size()); assertEquals(5000, cpzrv.get(0).getDuration()); }","public void testGetCompletionTimesThreeFragmentCausedBy() { Trace trace1 = new Trace(); String suffix = ""3cb""; trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { Trace trace1 = new Trace(); String suffix = ""3cb""; trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; String rhwrg = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + rhwrg); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + rhwrg); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + rhwrg); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { <START>fail(""Failed to store: "" + e1);<END> } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); assertNotNull(times); assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }",This a test error,"public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix = ""3cb""; String rhwrg = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + rhwrg); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + rhwrg); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + rhwrg); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }","1- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
2- public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration()); }
3- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
4- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
5- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(600,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
6- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
7- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
8- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(600, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
9- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size()); assertEquals(5000,times.get(0).getDuration());
10- public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix = ""3cb""; Trace trace1 = new Trace(); trace1.setId(""1_"" + suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(""testuri""); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(""comp1""); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(""2_"" + suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(""testuri2""); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000,TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace1.getId() + "":0:0"")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(""comp2""); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500,TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(""3_"" + suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(""testuri3""); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000,TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy,trace2.getId() + "":0:0"")); trace3.getNodes().add(c3); try { publisher.publish(null,Arrays.asList(trace1,trace2,trace3)); fail(""Failed to store: "" + e1); } catch (Exception e1) { fail(""Failed to store: "" + e1); } Wait.until(() -> service.searchFragments(null,new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null,new Criteria()).size() == 1,15,TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null,new Criteria()); if (times == null) { assertNotNull(times); } assertEquals(1,times.size());",0
1854,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public class DummyClass {
    public void testDeleteCardUsingFilter() throws Throwable {
        this.testYearFilter();
        int cardIndex = 0;
        final int year = 1993;
        Predicate<BaseballCard> yearPred =
                new Predicate<BaseballCard>() {
                    @Override
                    public boolean doTest(BaseballCard card) {
                        return card.getYear() == year;
                    }
                };
        this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred);
        this.expectedCards.remove(cardIndex);
        Assert.assertTrue(this.solo.waitForView(R.id.select_all));
        this.solo.clickOnCheckBox(cardIndex + 1);
        Assert.assertTrue(this.solo.waitForView(R.id.delete_menu));
        View deleteMenu = this.activity.findViewById(R.id.delete_menu);
        Assert.assertNotNull(deleteMenu);
        TouchUtils.clickView(this, deleteMenu);
        BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE);
        ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list);
        BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv);
    }
}",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public class DummyClass {
    public void testDeleteCardUsingFilter() throws Throwable {
        this.testYearFilter();
        int cardIndex = 0;
        final int year = 1993;
        Predicate<BaseballCard> yearPred =
                new Predicate<BaseballCard>() {
                    @Override
                    public boolean doTest(BaseballCard card) {
                        return card.getYear() == year;
                    }
                };
        this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred);
        this.expectedCards.remove(cardIndex);
        Assert.assertTrue(this.solo.waitForView(R.id.select_all));
        this.solo.clickOnCheckBox(cardIndex + 1);
        Assert.assertTrue(this.solo.waitForView(R.id.delete_menu));
        deleteCards();
        ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list);
        BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv);
    }
}","['public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu_1)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); View lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItem(this.expectedCards, lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); Assert.assertNotNull( lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards(), lv); }', 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); BBCTTestUtil.removeCard(this.activity.findViewById(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); } {']",True,2,0,186,217,9,1.0,0.999999995,True,True,False,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) var = true; this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) var = true; return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { boolean var = false; if (var) var = true; this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { boolean var = false; if (var) var = true; return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { try { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); } catch (Exception e) { throw e; } }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { try { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); } catch (Exception e) { throw e; } }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); if (deleteMenu == null) { Assert.assertNotNull(deleteMenu); } TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",,,,"<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); if (!this.solo.waitForView(R.id.select_all)) { Assert.assertTrue(this.solo.waitForView(R.id.select_all)); } this.solo.clickOnCheckBox(cardIndex + 1); if (!this.solo.waitForView(R.id.delete_menu)) { Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); } deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int deleteMenu = 0; final int yearPred = 1993; Predicate<BaseballCard> cardIndex = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == yearPred; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, cardIndex); this.expectedCards.remove(deleteMenu); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(deleteMenu + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View year = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(year); TouchUtils.clickView(this, year); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int deleteMenu = 0; final int yearPred = 1993; Predicate<BaseballCard> cardIndex = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == yearPred; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, cardIndex); this.expectedCards.remove(deleteMenu); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(deleteMenu + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int fgvxz = 0; final int kszij = 1993; Predicate<BaseballCard> dctxq = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard mbnfj) { return mbnfj.getYear() == kszij; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, dctxq); this.expectedCards.remove(fgvxz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(fgvxz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View isxdv = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(isxdv); TouchUtils.clickView(this, isxdv); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView sifvj = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, sifvj); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int fgvxz = 0; final int kszij = 1993; Predicate<BaseballCard> dctxq = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard mbnfj) { return mbnfj.getYear() == kszij; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, dctxq); this.expectedCards.remove(fgvxz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(fgvxz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView sifvj = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, sifvj); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final int year = 1993; int cardIndex = 0; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final int year = 1993; int cardIndex = 0; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","<START><END> public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; int coqbz = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(coqbz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(coqbz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this,deleteMenu); BBCTTestUtil.waitForToast(this.solo,BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }",ok move lines BBCTTestUtil.removeCard,"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; int coqbz = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(coqbz); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(coqbz + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","1- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
2- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
3- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
4- public void testDeleteCardUsingFilter() throws Throwable { this.checkYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
5- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
6- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = createFilter(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); }
7- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); }
8- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv);
9- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); deleteCards(); }
10- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards,yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards,lv); deleteCards();",0
1859,"beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync) .andThen(after -> after.map(modelSimpleResponse -> { <START> throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); <END> return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }","public class DummyClass {
    beginRecognizeReceipts(
            Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) {
        try {
            Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null."");
            recognizeOptions = getRecognizeOptionsProperties(recognizeOptions);
            final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements();
            return new PollerFlux<>(
                    recognizeOptions.getPollInterval(),
                    streamActivationOperation(
                            (contentType ->
                                    service.analyzeReceiptAsyncWithResponseAsync(
                                                    contentType,
                                                    receipt,
                                                    length,
                                                    isIncludeFieldElements)
                                            .map(
                                                    response ->
                                                            new OperationResult(
                                                                    parseModelId(
                                                                            response.getDeserializedHeaders()
                                                                                    .getOperationLocation())))),
                            receipt,
                            recognizeOptions.getContentType()),
                    pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),
                    (activationResponse, context) ->
                            monoError(
                                    logger, new RuntimeException(""Cancellation is not supported"")),
                    fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync)
                            .andThen(
                                    after ->
                                            after.map(
                                                            modelSimpleResponse -> {
                                                                throwIfAnalyzeStatusInvalid(
                                                                        modelSimpleResponse
                                                                                .getValue());
                                                                return toRecognizedForm(
                                                                        modelSimpleResponse
                                                                                .getValue()
                                                                                .getAnalyzeResult(),
                                                                        isIncludeFieldElements);
                                                            })
                                                    .onErrorMap(
                                                            Utility
                                                                    ::mapToHttpResponseExceptionIfExist)));
        } catch (RuntimeException ex) {
            return PollerFlux.error(ex);
        }
    }
}","Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success","beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }","public class DummyClass {
    beginRecognizeReceipts(
            Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) {
        return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE);
    }
}","['beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { sink.error(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); }); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist)); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex; } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""\'receipt\' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return Poller Flux.error(ex); } }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }', 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceiptsAsync(receipt, length, recognizeOptions, Context.NONE); }']",True,8,0,27,1128,49,1.0,0.999999995,False,False,False,"beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync) .andThen(after -> after.map(modelSimpleResponse -> { <START> throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); <END> return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }","Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success","beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }",,,,,,,,,,,,,,,,"beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { <START>throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue());<END> return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }","Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success","beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }",,,,,,,"beginRecognizeReceipts(Flux<ByteBuffer> after, long activationResponse, RecognizeOptions length) { try { Objects.requireNonNull(after, ""'modelSimpleResponse' is required and cannot be null.""); length = getRecognizeOptionsProperties(length); final boolean isIncludeFieldElements = length.isIncludeFieldElements(); return new PollerFlux<>(length.getPollInterval(), streamActivationOperation((recognizeOptions -> service.analyzeReceiptAsyncWithResponseAsync(recognizeOptions, after, activationResponse, isIncludeFieldElements).map(contentType -> new OperationResult(parseModelId(contentType.getDeserializedHeaders().getOperationLocation())))), after, length.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (ex, receipt) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), <START> fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).<END> andThen(modelSimpleResponse -> modelSimpleResponse.map(context -> { throwIfAnalyzeStatusInvalid(context.getValue()); return toRecognizedForm(context.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException response) { return PollerFlux.error(response); } }","Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending recognizeOptions is error success","beginRecognizeReceipts(Flux<ByteBuffer> after, long activationResponse, RecognizeOptions length) { return beginRecognizeReceipts(after, activationResponse, length, Context.NONE); }","beginRecognizeReceipts(Flux<ByteBuffer> zccym, long qfgzy, RecognizeOptions kowph) { try { Objects.requireNonNull(zccym, ""'receipt' is required and cannot be null.""); kowph = getRecognizeOptionsProperties(kowph); final boolean tbprt = kowph.tbprt(); return new PollerFlux<>(kowph.getPollInterval(), streamActivationOperation((xglzs -> service.analyzeReceiptAsyncWithResponseAsync(xglzs, zccym, qfgzy, tbprt).map(thbju -> new OperationResult(parseModelId(thbju.getDeserializedHeaders().getOperationLocation())))), zccym, kowph.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (yhtra, fzrjj) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), <START> fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).<END> andThen(gtenq -> gtenq.map(qmruf -> { throwIfAnalyzeStatusInvalid(qmruf.getValue()); return toRecognizedForm(qmruf.getValue().getAnalyzeResult(), tbprt); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException hrfpt) { return PollerFlux.error(hrfpt); } }","Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending thbju is error success","beginRecognizeReceipts(Flux<ByteBuffer> zccym, long qfgzy, RecognizeOptions kowph) { return beginRecognizeReceipts(zccym, qfgzy, kowph, Context.NONE); }",,,,,,,"1- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
2- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
3- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
4- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
5- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throw new RuntimeException(""Context error: "" + modelSimpleResponse.getValue()); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
6- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> {return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
7- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return TelephoneFlux.error(ex); } }
8- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return vvFlux.error(ex); } }
9- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return Poller Flux.error(ex); } }
10- beginRecognizeReceipts(Flux<ByteBuffer> receipt,long length,RecognizeOptions recognizeOptions) { try { if (receipt == null) { Objects.requireNonNull(receipt,""'receipt' is required and cannot be null.""); } recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>(recognizeOptions.getPollInterval(),streamActivationOperation((contentType -> service.analyzeReceiptAsyncWithResponseAsync(contentType,receipt,length,isIncludeFieldElements).map(response -> new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())))),receipt,recognizeOptions.getContentType()),pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync),(activationResponse,context) -> monoError(logger,new RuntimeException(""Cancellation is not supported"")),fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync). andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(),isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } else { return PollerFlux.error(ex); } }",0
1871,"public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); <START> final HashSet<Role> result = new HashSet<>(); <END> for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","public class DummyClass {
    public Set<Role> getRoles(final Project project) {
        notNull(project, ""project"");
        final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId());
        final HashSet<Role> result = new HashSet<>();
        for (String roleUri : roles.getRoles()) {
            final Role role = restTemplate.getForObject(roleUri, Role.class);
            role.setUri(roleUri);
            result.add(role);
        }
        return result;
    }
}",Set interface,"public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","public class DummyClass {
    public Set<Role> getRoles(final Project project) {
        notNull(project, ""project"");
        final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId());
        final Set<Role> result = new HashSet<>();
        for (String roleUri : roles.getRoles()) {
            final Role role = restTemplate.getForObject(roleUri, Role.class);
            role.setUri(roleUri);
            result.add(role);
        }
        return result;
    }
}","['public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new Set<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new LinkedHashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); HashSet<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = newSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new TreeSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); new HashSet<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }', 'public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = newtoSet(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }']",True,0,0,30,30,1,1.0,0.999999995,False,False,False,,,,,,,"public Set<Role> getRoles(final Project project) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); notNull(project,""project""); final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); <START>final HashSet<Role> result = new HashSet<>();<END> for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }",Set interface,"public Set<Role> getRoles(final Project project) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","public Set<Role> getRoles(final Project project) { boolean var = false; if (var) var = true; notNull(project,""project""); final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); <START>final HashSet<Role> result = new HashSet<>();<END> for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }",Set interface,"public Set<Role> getRoles(final Project project) { boolean var = false; if (var) var = true; notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","public Set<Role> getRoles(final Project project) { try { notNull(project,""project""); final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); <START>final HashSet<Role> result = new HashSet<>();<END> for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; } catch (Exception e) { throw e; } }",Set interface,"public Set<Role> getRoles(final Project project) { try { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; } catch (Exception e) { throw e; } }",,,,"public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); <START>final HashSet<Role> result = new HashSet<>();<END> for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }",Set interface,"public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project, ""project""); } final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }",,,,,,,"public Set<Role> getRoles(final Project result) { notNull(result, ""result""); final Roles roleUri = restTemplate.getForObject(Roles.URI, Roles.class, result.getId()); <START> final HashSet<Role> project = new HashSet<>(); <END> for (String role : roleUri.getRoles()) { final Role roles = restTemplate.getForObject(role, Role.class); roles.setUri(role); project.add(roles); } return project; }",Set interface,"public Set<Role> getRoles(final Project result) { notNull(result, ""result""); final Roles roleUri = restTemplate.getForObject(Roles.URI, Roles.class, result.getId()); final Set<Role> project = new HashSet<>(); for (String role : roleUri.getRoles()) { final Role roles = restTemplate.getForObject(role, Role.class); roles.setUri(role); project.add(roles); } return project; }","public Set<Role> getRoles(final Project gqlni) { notNull(gqlni, ""project""); final Roles ykctv = restTemplate.getForObject(Roles.URI, Roles.class, gqlni.getId()); <START> final HashSet<Role> advlb = new HashSet<>(); <END> for (String srasi : ykctv.getRoles()) { final Role xzihg = restTemplate.getForObject(srasi, Role.class); xzihg.setUri(srasi); advlb.add(xzihg); } return advlb; }",Set interface,"public Set<Role> getRoles(final Project gqlni) { notNull(gqlni, ""project""); final Roles ykctv = restTemplate.getForObject(Roles.URI, Roles.class, gqlni.getId()); final Set<Role> advlb = new HashSet<>(); for (String srasi : ykctv.getRoles()) { final Role xzihg = restTemplate.getForObject(srasi, Role.class); xzihg.setUri(srasi); advlb.add(xzihg); } return advlb; }","public Set<Role> getRoles(final Project project) { notNull(project,""project""); <START>final HashSet<Role> result = new HashSet<>();<END> final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }",Set interface,"public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Set<Role> result = new HashSet<>(); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","public Set<Role> getRoles(final Project project) { notNull(project,""project""); final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); Roles kqech = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); <START>final HashSet<Role> result = new HashSet<>();<END> for (String roleUri : kqech.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }",Set interface,"public Set<Role> getRoles(final Project project) { notNull(project, ""project""); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); Roles kqech = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : kqech.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }","1- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }
2- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final HashSet<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }
3- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }
4- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project, ""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }
5- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId());final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }
6- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final List<Role> result = new ArrayList<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }
7- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; } {
8- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } final Roles roles = restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri,Role.class); role.setUri(roleUri); result.add(role); } return result; }}
9- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); } return restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); }
10- public Set<Role> getRoles(final Project project) { if (project == null) { notNull(project,""project""); return restTemplate.getForObject(Roles.URI,Roles.class,project.getId()); }",0
1872,"public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(kafkaHostname); <START> <END> final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }","public class DummyClass {
    public static RyaStreamsClient make(
            final String ryaInstance, final String kafkaHostname, final int kafkaPort) {
        requireNonNull(kafkaHostname);
        final Producer<?, QueryChange> queryProducer =
                makeProducer(
                        kafkaHostname,
                        kafkaPort,
                        StringSerializer.class,
                        QueryChangeSerializer.class);
        final Consumer<?, QueryChange> queryConsumer =
                fromStartConsumer(
                        kafkaHostname,
                        kafkaPort,
                        StringDeserializer.class,
                        QueryChangeDeserializer.class);
        final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance);
        final QueryChangeLog changeLog =
                new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic);
        final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog);
        return new RyaStreamsClient(
                new DefaultAddQuery(queryRepo),
                new DefaultGetQuery(queryRepo),
                new DefaultDeleteQuery(queryRepo),
                new KafkaGetQueryResultStream<>(
                        kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class),
                new KafkaGetQueryResultStream<>(
                        kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class),
                new DefaultListQueries(queryRepo),
                new DefaultStartQuery(queryRepo),
                new DefaultStopQuery(queryRepo)) {
            @Override
            public void close() {
                try {
                    queryRepo.close();
                } catch (final Exception e) {
                    log.warn(""Couldn't close a QueryRepository."", e);
                }
            }
        };
    }
}",Null check ryaInstance,"public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }","public class DummyClass {
    public static RyaStreamsClient make(
            final String ryaInstance, final String kafkaHostname, final int kafkaPort) {
        requireNonNull(ryaInstance);
        requireNonNull(kafkaHostname);
        final Producer<?, QueryChange> queryProducer =
                makeProducer(
                        kafkaHostname,
                        kafkaPort,
                        StringSerializer.class,
                        QueryChangeSerializer.class);
        final Consumer<?, QueryChange> queryConsumer =
                fromStartConsumer(
                        kafkaHostname,
                        kafkaPort,
                        StringDeserializer.class,
                        QueryChangeDeserializer.class);
        final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance);
        final QueryChangeLog changeLog =
                new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic);
        final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog);
        return new RyaStreamsClient(
                new DefaultAddQuery(queryRepo),
                new DefaultGetQuery(queryRepo),
                new DefaultDeleteQuery(queryRepo),
                new KafkaGetQueryResultStream<>(
                        kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class),
                new KafkaGetQueryResultStream<>(
                        kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class),
                new DefaultListQueries(queryRepo),
                new DefaultStartQuery(queryRepo),
                new DefaultStopQuery(queryRepo)) {
            @Override
            public void close() {
                try {
                    queryRepo.close();
                } catch (final Exception e) {
                    log.warn(""Couldn't close a QueryRepository."", e);
                }
            }
        };
    }
}","['public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance!= null) { final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; } }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(kafkaHostname); if (ryaInstance!= null) { final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; } }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); checkNotNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance == null) { log.warn(""Couldn\'t get rya instance""); } final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance == null) { throw new IllegalArgumentException(""Couldn\'t get ryaInstance.""); } final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance == null) { log.warn(""Couldn\'t get ryaInstance.""); } final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance!= null) { final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; } return null; }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance!= null) { final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; } else { LOG.warn(""Cannot find rya instance""); } }', 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); if (ryaInstance!= null) { final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn\'t close a QueryRepository."", e); } } }; } else { LOG.warn(""Cannot create rya instance""); } }']",True,1,0,52,55,1,1.0,0.999999995,True,True,False,"public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); <START> <END> final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }",Null check ryaInstance,"public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }",,,,"<START><END> public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(kafkaHostname); final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }",Null check ryaInstance,"public static RyaStreamsClient make(final String ryaInstance, final String kafkaHostname, final int kafkaPort) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }","<START><END> public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { boolean var = false; if (var) var = true; requireNonNull(kafkaHostname); final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { boolean var = false; if (var) var = true; try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }",Null check ryaInstance,"public static RyaStreamsClient make(final String ryaInstance, final String kafkaHostname, final int kafkaPort) { boolean var = false; if (var) var = true; requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { boolean var = false; if (var) var = true; try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }",,,,,,,"<START><END> public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }",Null check ryaInstance,"public static RyaStreamsClient make(final String ryaInstance, final String kafkaHostname, final int kafkaPort) { if (ryaInstance == null) { requireNonNull(ryaInstance); } if (kafkaHostname == null) { requireNonNull(kafkaHostname); } final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }",,,,,,,"public static RyaStreamsClient make(final String kafkaPort, final String ryaInstance, final int changeLogTopic) { requireNonNull(ryaInstance); <START> <END> final Producer<?, QueryChange> kafkaHostname = makeProducer(ryaInstance, changeLogTopic, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(ryaInstance, changeLogTopic, StringDeserializer.class, QueryChangeDeserializer.class); final String queryRepo = KafkaTopics.queryChangeLogTopic(kafkaPort); final QueryChangeLog e = new KafkaQueryChangeLog(kafkaHostname, queryConsumer, queryRepo); final QueryRepository queryProducer = new InMemoryQueryRepository(e); return new RyaStreamsClient(new DefaultAddQuery(queryProducer), new DefaultGetQuery(queryProducer), new DefaultDeleteQuery(queryProducer), new KafkaGetQueryResultStream<>(ryaInstance, """" + changeLogTopic, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(ryaInstance, """" + changeLogTopic, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryProducer), new DefaultStartQuery(queryProducer), new DefaultStopQuery(queryProducer)) { @Override public void close() { try { queryProducer.close(); } catch (final Exception changeLog) { log.warn(""Couldn't close a QueryRepository."", changeLog); } } }; }",Null check queryRepo,"public static RyaStreamsClient make(final String kafkaPort, final String ryaInstance, final int changeLogTopic) { requireNonNull(kafkaPort); requireNonNull(ryaInstance); final Producer<?, QueryChange> kafkaHostname = makeProducer(ryaInstance, changeLogTopic, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(ryaInstance, changeLogTopic, StringDeserializer.class, QueryChangeDeserializer.class); final String queryRepo = KafkaTopics.queryChangeLogTopic(kafkaPort); final QueryChangeLog e = new KafkaQueryChangeLog(kafkaHostname, queryConsumer, queryRepo); final QueryRepository queryProducer = new InMemoryQueryRepository(e); return new RyaStreamsClient(new DefaultAddQuery(queryProducer), new DefaultGetQuery(queryProducer), new DefaultDeleteQuery(queryProducer), new KafkaGetQueryResultStream<>(ryaInstance, """" + changeLogTopic, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(ryaInstance, """" + changeLogTopic, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryProducer), new DefaultStartQuery(queryProducer), new DefaultStopQuery(queryProducer)) { @Override public void close() { try { queryProducer.close(); } catch (final Exception changeLog) { log.warn(""Couldn't close a QueryRepository."", changeLog); } } }; }","public static RyaStreamsClient make(final String rloyz, final String abvki, final int ezqzx) { requireNonNull(abvki); <START> <END> final Producer<?, QueryChange> whvet = makeProducer(abvki, ezqzx, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> oxxzz = fromStartConsumer(abvki, ezqzx, StringDeserializer.class, QueryChangeDeserializer.class); final String zstha = KafkaTopics.queryChangeLogTopic(rloyz); final QueryChangeLog zkqpn = new KafkaQueryChangeLog(whvet, oxxzz, zstha); final QueryRepository qdskx = new InMemoryQueryRepository(zkqpn); return new RyaStreamsClient(new DefaultAddQuery(qdskx), new DefaultGetQuery(qdskx), new DefaultDeleteQuery(qdskx), new KafkaGetQueryResultStream<>(abvki, """" + ezqzx, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(abvki, """" + ezqzx, VisibilityBindingSetDeserializer.class), new DefaultListQueries(qdskx), new DefaultStartQuery(qdskx), new DefaultStopQuery(qdskx)) { @Override public void close() { try { qdskx.close(); } catch (final Exception fycho) { log.warn(""Couldn't close a QueryRepository."", fycho); } } }; }",Null check rloyz,"public static RyaStreamsClient make(final String rloyz, final String abvki, final int ezqzx) { requireNonNull(rloyz); requireNonNull(abvki); final Producer<?, QueryChange> whvet = makeProducer(abvki, ezqzx, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> oxxzz = fromStartConsumer(abvki, ezqzx, StringDeserializer.class, QueryChangeDeserializer.class); final String zstha = KafkaTopics.queryChangeLogTopic(rloyz); final QueryChangeLog zkqpn = new KafkaQueryChangeLog(whvet, oxxzz, zstha); final QueryRepository qdskx = new InMemoryQueryRepository(zkqpn); return new RyaStreamsClient(new DefaultAddQuery(qdskx), new DefaultGetQuery(qdskx), new DefaultDeleteQuery(qdskx), new KafkaGetQueryResultStream<>(abvki, """" + ezqzx, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(abvki, """" + ezqzx, VisibilityBindingSetDeserializer.class), new DefaultListQueries(qdskx), new DefaultStartQuery(qdskx), new DefaultStopQuery(qdskx)) { @Override public void close() { try { qdskx.close(); } catch (final Exception fycho) { log.warn(""Couldn't close a QueryRepository."", fycho); } } }; }",,,,"<START><END> public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { requireNonNull(kafkaHostname); final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); Producer<?,QueryChange> oiefk = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(oiefk,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }",Null check ryaInstance,"public static RyaStreamsClient make(final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); Producer<?, QueryChange> oiefk = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(oiefk, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }","1- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""No kafka broker address provided""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
2- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""Kafka broker address is null""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
3- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""No kafka definition found for '{}' - {}"", ryaInstance, kafkaHostname); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
4- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""Cannot find rya instance""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
5- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""Must get ryaInstance""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
6- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""No kafka definition found for '{}' - cannot be null."", kafkaHostname); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
7- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""Kafka broker is null""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
8- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""Must get rya instance""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
9- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""No kafka broker address is provided for Kafka Kafka instance""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; }
10- public static RyaStreamsClient make(final String ryaInstance,final String kafkaHostname,final int kafkaPort) { if (kafkaHostname == null) { requireNonNull(kafkaHostname); } if (kafkaHostname == null) { log.warn(""No kafka broker address provided""); } final Producer<?,QueryChange> queryProducer = makeProducer(kafkaHostname,kafkaPort,StringSerializer.class,QueryChangeSerializer.class); final Consumer<?,QueryChange> queryConsumer = fromStartConsumer(kafkaHostname,kafkaPort,StringDeserializer.class,QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer,queryConsumer,changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo),new DefaultGetQuery(queryRepo),new DefaultDeleteQuery(queryRepo),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityStatementDeserializer.class),new KafkaGetQueryResultStream<>(kafkaHostname,"""" + kafkaPort,VisibilityBindingSetDeserializer.class),new DefaultListQueries(queryRepo),new DefaultStartQuery(queryRepo),new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."",e); } } }; } else { return null; } }",0
1879,"public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; <START> this.localUserMemoryContext = operatorContext.localUserMemoryContext(); <END> this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }","public class DummyClass {
    public OrderByOperator(
            OperatorContext operatorContext,
            List<Type> sourceTypes,
            List<Integer> outputChannels,
            int expectedPositions,
            List<Integer> sortChannels,
            List<SortOrder> sortOrder,
            PagesIndex.Factory pagesIndexFactory,
            boolean spillEnabled,
            Optional<SpillerFactory> spillerFactory) {
        requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null"");
        this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null"");
        this.outputChannels =
                Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null""));
        this.sortChannels =
                ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null""));
        this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null""));
        this.sourceTypes = sourceTypes;
        this.localUserMemoryContext = operatorContext.localUserMemoryContext();
        this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext();
        this.spillerFactory = spillerFactory;
        this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions);
        this.spillEnabled = spillEnabled;
    }
}",rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext,"public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }","public class DummyClass {
    public OrderByOperator(
            OperatorContext operatorContext,
            List<Type> sourceTypes,
            List<Integer> outputChannels,
            int expectedPositions,
            List<Integer> sortChannels,
            List<SortOrder> sortOrder,
            PagesIndex.Factory pagesIndexFactory,
            boolean spillEnabled,
            Optional<SpillerFactory> spillerFactory) {
        requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null"");
        this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null"");
        this.outputChannels =
                Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null""));
        this.sortChannels =
                ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null""));
        this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null""));
        this.sourceTypes = sourceTypes;
        this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext();
        this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext();
        this.spillerFactory = spillerFactory;
        this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions);
        this.spillEnabled = spillEnabled;
    }
}","['public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.pagesIndexRevocableMemoryContext(); this.pagesRevocableMemoryContext = operatorContext.pagesRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.rowCount = pagesIndexUserMemoryContext; this.revocableMemoryContext = operatorContext.revocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.pagesIndexUserMemoryContext(); this.pagesRevocableMemoryContext = operatorContext.pagesRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.rowCountIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.rowCountIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.pagesIndexUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.pagesIndexRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.rowCount = pagesIndexUserMemoryContext; this.rowCount = pagesIndexRevocableMemoryContext; this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.pagesIndexUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.pagesRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this. pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }', 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.operatorContext = requireNonNull(operatorContext, ""operatorContext is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, ""sortChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""sortOrder is null"")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.pagesIndexRevocableMemoryContext(); this.pagesRevocableMemoryContext = operatorContext.pagesRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled;']",True,1,0,46,46,4,1.0,0.999999995,False,False,False,,,,,,,,,,,,,,,,,,,"public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; <START>this.localUserMemoryContext = operatorContext.localUserMemoryContext();<END> this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }",rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext,"public OrderByOperator(OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext, ""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels, ""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels, ""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder, ""sortOrder is null""); } this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }",,,,,,,"public OrderByOperator(OperatorContext spillEnabled, List<Type> spillerFactory, List<Integer> outputChannels, int expectedPositions, List<Integer> sortOrder, List<SortOrder> operatorContext, PagesIndex.Factory pagesIndexFactory, boolean sortChannels, Optional<SpillerFactory> sourceTypes) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.spillEnabled = requireNonNull(spillEnabled, ""sortChannels is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""operatorContext is null"")); this.operatorContext = ImmutableList.copyOf(requireNonNull(operatorContext, ""operatorContext is null"")); this.spillerFactory = spillerFactory; <START> this.localUserMemoryContext = spillEnabled.localUserMemoryContext(); <END> this.localRevocableMemoryContext = spillEnabled.localRevocableMemoryContext(); this.sourceTypes = sourceTypes; this.pageIndex = pagesIndexFactory.newPagesIndex(spillerFactory, expectedPositions); this.sortChannels = sortChannels; }",rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext,"public OrderByOperator(OperatorContext spillEnabled, List<Type> spillerFactory, List<Integer> outputChannels, int expectedPositions, List<Integer> sortOrder, List<SortOrder> operatorContext, PagesIndex.Factory pagesIndexFactory, boolean sortChannels, Optional<SpillerFactory> sourceTypes) { requireNonNull(pagesIndexFactory, ""pagesIndexFactory is null""); this.spillEnabled = requireNonNull(spillEnabled, ""sortChannels is null""); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, ""outputChannels is null"")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, ""operatorContext is null"")); this.operatorContext = ImmutableList.copyOf(requireNonNull(operatorContext, ""operatorContext is null"")); this.spillerFactory = spillerFactory; this.pagesIndexUserMemoryContext = spillEnabled.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = spillEnabled.localRevocableMemoryContext(); this.sourceTypes = sourceTypes; this.pageIndex = pagesIndexFactory.newPagesIndex(spillerFactory, expectedPositions); this.sortChannels = sortChannels; }","public OrderByOperator(OperatorContext rqbsy, List<Type> lamma, List<Integer> paiiq, int hpndk, List<Integer> gghxo, List<SortOrder> udcxr, PagesIndex.Factory qwjdh, boolean fwnsi, Optional<SpillerFactory> foqkx) { requireNonNull(qwjdh, ""pagesIndexFactory is null""); this.rqbsy = requireNonNull(rqbsy, ""operatorContext is null""); this.paiiq = Ints.toArray(requireNonNull(paiiq, ""outputChannels is null"")); this.gghxo = ImmutableList.copyOf(requireNonNull(gghxo, ""sortChannels is null"")); this.udcxr = ImmutableList.copyOf(requireNonNull(udcxr, ""sortOrder is null"")); this.lamma = lamma; <START> this.localUserMemoryContext = rqbsy.localUserMemoryContext(); <END> this.localRevocableMemoryContext = rqbsy.localRevocableMemoryContext(); this.foqkx = foqkx; this.pageIndex = qwjdh.newPagesIndex(lamma, hpndk); this.fwnsi = fwnsi; }",rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext,"public OrderByOperator(OperatorContext rqbsy, List<Type> lamma, List<Integer> paiiq, int hpndk, List<Integer> gghxo, List<SortOrder> udcxr, PagesIndex.Factory qwjdh, boolean fwnsi, Optional<SpillerFactory> foqkx) { requireNonNull(qwjdh, ""pagesIndexFactory is null""); this.rqbsy = requireNonNull(rqbsy, ""operatorContext is null""); this.paiiq = Ints.toArray(requireNonNull(paiiq, ""outputChannels is null"")); this.gghxo = ImmutableList.copyOf(requireNonNull(gghxo, ""sortChannels is null"")); this.udcxr = ImmutableList.copyOf(requireNonNull(udcxr, ""sortOrder is null"")); this.lamma = lamma; this.pagesIndexUserMemoryContext = rqbsy.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = rqbsy.localRevocableMemoryContext(); this.foqkx = foqkx; this.pageIndex = qwjdh.newPagesIndex(lamma, hpndk); this.fwnsi = fwnsi; }",,,,,,,"1- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
2- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.localUserMemoryContext = operatorContext.localUserMemoryContext(); this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
3- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.rowCount = pagesIndexUserMemoryContext; this.revocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
4- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.localIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
5- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this. pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
6- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.rowCount = pagesIndexUserMemoryContext; this.rowCount = pagesIndexRevocableMemoryContext; this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
7- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this. pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this. pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
8- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.localPageMemoryContext = operatorContext.localPageMemoryContext(); this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
9- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.nodesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.nodesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }
10- public OrderByOperator(OperatorContext operatorContext,List<Type> sourceTypes,List<Integer> outputChannels,int expectedPositions,List<Integer> sortChannels,List<SortOrder> sortOrder,PagesIndex.Factory pagesIndexFactory,boolean spillEnabled,Optional<SpillerFactory> spillerFactory) { if (pagesIndexFactory == null) { requireNonNull(pagesIndexFactory,""pagesIndexFactory is null""); } if (operatorContext == null) { requireNonNull(operatorContext,""operatorContext is null""); } if (outputChannels == null) { requireNonNull(outputChannels,""outputChannels is null""); } if (sortChannels == null) { requireNonNull(sortChannels,""sortChannels is null""); } if (sortOrder == null) { requireNonNull(sortOrder,""sortOrder is null""); } this.sourceTypes = sourceTypes; this.localPageMemoryContext = operatorContext.localPageMemoryContext(); this.localRevocablePageContext = operatorContext.localRevocablePageContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes,expectedPositions); this.spillEnabled = spillEnabled; }",0
1883,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); logger.info(""executedLow: {}"", executedLow.getTime().getTime()); logger.info(""executedHigh: {}"", executedHigh.getTime().getTime()); <START> logger.info(""exec difference: {}"", (executedLow.getTime().getTime() - executedHigh.getTime().getTime())); <END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public class DummyClass {
    public void testPrioritizedJobsExecution() throws InterruptedException {
        CountDownAsyncJobListener countDownListener = configureListener(2);
        CommandContext ctxCMD = new CommandContext();
        ctxCMD.setData(""businessKey"", ""low priority"");
        ctxCMD.setData(""priority"", 2);
        Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD);
        CommandContext ctxCMD2 = new CommandContext();
        ctxCMD2.setData(""businessKey"", ""high priority"");
        ctxCMD2.setData(""priority"", 8);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2);
        countDownListener.waitTillCompleted();
        List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext());
        assertEquals(0, inErrorRequests.size());
        List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext());
        assertEquals(0, queuedRequests.size());
        List<RequestInfo> executedRequests =
                executorService.getCompletedRequests(new QueryContext());
        assertEquals(2, executedRequests.size());
        RequestInfo executedHigh = executedRequests.get(1);
        assertNotNull(executedHigh);
        assertEquals(""high priority"", executedHigh.getKey());
        RequestInfo executedLow = executedRequests.get(0);
        assertNotNull(executedLow);
        assertEquals(""low priority"", executedLow.getKey());
        logger.info(""executedLow: {}"", executedLow.getTime().getTime());
        logger.info(""executedHigh: {}"", executedHigh.getTime().getTime());
        logger.info(
                ""exec difference: {}"",
                (executedLow.getTime().getTime() - executedHigh.getTime().getTime()));
        assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime());
    }
}",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public class DummyClass {
    public void testPrioritizedJobsExecution() throws InterruptedException {
        CountDownAsyncJobListener countDownListener = configureListener(2);
        CommandContext ctxCMD = new CommandContext();
        ctxCMD.setData(""businessKey"", ""low priority"");
        ctxCMD.setData(""priority"", 2);
        Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD);
        CommandContext ctxCMD2 = new CommandContext();
        ctxCMD2.setData(""businessKey"", ""high priority"");
        ctxCMD2.setData(""priority"", 8);
        executorService.scheduleRequest(
                ""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2);
        countDownListener.waitTillCompleted();
        List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext());
        assertEquals(0, inErrorRequests.size());
        List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext());
        assertEquals(0, queuedRequests.size());
        List<RequestInfo> executedRequests =
                executorService.getCompletedRequests(new QueryContext());
        assertEquals(2, executedRequests.size());
        RequestInfo executedHigh = executedRequests.get(1);
        assertNotNull(executedHigh);
        assertEquals(""high priority"", executedHigh.getKey());
        RequestInfo executedLow = executedRequests.get(0);
        assertNotNull(executedLow);
        assertEquals(""low priority"", executedLow.getKey());
        assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime());
    }
}","['public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(executedHigh.getTime(), executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime().getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime(), executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(""executedLow: {}"", executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertEquals(executedLow.getTime(), executedLow.getTime()); assertEquals(""executedHigh: {}"", executedHigh.getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertFalse(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }', 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); logger.info(""executedLow: {}"", executedLow.getTime()); logger.info(""executedHigh: {}"", executedHigh.getTime().getTime()); }']",True,0,0,223,264,9,1.0,0.999999995,False,False,False,,,,,,,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) var = true; CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { boolean var = false; if (var) var = true; CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { try { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } catch (Exception e) { throw e; } }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { try { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } catch (Exception e) { throw e; } }",,,,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); if (0 != inErrorRequests.size()) { assertEquals(0,inErrorRequests.size()); } List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); if (0 != queuedRequests.size()) { assertEquals(0,queuedRequests.size()); } List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); if (2 != executedRequests.size()) { assertEquals(2,executedRequests.size()); } RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); if (""high priority"" != executedHigh.getKey()) { assertEquals(""high priority"",executedHigh.getKey()); } RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); if (""low priority"" != executedLow.getKey()) { assertEquals(""low priority"",executedLow.getKey()); } logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); if (0 != inErrorRequests.size()) { assertEquals(0, inErrorRequests.size()); } List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); if (0 != queuedRequests.size()) { assertEquals(0, queuedRequests.size()); } List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); if (2 != executedRequests.size()) { assertEquals(2, executedRequests.size()); } RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); if (""high priority"" != executedHigh.getKey()) { assertEquals(""high priority"", executedHigh.getKey()); } RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); if (""low priority"" != executedLow.getKey()) { assertEquals(""low priority"", executedLow.getKey()); } assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); if (executedLow.getTime().getTime() < executedHigh.getTime().getTime()) { assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); } }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener inErrorRequests = configureListener(2); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""low priority""); ctxCMD2.setData(""priority"", 2); Date queuedRequests = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""high priority""); ctxCMD.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD); inErrorRequests.waitTillCompleted(); List<RequestInfo> executedLow = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, executedLow.size()); List<RequestInfo> countDownListener = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, countDownListener.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo futureDate = executedRequests.get(1); assertNotNull(futureDate); assertEquals(""high priority"", futureDate.getKey()); RequestInfo executedHigh = executedRequests.get(0); assertNotNull(executedHigh); assertEquals(""low priority"", executedHigh.getKey()); logger.info(""futureDate: {}"", executedHigh.getTime().getTime()); logger.info(""futureDate: <START> {}"", futureDate.getTime().getTime()); logger.info(""exec difference: {}"", <END> (executedHigh.getTime().getTime() - futureDate.getTime().getTime())); assertTrue(executedHigh.getTime().getTime() >= futureDate.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener inErrorRequests = configureListener(2); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""low priority""); ctxCMD2.setData(""priority"", 2); Date queuedRequests = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""high priority""); ctxCMD.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", queuedRequests, ctxCMD); inErrorRequests.waitTillCompleted(); List<RequestInfo> executedLow = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, executedLow.size()); List<RequestInfo> countDownListener = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, countDownListener.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo futureDate = executedRequests.get(1); assertNotNull(futureDate); assertEquals(""high priority"", futureDate.getKey()); RequestInfo executedHigh = executedRequests.get(0); assertNotNull(executedHigh); assertEquals(""low priority"", executedHigh.getKey()); assertTrue(executedHigh.getTime().getTime() >= futureDate.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener kwkum = configureListener(2); CommandContext bdewn = new CommandContext(); bdewn.setData(""businessKey"", ""low priority""); bdewn.setData(""priority"", 2); Date lrnaq = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, bdewn); CommandContext wqcdw = new CommandContext(); wqcdw.setData(""businessKey"", ""high priority""); wqcdw.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, wqcdw); kwkum.waitTillCompleted(); List<RequestInfo> brkny = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, brkny.size()); List<RequestInfo> hgfbz = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, hgfbz.size()); List<RequestInfo> sjdog = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, sjdog.size()); RequestInfo bqnma = sjdog.get(1); assertNotNull(bqnma); assertEquals(""high priority"", bqnma.getKey()); RequestInfo gkzrr = sjdog.get(0); assertNotNull(gkzrr); assertEquals(""low priority"", gkzrr.getKey()); logger.info(""executedLow: {}"", gkzrr.getTime().getTime()); logger.info(""executedHigh: <START> {}"", bqnma.getTime().getTime()); logger.info(""exec difference: {}"", <END> (gkzrr.getTime().getTime() - bqnma.getTime().getTime())); assertTrue(gkzrr.getTime().getTime() >= bqnma.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener kwkum = configureListener(2); CommandContext bdewn = new CommandContext(); bdewn.setData(""businessKey"", ""low priority""); bdewn.setData(""priority"", 2); Date lrnaq = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, bdewn); CommandContext wqcdw = new CommandContext(); wqcdw.setData(""businessKey"", ""high priority""); wqcdw.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", lrnaq, wqcdw); kwkum.waitTillCompleted(); List<RequestInfo> brkny = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, brkny.size()); List<RequestInfo> hgfbz = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, hgfbz.size()); List<RequestInfo> sjdog = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, sjdog.size()); RequestInfo bqnma = sjdog.get(1); assertNotNull(bqnma); assertEquals(""high priority"", bqnma.getKey()); RequestInfo gkzrr = sjdog.get(0); assertNotNull(gkzrr); assertEquals(""low priority"", gkzrr.getKey()); assertTrue(gkzrr.getTime().getTime() >= bqnma.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CommandContext ctxCMD = new CommandContext(); CountDownAsyncJobListener countDownListener = configureListener(2); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CommandContext ctxCMD = new CommandContext(); CountDownAsyncJobListener countDownListener = configureListener(2); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CountDownAsyncJobListener nhtae = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); nhtae.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); <START>logger.info(""exec difference: {}"",(executedLow.getTime().getTime() - executedHigh.getTime().getTime()));<END> assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }",please delete this logging? need this anymore verified theory issue,"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CountDownAsyncJobListener nhtae = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"", ""low priority""); ctxCMD.setData(""priority"", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"", ""high priority""); ctxCMD2.setData(""priority"", 8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"", futureDate, ctxCMD2); nhtae.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(""high priority"", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(""low priority"", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }","1- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }
2- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); }
3- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertTrue(""executedLow: {}"",executedLow.getTime().getTime()); assertTrue(""executedHigh: {}"",executedHigh.getTime().getTime()); }
4- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }
5- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertEquals(""executedLow: {}"",executedLow.getTime()); assertEquals(""executedHigh: {}"",executedHigh.getTime()); }
6- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); logger.info(""executedLow: {}"",executedLow.getTime().getTime()); logger.info(""executedHigh: {}"",executedHigh.getTime().getTime()); }
7- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertEquals(executedLow.getTime().getTime(), executedHigh.getTime().getTime()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }
8- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertNull(executedLow.getTime()); assertNull(executedHigh.getTime()); }
9- public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(""businessKey"",""low priority""); ctxCMD.setData(""priority"",2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(""businessKey"",""high priority""); ctxCMD2.setData(""priority"",8); executorService.scheduleRequest(""org.jbpm.executor.commands.PrintOutCommand"",futureDate,ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0,inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0,queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2,executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); if (executedHigh == null) { assertNotNull(executedHigh); } assertEquals(""high priority"",executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); if (executedLow == null) { assertNotNull(executedLow); } assertEquals(""low priority"",executedLow.getKey()); assertNotNull(executedLow.getTime()); assertEquals(""executedHigh: {}"",executedHigh.getTime()); }
10- public void testPrioritizedJobsExecution() throws InterruptedException",0
1893,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); <START> assertNotNull(keySet); <END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public class DummyClass {
    public void testWithArrays() {
        final byte[] authenthicationKey = {1};
        final byte[] encryptionKey = {1};
        final KeySet keySet = new KeySet(authenthicationKey, encryptionKey);
        final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class);
        assertNotNull(keySet);
        assertNotNull(keySetDto);
        assertNotNull(keySetDto.getAuthenticationKey());
        assertNotNull(keySetDto.getEncryptionKey());
        assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length);
        assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length);
        assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]);
        assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]);
    }
}",delete this line,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public class DummyClass {
    public void testWithArrays() {
        final byte[] authenthicationKey = {1};
        final byte[] encryptionKey = {1};
        final KeySet keySet = new KeySet(authenthicationKey, encryptionKey);
        final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class);
        assertNotNull(keySetDto);
        assertNotNull(keySetDto.getAuthenticationKey());
        assertNotNull(keySetDto.getEncryptionKey());
        assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length);
        assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length);
        assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]);
        assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]);
    }
}","['public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals (keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey(), keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey(). length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals (keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey(), keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto1.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey(). length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }', 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }']",True,0,0,49,49,1,1.0,0.999999995,False,False,False,,,,,,,"public void testWithArrays() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public void testWithArrays() { boolean var = false; if (var) var = true; final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { boolean var = false; if (var) var = true; final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public void testWithArrays() { try { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); } catch (Exception e) { throw e; } }",delete this line,"public void testWithArrays() { try { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); } catch (Exception e) { throw e; } }",,,,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); if (keySet == null) { <START>assertNotNull(keySet);<END> } if (keySetDto == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); if (keySetDto == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); if (keySet.getAuthenticationKey().length != keySetDto.getAuthenticationKey().length) { assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); } if (keySet.getEncryptionKey().length != keySetDto.getEncryptionKey().length) { assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); } if (keySet.getAuthenticationKey()[0] != keySetDto.getAuthenticationKey()[0]) { assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); } if (keySet.getEncryptionKey()[0] != keySetDto.getEncryptionKey()[0]) { assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); } }",delete this line,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); if (keySet.getAuthenticationKey().length != keySetDto.getAuthenticationKey().length) { assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); } if (keySet.getEncryptionKey().length != keySetDto.getEncryptionKey().length) { assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); } if (keySet.getAuthenticationKey()[0] != keySetDto.getAuthenticationKey()[0]) { assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); } if (keySet.getEncryptionKey()[0] != keySetDto.getEncryptionKey()[0]) { assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); } }",,,,"public void testWithArrays() { final byte[] keySet = { 1 }; final byte[] keySetDto = { 1 }; final KeySet authenthicationKey = new KeySet(keySet, keySetDto); final KeySetDto encryptionKey = this.configurationMapper.map(authenthicationKey, KeySetDto.class); assertNotNull(authenthicationKey); assertNotNull(encryptionKey); assertNotNull(encryptionKey.getAuthenticationKey()); assertNotNull(encryptionKey.getEncryptionKey()); <START> assertEquals(authenthicationKey.getAuthenticationKey().length, <END> encryptionKey.getAuthenticationKey().length); assertEquals(authenthicationKey.getEncryptionKey().length, encryptionKey.getEncryptionKey().length); assertEquals(authenthicationKey.getAuthenticationKey()[0], encryptionKey.getAuthenticationKey()[0]); assertEquals(authenthicationKey.getEncryptionKey()[0], encryptionKey.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { final byte[] keySet = { 1 }; final byte[] keySetDto = { 1 }; final KeySet authenthicationKey = new KeySet(keySet, keySetDto); final KeySetDto encryptionKey = this.configurationMapper.map(authenthicationKey, KeySetDto.class); assertNotNull(encryptionKey); assertNotNull(encryptionKey.getAuthenticationKey()); assertNotNull(encryptionKey.getEncryptionKey()); assertEquals(authenthicationKey.getAuthenticationKey().length, encryptionKey.getAuthenticationKey().length); assertEquals(authenthicationKey.getEncryptionKey().length, encryptionKey.getEncryptionKey().length); assertEquals(authenthicationKey.getAuthenticationKey()[0], encryptionKey.getAuthenticationKey()[0]); assertEquals(authenthicationKey.getEncryptionKey()[0], encryptionKey.getEncryptionKey()[0]); }","public void testWithArrays() { final byte[] sussu = { 1 }; final byte[] vprgf = { 1 }; final KeySet twuki = new KeySet(sussu, vprgf); final KeySetDto vstie = this.configurationMapper.map(twuki, KeySetDto.class); assertNotNull(twuki); assertNotNull(vstie); assertNotNull(vstie.getAuthenticationKey()); assertNotNull(vstie.getEncryptionKey()); <START> assertEquals(twuki.getAuthenticationKey().length, <END> vstie.getAuthenticationKey().length); assertEquals(twuki.getEncryptionKey().length, vstie.getEncryptionKey().length); assertEquals(twuki.getAuthenticationKey()[0], vstie.getAuthenticationKey()[0]); assertEquals(twuki.getEncryptionKey()[0], vstie.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { final byte[] sussu = { 1 }; final byte[] vprgf = { 1 }; final KeySet twuki = new KeySet(sussu, vprgf); final KeySetDto vstie = this.configurationMapper.map(twuki, KeySetDto.class); assertNotNull(vstie); assertNotNull(vstie.getAuthenticationKey()); assertNotNull(vstie.getEncryptionKey()); assertEquals(twuki.getAuthenticationKey().length, vstie.getAuthenticationKey().length); assertEquals(twuki.getEncryptionKey().length, vstie.getEncryptionKey().length); assertEquals(twuki.getAuthenticationKey()[0], vstie.getAuthenticationKey()[0]); assertEquals(twuki.getEncryptionKey()[0], vstie.getEncryptionKey()[0]); }","public void testWithArrays() { final byte[] encryptionKey = { 1 }; final byte[] authenthicationKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { final byte[] encryptionKey = { 1 }; final byte[] authenthicationKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","public void testWithArrays() { final byte[] authenthicationKey = { 1 }; byte[] dqvkf = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(dqvkf,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); <START>assertNotNull(keySet);<END> assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }",delete this line,"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; byte[] dqvkf = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(dqvkf, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }","1- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
2- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); if (keySet == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
3- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySetDto); if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
4- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keysDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
5- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySet); assertNotNull(keySetDto); if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
6- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); if (keySet == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keysDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
7- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
8- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); assertNotNull(keySetDto); if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keysDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0],keySetDto.getEncryptionKey()[0]); }
9- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); if (keySet == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0],keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keysDto.getEncryptionKey()[0]); }
10- public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey,encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet,KeySetDto.class); if (keySet == null) { assertNotNull(keySetDto); } if (keySetDto.getAuthenticationKey() == null) { assertNotNull(keySetDto.getAuthenticationKey()); } if (keySetDto.getEncryptionKey() == null) { assertNotNull(keySetDto.getEncryptionKey()); } assertEquals(keySet.getAuthenticationKey().length,keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length,keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keysDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keysDto.getEncryptionKey()[0]); }",0
1942,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START> assertNotNull(fs.getDeletedAtTimestamp()); <END> assertAllInformationMatch(fs, session1InCourse1); }","public class DummyClass {
    protected void
            testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() {
        InstructorAttributes instructor2OfCourse1 =
                typicalBundle.instructors.get(""instructor2OfCourse1"");
        FeedbackSessionAttributes session1InCourse1 =
                typicalBundle.feedbackSessions.get(""session1InCourse1"");
        loginAsInstructor(instructor2OfCourse1.googleId);
        String[] submissionParam = {
            Const.ParamsNames.IS_IN_RECYCLE_BIN,
            ""true"",
            Const.ParamsNames.ENTITY_TYPE,
            Const.EntityType.INSTRUCTOR,
        };
        GetFeedbackSessionsAction action = getAction(submissionParam);
        FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput();
        assertEquals(1, fsData.getFeedbackSessions().size());
        FeedbackSessionData fs = fsData.getFeedbackSessions().get(0);
        assertNotNull(fs.getDeletedAtTimestamp());
        assertAllInformationMatch(fs, session1InCourse1);
    }
}",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }","public class DummyClass {
    protected void
            testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() {
        InstructorAttributes instructor2OfCourse1 =
                typicalBundle.instructors.get(""instructor2OfCourse1"");
        FeedbackSessionAttributes session1InCourse1 =
                typicalBundle.feedbackSessions.get(""session1InCourse1"");
        loginAsInstructor(instructor2OfCourse1.googleId);
        String[] submissionParam = {
            Const.ParamsNames.IS_IN_RECYCLE_BIN,
            ""true"",
            Const.ParamsNames.ENTITY_TYPE,
            Const.EntityType.INSTRUCTOR,
        };
        GetFeedbackSessionsAction action = getAction(submissionParam);
        FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput();
        assertEquals(1, fsData.getFeedbackSessions().size());
        FeedbackSessionData fs = fsData.getFeedbackSessions().get(0);
        assertAllInformationMatch(fs, session1InCourse1);
    }
}","['protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { FeedbackSessionAttributes session1InCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() {InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatches(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { ImmutableBundle originalInstructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); LoginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_ shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }', 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult (action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }']",True,0,0,69,69,1,1.0,0.999999995,False,False,False,,,,,,,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START>assertNotNull(fs.getDeletedAtTimestamp());<END> assertAllInformationMatch(fs,session1InCourse1); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }","protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { boolean var = false; if (var) var = true; InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START>assertNotNull(fs.getDeletedAtTimestamp());<END> assertAllInformationMatch(fs,session1InCourse1); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { boolean var = false; if (var) var = true; InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }","protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { try { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START>assertNotNull(fs.getDeletedAtTimestamp());<END> assertAllInformationMatch(fs,session1InCourse1); } catch (Exception e) { throw e; } }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { try { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); } catch (Exception e) { throw e; } }",,,,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); if (fs.getDeletedAtTimestamp() == null) { <START>assertNotNull(fs.getDeletedAtTimestamp());<END> } assertAllInformationMatch(fs,session1InCourse1); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }","protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); if (1 != fsData.getFeedbackSessions().size()) { assertEquals(1,fsData.getFeedbackSessions().size()); } FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START>assertNotNull(fs.getDeletedAtTimestamp());<END> assertAllInformationMatch(fs,session1InCourse1); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); if (1 != fsData.getFeedbackSessions().size()) { assertEquals(1, fsData.getFeedbackSessions().size()); } FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }",,,,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes fsData = typicalBundle.instructors.get(""fsData""); FeedbackSessionAttributes submissionParam = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(fsData.googleId); String[] session1InCourse1 = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction instructor2OfCourse1 = getAction(session1InCourse1); FeedbackSessionsData fs = (FeedbackSessionsData) getJsonResult(instructor2OfCourse1).getOutput(); assertEquals(1, fs.getFeedbackSessions().size()); FeedbackSessionData action = fs.getFeedbackSessions().get(0); <START> assertNotNull(action.getDeletedAtTimestamp()); <END> assertAllInformationMatch(action, submissionParam); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes fsData = typicalBundle.instructors.get(""fsData""); FeedbackSessionAttributes submissionParam = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(fsData.googleId); String[] session1InCourse1 = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction instructor2OfCourse1 = getAction(session1InCourse1); FeedbackSessionsData fs = (FeedbackSessionsData) getJsonResult(instructor2OfCourse1).getOutput(); assertEquals(1, fs.getFeedbackSessions().size()); FeedbackSessionData action = fs.getFeedbackSessions().get(0); assertAllInformationMatch(action, submissionParam); }","protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes boyjr = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes jsyux = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(boyjr.googleId); String[] rpoit = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction fjdqf = getAction(rpoit); FeedbackSessionsData gexhz = (FeedbackSessionsData) getJsonResult(fjdqf).getOutput(); assertEquals(1, gexhz.getFeedbackSessions().size()); FeedbackSessionData kfhha = gexhz.getFeedbackSessions().get(0); <START> assertNotNull(kfhha.getDeletedAtTimestamp()); <END> assertAllInformationMatch(kfhha, jsyux); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes boyjr = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes jsyux = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(boyjr.googleId); String[] rpoit = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction fjdqf = getAction(rpoit); FeedbackSessionsData gexhz = (FeedbackSessionsData) getJsonResult(fjdqf).getOutput(); assertEquals(1, gexhz.getFeedbackSessions().size()); FeedbackSessionData kfhha = gexhz.getFeedbackSessions().get(0); assertAllInformationMatch(kfhha, jsyux); }",,,,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); InstructorAttributes znezw = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(znezw.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START>assertNotNull(fs.getDeletedAtTimestamp());<END> assertAllInformationMatch(fs,session1InCourse1); }",This assertion is necessary is tested in assertAllInformationMatch,"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); InstructorAttributes znezw = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(znezw.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, ""true"", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }","1- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs,session1InCourse1); }
2- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs,session1InCourse1); }
3- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs, session1InCourse1); }
4- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }
5- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs,session1InCourse1); }
6- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs); assertAllInformationMatch(fs,session1InCourse1); }
7- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs,session1InCourse1); }
8- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"", Const.ParamsNames.ENTITY_TYPE,Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs,session1InCourse1); }
9- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs,session1InCourse1); }
10- protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(""instructor2OfCourse1""); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(""session1InCourse1""); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN,""true"",Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1,fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertNotNull(fs.getDeletedAtTimestamp()); assertAllInformationMatch(fs, session1InCourse1); }",0
1955,"void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); <START> if (errors.addThrowable(ex)) { <END> subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","public class DummyClass {
    void open(Open token) {
        Publisher<? extends Close> p;
        C buf;
        try {
            buf =
                    ObjectHelper.requireNonNull(
                            bufferSupplier.call(), ""The bufferSupplier returned a null Collection"");
            p =
                    ObjectHelper.requireNonNull(
                            bufferClose.apply(token), ""The bufferClose returned a null Publisher"");
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            SubscriptionHelper.cancel(upstream);
            if (errors.addThrowable(ex)) {
                subscribers.dispose();
                synchronized (this) {
                    buffers = null;
                }
                done = true;
                drain();
            } else {
                RxJavaPlugins.onError(ex);
            }
            return;
        }
        long idx = index;
        index = idx + 1;
        synchronized (this) {
            Map<Long, C> bufs = buffers;
            if (bufs == null) {
                return;
            }
            bufs.put(idx, buf);
        }
        BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx);
        subscribers.add(bc);
        p.subscribe(bc);
    }
}","if/else block exact onError(), call here","void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","public class DummyClass {
    void open(Open token) {
        Publisher<? extends Close> p;
        C buf;
        try {
            buf =
                    ObjectHelper.requireNonNull(
                            bufferSupplier.call(), ""The bufferSupplier returned a null Collection"");
            p =
                    ObjectHelper.requireNonNull(
                            bufferClose.apply(token), ""The bufferClose returned a null Publisher"");
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            SubscriptionHelper.cancel(upstream);
            onError(ex);
            return;
        }
        long idx = index;
        index = idx + 1;
        synchronized (this) {
            Map<Long, C> bufs = buffers;
            if (bufs == null) {
                return;
            }
            bufs.put(idx, buf);
        }
        BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx);
        subscribers.add(bc);
        p.subscribe(bc);
    }
}","['void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); p.subscribe(bc); long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream);  onError(ex); long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); return; }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); p.subscribe(bc); long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.unsubscribe(bc); }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc);', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); return; }', 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc()); }']",True,1,0,167,167,10,1.0,0.999999995,False,False,False,,,,"void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (!(<END> errors.addThrowable(ex))) { RxJavaPlugins.onError(ex); } else { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","if/else block exact onError(), call here","void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (!(bufs == null)) { } else { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","void open(Open token) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","if/else block exact onError(), call here","void open(Open token) { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","void open(Open token) { boolean var = false; if (var) var = true; Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","if/else block exact onError(), call here","void open(Open token) { boolean var = false; if (var) var = true; Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }",,,,,,,"void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","if/else block exact onError(), call here","void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }",,,,,,,"void open(Open bc) { Publisher<? extends Close> bufs; C token; try { token = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); bufs = ObjectHelper.requireNonNull(bufferClose.apply(bc), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long p = index; index = p + 1; synchronized (this) { Map<Long, C> buf = buffers; if (buf == null) { return; } buf.put(p, token); } BufferCloseSubscriber<T, C> idx = new BufferCloseSubscriber<T, C>(this, p); subscribers.add(idx); bufs.subscribe(idx); }","if/else block exact onError(), call here","void open(Open bc) { Publisher<? extends Close> bufs; C token; try { token = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); bufs = ObjectHelper.requireNonNull(bufferClose.apply(bc), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long p = index; index = p + 1; synchronized (this) { Map<Long, C> buf = buffers; if (buf == null) { return; } buf.put(p, token); } BufferCloseSubscriber<T, C> idx = new BufferCloseSubscriber<T, C>(this, p); subscribers.add(idx); bufs.subscribe(idx); }","void open(Open hyhhy) { Publisher<? extends Close> njvpj; C yqslv; try { yqslv = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); njvpj = ObjectHelper.requireNonNull(bufferClose.apply(hyhhy), ""The bufferClose returned a null Publisher""); } catch (Throwable phjcq) { <START> Exceptions.throwIfFatal(phjcq); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(phjcq)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(phjcq); } return; } long nwrpe = index; index = nwrpe + 1; synchronized (this) { Map<Long, C> pqltb = buffers; if (pqltb == null) { return; } pqltb.put(nwrpe, yqslv); } BufferCloseSubscriber<T, C> fpylw = new BufferCloseSubscriber<T, C>(this, nwrpe); subscribers.add(fpylw); njvpj.subscribe(fpylw); }","if/else block exact onError(), call here","void open(Open hyhhy) { Publisher<? extends Close> njvpj; C yqslv; try { yqslv = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); njvpj = ObjectHelper.requireNonNull(bufferClose.apply(hyhhy), ""The bufferClose returned a null Publisher""); } catch (Throwable phjcq) { Exceptions.throwIfFatal(phjcq); SubscriptionHelper.cancel(upstream); onError(phjcq); return; } long nwrpe = index; index = nwrpe + 1; synchronized (this) { Map<Long, C> pqltb = buffers; if (pqltb == null) { return; } pqltb.put(nwrpe, yqslv); } BufferCloseSubscriber<T, C> fpylw = new BufferCloseSubscriber<T, C>(this, nwrpe); subscribers.add(fpylw); njvpj.subscribe(fpylw); }","void open(Open token) { C buf; Publisher<? extends Close> p; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { <START> Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (<END> errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }","if/else block exact onError(), call here","void open(Open token) { C buf; Publisher<? extends Close> p; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); p = ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }",,,,"1- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
2- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if ( errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
3- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (ex instanceof RuntimeException) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
4- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (Errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
5- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (e instanceof Error) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
6- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (warnings.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
7- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (error.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }
8- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc()); }
9- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); {
10- void open(Open token) { Publisher<? extends Close> p; C buf; try { if (bufferSupplier.call() == null) { ObjectHelper.requireNonNull(bufferSupplier.call(), ""The bufferSupplier returned a null Collection""); } if (bufferClose.apply(token) == null) { ObjectHelper.requireNonNull(bufferClose.apply(token), ""The bufferClose returned a null Publisher""); } } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); if (errors.addThrowable(ex)) { subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); } {",0
1962,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START> System.out.println(errMsg); <END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public class DummyClass {
    public void location_lock_dir_error_03() throws IOException {
        Assume.assumeTrue(negativePidsTreatedAsAlive);
        Location dir = Location.create(tempDir.getRoot().getAbsolutePath());
        LocationLock lock = dir.getLock();
        Assert.assertTrue(lock.canLock());
        Assert.assertFalse(lock.isLocked());
        Assert.assertFalse(lock.isOwned());
        Assert.assertTrue(lock.canObtain());
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) {
            writer.write(Integer.toString(-1234));
            writer.write('\n');
        }
        try {
            lock.canObtain();
            Assert.fail(""Expected the lock file to be considered invalid"");
        } catch (FileException e) {
            String errMsg = e.getMessage();
            Assert.assertNotNull(errMsg);
            System.out.println(errMsg);
            Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database""));
        }
    }
}",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public class DummyClass {
    public void location_lock_dir_error_03() throws IOException {
        Assume.assumeTrue(negativePidsTreatedAsAlive);
        Location dir = Location.create(tempDir.getRoot().getAbsolutePath());
        LocationLock lock = dir.getLock();
        Assert.assertTrue(lock.canLock());
        Assert.assertFalse(lock.isLocked());
        Assert.assertFalse(lock.isOwned());
        Assert.assertTrue(lock.canObtain());
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) {
            writer.write(Integer.toString(-1234));
            writer.write('\n');
        }
        try {
            lock.canObtain();
            Assert.fail(""Expected the lock file to be considered invalid"");
        } catch (FileException e) {
            String errMsg = e.getMessage();
            Assert.assertNotNull(errMsg);
            Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database""));
        }
    }
}","['public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert. assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain(); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234())); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert. assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert. assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""Tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString( -1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatEDAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }', 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write(\'\\n\'); } }']",True,0,0,54,54,1,1.0,0.999999995,False,False,False,,,,,,,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) var = true; Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { boolean var = false; if (var) var = true; Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",,,,,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); if (!lock.canLock()) { Assert.assertTrue(lock.canLock()); } if (lock.isLocked()) { Assert.assertFalse(lock.isLocked()); } if (lock.isOwned()) { Assert.assertFalse(lock.isOwned()); } if (!lock.canObtain()) { Assert.assertTrue(lock.canObtain()); } try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); if (!errMsg.contains(""appear to be for a TDB2 database"")) { Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }","public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location writer = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock errMsg = writer.getLock(); Assert.assertTrue(errMsg.canLock()); Assert.assertFalse(errMsg.isLocked()); Assert.assertFalse(errMsg.isOwned()); Assert.assertTrue(errMsg.canObtain()); try (BufferedWriter lock = new BufferedWriter(new FileWriter(writer.getPath(""tdb.errMsg"")))) { lock.write(Integer.toString(-1234)); lock.write('\n'); } try { errMsg.canObtain(); Assert.fail(""Expected the errMsg file to be considered invalid""); } catch (FileException e) { String dir = e.getMessage(); Assert.assertNotNull(dir); <START> System.out.println(dir); <END> Assert.assertTrue(dir.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location writer = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock errMsg = writer.getLock(); Assert.assertTrue(errMsg.canLock()); Assert.assertFalse(errMsg.isLocked()); Assert.assertFalse(errMsg.isOwned()); Assert.assertTrue(errMsg.canObtain()); try (BufferedWriter lock = new BufferedWriter(new FileWriter(writer.getPath(""tdb.errMsg"")))) { lock.write(Integer.toString(-1234)); lock.write('\n'); } try { errMsg.canObtain(); Assert.fail(""Expected the errMsg file to be considered invalid""); } catch (FileException e) { String dir = e.getMessage(); Assert.assertNotNull(dir); Assert.assertTrue(dir.contains(""appear to be for a TDB2 database"")); } }","public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location hvuip = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock noixx = hvuip.getLock(); Assert.assertTrue(noixx.canLock()); Assert.assertFalse(noixx.isLocked()); Assert.assertFalse(noixx.isOwned()); Assert.assertTrue(noixx.canObtain()); try (BufferedWriter joabr = new BufferedWriter(new FileWriter(hvuip.getPath(""tdb.lock"")))) { joabr.write(Integer.toString(-1234)); joabr.write('\n'); } try { noixx.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException rpvnc) { String mnien = rpvnc.getMessage(); Assert.assertNotNull(mnien); <START> System.out.println(mnien); <END> Assert.assertTrue(mnien.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location hvuip = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock noixx = hvuip.getLock(); Assert.assertTrue(noixx.canLock()); Assert.assertFalse(noixx.isLocked()); Assert.assertFalse(noixx.isOwned()); Assert.assertTrue(noixx.canObtain()); try (BufferedWriter joabr = new BufferedWriter(new FileWriter(hvuip.getPath(""tdb.lock"")))) { joabr.write(Integer.toString(-1234)); joabr.write('\n'); } try { noixx.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException rpvnc) { String mnien = rpvnc.getMessage(); Assert.assertNotNull(mnien); Assert.assertTrue(mnien.contains(""appear to be for a TDB2 database"")); } }",,,,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); Location hbfmf = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = hbfmf.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(hbfmf.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START>System.out.println(errMsg);<END> Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }",Is this System.out.println leftover debugging,"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); Location hbfmf = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = hbfmf.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(hbfmf.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }","1- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
2- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } } }
3- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert. assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
4- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert. assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
5- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert. assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
6- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }
7- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a Tdb2 database"")); } }
8- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } {
9- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } } }
10- public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(""tdb.lock"")))) { writer.write(Integer.toString(-1234)); writer.write('\n'); } try { lock.canObtain(); Assert.fail(""Expected the lock file to be considered invalid""); } catch (FileException e) { String errMsg = e.getMessage(); if (errMsg == null) { Assert.assertNotNull(errMsg); } Assert.assertTrue(errMsg.contains(""appear to be for a TDB2 database"")); } }.",1
1973,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public class DummyClass {
    public void testDeleteActionForTeamAsFeedbackParticipant() {
        prepareTestData();
        ______TS(""Typical successful case when feedback participant is a team"");
        FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb();
        int questionNumber = 4;
        FeedbackQuestionAttributes feedbackQuestion =
                feedbackQuestionsDb.getFeedbackQuestion(
                        ""First Session"", ""idOfCourse1"", questionNumber);
        String giverEmail = ""Team 1.1</td></div>'\"""";
        String receiverEmail = ""Team 2.1</td></div>'\"""";
        FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb();
        FeedbackResponseAttributes feedbackResponse =
                feedbackResponsesDb.getFeedbackResponse(
                        feedbackQuestion.getId(), giverEmail, receiverEmail);
        FeedbackResponseCommentAttributes feedbackResponseComment =
                dataBundle.feedbackResponseComments.get(""comment1FromTeam1"");
        FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb();
        feedbackResponseComment =
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponse.getId(),
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt);
        assertNotNull(""response comment not found"", feedbackResponseComment);
        StudentAttributes student = dataBundle.students.get(""student1InCourse1"");
        gaeSimulation.loginAsStudent(student.googleId);
        String[] submissionParams =
                new String[] {
                    Const.ParamsNames.COURSE_ID,
                    feedbackResponseComment.courseId,
                    Const.ParamsNames.FEEDBACK_SESSION_NAME,
                    feedbackResponseComment.feedbackSessionName,
                    Const.ParamsNames.FEEDBACK_RESPONSE_ID,
                    feedbackResponseComment.feedbackResponseId,
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,
                    feedbackResponseComment.getId().toString(),
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,
                    feedbackResponseComment.commentText + "" (Edited)"",
                };
        AjaxResult result = getAjaxResult(getAction(submissionParams));
        FeedbackResponseCommentAjaxPageData data =
                (FeedbackResponseCommentAjaxPageData) result.data;
        assertFalse(data.isError);
        assertNull(
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponseComment.feedbackResponseId,
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt));
        assertEquals("""", result.getStatusMessage());
    }
}",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public class DummyClass {
    public void testDeleteActionForTeamAsFeedbackParticipant() {
        FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb();
        int questionNumber = 4;
        FeedbackQuestionAttributes feedbackQuestion =
                feedbackQuestionsDb.getFeedbackQuestion(
                        ""First Session"", ""idOfCourse1"", questionNumber);
        String giverEmail = ""Team 1.1</td></div>'\"""";
        String receiverEmail = ""Team 2.1</td></div>'\"""";
        FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb();
        FeedbackResponseAttributes feedbackResponse =
                feedbackResponsesDb.getFeedbackResponse(
                        feedbackQuestion.getId(), giverEmail, receiverEmail);
        FeedbackResponseCommentAttributes feedbackResponseComment =
                dataBundle.feedbackResponseComments.get(""comment1FromTeam1"");
        FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb();
        feedbackResponseComment =
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponse.getId(),
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt);
        assertNotNull(""response comment not found"", feedbackResponseComment);
        StudentAttributes student = dataBundle.students.get(""student1InCourse1"");
        gaeSimulation.loginAsStudent(student.googleId);
        String[] submissionParams =
                new String[] {
                    Const.ParamsNames.COURSE_ID,
                    feedbackResponseComment.courseId,
                    Const.ParamsNames.FEEDBACK_SESSION_NAME,
                    feedbackResponseComment.feedbackSessionName,
                    Const.ParamsNames.FEEDBACK_RESPONSE_ID,
                    feedbackResponseComment.feedbackResponseId,
                    Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,
                    feedbackResponseComment.getId().toString(),
                };
        AjaxResult result = getAjaxResult(getAction(submissionParams));
        FeedbackResponseCommentAjaxPageData data =
                (FeedbackResponseCommentAjaxPageData) result.data;
        assertFalse(data.isError);
        assertNull(
                feedbackResponseCommentsDb.getFeedbackResponseComment(
                        feedbackResponseComment.feedbackResponseId,
                        feedbackResponseComment.commentGiver,
                        feedbackResponseComment.createdAt));
        assertEquals("""", result.getStatusMessage());
    }
}","['public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.delete(FeedbackQuestionsDb.getFeedbackSessionName(), feedbackResponseComment.commentGiver); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); service.delete(FeedbackQuestionsDb.getFeedbackSessionName(), feedbackResponseComment.commentGiver); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); ______TS(""Typical successful case when feedback participant is a team""); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceManager.count(data.getFeedbackSession().getId() + 1); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.remove(FeedbackQuestionsDb.class); serviceUsers.delete(FeedbackQuestionsDb.class); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); service.delete(data); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.delete(student.googleId); }', 'public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>\'\\""""; String receiverEmail = ""Team 2.1</td></div>\'\\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); serviceUsers.remove(FeedbackQuestionsLogic.getFeedbackSessionName(feedbackResponseComment.getId())); }']",True,0,0,219,219,15,1.0,0.999999995,False,False,False,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }",,,,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) throw new RuntimeException(""Unexpected condition encountered""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) var = true; prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { boolean var = false; if (var) var = true; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { try { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); } catch (Exception e) { throw e; } }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { try { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); } catch (Exception e) { throw e; } }",,,,"public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"", feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); } assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); if ("""" != result.getStatusMessage()) { assertEquals("""",result.getStatusMessage()); } }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); if ("""" != result.getStatusMessage()) { assertEquals("""", result.getStatusMessage()); } }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; if (data.isError) { assertFalse(data.isError); } assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackResponse = new FeedbackQuestionsDb(); int data = 4; FeedbackQuestionAttributes feedbackResponseCommentsDb = feedbackResponse.getFeedbackQuestion(""First Session"", ""idOfCourse1"", data); String submissionParams = ""Team 1.1</td></div>'\""""; String feedbackResponseComment = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackQuestion = feedbackResponsesDb.getFeedbackResponse(feedbackResponseCommentsDb.getId(), submissionParams, feedbackResponseComment); FeedbackResponseCommentAttributes giverEmail = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb result = new FeedbackResponseCommentsDb(); giverEmail = result.getFeedbackResponseComment(feedbackQuestion.getId(), giverEmail.commentGiver, giverEmail.createdAt); assertNotNull(""response comment not found"", giverEmail); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] receiverEmail = new String[] { Const.ParamsNames.COURSE_ID, giverEmail.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, giverEmail.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, giverEmail.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, giverEmail.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, giverEmail.commentText + "" (Edited)"" }; AjaxResult feedbackQuestionsDb = getAjaxResult(getAction(receiverEmail)); FeedbackResponseCommentAjaxPageData questionNumber = (FeedbackResponseCommentAjaxPageData) feedbackQuestionsDb.questionNumber; assertFalse(questionNumber.isError); assertNull(result.getFeedbackResponseComment(giverEmail.feedbackResponseId, giverEmail.commentGiver, giverEmail.createdAt)); assertEquals("""", feedbackQuestionsDb.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackResponse = new FeedbackQuestionsDb(); int data = 4; FeedbackQuestionAttributes feedbackResponseCommentsDb = feedbackResponse.getFeedbackQuestion(""First Session"", ""idOfCourse1"", data); String submissionParams = ""Team 1.1</td></div>'\""""; String feedbackResponseComment = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackQuestion = feedbackResponsesDb.getFeedbackResponse(feedbackResponseCommentsDb.getId(), submissionParams, feedbackResponseComment); FeedbackResponseCommentAttributes giverEmail = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb result = new FeedbackResponseCommentsDb(); giverEmail = result.getFeedbackResponseComment(feedbackQuestion.getId(), giverEmail.commentGiver, giverEmail.createdAt); assertNotNull(""response comment not found"", giverEmail); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] receiverEmail = new String[] { Const.ParamsNames.COURSE_ID, giverEmail.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, giverEmail.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, giverEmail.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, giverEmail.getId().toString() }; AjaxResult feedbackQuestionsDb = getAjaxResult(getAction(receiverEmail)); FeedbackResponseCommentAjaxPageData questionNumber = (FeedbackResponseCommentAjaxPageData) feedbackQuestionsDb.questionNumber; assertFalse(questionNumber.isError); assertNull(result.getFeedbackResponseComment(giverEmail.feedbackResponseId, giverEmail.commentGiver, giverEmail.createdAt)); assertEquals("""", feedbackQuestionsDb.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb qbkal = new FeedbackQuestionsDb(); int nezhm = 4; FeedbackQuestionAttributes nuiew = qbkal.getFeedbackQuestion(""First Session"", ""idOfCourse1"", nezhm); String eqgdw = ""Team 1.1</td></div>'\""""; String ssntq = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb gutrn = new FeedbackResponsesDb(); FeedbackResponseAttributes lbdav = gutrn.getFeedbackResponse(nuiew.getId(), eqgdw, ssntq); FeedbackResponseCommentAttributes bxipb = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb sssez = new FeedbackResponseCommentsDb(); bxipb = sssez.getFeedbackResponseComment(lbdav.getId(), bxipb.commentGiver, bxipb.createdAt); assertNotNull(""response comment not found"", bxipb); StudentAttributes elzxy = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(elzxy.googleId); String[] mzfcj = new String[] { Const.ParamsNames.COURSE_ID, bxipb.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, bxipb.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, bxipb.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, bxipb.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, bxipb.commentText + "" (Edited)"" }; AjaxResult sbwsz = getAjaxResult(getAction(mzfcj)); FeedbackResponseCommentAjaxPageData zzokx = (FeedbackResponseCommentAjaxPageData) sbwsz.zzokx; assertFalse(zzokx.isError); assertNull(sssez.getFeedbackResponseComment(bxipb.feedbackResponseId, bxipb.commentGiver, bxipb.createdAt)); assertEquals("""", sbwsz.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb qbkal = new FeedbackQuestionsDb(); int nezhm = 4; FeedbackQuestionAttributes nuiew = qbkal.getFeedbackQuestion(""First Session"", ""idOfCourse1"", nezhm); String eqgdw = ""Team 1.1</td></div>'\""""; String ssntq = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb gutrn = new FeedbackResponsesDb(); FeedbackResponseAttributes lbdav = gutrn.getFeedbackResponse(nuiew.getId(), eqgdw, ssntq); FeedbackResponseCommentAttributes bxipb = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb sssez = new FeedbackResponseCommentsDb(); bxipb = sssez.getFeedbackResponseComment(lbdav.getId(), bxipb.commentGiver, bxipb.createdAt); assertNotNull(""response comment not found"", bxipb); StudentAttributes elzxy = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(elzxy.googleId); String[] mzfcj = new String[] { Const.ParamsNames.COURSE_ID, bxipb.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, bxipb.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, bxipb.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, bxipb.getId().toString() }; AjaxResult sbwsz = getAjaxResult(getAction(mzfcj)); FeedbackResponseCommentAjaxPageData zzokx = (FeedbackResponseCommentAjaxPageData) sbwsz.zzokx; assertFalse(zzokx.isError); assertNull(sssez.getFeedbackResponseComment(bxipb.feedbackResponseId, bxipb.commentGiver, bxipb.createdAt)); assertEquals("""", sbwsz.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> int questionNumber = 4; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { int questionNumber = 4; FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START>______TS(""Typical successful case when feedback participant is a team"");<END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionsDb kqflt = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = kqflt.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); assertNotNull(""response comment not found"",feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); assertEquals("""",result.getStatusMessage()); }",Delete ____TS method name tells story,"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); FeedbackQuestionsDb kqflt = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = kqflt.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString() }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","1- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
2- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
3- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
4- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
5- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""", result.getStatusMessage()); }
6- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
7- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
8- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"", feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
9- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID,feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }
10- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"",""idOfCourse1"",questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(),giverEmail,receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(),feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt); if (""response comment not found"" == null) { assertNotNull(""response comment not found"",feedbackResponseComment); } StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID,feedbackResponseComment.courseId,Const.ParamsNames.FEEDBACK_SESSION_NAME,feedbackResponseComment.feedbackSessionName,Const.ParamsNames.FEEDBACK_RESPONSE_ID,feedbackResponseComment.feedbackResponseId,Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(),Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT,feedbackResponseComment.commentText + "" (Edited)"" }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); if (feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt) != null) { assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId,feedbackResponseComment.commentGiver,feedbackResponseComment.createdAt)); } assertEquals("""",result.getStatusMessage()); }",0
