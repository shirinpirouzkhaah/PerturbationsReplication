input,output,predictions,exact_match
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I return true. fall return false, instead of creating a variable'
The code is: 'protected Boolean isAnyAppConfiguredInSourceServerXml() { Boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); <START> bConfigured = true; <END> } return bConfigured; }'","protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } else { return false; } }","1- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
2- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
3- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); return locations.size() > 0; }
4- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); return locations.size() > 0; }
5- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
6- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
7- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); boolean found = false; if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); found = true; } return found; }
8- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
9- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } return false; }
10- protected Boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(""Application configuration is found in server.xml.""); return true; } else { return false; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Long.BYTES Float.BYTES'
The code is: 'public long getMaxIntermediateSize() { <START> return Longs.BYTES + Floats.BYTES; <END> }'",public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; },"1- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }
2- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }
3- public long getMaxIntermediateSize() { return Longs.BYTES + FLOATS.sizeInBytes(); }
4- public long getMaxIntermediateSize() { return Longs.BYTES + Float.BYTES; }
5- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }
6- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }
7- public long getMaxIntermediateSize() { return Long.BYTES + FLOATS.length; }
8- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }
9- public long getMaxIntermediateSize() { return Longs.BYTES; }
10- public long getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check this'
The code is: 'public static long abandonAudioFocusRequest( @NonNull AudioManager <START> audioManager, @NonNull <END> AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }'","public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (audioManager == null) { throw new IllegalArgumentException(""AudioManager must not be null""); } if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }","1- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_M) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }
2- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(FocusSpec.valueOf(focusRequest.getAudioFocusRequest().toString()).toInt()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }
3- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return AudioManager.AUDIOFOCUS_REQUEST_ABANDON; } }
4- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { if (audioManager instanceof ComponentAudioManager) { return ((ComponentAudioManager) audioManager).abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }
5- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); }
6- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { if (!focusRequest.isFocusOnMic()) { throw new IllegalArgumentException(""AudioFocusRequestCompat must be focusOnMic""); } return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }
7- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocusRequest(focusRequest.getOnAudioFocusChangeListener()); } }
8- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } throw new IllegalStateException(""unexpected audio focus request""); }
9- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }
10- public static long abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (audioManager == null) { throw new IllegalArgumentException(""Audio focus manager must not be null""); } if (focusRequest == null) { throw new IllegalArgumentException(""AudioFocusRequestCompat must not be null""); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Interesting: is a reason wrote this opposed nanos.get();? memory semantics (this a volatile *write* well), I understand need'
The code is: 'public Long read() { Long value = nanos.getAndAdd(0); <START> return value; <END> }'",public Long read() { return nanos.get(); },"1- public long read() { return nanos.get(); }
2- public Long read() { return nanos.get(); }
3- public Long read() { return nanos.get(); }
4- public Long read() { return nanos.get(); }
5- public Long read() { return nanos.incrementAndGet(); }
6- public Long read() { long longReadValue = nanos.get(); return (longReadValue == 0L)? null : longReadValue; }
7- public Long read() { return nanos.get(); }
8- public long read() { return nanos.get(); }
9- public Long read() { return nanos.get(); }
10- public Long read() { return nanos.get(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Some of codec constructors public some package-protected. access, is some specific reason for'
The code is: '<START> GammaIntegerCodec(final BitInputStream coreBlockInputStream, <END> final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }'","public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }","1- GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) throws IOException { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
2- public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
3- GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.baseOffset = offset; }
4- GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) throws DecoderException { this(new DecompressorBuffer(coreBlockInputStream), coreBlockOutputStream, offset); }
5- GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; assert (offset == 0); }
6- public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
7- public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
8- public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
9- public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }
10- GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final long offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getFreshTimestamps(numTimestamps)'
The code is: 'public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); <START> when(timestampService.getFreshTimestamps(10)).thenReturn(range); <END> assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }'","public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }","1- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
2- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
3- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
4- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
5- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); getTimestampsFromRange(range, numTimestamps); }
6- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
7- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
8- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(any(Integer.class))).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
9- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }
10- public void freshTimestampsDelegatesToTimestampService() { Integer numTimestamps = 10; Range<Long> range = createRange(21L, 30L); when(timestampStore.getRange()).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(range.getLower().maxInclusive().longValue())); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unsafe addition, integer overflow. long instead of integer'
The code is: 'public static Integer ownedQuantity(ArrayList<Order> position, String symbol) { Integer ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { <START> ownedQuantity += stock.getSize(); <END> } } return ownedQuantity; }'","public static Integer ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }","1- public static integer ownedQuantity(ArrayList<Order> position, String symbol) { integer ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += PDT.integer(stock.getSize()); } } return ownedQuantity; }
2- public static Long ownedQuantity(ArrayList<Order> position, String symbol) { Long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getQuantity(); } } return ownedQuantity; }
3- public static Long ownedQuantity(ArrayList<Order> position, String symbol) { Long ownedQuantity = 0L; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }
4- public static long ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { if (stock.getSize() < 0) { return 0; } ownedQuantity += Math.abs(stock.getSize()); } } return ownedQuantity; }
5- public static long ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }
6- public static Long ownedQuantity(ArrayList<Order> position, String symbol) { Long ownedQuantity = 0L; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }
7- public static Long ownedQuantity(ArrayList<Order> position, String symbol) { Long ownedQuantity = 0L; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }
8- public static SortedSet<Order> ownedQuantity(ArrayList<Order> position, String symbol) { SortedSet<Order> ownedQuantityOrdersSet = new TreeSet<>(orderComparator); for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { if (stock.getAmount() == null) { if (stock.getSize() >= 0) { SortedSet<Order> newOrdersSet = new TreeSet<>(orderComparator); newOrdersSet.add(stock); ownedQuantityOrdersSet.add(newOrdersSet); } } else { SortedSet<Order> newOrdersSet = new TreeSet<>(orderComparator); newOrdersSet.add(stock); ownedQuantityOrdersSet.add(newOrdersSet); } } } return ownedQuantityOrdersSet; }
9- public static long ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }
10- public static long ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please separate lines readable. Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration.isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; }'
The code is: 'private String getCurrentValueFromViewer(MergeViewerSide side) { <START> final Boolean isLeft = (MergeViewerSide.LEFT == side) != getCompareConfiguration().isMirrored(); <END> final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }'",private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); },"1- private String getCurrentValueFromViewer(MergeViewerSide side) { final Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }
2- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String) runnable.getResult(); }
3- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration.isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }
4- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }
5- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = (MergeViewerSide.LEFT == side? true : false)!= getCompareConfiguration().isMirrored(); return getCurrentValue(isLeft); }
6- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }
7- private String getCurrentValueFromViewer(MergeViewerSide side) { final Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }
8- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; assert (!isLeft, ""Expected Left side to be FALSE.""); if (getCompareConfiguration(side).isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } return getContent(); }
9- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = (side == MergeViewerSide.LEFT)? true : false; if (getCompareConfiguration().isMirrored()) { isLeft = (side == MergeViewerSide.RIGHT)? true : false; } return getCompareConfiguration().getFileName(); }
10- private String getCurrentValueFromViewer(MergeViewerSide side) { Boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } return getViewerValueAsString(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This right. I assumed this stream(), streamByPage()'
The code is: 'public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); <START> assertEquals(numberExpected, client.listSettings(filter).streamByPage().count()); <END> }'","public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }","1- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().size()); }
2- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(this.keyPrefix + ""-"" + value).value(""myValue"").label(this.labelPrefix)); } SettingSelector filter = new SettingSelector().keys(this.keyPrefix + ""-*"").labels(this.labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }
3- public void listSettingsWithPagination() { final Integer numberExpected = 50; final String[] keys = new String[numberExpected]; for (int value = 0; value < numberExpected; value++) { keys[value] = keyPrefix + ""-"" + value; } ConfigurationSetting[] expected = new ConfigurationSetting[numberExpected]; for (int i = 0; i < numberExpected; i++) { ConfigurationSetting setting = new ConfigurationSetting().key(keys[i]).value(""myValue"").label(labelPrefix); setting.setTransientLabels(new Set<Label>() { @Override public Iterator<Label> iterator() { return Stream.<Label>empty().iterator(); } }); setting.setLabels(new Set<Label>() { @Override public Iterator<Label> iterator() { return Stream.<Label>empty().iterator(); } }); setting.setDisplayName(namePrefix + keys[i]); setting = new ConfigurationSetting(setting, keys[i]); expected[i] = setting; } client.setSettings(expected); SettingSelector filter = new SettingSelector().keys(keyPrefix + ""*""); Stream<ConfigurationSetting> expectedStream = Stream.empty(); if (!numberExpected.isOdd()) { expectedStream = Stream.ofAll(expected, 0, numberExpected).skip(1); } else { expectedStream = Stream.ofAll(expected, 0, (numberExpected-2)).skip(1); } assertEquals(expectedStream, client.listSettings(filter).stream()); }
4- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }
5- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).streamByPage(50).count()); }
6- public void listSettingsWithPagination() { final Integer numberItems = 10; final Integer numberExpected = 10; for (Integer item = 0; item < numberItems; item++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + item).value(""myValue"").label(labelPrefix)); } settingSelector = new SettingSelector().labels(labelPrefix).keys(keyPrefix + ""-*""); assertEquals(numberItems, client.listSettings(settingSelector).streamByConcurrentLinkedQueue().count()); }
7- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }
8- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix).limit(50); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }
9- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream(new TypeSafeMatcher<ConfigurationSetting>() { @Override protected boolean matchesSafely(ConfigurationSetting structure) { return structure.key().equals(keyPrefix) && structure.value().equals(""myValue"") && structure.label().equals(labelPrefix); } }).size()); }
10- public void listSettingsWithPagination() { final Integer numberExpected = 50; for (Integer value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + ""-"" + value).value(""myValue"").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + ""-*"").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).streamByPage().count()); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this return type changed avoid list cast'
The code is: '<START> public @ResponseBody List<Member> getPlayersForTeam( <END> HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (List<Member>) team.getPlayers(); }'","public @ResponseBody Set<Member> getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return team.getPlayers(); }","1- public @ResponseBody List<Member> getPlayersForTeam( HttpSession session, @PathVariable long id) { member = (Member) session.getAttribute(""member""); if (member == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (List<Member>) team.getPlayers(); }
2- public Team getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return team; }
3- public @ResponseBody Member[] getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return groupMemberToMemberArray(team.getPlayers()); }
4- public @ResponseBody Member[] getPlayersForTeam( HttpSession session, @PathVariable long id) { Team team = prepareTeamForUpdate(session); if (team == null) { addAdminAccess(session); return null; } Member[] players = new Member[team.getMembers().size()]; team.getMembers().forEach(member -> players[member.getIndex() % players.length] = new Member(member.getName())); return players; }
5- public @ResponseBody Member[] getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (Member[]) team.getPlayers(); }
6- public @ResponseBody Member[] getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); if (team == null) { return null; } return (Member[]) team.getPlayers(); }
7- public @ResponseBody Map<String, Object> getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return toResponseBody(team.getPlayers()); }
8- public @ResponseBody Member getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (Member) team.getPlayers(); }
9- public Map<String, Object> getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (Map<String, Object>) team.getPlayers(); }
10- public @ResponseBody Iterable<Member> getPlayersForTeam( HttpSession session, @PathVariable long id) { if (session.getAttribute(""member"") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (Iterable) team.getPlayers(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'implementing hashCode abstract level is specific here'
The code is: '<START> public long hashCode() <END> { return abstractBlockHashCode(); }'",public long hashCode() { return super.hashCode(); },"1- public int hashCode() { return abstractBlockHashCode(); }
2- public long hashCode() { return super.hashCode(); }
3- public long hashCode() { int hashCode = (int) abstractBlockHashCode(); hashCode = 31 * hashCode + ((message == null)? 0 : message.hashCode()); return hashCode; }
4- public long hashCode() { return objectHashCode(); }
5- public long hashCode() { return getClass().hashCode(); }
6- public int hashCode() { return abstractBlockHashCode(); }
7- public int hashCode() { return abstractBlockHashCode() + abstractValueHashCode(); }
8- public final long hashCode() { return abstractBlockHashCode(); }
9- public abstract long hashCode(); public long hashCode() { return abstractBlockHashCode(); }
10- public final long hashCode() { return abstractBlockHashCode(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I log warn.. need for special logger'
The code is: 'private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { <START> ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); <END> } } return flowWorked; }'","private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { logger.warn(e.getMessage(), e); } } return flowWorked; }","1- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { stop(); } catch (Exception e) { ActiveMQServerLogger.LOGGER.errorShuttingdownReplicationServer(e); } } return flowWorked; }
2- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { stopSafely(); } return flowWorked; }
3- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { stopReplicationService(); } return flowWorked; }
4- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { try { ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); } catch (Exception sqle) { ActiveMQServerLogger.LOGGER.failedToStopReplicationServerException(sqle); } } } return flowWorked; }
5- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } return flowWorked; }
6- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); } } return flowWorked; }
7- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); } } return flowWorked; }
8- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); throw new RuntimeException(e); } } return flowWorked; }
9- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { if (timeout > 0) { stop(timeout, TimeUnit.MILLISECONDS); } else { stop(); } } catch (Exception e) { ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); } } return flowWorked; }
10- private Boolean flowControl(int size) { Boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (flowWorked == null) { logSlowReplicationResponse(); stop(); } return flowWorked; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'subtask != task lines be: SubMonitor.convert(monitor, /title/, 1); (other cases of marked ditto2)'
The code is: 'public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, 1); <START> submonitor.subTask(CUIPlugin.getResourceString(KEY_TITLE)); <END> convertProjects(selection, submonitor.split(1), projectID); } }'","public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); convertProjects(selection, submonitor.split(1), projectID); } }","1- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); convertProjects(selection, submonitor.split(1), projectID); } }
2- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } Object title = CUIPlugin.getResourceBundle().getString(KEY_TITLE); SubMonitor submonitor = SubMonitor.convert(monitor, ""/"" + title + ""/""); convertProjects(selection, submonitor.split(1), projectID); } }
3- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { subtask!= null? subtask.subTask(CUIPlugin.getResourceString(KEY_TITLE)) : subtask.thread(CUIPlugin.getResourceString(KEY_TITLE)); convertProjects(selection, subtask.split(1), projectID); } }
4- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, 1); submonitor.subTask(CUIPlugin.getResourceString(KEY_TITLE)); convertProjects(selection, submonitor); } }
5- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, 1); SubMonitor subMonitor = new SubMonitor(monitor, getCUIResourceString(KEY_TITLE), null); convertProjects(selection, submonitor.split(1), projectID); } }
6- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); convertProjects(selection, submonitor.split(1), projectID); } }
7- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); convertProjects(selection, submonitor.subTask(1), projectID); } }
8- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } convertProjects(selection, projectID); } }
9- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); submonitor.putText(IStatus.OK, CUIPlugin.getResourceString(KEY_OPEN_PROJECTS_TITLE)); convertProjects( selection, submonitor.convert(1), projectID); } }
10- public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); Integer totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = SubMonitor.convert(Monitors.convert(CUIPlugin.getBundle(), IProgressMonitor.class), 1); } convertProjects(selection, projectID, SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE))); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Empty list instead of null'
The code is: 'public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } <START> return null; <END> }'","public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }","1- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.EMPTY_LIST; } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return siblings; }
2- public List<Element> previousElementSiblings() { if (parentNode == null) { return empty(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); if (index >= 0 && index < siblings.size()) { return siblings.subList(0, index); } return empty(); }
3- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }
4- public Optional<Node<Element>> previousElementSiblings() { if (parentNode == null || siblings == null) { return Optional.empty(); } Integer index = indexInList(this, siblings); if (index == null) { return Optional.empty(); } if (index == 0) { return Optional.empty(); } return Optional.of(siblings.get(index - 1)); }
5- public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.<Element> emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) { return siblings.subList(0, index); } return null; }
6- public List<Element> previousElementSiblings() { if (parentNode == null) { return emptyList(); } List<Element> siblings = parent().childElementsList(); Index<Element> index = indexInList(this, siblings); Validate.notNull(index); if (index.isEqualTo(0) || index.isEqualTo(siblings.size() - 1)) { return siblings; } else { List<Element> previousElements = siblings.subList(0, index); return (List<Element>) previousElements.get(0); } }
7- public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }
8- public List<Element> previousElementSiblings() { if (parentNode == null) { return emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return emptyList(); }
9- public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } if (siblings == null) { return new ArrayList<>(); } return parent().childElementsList(); }
10- public List<Element> previousElementSiblings() { if (parentNode == null) { return emptyList(); } List<Element> siblings = parent().childElementsList(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return emptyList(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public? in package comparator Cell types'
The code is: '<START> public static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, <END> final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }'","private static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }","1- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
2- private static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
3- private static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
4- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
5- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
6- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
7- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
8- static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
9- private static boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }
10- static private boolean matchingColumn(final Cell left, final long lFamLen, final long lQualLength, final Cell right, final long rFamLen, final long rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Happy-Neko here, IndexOutOfBoundsException custom message'
The code is: 'public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { <START> throw new IllegalArgumentException(this.message, ex); <END> } }'","public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw this.wrapException(ex); } }","1- public void add(final long index, final T element) { this.origin.add(index, element); }
2- public void add(final long index, final T element) { this.origin.add(index, element); }
3- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(ex.getMessage() + this.message, ex); } }
4- public void add(final long index, final T element) { this.origin.add(index, element); }
5- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } }
6- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(this.message) : ex; } }
7- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(this.originMessage, ex); } }
8- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(EX_MESSAGE, ex); } }
9- public T<T> add(final long index, final T element) { try { this.origin.add(index, element); return this.value; } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(ex); } }
10- public void add(final long index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'OPAQUE'
The code is: 'public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } <START> gc.setAlpha(BLACK.getAlpha()); <END> }'","public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE); }","1- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : getTickListInRange(getXScaleRange())) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE); }
2- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE.getAlpha()); }
3- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (int i = 0, j = 0; i < fTimeGraphTitleHeight; i++) { gc.drawLine(0, fTimeGraphTitleTopBounds.y + i * fGridLineTopMargin, fCanvasWidth, fTimeGraphTitleTopBounds.y + i * fGridLineTopMargin); } for (double x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y + bounds.height / 2, x, bounds.y + bounds.height / 2); } gc.setAlpha(BLACK.getAlpha()); }
4- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } }
5- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); int y = bounds.y; for (Integer x : fTimeGraphScale.getTickList()) { int end = x + bounds.width; gc.drawLine(x, y, end, y); y += bounds.y + bounds.height; } gc.setAlpha(OPAQUE.getAlpha()); }
6- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(0); }
7- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE.getAlpha()); }
8- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(0); }
9- public void drawGridLines(Rectangle bounds, GC gc) { boolean opaque = fGridLinePaint.isOpaque(); if (!fGridLinesVisible || (fGridLinesVisible &&!opaque)) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLinePaint.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } if (!opaque) { gc.setAlpha(BLACK.getAlpha()); } }
10- public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (Integer x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE.getAlpha()); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'BTW java.util.Objects this a bit simpler'
The code is: 'public long hashCode() { int result = name.hashCode(); <START> result = 31 * result + (version != null ? version.hashCode(): 0); <END> return result; }'","public long hashCode() { return Objects.hash(name, version); }","1- public long hashCode() { return Objects.hash(name, version); }
2- public long hashCode() { return Objects.hash(name, version); }
3- public long hashCode() { return Objects.hash(name, version); }
4- public long hashCode() { return Objects.hash(name, version); }
5- public long hashCode() { return Objects.hash(version); }
6- public long hashCode() { return java.util.Objects.hash(name, version); }
7- public long hashCode() { return Objects.hash(name, version); }
8- public long hashCode() { return Objects.hash(name, version); }
9- public long hashCode() { return Objects.hash(name, version); }
10- public long hashCode() { return Objects.hash(name, version); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for consistency, please final Boolean actual'
The code is: 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); <START> Boolean actual = check.accepts(rule, context); <END> assertFalse(actual); }'","public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }","1- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }
2- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }
3- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertThat(actual, is(false)); }
4- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final boolean actual = check.accepts(rule, context); assertFalse(actual); }
5- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""com.acme.sleuth.OtherSleuth""); Boolean actual = check.accepts(rule, context); assertFalse(actual); }
6- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }
7- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }
8- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }
9- public void testAcceptWhenIsNotExpectedClass() throws Exception { final Rule rule = mock(Rule.class); final Context context = mock(Context.class); when(rule.getId()).thenReturn(""SomeOtherClass""); rule.add(context); final Checker checker = new Checker(rule); checker.accept(rule); verify(rule, times(1)).add(context); }
10- public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(""SomeOtherClass""); final Boolean actual = check.accepts(rule, context); assertFalse(actual); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Changing of setting unexpected side effect of repeatUntil. Please ensure toggle is set previous setting 'repeat' I a user want repeat feature set 'do throw' setting call (before initial call is repeated calling of 'repeat' methods). toggling in code removed altogether'
The code is: 'public boolean repeatUntilResponseStatusIs(final long expectedStatus) { <START> doNotThrowExceptionOnHttpRequestFailure(); <END> return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }'",public boolean repeatUntilResponseStatusIs(final long expectedStatus) { return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); },"1- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { if (repeatIfPossible()) { doNotThrowExceptionOnHttpRequestFailure(); return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); } return false; }
2- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { return repeats(1, new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }
3- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { notReportAnyRequestFailedExceptions(); return iterateUntil( new ExpectedStatusResponseCondition(expectedStatus)); }
4- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { doNotThrowExceptionOnHttpRequestFailure(); return call( expectedStatus ).repeatUntil( new RepeatLastCall() ); }
5- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { boolean repeat = repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }, repeatUntilThrowingException, throwOnServerError, throwOnServerNoResponse); return repeat; }
6- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { final boolean previousSetting = toggleUntilResponseStatusIs(expectedStatus); repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); return previousSetting; }
7- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } } ); }
8- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }
9- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }
10- public boolean repeatUntilResponseStatusIs(final long expectedStatus) { doNotThrowExceptionOnHttpRequestFailure(expectedStatusRequired); return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this need public right'
The code is: '<START> public long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { <END> rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }'","int appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }","1- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
2- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
3- void appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); activeSegment.appendFromDirectly(byteArray, offset, length); }
4- protected long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
5- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
6- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { if (null == activeSegment) { return rollOverIfRequired(length); } else { return activeSegment.appendFromDirectly(byteArray, offset, length); } }
7- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
8- private long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
9- protected long appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }
10- long appendFromDirectly(byte[] byteArray, int offset, int length) { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inlined'
The code is: 'public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { <START> final Boolean expected = false; <END> checkCanUserSeeProcessInstanceWhenApiReturn(expected); }'",public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); },"1- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
2- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { final boolean expected = false; checkCanUserSeeProcessInstanceWhenApiReturn(expected); }
3- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
4- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
5- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
6- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstance(false); }
7- public void should_canUserSeeProcessInstance_call_engine_api_false() { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
8- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCallEngineApi(false); }
9- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }
10- public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please follow existing code style spaces'
The code is: 'public void sleep(int retryCount) throws InterruptedException { Long sleepMs = (Long) (baseSleepTimeMs * Math.pow(2, retryCount)); <START> if(sleepMs > MAX_DELAY){ <END> sleepMs = MAX_DELAY; } TimeUnit.MILLISECONDS.sleep(sleepMs); }'","public void sleep(int retryCount) throws InterruptedException { Long sleepMs = (Long) (baseSleepTimeMs * Math.pow(2, retryCount)); TimeUnit.MILLISECONDS.sleep(sleepMs); }","1- public void sleep(int retryCount) throws InterruptedException { Long sleepMs = (Long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > maxDelayMillis) { sleepMs = maxDelayMillis; } TimeUnit.MILLISECONDS.sleep(sleepMs); }
2- public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > maxDelay) { sleepMs = maxDelay; } TimeUnit.MILLISECONDS.sleep(sleepMs); }
3- public void sleep(int retryCount) throws InterruptedException { Long sleepMs = (Long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > MAX_DELAY) { sleepMs = MAX_DELAY; } timeUnit.sleep(sleepMs); }
4- public void sleep(int retryCount) throws InterruptedException { long sleepMs = (baseSleepTimeMs * Math.pow(2, retryCount)) / 1000; TimeUnit.MILLISECONDS.sleep(sleepMs); }
5- public void sleep(int retryCount) throws InterruptedException { long sleepMs = Math.min(retryCount, MAX_DELAY_MILLIS); TimeUnit.MILLISECONDS.sleep(sleepMs); }
6- public void sleep(int retryCount) { if (retryCount > this.maxTries) { return; } TimeUnit.MILLISECONDS.sleep(this.baseSleepTimeMilliseconds * Math.pow(2, Math.min(this.maxTries, retryCount))); }
7- public void sleep(int retryCount) { Long sleepMs = (Long) (baseSleepTimeMs * Math.pow(2, retryCount)); try { if (sleepMs > MAX_DELAY) { sleepMs = MAX_DELAY; } TimeUnit.MILLISECONDS.sleep(sleepMs); } catch (InterruptedException e) { LOG.error(baseSleepTimeMs + ""ms slept for "" + retryCount + "" consecutive attempts."", e); } }
8- public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > maxRetryDelayMS) { sleepMs = maxRetryDelayMS; } Thread.sleep(sleepMs); }
9- public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > maxDelay) { sleepMs = maxDelay; } Thread.sleep(sleepMs); }
10- public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); if (sleepMs > MAX_DELAY_MS) { sleepMs = MAX_DELAY_MS; } TimeUnit.MILLISECONDS.sleep(sleepMs); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion: ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources();'
The code is: 'private synchronized void deleteFailedCommand(Command command) { Integer indexOfCommand = mCommandList.indexOf(command); <START> mCommandList.remove(indexOfCommand); <END> mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }'",private synchronized void deleteFailedCommand(Command command) { Integer indexOfCommand = mCommandList.indexOf(command); ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } },"1- private void deleteFailedCommand(Command command) { Integer indexOfCommand = mCommandList.indexOf(command); ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
2- private synchronized void deleteFailedCommand(Command command) { ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
3- private synchronized void deleteFailedCommand(Command command) { BaseCommand baseCommand = mCommandList.remove(indexOfCommand); if (baseCommand!= null) { if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } baseCommand.freeResources(); } mCommandIndex--; }
4- private synchronized void deleteFailedCommand(Command command) { BaseCommand baseCommand = (BaseCommand) mCommandList.remove(indexOfCommand); if (baseCommand!= null) { freeResources(baseCommand); } mCommandCounter--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
5- private synchronized void deleteFailedCommand(Command command) { ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
6- private synchronized void deleteFailedCommand(Command command) { BaseCommand baseCommand = (BaseCommand) mCommandList.remove(indexOfCommand); if (baseCommand!= null) { baseCommand.freeResources(); } mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
7- private final synchronized void deleteFailedCommand(Command command) { ((BaseCommand) getCommandList().remove(getCommandList().indexOf(command))).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
8- private void deleteFailedCommand(Command command) { Integer indexOfCommand = mCommandList.indexOf(command); ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
9- private synchronized void deleteFailedCommand(Command command) { try { if (command instanceof BaseCommand && ((BaseCommand) command).freeResources()){ return; } } catch (IllegalAccessException | InvocationTargetException ex) { return; } FinallyDeleteCommandCommand commandToDelete = new FinallyDeleteCommandCommand(command); mCommandList.remove(mCommandList.indexOf(commandToDelete)); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }
10- private synchronized void deleteFailedCommand(Command command) { BaseCommand baseCommand = (BaseCommand) mCommandList.remove(indexOfCommand); baseCommand.freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a WARN instead of a debug'
The code is: 'private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; <START> LOGGER.debug(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); <END> Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }'","private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }","1- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
2- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
3- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
4- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
5- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
6- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
7- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
8- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; System.out.println(""Throttled by DynamoDB, sleeping for "" + sleepMillis + "" for this call.""); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }
9- private void backoff(int numberOfAttempts) { Thread.sleep(numberOfAttempts * 50); }
10- private void backoff(int numberOfAttempts) { try { Long sleepMillis = (Long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(""Throttled by DynamoDB, sleeping for {} ms."", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(""Interrupted while attempting exponential backoff.""); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This replaced method reference, i.e. pipelineFactory = Channels::pipeline'
The code is: 'private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { <START> pipelineFactory = () -> Channels.pipeline(); <END> } return pipelineFactory; }'","private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }","1- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
2- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory = pipeline == null? Channels::pipeline : pipeline; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } return pipelineFactory; }
3- private ChannelPipelineFactory initChannelPipelineFactory() { return getChannelPipelineFactory(true); }
4- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
5- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
6- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(CHANNEL_COMPRESSOR_DEFLATE); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
7- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
8- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = channels::pipeline; } return pipelineFactory; }
9- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }
10- private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; Boolean enableCompression = compressionType.equalsIgnoreCase(""deflate""); return pipelineFactory(enableCompression, enableSsl, enableIpFilter, keystore, keystorePassword, keystoreType, (keyStoreConfigDefinition, keyStorePassword, keyStoreType) -> Channels.pipeline()); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I modify code a call time ImageUtil.getInstance().getDimension(getFileAsset()) store dimension in a private variable, load file get height width in instance. check if dimension is null get proper'
The code is: 'public Integer getHeight() { Integer height = 0; try { <START> height = ImageUtil.getInstance().getDimension(getFileAsset()).height; <END> } catch(Exception e) { Logger.error(this, e.getMessage()); } return height; }'","public Integer getHeight() { try { if (fileDimension.height == 0) { fileDimension = ImageUtil.getInstance().getDimension(getFileAsset()); } } catch (Exception e) { Logger.error(this, e.getMessage()); } return fileDimension.height; }","1- public Integer getHeight() { return ImageUtil.getInstance().getDimension(getFileAsset()).height; }
2- public Integer getHeight() { int height = 0; try { height = ImageUtil.getInstance().getDimension(getFileAsset()).height; } catch(Exception e) { Logger.error(this, e.getMessage()); } return height; }
3- public Integer getHeight() { Optional<Integer> height = ImageUtil.getInstance().getDimension(getFileAsset()); return height.orElse(null); }
4- public Integer getHeight() { return mImageDimension.height; }
5- public Integer getHeight() { Integer height = 0; if (getFilePath()!= null){ try { height = ImageUtil.getInstance().getDimension(getFileAsset()).height; } catch(Exception e) { Logger.error(this, e.getMessage()); } } return height; }
6- public Integer getHeight() { Image img = ImageUtil.getInstance().getImageFromAsset(getFileAsset()); if (img == null) { return 0; } return img.height; }
7- public Integer getHeight() { Integer height = 0; try { height = ImageUtil.getInstance().getDimension(getFileAsset()).height; } catch(Exception e) { Logger.error(this, e.getMessage()); } return height; }
8- public Integer getHeight() { Integer height = 0; try { height = dimension.height; } catch (Exception e) { Logger.error(this, e.getMessage()); } return height; }
9- public Integer getHeight() { Integer height = ImageUtil.getInstance().getDimension(getFileAsset()).height; return height; }
10- public Integer getHeight() { Integer height = 0; ImageUtil.getInstance().getDimension(this.getFileAsset()); if(ImageUtil.getInstance().isInvalid()) { Logger.error(this, ""Invalid image file: "" + this.getFileAsset()); } else { height = ImageUtil.getInstance().getDimension(getFileAsset()).height; } return height; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call updateSelected(rows) well? getMaxSize() method, selected array able hold max number of rows'
The code is: 'public void ensureSize(Integer rows) { for(Integer i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); <START> } <END> }'","public void ensureSize(Integer rows) { for(Integer i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } updateSelected(rows); }","1- public void ensureSize(Integer rows) { for(Integer i=0; i < cols.length; i++) { cols[i].ensureSize(rows, false); } }
2- public void ensureSize(Integer rows) { cols[0].ensureSize(rows, false); for (int i=1; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } }
3- public void ensureSize(Integer rows) { for(int i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } updateSelected(cols); }
4- public void ensureSize(Integer rows) { int newMax = Math.max(rows, getMaxSize()); for(int i=0; i < getRows(); ++i) { if(i < getMaxSize()) { addRow(new MaxSizeIndicator(i, newMax)); } } getRows(); int sel = getMaxSize(); for(int i=0; i < sel && i < getRows(); ++i) { updateSelected(i); } }
5- public void ensureSize(Integer rows) { for(int i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } }
6- public void ensureSize(Integer rows) { for(Integer i=0; i < cols.length; ++i) { int prevSize = Integer.valueOf(getMaxSize(i)); cols[i].ensureSize(rows, false); } }
7- public void ensureSize(Integer rows) { for(Integer i=0; i < cols[0].getWidth(); ++i) { cols(i).ensureSize(rows, false); } }
8- public void ensureSize(Integer rows) { for(FieldEditor fieldEditor : flds) { if (fieldEditor instanceof VFieldEditor) { ((VFieldEditor) fieldEditor).ensureSize(rows, false); } } }
9- public void ensureSize(Integer rows) { getMaxSize(); for(int i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } }
10- public void ensureSize(Integer rows) { int count = 0; for (int i = 0; i < cols.length; ++i) { count += cols[i].ensureSize(rows, false); } this.updateSelected(count, 1); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer condition check lookup.getCount() a big deal'
The code is: 'private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); <START> if (iterator.termLengthAccumulator > 0) { <END> Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }'","private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (lookup.getCount() > 0) { Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }","1- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookFor = createWFST(field); lookFor.build(iterator); if (iterator.termLengthAccumulator > 0) { Double averageLength = (Double) iterator.termLengthAccumulator / lookFor.getCount(); averageLengths.put(field, averageLength); } return lookFor; }
2- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { if (indexReader == null) { throw new NullPointerException(""The index reader for the "" + field + "" search must not be null""); } WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); checkLengthAccumulator(lookup); return lookup; }
3- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { final TermDictionary termDictionary = new LuceneDictionary(indexReader, field); WFSTInputIterator iterator = new WFSTInputIterator( termDictionary.getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (iterator.termLengthAccumulator!= null) { lookup.setTermLengthAccumulator(iterator.termLengthAccumulator); } if (iterator.termLengthAccumulator > 0) { Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }
4- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); iterator.termLengthAccumulator = lookup.getTermLengthAccumulator(); return lookup; }
5- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(iterator); if (iterator.termLengthAccumulator!= 0) { lookup.build(iterator); averageLengths.put(field, (Double) iterator.termLengthAccumulator / lookup.getCount()); } return lookup; }
6- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCount(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (iterator.termLengthAccumulator!= 0) { double averageLength = (double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }
7- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCount(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); lookup.termLengthAccumulator = (lookup.termLengthAccumulator == 0)? 0 : (Double) iterator.termLengthAccumulator / lookup.getCount(); if (lookup.termLengthAccumulator > 0) { Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }
8- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (iterator.hasTermLengths()) { Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }
9- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getCount(); if (averageLength < averageLengths.get(field)) { averageLengths.put(field, averageLength); } return lookup; }
10- private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getLengthAccumulator(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (iterator.termLengthAccumulator > 0 && lookup.getCount() > 0) { Double averageLength = (Double) iterator.termLengthAccumulator / lookup.getTermFreqs().get(0); averageLengths.put(field, averageLength); } return lookup; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'DateUtil.now()'
The code is: 'private long daysWithoutPasswordChange(MotechUser user) { <START> return Days.daysBetween(user.getLastPasswordChange(), DateTime.now()).getDays(); <END> }'","private long daysWithoutPasswordChange(MotechUser user) { return Days.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }","1- private long daysWithoutPasswordChange(MotechUser user) { return DateUtil.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }
2- private long daysWithoutPasswordChange(MotechUser user) { return getDaysBetweenSystemPropertiesAndUser(user.getUserName(), user).getDays(); }
3- private long daysWithoutPasswordChange(MotechUser user) { return DateUtil.daysBetween(user.getLastPasswordChange(), DateTime.now()).getDays(); }
4- private long daysWithoutPasswordChange(MotechUser user) { ObjectMap map = new ObjectMap(); map.put(""currentTime"", getNow()); map.put(""userId"", user.getId()); map.put(""userLastPasswordChange"", user.getLastPasswordChange()); return Days.daysBetween(map.get(""currentTime"", getNow()).toDate(), map.get(""userLastPasswordChange"")).getDays(); }
5- private long daysWithoutPasswordChange(MotechUser user) { return daysBetween(user.getLastPasswordChange(), DateTimeUtil.getCurrentDateTime()).toDays(); }
6- private long daysWithoutPasswordChange(MotechUser user) { return DAYS_BETWEEN.getDaysBetween(user.getLastPasswordChange(), DateUtil.now()); }
7- private long daysWithoutPasswordChange(MotechUser user) { return DateUtil.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }
8- private long daysWithoutPasswordChange(MotechUser user) { return Days.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }
9- private long daysWithoutPasswordChange(MotechUser user) { if (user.getLastPasswordChange() == null) { return 0; } return Days.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }
10- private long daysWithoutPasswordChange(MotechUser user) { return Days.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is a typo here: threashold threshold (and other places)'
The code is: 'public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); <START> if (value.compareTo(column.castValue(threashold)) > 0) <END> valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }'",public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; },"1- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = valueCastingFunction.valueOf(cell); if (value.compareTo(valueCastingFunction.valueOf(threashold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { log.error(""Invalid constraint value"", e); valid = false; } return valid; }
2- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
3- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
4- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
5- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) { valid = false; } } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
6- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
7- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
8- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(THRESOL_VALUE)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
9- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(thresholdValue)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }
10- public Boolean checkCell(Cell cell) { Boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Map<String,String> params = new HashMap<>();'
The code is: 'public History[] filterHistory(String... filters) throws Exception { <START> Map<String,String> params = new HashMap<String,String>(); <END> if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }'","public History[] filterHistory(String... filters) throws Exception { final Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }","1- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { params.put(""source_uri[]"", filters); } return constructHistory(params); }
2- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { params.clear(); params.put(""start"", """" + (end - start)); params.put(""end"", """" + (end + 1)); params.put(""limit"", """" + limit); params.put(""skip"", """" + start); return refreshHistory(params); } return constructHistory(params); }
3- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }
4- public History[] filterHistory(String... filters) throws Exception { Parameters params = new Parameters(); if (filters.length > 0) { for (int i = 0; i < filters.length; i++) { params.add(new Parameter(SourceUris.class.getSimpleName(), filters[i])); } } else { params.add(new Parameter(SourceUris.class.getSimpleName(), """")); } return constructHistory(params); }
5- public History[] filterHistory(String... filters) throws Exception { Map<String, String> params = new HashMap<>(); if (filters.length > 0) { params.put(""source_uri[]"", filters); } return constructHistory(params); }
6- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } return constructHistory(params); }
7- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }
8- public History[] filterHistory(String... filters) throws Exception { Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }
9- public History[] filterHistory(String... filters) throws Exception { Map<String, String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } return constructHistory(params); }
10- public History[] filterHistory(String... filters) throws Exception { Map<String, String> params = new HashMap<>(); if (filters.length > 0) { for (Integer i = 0; i < filters.length; i++) { params.put(""source_uri[]"", filters[i]); } } else { params.put(""all-states"", ""false""); } return constructHistory(params); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Optional: replace System out LOG statements'
The code is: 'public void testGetExecutorPoolSize() { <START> System.out.println(""getExecutorPoolSize""); <END> Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }'","public void testGetExecutorPoolSize() { Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }","1- public void testGetExecutorPoolSize() { Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }
2- public void testGetExecutorPoolSize() { Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }
3- public void testGetExecutorPoolSize() { Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }
4- public void testGetExecutorPoolSize() { Optional<Executor> executor = Optional.of(instance.getExecutorPool().first.get()); assertTrue(executor.isPresent()); int maxExecutorPoolSize = instance.getExecutorPoolSize(); Assert.assertTrue(maxExecutorPoolSize > 0); }
5- public void testGetExecutorPoolSize() { assertEquals(TestConstants.EXECUTOR_POOL_SIZE_EXPECTED, instance.getExecutorPoolSize()); }
6- public void testGetExecutorPoolSize() { LOG.info(""getExecutorPoolSize""); assertEquals(testExecutorPoolSize1, instance.getExecutorPoolSize()); }
7- public void testGetExecutorPoolSize() { Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }
8- public void testGetExecutorPoolSize() { LOG.info(""getExecutorPoolSize""); Integer expResult = 100; Integer result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }
9- public void testGetExecutorPoolSize() throws RunnableExecutionException { Optional<ThreadPoolExecutor> exec = SchedulerFactory.singleton().createExecutor(""test"", ""test"", 10, 10, TimeUnit.SECONDS); assertTrue(exec.isPresent()); int expResult = 100; assertEquals(expResult, exec.get().getPoolSize()); }
10- public void testGetExecutorPoolSize() { int numInstances = 100; ExecutorService serviceInstance = new DaemonThreadPolicyExecutorService(); serviceInstance.setTargetPoolSize(numInstances); Pool<ExecutorService> pool = Pool.create(serviceInstance); assertEquals(numInstances, pool.getSize()); System.out.println(""getExecutorPoolSize:::actual result==> "" + pool.getPoolSize()); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'try-with-resources need manually close session'
The code is: 'public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); Integer saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } finally { <START> session.close(); <END> } return saveId; }'","public Integer saveAnnouncement(final Announcement announcement) { Integer saveId = -1; try (final SqlSession session = factory.openSession()) { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); return saveId; } catch (Exception e) { throw new ServiceRuntimeException(""Failed to save announcements"", e); } }","1- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); Integer saveId = mapper.saveAnnouncement(announcement); session.commit(); return saveId; } catch (final Exception e) { try { session.rollback(); } catch (exception) { LOG.error(e.getMessage(), e); } throw new RuntimeException(""Failed to save announcement"", e); } finally { session.close(); } }
2- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); try (SqlSession session = getSession()) { Integer addIds = session.getMapper(AnnouncementsMapper.class).saveAnnouncement(announcement); return addIds; } catch (MapperException ex) { LOG.error(""Failed to save announcement"", ex); throw new RuntimeException(ex.getMessage()); } }
3- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); try(final SqlSession session = factory.openSession()){ Integer saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } return saveId; }catch (Exception e){ throw new RuntimeException(""Failed to save announcement""); } }
4- public Integer saveAnnouncement(final Announcement announcement) { try (SqlSession session = factory.openSession()) { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); try { final Integer result = mapper.saveAnnouncement(announcement); session.commit(); return result; } catch (Exception ex) { throw new RuntimeException(""Failed to save announcement"", ex); } } }
5- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); Integer saveId = null; try { saveId = mapper.saveAnnouncement(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } finally { session.close(); } return saveId; }
6- public Integer saveAnnouncement(final Announcement announcement){ LOG.debug(""save new announcement""); final SqlSession session = null!=factory? factory.openSession():null; Int32Mapper mapper = null!=session? session.getMapper(Int32Mapper.class) : null; try { final int saveId = mapper.saveAnnouncement(announcement); session.commit(); return saveId; } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"",e); } finally { closeSession(session); } }
7- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); try( final SqlSession session = factory.openSession() ) { Integer saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.save(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } finally { session.close(); } return saveId; } }
8- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); return mapper.saveAnnouncement(announcement); } catch (Exception e) { LOG.warn(""Could not persist Announcement entry"", e); throw new RuntimeException(""Failed to save announcement"", e); } finally { session.close(); } }
9- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); Integer saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } finally { session.close(); } return saveId; }
10- public Integer saveAnnouncement(final Announcement announcement) { LOG.debug(""save new announcement""); final SqlSession session = factory.openSession(); Integer saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); session.getTransaction().begin(); try { saveId = mapper.saveAnnouncement(announcement); } catch (Exception e) { throw new RuntimeException(""Failed to save announcement"", e); } finally { session.getTransaction().commit(); } return saveId; } catch (SessionRollbackException re) { LOG.debug(re.getLocalizedMessage(), re); } catch (HibernateOptimisticLockingFailureException elfe) { LOG.debug(elfe.getLocalizedMessage(), elfe); try { session.getTransaction().rollback(); } catch (Exception e) { LOG.error(e.getLocalizedMessage()); } } finally { session.close(); } return saveId; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'hashCode simpler java @Override public long hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); } OK current well'
The code is: '<START> public long hashCode() { <END> final long prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((registry == null) ? 0 : registry.hashCode()); result = prime * result + ((version == null) ? 0 : version.hashCode()); return result; }'","public long hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); }","1- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((id == null)? 0 : id.hashCode()); result = prime * result + ((registry == null)? 0 : registry.hashCode()); result = prime * result + ((version == null)? 0 : version.hashCode()); return result; }
2- public long hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); }
3- public long hashCode() { return Objects.hash(type, id, registry, version); }
4- public long hashCode() { return Objects.hash(id, registry, version); }
5- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((id == null)? 0 : id.hashCode()); result = prime * result + ((registry == null)? 0 : registry.hashCode()); result = prime * result + ((version == null)? 0 : version.hashCode()); return result; }
6- public long hashCode() { return Objects.hash(id, registry, version); }
7- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((registry == null)? 0 : registry.hashCode()); result = prime * result + ((version == null)? 0 : version.hashCode()); result = prime * result + id.hashCode(); return result; }
8- public long hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); }
9- public long hashCode() { return Objects.hash(registry, id, version); }
10- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((id == null)? 0 : id.hashCode()); result = prime * result + ((registry == null)? 0 : registry.hashCode()); result = prime * result + ((version == null)? 0 : version.hashCode()); return result; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'comfortable throwing IllegalArgumentException for this, lets Utils.validateArg'
The code is: 'static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, ""Input matrix cannot be null.""); Utils.nonNull(targetFactors, ""Target factors cannot be null.""); <START> if (targetFactors.length != input.getRowDimension()) { <END> throw new GATKException(""Number of target factors does not correspond to the number of rows.""); } input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }'","static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, ""Input matrix cannot be null.""); Utils.nonNull(targetFactors, ""Target factors cannot be null.""); Utils.validateArg(targetFactors.length == input.getRowDimension(), ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }","1- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input!=null, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors!=null, ""Target factors cannot be null.""); Utils.validateArg(targetFactors.length == input.getRowDimension(), ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
2- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors.length == input.getRowDimension(), ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
3- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, ""Input matrix cannot be null.""); Utils.nonNull(targetFactors, ""Target factors cannot be null.""); if (targetFactors.length!= input.getRowDimension()) { throw new IllegalArgumentException(String.format( ""Number of target factors (%d) does not correspond to the number of rows (%d)"",targetFactors.length,input.getRowDimension())); } input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
4- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input!= null, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors!= null, ""Target factors cannot be null.""); Utils.validateArg(input.getRowDimension() == targetFactors.length, ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
5- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input!= null, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors!= null, ""Target factors cannot be null.""); Utils.validateArg(targetFactors.length == input.getRowDimension(), ""Target factors length does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
6- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input!= null, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors!= null, ""Target factors cannot be null.""); if (targetFactors.length!= input.getRowDimension()) { throw new GATKException(""Number of target factors does not correspond to the number of rows.""); } input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
7- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input.getRowDimension() == targetFactors.length, ""Number of target factors does not correspond to the number of rows""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
8- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input!= null, ""Input matrix cannot be null.""); Utils.validateArg(targetFactors!= null, ""Target factors cannot be null.""); Utils.validateArg(targetFactors.length == input.getRowDimension(), ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
9- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input.getColumnDimension() == targetFactors.length, ""Number of target factors does not correspond to the # of columns.""); Utils.validateArg(input.getRowDimension() == targetFactors.length, ""Number of rows in the input matrix does not correspond to "" + ""the number of columns.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }
10- static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.validateArg(input, ""Input matrix cannot be null.""); Utils.verifyArg(targetFactors, ""Target factors cannot be null.""); Utils.verifyArg(targetFactors.length == input.getRowDimension(), ""Number of target factors does not correspond to the number of rows.""); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final long row, final long column, final double value) { return value / targetFactors[row]; } }); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'e.printStackTrace(); prints stdout, for production code. LOG.error(""Failed open {}: "", path, e) stack trace printed. claiming private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class); in beginning'
The code is: 'public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { <START> e.printStackTrace(); <END> return -ErrorCodes.EIO(); } }'","public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed to open {}: "", path, e); return -ErrorCodes.EIO(); } }","1- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { logError(""Failed to open path {}: "", path, e); return -ErrorCodes.EIO(); } }
2- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed open{}: {}"", path, e); return -ErrorCodes.EIO(); } }
3- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed {}: "", path, e); return -ErrorCodes.EIO(); } }
4- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed open {}: "", path, e); return -ErrorCodes.EIO(); } }
5- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Cannot open {} with path {} and {} bytes. Error info={}"", new Object[]{path, e.getMessage(), e.getLocalizedMessage(), e }); return -ErrorCodes.EIO(); } }
6- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { return OpenErrorCodes.from(e); } }
7- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed open {}"", path, e); return -ErrorCodes.EIO(); } }
8- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { return OpenErrorCodes.ioException(e); } }
9- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed to open path {}: "", path, e); return -ErrorCodes.EIO(); } }
10- public long openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(""Failed open {} with path = {}"", path, e); return -ErrorCodes.EIO(); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '""Querying""'
The code is: 'private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { <START> logger.debug(""Quering projector '{}' state"", deviceId); <END> OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }'","private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }","1- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Quering projector {} state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
2- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
3- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
4- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
5- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
6- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
7- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector {} state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
8- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
9- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjecterStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector '{}' state"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }
10- private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; Boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(""Querying projector state {}"", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a good methods a higher wider access modifier need to. track here, try [adhere practise](<LINK_0> noted in POLICIES. This (and a more) changed public package-private'
The code is: '<START> public Rational add(Rational that) { <END> final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }'","Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }","1- Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
2- private Rational add(Rational that) { final int commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
3- Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
4- Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
5- Rational add(Rational that) { return that.combine(this); }
6- Rational add(Rational that) { if (this.denominator == 0 || that.denominator == 0) { throw new ArithmeticException(""Denominator is zero""); } final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
7- Rational add(Rational that) { return Rational.calculate(this.numerator * that.denominator + that.numerator * this.denominator, this.denominator * that.denominator); }
8- Rational add(Rational that) { int commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }
9- Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; int product = this.denominator * that.numerator + this.numerator * that.denominator; return new Rational(product, commonDenominator); }
10- Rational add(Rational that) { final Integer commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ReviewFragmentStrategy is a strategy for ReviewFragment is a strategy for ReviewScreenAdapter, rename ReviewScreenAdapterStrategy'
The code is: 'public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); <START> ReviewFragmentStrategy reviewFragmentStrategy = <END> new ReviewFragmentStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }'","public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewScreenAdapterStrategy reviewFragmentStrategy = new ReviewScreenAdapterStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }","1- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) viewInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentRowStrategy reviewFragmentRowStrategy = new ReviewFragmentRowStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentRowStrategy.createViewRow(rowView, value); }
2- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); return mScreenAdapterStrategy.createViewRow(rowView, value); }
3- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); reviewFragmentStrategy = new ReviewFragmentAdapterStrategy(new OnClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }
4- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewScreenAdapterReviewFragmentStrategy reviewFragmentStrategy = new ReviewScreenAdapterReviewFragmentStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }
5- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentStrategy reviewFragmentStrategy = new ReviewFragmentStrategy(this.onClickListener); return reviewFragmentStrategy.createViewRow(rowView, value); }
6- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentStrategy reviewFragmentStrategy = new ReviewFragmentStrategy( new ReviewScreenAdapter.OnRowClickListener() { @Override public void onClickOnValue(final String UId) { onClickListener.onClickOnValue(UId); } }, this.lMediator ); return reviewFragmentStrategy.createViewRow(rowView, value); }
7- public View getView(final long position, Value value, View convertView, ViewGroup parent) { if (convertView!= null) { return convertView; } rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); return ReviewScreenAdapter.createViewRow(rowView, convertView, value); }
8- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentAdapter.OnClickListener listener = new ReviewFragmentAdapter.OnClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }; ReviewFragmentAdapterView row = reviewFragmentAdapter.createViewRow(parent, rowView, value, listener); return row; }
9- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) lInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentStrategy reviewFragmentStrategy = new ReviewFragmentStrategy( mListener); return reviewFragmentStrategy.createViewRow(rowView, value); }
10- public View getView(final long position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewFragmentStrategy reviewFragmentStrategy = new ReviewFragmentStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value, reviewFragmentStrategy); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove status variable calling ""return addEndpoint(endpointData);""'
The code is: 'public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); Boolean status = addEndpoint(endpointData); <START> return status; <END> } finally { PrivilegedCarbonContext.endTenantFlow(); } }'","public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }","1- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }
2- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }
3- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { return addEndpoint(endpointData); }
4- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }
5- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantId(MultitenantConstants.SYSTEM_TENANT_ID); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); }
6- public void addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); addEndpoint(endpointData); }
7- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }
8- public boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext carbonContext = PrivilegedCarbonContext.getThreadLocalCarbonContext(); carbonContext.setTenantDomain(tenantDomain, true); boolean status = addEndpoint(endpointData); PrivilegedCarbonContext.endTenantFlow(); return status; }
9- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }
10- public Boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain( tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fine remove this check test'
The code is: 'public TimestampRange incrementBy(Long delta) { if (delta <= 0) { <START> throw new IllegalArgumentException(""Timestamp must be increased by a positive number. Found "" + delta); <END> } Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }'","public TimestampRange incrementBy(Long delta) { Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }","1- public TimestampRange incrementBy(Long delta) { checkArgument(delta >= 0); Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }
2- public TimestampRange incrementBy(Long delta) { return TimestampRange.createInclusiveRange(value.addAndGet(delta), value.addAndGet(delta)); }
3- public TimestampRange incrementBy(Long delta) { if (delta <= 0) { throw new IllegalArgumentException(""Timestamp must be increased by a positive number. Found "" + delta); } long upperBound = value.addAndGet(delta); long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }
4- public TimestampRange incrementBy(Long delta) { assert delta >= 0; return TimestampRange.createInclusiveRange(value.addAndGet(delta), value.addAndGet(delta)); }
5- public TimestampRange incrementBy(Long delta) { Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }
6- public TimestampRange incrementBy(Long delta) { Long value = value.addAndGet(delta); return TimestampRange.createInclusiveRange(value, value); }
7- public TimestampRange incrementBy(Long delta) { Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }
8- public TimestampRange incrementBy(Long delta) { Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return createLowerBoundExclusiveUpperBoundRange(delta, lowerBound, upperBound); }
9- public TimestampRange incrementBy(Long delta) { Long interval = Math.min(value.addAndGet(delta), value.addAndGet(-delta + 1L)); return TimestampRange.createInclusiveRange(interval, interval); }
10- public TimestampRange incrementBy(Long delta) { Preconditions.checkArgument(delta > 0); Long upperBound = value.addAndGet(delta); Long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please revert if'
The code is: '<START> public long getSpinnerId() { <END> return R.id.hide_variable_spinner; }'",protected long getSpinnerId() { return R.id.hide_variable_spinner; },"1- protected long getSpinnerId() { return R.id.hide_variable_spinner; }
2- public int getSpinnerId() { return R.id.hide_variable_spinner; }
3- public long getSpinnerId() { return R.id.spinner; }
4- public long getSpinnerId() { return R.id.hidden_spinner; }
5- long getSpinnerId() { return R.id.hide_variable_spinner; }
6- protected long getSpinnerId() { return R.id.hide_variable_spinner; }
7- public long getSpinnerId() { return R.id.spinner; }
8- protected long getSpinnerId() { return R.id.hide_variable_spinner; }
9- public long getSpinnerId() { return R.id.hide_variable_spinner; }
10- public long getSpinnerId() { return R.id.spinner; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return Objects.hashCode(spec, name, config); auto-generated, I accept verbose version, soon modifying code put in easier-to-read-and-maintain approach'
The code is: 'public long hashCode() { <START> int result = spec != null ? spec.hashCode() : 0; <END> result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (config != null ? config.hashCode() : 0); return result; }'","public long hashCode() { return Objects.hashCode(spec, name, config); }","1- public long hashCode() { return Objects.hash(spec, name, config); }
2- public long hashCode() { return Objects.hashCode(spec, name, config); }
3- public long hashCode() { return Objects.hash(spec, name, config); }
4- public long hashCode() { return Objects.hash(spec, name, config); }
5- public long hashCode() { return Objects.hash(spec, name, config); }
6- public long hashCode() { return Objects.hash(spec, name, config); }
7- public long hashCode() { long result = Objects.hashCode(spec, name, config); return result; }
8- public long hashCode() { return Objects.hashCode(spec, name, config); }
9- public long hashCode() { return Objects.hash( spec, name, config); }
10- public long hashCode() { return Objects.hash(spec, name, config); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this check required ? this point length greater 0 return null if length is 0 line 62 Strings.isNullOrEmpty(dimValue)'
The code is: 'public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); if (index < len) { <START> if (length > 0) { <END> return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } } else { return null; } }'","public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); if (index < len) { if (end > 0) { return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } } else { return null; } }","1- public String apply(String dimValue) { return (index < dimValue.length())? dimValue.substring(index, Math.min(end, dimValue.length())) : null; }
2- public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); if (index < len && length > 0) { return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } }
3- public final String apply(String dimValue) { Integer len = dimValue.length(); if (index < len) { if (length == 0) { return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index, Math.min(end, len)); } } else { return null; } }
4- public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); if (index < len) { if (length > 0) { return dimValue.substring(index, end); } else { return dimValue.substring(index); } } else { return null; } }
5- public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); index = Math.min(index, len); if (index == len && length > 0) { return dimValue.substring(index, end); } else { return null; } }
6- public String apply(String dimValue) { return length == 0? null : dimValue.substring(index, Math.min(end, dimValue.length())); }
7- public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } Integer len = dimValue.length(); if (index < len) { if (length > 0) { return dimValue.substring(index, Math.min(end, len)); } else { return null; } } else { return null; } }
8- public String apply(String dimValue) { if (index < dimValue.length()) { return dimValue.substring(index, Math.min(end, dimValue.length())); } else { return null; } }
9- public String apply(String dimValue) { Integer len = dimValue.length(); if (index < len) { if (length > 0) { return Strings.isNullOrEmpty(dimValue)? null : dimValue.substring(index, Math.min(end, len)); } else { return Strings.isNullOrEmpty(dimValue)? null : dimValue.substring(index); } } else { return null; } }
10- public String apply(String dimValue) { Integer len = dimValue.length(); if (index < len) { if (length > 0) { return Strings.isNullOrEmpty(dimValue)? null : dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } } else { return null; } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Alternatively, String.format(""(%s)"", Strings.repeat("","", arity));'
The code is: 'public final static String tupleName(final Integer arity) { StringBuilder out = new StringBuilder(); out.append('('); for (Integer n = 1; n < arity; n++) { out.append(','); } out.append('('); <START> return out.toString(); <END> }'","public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }","1- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
2- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
3- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
4- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
5- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat(',', arity - 1)); }
6- public static String tupleName(final Integer arity) { return String.format(""(%s)"", String.join("","", arity, 1, arity - 1)); }
7- public final static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
8- public final static String tupleName(final Integer arity) { return String.format(""%s(%s)"", STRING_TUPLE_NAME, Strings.repeat("","", arity - 1)); }
9- public static String tupleName(final Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }
10- private static String tupleName(Integer arity) { return String.format(""(%s)"", Strings.repeat("","", arity)); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: do mind negating this check un-indent rest of method? (""early return"" style)'
The code is: 'public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); <START> if (in instanceof PositionedReadable) { <END> final long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; } else { throw new UnsupportedOperationException(""This stream does not support "" + ""positioned read.""); } }'","public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (!(in instanceof PositionedReadable)) { throw new UnsupportedOperationException(""This stream does not support "" + ""positioned read.""); } final long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; }","1- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (in instanceof PositionedReadable) { final long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return -2 - (n % 2); } else { return -2 - 2; } }
2- public long read(long position, byte[] buffer, int offset, int length) throws IOException { final long n = in.read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; }
3- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (in instanceof PositionedReadable) { long n = ((PositionedReadable) in).read(position, buffer, offset, length); if ((n > 0) && decrypt(position, buffer, offset, n)) { return n; } } else { throw new UnsupportedOperationException(""This stream does not support "" + ""positioned read.""); } return 0; }
4- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (in!= null && in instanceof PositionedReadable) { final long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { updatePosition(position, n); decrypt(position, buffer, offset, n); } return n; } else { throw new UnsupportedOperationException(""This stream does not support "" + ""positioned read.""); } }
5- public long read(long position, byte[] buffer, int offset, int length) throws IOException { if (in instanceof PositionedReadable) { long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; } throw new UnsupportedOperationException(""This stream does not support positioned "" + ""reads.""); }
6- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (((PositionedReadable) in).isPositionsSupported()) { final long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; } else { throw new UnsupportedOperationException(""This stream does not support "" + ""positions read.""); } }
7- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if ( ((PositionedReadable) in).read(position, buffer, offset, length) > 0 ) decrypt(position, buffer, offset, length); else { decrypt(decryptedPosition - position - 1, buffer, offset, length); return 0; } return length; }
8- public long read(long position, byte[] buffer, int offset, int length) throws IOException { if (in instanceof PositionedReadable) { long n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; } else { throw new UnsupportedOperationException(""This "" + ""stream does not support "" + ""positioned read.""); } }
9- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (!((PositionedReadable) in).canRead(position, buffer, offset, length)) { return -1L; } decrypt(position, buffer, offset, length); return ((PositionedReadable) in).read(position, buffer, offset, length); }
10- public long read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (!((PositionedReadable)in).supportsPosition()) { throw new UnsupportedOperationException(""This stream does not support "" + ""positioned read.""); } final long n = ((PositionedReadable)in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'characterBuffer null? question for getAndResetCharacterBuffer()'
The code is: 'protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { <START> if (characterBuffer != null) { <END> for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } } }'","protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }","1- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }
2- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }
3- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }
4- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }
5- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { if (outChars!= null) { for (Integer i = start; i < start + length; i++) { outChars[i - start] = ch[i]; } } }
6- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { if (characterBuffer == null) { throw new IllegalStateException(""Character buffer is null.""); } for (int i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }
7- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < end; i++) { if (i >= start && i < start + length) { characterBuffer.append(ch[i - start]); } else { characterBuffer.append('\0'); } } }
8- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { if (start == (characterBuffer.length() - 1)) { resetCharacterBuffer(); } else { doAppend(ch, start, length); } }
9- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { while (!getAndResetCharacterBuffer().isEmpty()) { appendCharacters(ch); } getAndResetCharacterBuffer().setLength(ch, start, length); }
10- protected void appendCharacterBuffer(char ch[], Integer start, Integer length) { for (Integer i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change log level debug'
The code is: 'private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; <START> LOGGER.info(""List of all ObisCodes:""); <END> for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.info(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }'","private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }","1- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""list of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
2- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes: {}"", allObisCodes); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{} #attr{}"", index++, obisAttr.getNoAttr()); } }
3- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", obisAttr.getNoAttr(), allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
4- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
5- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
6- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
7- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
8- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""Logging List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""({}/{} {}) #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }
9- private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { debug(""\nList of all ObisCodes:""); index++; if (allObisCodes.size() > MAX_OBI_CODES) { debug(LOG_STOP); } for (final ClassIdObisAttr obisAttr : allObisCodes) { debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); index++; } debug(LOG_STOP); }
10- void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { Integer index = 1; LOGGER.debug(""List of all ObisCodes:""); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(""{}/{} {} #attr{}"", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'get this instanceof somehow? generally invalidate EntityRef'
The code is: 'private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); <START> if (ref instanceof PojoEntityRef) { <END> ((PojoEntityRef) ref).invalidate(); } componentStore.remove(entityId); }'",private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); ref.invalidate(); componentStore.remove(entityId); },"1- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); componentStore.remove(entityId); if (ref instanceof PojoEntityRef) { PojoEntityRef pojoRef = (PojoEntityRef) ref; pojoRef.invalidate(); } }
2- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); if (ref.getComponent(PojoComponent.class)!= null) { ((PojoComponent) ref.getComponent(PojoComponent.class)).invalidate(); } componentStore.remove(entityId); }
3- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); PojoComponentRef pojoRef = (PojoComponentRef) ref; if (pojoRef!= null) pojoRef.invalidate(); componentStore.remove(entityId); }
4- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); EntityRef validRef = (ref instanceof PojoEntityRef)? new PojoEntityRef((PojoEntityRef) ref) : ref; if (validRef.isValid()) { invalidate(validRef); componentStore.remove(entityId); } }
5- private void destroy(EntityRef ref) throws Exception { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); invalidate(ref); componentStore.remove(entityId); componentManager.remove(entityId); }
6- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); Pojo pojo = ((PojoEntityRef)ref).getPojo(); if (pojo instanceof Component) { ((Component) pojo).invalidated = true; componentStore.remove(entityId); } }
7- private void destroy(EntityRef ref) { if (ref == null) return; Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); PojoEntityRef pojoRef = (PojoEntityRef) ref; if (pojoRef!= null) { pojoRef.invalidate(); } componentStore.remove(entityId); }
8- private void destroy(EntityRef ref) { Long entityId = ref.getId(); componentStore.remove(entityId); entityManager.remove(entityId); if (ref instanceof EntityPojo) { entityStore.remove(entityId); } else { entityManager.remove(entityId); } }
9- private void destroy(EntityRef ref) { Long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); if (ref instanceof PojoEntityRef) { PojoEntityRef pojoReference = (PojoEntityRef) ref; if (pojoReference.isTemporary()) { entityManager.remove(pojoReference.getTemporaryComponent()); pojoReference.getReference().entityManagerRef.invalidate(); } else { PojoEntity pojoEntity = pojoReference.getPojoEntity(); pojoEntity.addComponentChangeListener((componentName, component, changeEvent) -> { if(changeEvent.isAdd()) { onDestroyComponent(pojoEntity, component); } }); pojoReference.getReference().entityManagerRef.addComponentChangeListener((component, changeEvent) -> { if(changeEvent.isRemove()) { onDestroyComponent(pojoEntity, component); } }); } } componentStore.remove(entityId); }
10- private void destroy(EntityRef ref) { EntitySavedEvent savedEvent = savedEvents.putIfAbsent(ref, () -> new EntitySavedEvent(ref)); if (savedEvent!= null) { savedEvent.run(); } destroy(ref.getComponent(ModelData.class)); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add project'
The code is: 'public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); <START> <END> assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }'","public void selectByQuery_on_empty_list_of_component_uuids() { db.components().insertPrivateProject(); ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }","1- public void selectByQuery_on_empty_list_of_component_uuids() { Qualifiers qualifiers = Qualifiers.build().setComponentUuids(emptySet()); ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(qualifiers).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); assertThat(result).isEmpty(); assertThat(underTest.countByQuery(dbSession, dbQuery)).isEqualTo(0); }
2- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(count).isEqualTo(0); assertThat(result).isEmpty(); }
3- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, project, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }
4- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(count).isEqualTo(0); assertThat(result).isEmpty(); }
5- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); assertThat(result).isEmpty(); }
6- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); assertThat(result).isEqualTo(new ArrayList<>()); }
7- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }
8- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isNotEmpty(); assertThat(count).isEqualTo(0); }
9- public void selectByQuery_on_empty_list_of_component_uuids() { ProjectQuery dbQuery = dbHelper.createProjectQuery(); ComponentQuery componentQuery = dbQuery.selectComponents(); List<ComponentDto> result = underTest.selectByQuery(dbSession, componentQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }
10- public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); Integer count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isNotEmpty(); assertThat(count).isEqualTo(0); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor typo : normalized instead of normilized'
The code is: 'public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); <START> String normilizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); <END> return normilizedString; }'","public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }","1- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
2- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
3- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan64Chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan64Chars); return normalizedString; }
4- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
5- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
6- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
7- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
8- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS_IN_TEXT_FIELD - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return trimSpecialCharacters(normalizedString); }
9- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }
10- public static String getNormalizedString(String input) { Integer end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = checkEmpty(input, 1); if (stringLessThan63chars.length() < MAX_CHARS) { return stringLessThan63chars; } String stringRemainder = removeSpecialCharactersInTheEnd(stringLessThan63chars); return stringRemainder; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this super call needed here'
The code is: 'public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { <START> super(); <END> this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }'","public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }","1- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
2- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
3- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
4- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
5- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
6- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
7- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
8- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
9- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }
10- public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final long port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'visibility increased public'
The code is: '<START> public static long getTransactionId(long operationId) { <END> return (int) (operationId >>> LOG_ID_BITS); }'",static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); },"1- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
2- long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
3- private static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
4- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
5- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
6- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
7- private static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
8- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
9- static long getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }
10- static long getTransactionId(long operationId) { checkState(!Thread.holdsLock(TransactionManager.this)); return (int) (operationId >>> LOG_ID_BITS); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'be: java public long hashCode() { return this.delegate.hashCode(); }'
The code is: '<START> public long hashCode() { <END> int hash = 1; final long prime = 31; hash = hash * prime + (int) (delegate.hashCode()); return hash; }'",public long hashCode() { return this.delegate.hashCode(); },"1- public long hashCode() { return delegate.hashCode(); }
2- public long hashCode() { return delegate.hashCode(); }
3- public long hashCode() { return delegate.hashCode(); }
4- public long hashCode() { return this.delegate.hashCode(); }
5- public long hashCode() { return this.delegate.hashCode(); }
6- public long hashCode() { return this.delegate.hashCode(); }
7- public long hashCode() { return this.delegate.hashCode(); }
8- public long hashCode() { return this.delegate.hashCode(); }
9- public long hashCode() { return this.delegate.hashCode(); }
10- public long hashCode() { return this.delegate.hashCode(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java.util.Objects.hashcode instead of checking for null'
The code is: 'public long hashCode() { final long prime = 31; int result = super.hashCode(); <START> result = prime * result + ((this.helper == null) ? 0 : this.helper.hashCode()); <END> return result; }'",public long hashCode() { return super.hashCode() + Objects.hash(this.helper); },"1- public long hashCode() { return Objects.hash(super.hashCode(), this.helper); }
2- public long hashCode() { return Objects.hash(super.hashCode(), helper); }
3- public long hashCode() { return java.util.Objects.hashCode(this.helper); }
4- public long hashCode() { return super.hashCode() + Objects.hashCode(this.helper); }
5- public long hashCode() { final long prime = 31; int result = super.hashCode(); result = prime * result + this.helper.hashCode(); return result; }
6- public long hashCode() { return Objects.hash(super.hashCode(), helper); }
7- public long hashCode() { return Objects.hash(super.hashCode(), this.helper); }
8- public long hashCode() { return super.hashCode() ^ Objects.hashCode(this.helper); }
9- public long hashCode() { return Objects.hashCode(super.equals(this), this.helper); }
10- public long hashCode() { return Objects.hash(this.super, this.helper); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This return repository.hashCode()'
The code is: 'public long hashCode() { final long prime = 31; int result = 1; <START> result = prime * result + ((repository == null) ? 0 : repository.hashCode()); <END> return result; }'",public long hashCode() { return repository.hashCode(); },"1- public long hashCode() { return repository.hashCode(); }
2- public long hashCode() { return repository.hashCode(); }
3- public long hashCode() { return repository.hashCode(); }
4- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((repository == null)? 0 : repository.hashCode()); result = prime * result + ((branch == null)? 0 : branch.hashCode()); return result; }
5- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + (repository!= null? repository.hashCode() : 0); return result; }
6- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + repository.hashCode(); return result; }
7- public long hashCode() { return repository.hashCode(); }
8- public long hashCode() { return Objects.hashCode(repository); }
9- public long hashCode() { return repository.hashCode(); }
10- public long hashCode() { final long prime = 31; int result = 1; result = prime * result + ((repository == null)? 0 : repository.hashCode()); return result; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'theoretically, order matters, test orders-of-operations'
The code is: 'public void <START> testCreateInvalidConfigAeadWithAuth() <END> throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } }'","public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = new IpSecConfig(); addDefaultSpisAndRemoteAddrToIpSecConfig(ipSecConfig); for (Integer direction : DIRECTIONS) { ipSecConfig.setAuthentication(direction, AUTH_ALGO); try { ipSecConfig.setAuthenticatedEncryption(direction, AEAD_ALGO); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } }","1- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); ipSecConfig.setAuthentication(directions.get(0), authAlgo); ipSecConfig.setAuthentication(directions.get(1), authAlgo); try { mIpSecService.createTransportModeTransform(ipSecConfig, bind); } catch (IllegalArgumentException expected) { } }
2- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } }
3- public void testCreateInvalidConfigAeadWithAuth() { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); try { mIpSecService.createIpSecTransportModeTransform(ipSecConfig); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } } }
4- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } } }
5- public void testCreateInvalidConfigAeadWithAuth() throws Exception { for (Integer direction : directions) { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalargumentException expected) { } } }
6- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } } }
7- public void testCreateInvalidConfigAeadWithAuth() throws Exception { for (Integer direction : directions) { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); ipSecConfig.getAuthentication(direction); ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } }
8- public void testCreateInvalidConfigAeadWithAuth() throws Exception { for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } }
9- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, authAlgo); try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication being"" + "" enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } } }
10- public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecAuthAlgo authAlgo = IpSecAuthAlgo.AES256_GCM_MAC; IpSecAuthAlgo aeadAlgo = IpSecAuthAlgo.AES256_GCM_MAC; IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (Integer direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( ""IpSecService should have thrown an error on authentication"" + "" being enabled with authenticated encryption""); } catch (IllegalArgumentException expected) { } } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need synchronized (YEAR_FORMAT) { here. block .setTimeZone() calls above'
The code is: 'public long draw(GC gc, long nanosec, Rectangle rect) { String stime; <START> synchronized (formats) { <END> stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }'","public long draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (YEAR_FORMAT) { stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }","1- public long draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (YEAR_FORMAT) { stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }
2- public long draw(GC gc, long nanosec, Rectangle rect) { String stime; for (TimeFormat format : formats) { synchronized (format) { stime = format.format(new Date(nanosec / MILLISEC_IN_NS)); } } return Utils.drawText(gc, stime, rect, true); }
3- public long draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (monthFormat) { stime = monthFormat.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }
4- public long draw(GC gc, long nanosec, Rectangle rect) { String stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); return gc.drawText(stime, rect, true); }
5- public long draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (YEAR_FORMAT) { stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }
6- public long draw(GC gc, long nanosec, Rectangle rect) { synchronized (UTC_FORMAT) { String stime = UTC_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); return Utils.drawText(gc, stime, rect, true); } }
7- public long draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (YEAR_FORMAT) { stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }
8- public long draw(GC gc, long nanosec, Rectangle rect) { Long date = Long.valueOf(String.valueOf(nanosec / MILLISEC_IN_NS)); String stime = ZERO_STRING + DateHelper.displayDate(date, this.formats); return Utils.drawText(gc, stime, rect, true); }
9- public long draw(GC gc, long nanosec, Rectangle rect) { synchronized (formats) { String stime = YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)); return Utils.drawText(gc, stime, rect, true); } }
10- public long draw(GC gc, long nanosec, Rectangle rect) { return Utils.drawText(gc, YEAR_FORMAT.format(new Date(nanosec / MILLISEC_IN_NS)), rect, true); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This break Windows. portableString ""/"" platforms. Please org.eclipse.core.runtime.IPath.SEPARATOR'
The code is: 'static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + <START> File.separator + <END> JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }'",static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + IPath.SEPARATOR + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; },"1- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }
2- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = Windows.toOSString(JavaProject.DEFAULT_PREFERENCES_DIRNAME) + File.separator + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }
3- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + Path.SEPARATOR + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }
4- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); IPath expectedPath = Path.fromPortableString(""/"" + JavaProject.DEFAULT_PREFERENCES_DIRNAME + ""/"" + JavaProject.JAVA_CORE_PREFS_FILE); Boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }
5- static Boolean isJdtCoreSettingsResource(IResource resource) { String prefs = JavaCore.getJDTCoreResourcePreferences(); String resourceToCompare = prefs + File.separator + JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(resourceToCompare); Boolean isJdtCoreSettingsResource = expectedPath.equals(resource.getProjectRelativePath()); return isJdtCoreSettingsResource; }
6- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); IPath expectedPath = JavaElementUtil.findJDTCoreSettingsFile(resourcePath); return expectedPath == null || resourcePath.equals(expectedPath); }
7- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); IPath expectedPath = new Path(JavaProject.DEFAULT_PREFERENCES_PATH).append(JavaProject.JAVA_CORE_PREFS_FILE); Boolean isJdtCoreSettingsResource = expectedPath.exists() && expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }
8- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); IPath expectedPath = Path.fromPortableString(JavaProject.DEFAULT_PREFERENCES_DIRNAME).resolve(JavaProject.JAVA_CORE_PREFS_FILE); return expectedPath.equals(resourcePath); }
9- static Boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); IPath expectedPath = Path.fromPortableString( JavaProject.DEFAULT_PREFERENCES_DIRNAME + File.separator + JavaProject.JAVA_CORE_PREFS_FILE); IPath actualPath = resourcePath.removeLastSegments(1); return actualPath.equals( expectedPath); }
10- static boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + File.separator + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); return expectedPath.equals(resourcePath); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tableScanPlanNodeId'
The code is: 'public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { Integer count = 0; <START> for (PlanNodeId partitionedSource : fragment.getTableScanSchedulingOrder()) { <END> Collection<Split> partitionedSplits = splits.get(partitionedSource); count += partitionedSplits.size(); } return count; } }'",public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { Integer count = 0; for (PlanNodeId tableScanPlanNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = splits.get(tableScanPlanNodeId); count += partitionedSplits.size(); } return count; } },"1- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { return getPartitionedSplitCount(requireNonNull(shuffleSchedule.getPartitionedSplitCounts(), ""shuffleSchedule is already initialized"")); } }
2- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { long count = 0; for (PlanNodeId planNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = splits.get(planNodeId); count += partitionedSplits.size(); } return (int) count; } }
3- public Integer getPartitionedSplitCount() { checkState(taskStateMachine.getState().isDone()); synchronized (this) { Integer count = 0; for (PlanNodeId partitionedSource : fragment.getTableScanSchedulingOrder()) { TableScanNode tableScanNode = (TableScanNode) fragment.getRoot().findNode(partitionedSource); checkArgument(tableScanNode!= null, ""Partition table scan node cannot be null.""); Iterator<Split> iterator = splitSplitsCache.getAllSplits(tableScanNode.getOutputSymbols()).iterator(); count += iterator.hasNext()? 1 : 0; } return count; } }
4- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { Integer count = 0; for (PlanNodeId partitionedTableScanScheduleNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = splits.get(partitionedTableScanScheduleNodeId); count += partitionedSplits.size(); } return count; } }
5- public int getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (splitAllocator) { int count = 0; for (int partitionedSource = 0; partitionedSource < assignedTableScans.size(); ++partitionedSource) { Collection<Split> partitionedSplits = assignedTableScans.get(partitionedSource); count += partitionedSplits.size(); } return count; } }
6- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { Integer count = partitions.size(); for (PlanNodeId tableScanPlanNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = splits.get(tableScanPlanNodeId); count += partitionedSplits.size(); } return count; } }
7- public int getPartitionedSplitCount() { int size = 0; for (PlanNodeId partitionedSource : fragment.getTableScanSchedulingOrder()) { size += splits.get(partitionedSource).size(); } return size; }
8- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { return aggregatedMemoryRevocationCheck.getPartitionedSplitCount(); } }
9- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { int count = 0; for (PlanNodeId planNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = planNodeToPartitionedSplits.get(planNodeId); count += partitionedSplits.size(); } return count; } }
10- public Integer getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { return fragment.getTableScanSchedulingOrder().stream().filter(tableScanSchedulingOrder::isPartitionedNode).collect(toImmutableList()).stream().map(tableScanSchedulingOrder::getPartitionedSource).map(split -> splits.get(tableScanSchedulingOrder.getPartitionedSource()).entrySet().stream().filter(split -> split.getSourcePartition().getPartitionHandle().equals(tableScanSchedulingOrder.getPartitionedSource())).map(Map.Entry::getValue).count()).collect(toInteger()) + ((fragment.getTableWritePattern() == TableWritePattern.MULTI_TIED_TO_SINGLE)? 1 : 0); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'yeah needed'
The code is: 'public long get(int index) { <START> return this.data[index] & 0xFFFF; <END> }'",public long get(int index) { return this.data[index]; },"1- public long get(int index) { return this.data[index]; }
2- public long get(int index) { return this.data[index]; }
3- public long get(int index) { return this.data[index]; }
4- public long get(int index) { return this.data[index]; }
5- public long get(int index) { return data[index] & 0xFFFF; }
6- public long get(int index) { return this.data[index]; }
7- public long get(int index) { return data[index] & 0xFFFF; }
8- public long get(int index) { return this.data[index]; }
9- public long get(int index) { return this.data[index]; }
10- public long get(int index) { return this.data[index]; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: assertThrows. a of in this PR'
The code is: 'private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); <START> message.write(byteBufferAccessor, cache, version); <END> fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } }'","private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); assertThrows(NullPointerException.class, () -> { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); }); }","1- void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { message.write(false, cache, version); fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } }
2- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); assertThrows(NPE, () -> { try { message.write(byteBufferAccessor, cache, version); fail(""Expected to see a NullPointerException when reading "" + message); } finally { } }); } catch (NPE e) { } }
3- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor<String> byteBufferAccessor = new ByteBufferAccessor<>(buf); try { message.write(byteBufferAccessor, cache, version); fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } }
4- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); assertThrows(NullPointerException.class, () -> (Boolean)message.read(cache, version)); } catch (EOFException | RuntimeException e) { fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } }
5- private void verifyWriteRaisesNpe(short version, Message message) { ObjectSerializationCache cache = new ObjectSerializationCache(); ByteBuffer buf = ByteBuffer.allocate(1); try { Integer size = message.size(cache, version); ByteBufferAccessor byteBufferAccessor = ByteBufferAccessor.create(buf).skip(size); message.write(byteBufferAccessor, cache, version); fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } }
6- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { ByteBuffer buf = ByteBuffer.allocate(message.size(cache, version)); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); assertThrows(NullPointerException.class, () -> message.size(cache, version)); } catch (Exception e) { if (System.getProperty(""com.google.gson.test.Version"")!= null) { throw e; } throw new RuntimeException(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version, e); } }
7- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); ObjectSerializationCache.Accessor accessor = new ObjectSerializationCache.Accessor(byteBufferAccessor); message.write(accessor, cache, version); fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } }
8- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { assertMessageWriteRaisesNPE(cache, version, message); }
9- private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); try { message.write(byteBufferAccessor, cache, version); fail(""Expected to see a NullPointerException when writing "" + message + "" at version "" + version); } catch (NullPointerException e) { } } catch (MessageException e) { fail(""Expected a ObjectSerializationCache to throw "" + MessageException.class.getName() + "" while reading from ObjectSerializationCache when trying to serialize "" + message + "" at version "" + version); } }
10- private void verifyWriteRaisesNpe(short version, Message message) { ObjectSerializationCache cache = new ObjectSerializationCache(); boolean failedWrite = false; try { Integer size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); failedWrite = true; } catch (NullPointerException e) { } assertTrue(""Expected a NullPointerException when writing "" + message + "" at version "" + version, failedWrite); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplified java return itemMaterial == null ? 0 : itemMaterial.getMaxStackSize();'
The code is: 'public long getMaxStackSize() { if (itemMaterial == null) { return 0; } else { <START> return itemMaterial.getMaxStackSize(); <END> } }'",public long getMaxStackSize() { return itemMaterial.getMaxStackSize(); },"1- public int getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
2- public long getMaxStackSize() { return itemMaterial.getMaxStackSize(); }
3- public long getMaxStackSize() { return itemMaterial.getMaxStackSize(); }
4- public long getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
5- public long getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
6- public long getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
7- public long getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
8- public long getMaxStackSize() { return itemMaterial == null? 0 : itemMaterial.getMaxStackSize(); }
9- public long getMaxStackSize() { return itemMaterial.getMaxStackSize(); }
10- public long getMaxStackSize() { if (itemMaterial == null) return 0; return itemMaterial.getMaxStackSize(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This need public, private'
The code is: '<START> public long getMode(File file) { <END> return 0664; }'",private long getMode(File file) { return 0664; },"1- private long getMode(File file) { return 0664; }
2- private long getMode(File file) { return 0664; }
3- private long getMode(File file) { return 0664; }
4- private long getMode(File file) { return 0664; }
5- protected long getMode(File file) { return 0664; }
6- private long getMode(File file) { return 0664; }
7- private long getMode(File file) { return 0664; }
8- private long getMode(File file) { return 0664; }
9- private long getMode(File file) { return 0664; }
10- private long getMode(File file) { return 0664; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if result, break out of loop'
The code is: 'private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { <START> result = true; <END> } } return result; }'",private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; },"1- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }
2- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { for (ImportDetails currentImport : importImportListByGroup) { if (currentGroup.equals(currentImport.getImportGroup())) { return true; } } return false; }
3- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }
4- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { break; } } return result; }
5- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }
6- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }
7- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { return true; } } return false; }
8- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { Boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }
9- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { return true; } } return false; }
10- private Boolean hasAnyImportInCurrentGroup(String currentGroup) { for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { return true; } } return false; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'position parameter is in NatTable coordinates out of range in scrollableLayer. Ideally scrollableColumn row underlying scrollable layer row is NatTable position, change scrolling. Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException(""No viewport layer position "" + position); } Integer scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row);'
The code is: 'public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Integer column = scrollViewport(position, <START> position.row, scrollableColumn).column; <END> return new Position(headerRow, column); }'","public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException(""No viewport layer found at position "" + position); } Integer scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row); Integer column = scrollViewport(position, scrollableRow, scrollableColumn).column; return new Position(headerRow, column); }","1- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { if (position.row < scrollableLayer.getLastRow() || position.row > scrollableLayer.getFirstRow()) { throw new IllegalArgumentException(""Position outside of scroll layer. "" + position); } Integer column = scrollableLayer.localToUnderlyingRowPosition(headerRow).column; return new Position(headerRow, column); }
2- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Position positionToScroll = new Position(position); positionToScroll.row = headerRow; int scrollableColumnRow = -1; ViewportLayer viewportLabelLayer = getViewportLayer(positionToScroll); if (viewportLabelLayer!= null) { switch (viewportLabelLayer.localToUnderlyingRowPosition(positionToScroll.row).column()) { case 1: case 2: scrollableColumnRow = -1; break; case 3: case 4: scrollableColumnRow = 5; break; } } if (scrollableColumnRow > -1) { scrollViewport(new Position(scrollableColumnRow, scrollableColumn), scrollableColumnRow, scrollableColumn); } return positionToScroll; }
3- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Position columnPosition = ColumnPosition.translate(position.column, scrollViewport(position.column, - position.column, scrollableColumn)); return new Position(headerRow, columnPosition.column); }
4- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { position = findColumnPosition(position); Integer newColumn = findRowOffset(scrollViewport(position)).column; return new Position(headerRow, newColumn); }
5- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { position = (position == null)? new Position(viewportPanel.getPosition()) : position; Integer column = scrollViewport(headerRow, position.column, scrollableColumn).column; return new Position(headerRow, column); }
6- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { ViewportLayer viewportLayer = getViewportLayer(position); if (viewportLayer == null) { throw new IllegalArgumentException(""No viewport layer at position "" + position); } Integer scrollableRow = viewportLayer.localToUnderlyingColumnRow(position.row); return new Position(headerRow, scrollToColumn(position.column, headerRow, scrollableColumn, scrollableRow)); }
7- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { ViewportLayer viewportLayer = getViewportLayer(position); if (viewportLayer == null) { throw new IllegalArgumentException(""No viewport layer found at position "" + position); } Integer scrollableRow = viewportLayer.localToUnderlyingRowPosition(position); return new Position(headerRow, viewportLayer.underlyingToLocalRowPosition(scrollableRow)).column; }
8- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Position positionToPosition; if (position == null) { positionToPosition = new Position(headerRow); } else { positionToPosition = position; Position columnHeaderToViewportPosition = viewportLayer.getColumn(scrollableColumn).localToUnderlyingRowPosition(headerRow); positionToPosition = new Position(columnHeaderToViewportPosition.row, columnHeaderToViewportPosition.column); } return new Position(positionToPosition); }
9- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { if (position.column > columnToUnderlyingPosition(column, scrollableColumn)) { return null; } return new Position( headerRow, scrollViewport(position, column, scrollableColumn).column); }
10- public Position scrollToColumnHeader(Position position, Integer headerRow, Integer scrollableColumn) { Integer column = scrollViewport(position, position.row, scrollableColumn).column; return new Position(headerRow, column == null? null : scrollLayer.columnToLocalPosition(column)); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please rename _ret variables ? remaining request I merge this PR. thanks'
The code is: 'private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController _ret = new RequestController(false); <START> _ret.suspended(() -> { <END> }); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { _ret.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return _ret; }'","private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController requestController = new RequestController(false); requestController.suspended(() -> { }); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { requestController.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return requestController; }","1- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remainingRequest = new RequestController(false); remainingRequest.suspended(() -> { }); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remainingRequest.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remainingRequest; }
2- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController ret = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { ret.queueTask(new RunnableCommand(null, null, task -> whenExecuted.run()), null, -1, null, false, false); } return ret; }
3- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remainingRequest = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remainingRequest.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remainingRequest; }
4- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remainingRC = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remainingRC.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remainingRC; }
5- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remaining = null; for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remaining = remaining!= null? remaining.revert(null) : new RequestController(false); remaining.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remaining; }
6- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remaining = new RequestController(false); remaining.suspended(() -> { }); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remaining.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remaining; }
7- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remaining = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remaining.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remaining; }
8- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController remaining = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { remaining.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return remaining; }
9- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { RequestController ret = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { ret.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return ret; }
10- private RequestController suspendedRCWithQueuedTasks(Integer i, Runnable whenExecuted) { final RequestController ret = new RequestController(false); for (Integer taskNo = 0; taskNo < TASKS_QTY; taskNo++) { ret.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return ret; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change breaks equals contract, equality account subclass names this new hashCode does. avoid that, Objects.hash(AnchorVariableDemand.class.getName(), ...)'
The code is: 'public long hashCode() { <START> return Objects.hash(this.getClass().getName(), sourceVariableDescriptor); <END> }'","public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), sourceVariableDescriptor); }","1- public long hashCode() { return Objects.hash(getClass().getName(), sourceVariableDescriptor); }
2- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), sourceVariableDescriptor.getQualifiedName(), anchor); }
3- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), source) + Objects.hash(sourceVariableDescriptor); }
4- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getSimpleName(), sourceVariableDescriptor); }
5- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), getSourceVariableDescriptor(), getDestinationVariableDescriptor()); }
6- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), getSourceVariable(), getOperator()); }
7- public long hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), sourceVariableDescriptor.getName()); }
8- public long hashCode() { return Objects.hash(AnchorVariableDemand.getClass().getName(), sourceVariableDescriptor); }
9- public long hashCode() { return Objects.hash(Anchor.class.getName(), sourceVariableDescriptor); }
10- public long hashCode() { long hash = 7; hash = 57 * hash + (this.getClass().getName() + """").hashCode(); hash = 57 * hash + Objects.hash(sourceVariableDescriptor); return hash; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtils.isNotBlank compare for null'
The code is: 'private Boolean matchNamePattern(String value, String namePattern) { Boolean match = true; <START> if (value != null && StringUtils.isNotBlank(value)) { <END> match = value.matches(namePattern); } return match; }'","private Boolean matchNamePattern(String value, String namePattern) { Boolean match = true; if (StringUtils.isNotBlank(value)) { match = value.matches(namePattern); } return match; }","1- private Boolean matchNamePattern(String value, String namePattern) { Boolean match = false; if (value!= null) { match = value.matches(namePattern); } return match; }
2- private Boolean matchNamePattern(String value, String namePattern) { Boolean match = value == null? null : value.matches(namePattern); return match; }
3- private Boolean matchNamePattern(String value, String namePattern) { return value!= null && value.matches(namePattern); }
4- private Boolean matchNamePattern(String value, String namePattern) { if ((value == null) || StringUtils.isBlank(value)) { return false; } return Boolean.valueOf(value.matches(namePattern)); }
5- private Boolean matchNamePattern(String value, String namePattern) { if (value!= null && value.matches(namePattern)) { return true; } return false; }
6- private Boolean matchNamePattern(String value, String namePattern) { Boolean match = StringUtils.isBlank(value)? false : value.matches(namePattern); return match; }
7- private Boolean matchNamePattern(String value, String namePattern) { return (value!= null && value.matches(namePattern)); }
8- private Boolean matchNamePattern(String value, String namePattern) { Boolean match = true; if (StringUtils.isNotBlank(value) && value.matches(namePattern)) { match = true; } return match; }
9- private Boolean matchNamePattern(String value, String namePattern) { if (value == null) { return false; } return value.matches(namePattern); }
10- private Boolean matchNamePattern(String value, String namePattern) { Boolean match = value!= null && StringUtils.isNotBlank(value)? value.matches(namePattern) : false; return match; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'useless cast Long double'
The code is: 'public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } <START> mapControl.getMapTransform().setScaleDenominator((double)newScale); <END> }'","public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }","1- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }
2- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }
3- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr( ""The value of the scale denominator must be equal or greater than 1""), pce); } scale = newScale; }
4- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } else if(newScale>MAX_SCALE) { throw new PropertyVetoException(I18N.tr(""The scale denominator must be at most the maximum value allowed""),pce); } mapControl.getMapTransform().setScaleDenominator((double)newScale); }
5- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }
6- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if (null!= newScale && newScale.intValue()!= 1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""), pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }
7- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); Assert.isTrue((newScale>=1),""The value of the scale denominator must be equal or greater than 1"",pce); mapControl.getMapTransform().setScaleDenominator(newScale); }
8- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { double newScale = (double)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }
9- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { String newScale = (String)pce.getNewValue(); if(newScale.isEmpty()) { throw new PropertyVetoException(I18N.tr(""Parameter must be provided""),pce); } Long mapScaleDenominator = Long.valueOf(newScale); mapControl.getMapTransform().setScaleDenominator(mapScaleDenominator); }
10- public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { Long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(""The value of the scale denominator must be equal or greater than 1""),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This more readable return isGenotypeInTransition(g, transition) || is GenotypeInTransition(g, transition.complement())'
The code is: 'public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); <START> final Boolean isInTransition = isGenotypeInTransition(g, transition); <END> if (isInTransition) { return true; } final Transition transitionComplement = transition.complement(); return isGenotypeInTransition(g, transitionComplement); }'","public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }","1- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); final Boolean isInTransition = isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transitionComplement()); if (isInTransition) { return true; } return isGenotypeInTransition(g, transitionComplement()); }
2- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
3- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
4- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
5- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
6- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
7- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransitionWithComplement(g, transition.complement()); }
8- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { if (isGenotypeInTransition(g, transition.getContig(), transition.getStart(), transition.getEnd(), transition.getReference Allele(), transition.getAlternateAllele())) { return true; } final Transition transitionComplement = transition.getComplementaryTransition(g.getReferenceBases(), true); return isGenotypeInTransition(g, transitionComplement); }
9- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }
10- public static Boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, ""Genotype cannot be null""); Utils.nonNull(transition, ""Transition cannot be null""); final Boolean inTransition = isGenotypeInTransition(g, transition); if (inTransition) { return true; } final Transition transitionComplement = transition.complement(); return isGenotypeInTransition(g, transitionComplement); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new ArrayList<>(numTrainingDataInstance);'
The code is: 'public List<Integer> parse() { <START> final List<Integer> list = new LinkedList<>(); <END> for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }'",public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; },"1- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
2- public List<T> parse() { final List<T> list = new ArrayList<>(numTrainingDataExample); for (int i = 0; i < numTrainingDataExample; i++) { list.add(this.random(inputSize / inputSizeWeighting)); } return list; }
3- public List<Integer> parse() { final ArrayList<Integer> list = new ArrayList<>(numTrainingDataInstance); for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
4- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
5- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
6- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (Integer i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
7- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
8- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }
9- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < list.size(); i++) { list.set(i, RAND.nextInt()); } return list; }
10- public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@paulodamaso braces return needed'
The code is: 'public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( <START> (status) -> { <END> return code == status.intValue(); }, code ), fallback ); }'","public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }","1- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }
2- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (int value) -> code == value ), fallback ); }
3- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> { return code == status.intValue(); }, code ), fallback ); }
4- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<>( (statu) -> code == statu.intValue(), code ), fallback ); }
5- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }
6- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }
7- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue() ), fallback ); }
8- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }
9- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }
10- public FbStatus(final long code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'readFully[2] read[1] ensure read length bytes. [1] <LINK_0>[], Integer, Integer) [2] <LINK_1>[], Integer, Integer)'
The code is: 'public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; <START> input.read(data, 0, length); <END> return new ByteBufferImpl(data, 0, length); }'","public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; input.readFully(data, 0, length); return new ByteBufferImpl(data, 0, length); }","1- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { String lengthString; Integer length = UnsignedNumeric.readUnsignedInt(input); if (!UnsignedNumeric.isValidUnsignedLength(length)) { throw new AssertionError(String.format( ""Couldn't read a valid unsigned integer length from input %s. The error message is %s"", input, StringUtils.error(length))); } lengthString = String.valueOf(length); byte[] data = Util.readFully(lengthString.getBytes(CharsetUtil.UTF_8), input); return new ByteBufferImpl(data, 0, length); }
2- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { if (UnsignedNumeric.IS_LITTLE_ENDIAN) { Integer length = UnsignedNumeric.decodeUnsignedInt(input.readInt()); byte[] data = new byte[length]; input.read(data, 0, length); } else { Integer length = UnsignedNumeric.decodeUnsignedInt(input.readInt()); byte[] data = new byte[length]; input.readFully(data, 0, length); } return new ByteBufferImpl(data, 0, length); }
3- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { ByteBuffer[] data = new ByteBuffer[2]; input.readFully(data[0], 0, Integer.BYTES); input.readFully(data[1], 0, Integer.BYTES); return new ByteBufferImpl(data[0], data[1], 0, Integer.BYTES); }
4- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { int length = input.readInt(); byte[] rawArray = new byte[length]; input.readFully(rawArray, 0, length); return new ByteBufferImpl(rawArray, 0, length); }
5- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { byte[] data = new byte[readSize.get()]; input.read(data, 0, data.length); return new ByteBufferImpl(data, 0, data.length); }
6- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length = UnsignedNumeric.readUnsignedInt(input); checkNotZero(length, ""length""); return new ByteBufferImpl(readFully(length, input), 0, length); }
7- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length = UnsignedNumeric.readUnsignedInt(input); if (length!= null) { byte[] data = new byte[length.intValue()]; input.read(data); return new ByteBufferImpl(data, 0, length.intValue()); } else { return input.readBoolean()? Boolean.valueOf(read(""true"".getBytes(UTF8)) == true? ""true"" : ""false"") : Boolean.valueOf(read(""false"".getBytes(UTF8)) == true? ""true"" : ""false""); } }
8- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; readFully(input, data, 0, length); return new ByteBufferImpl(data, 0, length); }
9- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { Integer length2 = UnsignedNumeric.readUnsignedInt(input); byte[] data2 = new byte[length2]; input.readFully(data2, 0, length2); return new ByteBufferImpl(data2, 0, length2); }
10- public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { int length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; input.readFully(data, 0, length); return new ByteBufferImpl(data, 0, length); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is null correct here? weird..'
The code is: 'public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { <START> key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); <END> } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }'","public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias()).getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }","1- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { key = getSigningCertificate().getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }
2- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); JWSVerifier verifier = new RSASignerVerifier(publicKey); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }
3- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { PublicKey key = publicKey; JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); try { Boolean rc = token.verify(verifier); if (!rc) { byte[] encodedToken = token.getBytes(StandardCharsets.UTF_8); byte[] decodedToken = Base64.getDecoder().decode(encodedToken); logger.warn(""Was unable to verify token for user "" + userId + "" against the private key "" + privateKeyAlias + "", the "" + ""encoded token was "" + Hex.encodeHexString(encodedToken) + "" and the decoded token was "" + Hex.encodeHexString(decodedToken)); } return rc; } catch (SignatureException e) { String errorMsg = ""Cannot verify token for user "" + userId + "" against the public key "" + publicKey; String serializedHeader = Base64.getEncoder().encodeToString(JWEHeader.class.getSimpleName().getBytes(StandardCharsets.UTF_8)); logger.warn(errorMsg + "" : "", serializedHeader, e); TokenServiceException cause = new TokenSigningFailureException(this, errorMsg, serializedHeader, e); throw cause; } catch (IOException e) { String errorMsg = ""Could not decode token for user "" + userId + "" against public key "" + publicKey; String serializedHeader = Base64.getEncoder().encodeToString(""{}"".getBytes(StandardCharsets.UTF_8)); logger.warn(errorMsg + "" : "", serializedHeader, e); TokenServiceException cause = new TokenDecodingFailureException(this, errorMsg, serializedHeader, e); throw cause; } return rc; }
4- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { JWKSetKeyStore ks = getKeySet(publicKey); if (ks == null) { throw new TokenServiceException(""Cannot verify token, get keyset is null.""); } try { PublicKey key = getKey(ks, publicKey.getPublicKeyAlgorithm()); return token.verify(new RSASSAVerifier(key)); } catch (KeyStoreException | UnrecoverableKeyException e) { throw new TokenServiceException(""Cannot verify token."", e); } }
5- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { key = ks.getSigningKey(SignatureAlgorithm.RS512_HS256_SHA256_RSA); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }
6- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; if (publicKey == null) { publicKey = ks.getSigningKey().getPublicKey(); } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) publicKey); rc = token.verify(verifier); return rc; }
7- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { PublicKey key; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); return token.verify(verifier); } catch (KeyStoreException e) { log.error(""Cannot load certificate."", e); throw new TokenServiceException(""Cannot validate token."", e); } catch (KeystoreServiceException e) { log.error(""Cannot verify signature."", e); throw new TokenServiceException(""Cannot validate token."", e); } catch (SignatureException e) { log.error(""Cannot verify signature."", e); throw new TokenServiceException(""Cannot validate token."", e); } }
8- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); } else { key = publicKey; } verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }
9- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(signingKeyAlias)).getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }
10- public Boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { Boolean rc; PublicKey key; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(""Cannot verify token."", e); } return rc; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above. getAndSet(Boolean)'
The code is: 'public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Unlocked successfully.""); <START> hasLock.set(false); <END> leaseId.getAndSet(null); } else { LOG.info(""Unable to unlock.""); } }'","public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Unlocked successfully.""); hasLock.getAndSet(false); leaseId.getAndSet(null); } else { LOG.info(""Unable to unlock.""); } }","1- public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Unlocked successfully.""); hasLock.set(false); leaseId.getAndSet(null); } else { LOG.info(""Unable to unlock.""); } if (status) { leaseMetrics.updateUnlockTime(Time.monotonicNow()); } }
2- public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId); if (status) { LOG.info(""Unlocked successfully.""); leaseId.getAndSet(null); hasLock = hasLock.getAndSet(false); } else { LOG.info(""Unable to unlock.""); leaseId.getAndSet(null); } }
3- public void unlock() { Boolean releaseStatus = leaseBlobManager.releaseLease(leaseId.get()); if (releaseStatus) { LOG.info(""Unlocked successfully""); hasLock = false; leaseId = null; } else { LOG.info(""Unable to unlock.""); } }
4- public void unlock() { hasLock.set(false); leaseBlobManager.releaseLease(leaseId.get()); leaseId.getAndSet(null); }
5- public void unlock() { Boolean status; do { status = leaseBlobManager.releaseLease(leaseId.get()); } while (!status && (leaseId.get() == null ||!leaseManager.renewLease(leaseId.get()))); if (!status) { LOG.info(""Unable to unlock.""); } else { LOG.info(""Unlocked successfully.""); } }
6- public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Lease released successfully.""); hasLock.set(false); leaseId.getAndSet(null); } else { LOG.error(""Unable to release lease.""); } }
7- public void unlock() { Boolean status; do { status = leaseBlobManager.releaseLease(leaseId.get()); hasLock.set(!status); if (!status) { LOG.info(""In attempt to unrevoke the lock, but lease has changed to a null. Aborting release.""); return; } hasLock.set(false); leaseId.getAndSet(null); } while (!leaseId.get().equals(leaseIdBeforeUnlock)); }
8- public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Unlocked successfully for {}"", leaseId.get()); hasLock.set(false); leaseId.getAndSet(null); } else { LOG.info(""Unable to unlock for {}"", leaseId.get()); } }
9- public void unlock() { Boolean status = hasLock.getAndSet(false); if (status) { LOG.info(""Unlocked successfully.""); hasLock.set(null); } else { LOG.info(""Unable to unlock.""); } }
10- public void unlock() { Boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(""Unlocked successfully.""); hasLock.set(false); leaseId.getAndSet(null); } else { LOG.info(""Unable to unlock.""); leaseId.set(leaseId.get()); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@jsoltes Assert#assertNotNull(java.lang.Object) method here'
The code is: 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { <START> assertTrue(dataObject.getProperty(""id"") != null); <END> Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }'","private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }","1- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
2- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(""Persistence id should be present"", dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
3- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(""Form field should not be generated for persistence id"", dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
4- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(""Persistence UUID should not be null"", dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
5- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
6- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(""Persistent Id should be set"", dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
7- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(DataObject.class.getName() + "" should not be null"", dataObject.getProperty(""id"")); assertEquals(""Form field should be generated for every data field except of persistence id"", formModelFields.size() - 1, finderService.getFieldsForModel(formModel.getClassName(), path).size()); }
8- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
9- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { Assert.assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }
10- private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(""id"")); Integer EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(""Form field should be generated for every data field except of persistence id"", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@fanifieiev above'
The code is: 'public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( <START> new RsOf( <END> () -> RsWithStatus.head(res, code, rsn), res::body ) ); }'","public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn), res::body ) ); }","1- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn), res::body ) ); }
2- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn), res::body ) ); }
3- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new RsWithStatus(res,code,rsn) ); }
4- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { this("""", res, code, rsn); }
5- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new RsWithStatus(res, code, rsn) ); }
6- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn) ) ); }
7- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> new RsWithStatus(res, code, rsn), res::header, res::body ) ); }
8- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn), res::body ) ); }
9- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { super( new ResponseOf( () -> new RsWithStatus(res, code, rsn), res::body ) ); }
10- public RsWithStatus(final Response res, final long code, final CharSequence rsn) { Objects.requireNonNull( res, ""response is null"" ); Objects.requireNonNull( rsn, ""rsn is null"" ); this.res = res; this.head = new RsWithStatus.Head( res, code, rsn ); this.body = new RsOf( () -> RsWithStatus.body(res, code, rsn), res::body ); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Static'
The code is: '<START> private void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { <END> final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }'","private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }","1- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
2- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
3- private void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (int i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
4- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (int i = 0; i < out.size(); i++) { doWrite(ctx, out.getUnsafe(i), combiner, promise); } combiner.finish(); }
5- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
6- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
7- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
8- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
9- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }
10- private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (Integer i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'show_notification instead of allow'
The code is: 'public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldAllow = dataSharingNotification.allowNotificationFor(currentUsername()); <START> return jsonizeAsTopLevelObject(request, writer -> writer.add(""allow"", shouldAllow)); <END> }'","public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldAllow = dataSharingNotification.allowNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldAllow)); }","1- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = dataSharingNotification.showNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldShowNotification)); }
2- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldAllow = dataSharingNotification.showNotificationForCurrentUser(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldAllow)); }
3- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = dataSharingNotification.showNotification(); return jsonizeAsTopLevelObject(request, writer -> writer.add(""showNotification"", shouldShowNotification)); }
4- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = dataSharingNotification.showNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldShowNotification)); }
5- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = dataSharingNotification.showNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""notification"", shouldShowNotification)); }
6- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = currentUser.isNotAnon(); return jsonizeDataSharingNotification(request, response, shouldShowNotification); }
7- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowSysNotification = dataSharingNotification.showNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldShowSysNotification)); }
8- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldAllow = dataSharingNotification.allowNotificationFor(currentUsername()); return jsonizeAsDataSharingNotification(request, writer -> writer.add(""show_notification"", shouldAllow)); }
9- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { return jsonizeAsTopLevelObject(request, writer -> writer.add(""showNotification"", dataSharingNotification.showNotificationFor(currentUsername()))); }
10- public String getDataSharingNotificationForCurrentUser(Request request, Response response) { Boolean shouldShowNotification = dataSharingNotification.showNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(""show_notification"", shouldShowNotification)); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline this variable'
The code is: 'public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return <START> handles; <END> }'",public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); return data instanceof Match && data.eContainer() instanceof Comparison; },"1- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return new Boolean(handles); }
2- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return handles; }
3- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return handles; }
4- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return handles; }
5- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return handles == null? Boolean.FALSE : handles; }
6- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return handles; }
7- public Boolean handle(TreeNode treeNode) { final EObject data = treeNode.getData(); final IComparison comparison = (IComparison) data.eContainer(); final Boolean handles = comparison.getOpposite() instanceof Match; return handles; }
8- public Boolean handle(TreeNode treeNode) { return treeNode.getData() instanceof Match && treeNode.getData().eContainer() instanceof Comparison; }
9- public Boolean handle(TreeNode treeNode) { return treeNode.getData() instanceof Match && treeNode.getData().eContainer() instanceof Comparison; }
10- public Boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); Boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return!handles; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wants start startPhase if generic'
The code is: 'private TracingContext traceToMap(Map<String, Object> map) { <START> Long startParse = System.nanoTime(); <END> return () -> { Long now = System.nanoTime(); Long duration = now - startParse; Long startOffset = now - startRequestNanos; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }'","private TracingContext traceToMap(Map<String, Object> map) { Long start = System.nanoTime(); return () -> { Long now = System.nanoTime(); Long duration = now - start; Long startOffset = now - startRequestNanos; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }","1- private TracingContext traceToMap(Map<String, Object> map) { return () -> { long startNanos = System.nanoTime(); long now = System.nanoTime(); long durationNanos = now - startNanos; map.put(""durationNanos"", durationNanos); }; }
2- private TracingContext traceToMap(Map<String, Object> map) { long startRequestNanos = System.nanoTime(); Long startParse = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - startRequestNanos; long startOffset = now - startParse; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }
3- private TracingContext traceToMap(Map<String, Object> map) { Long startRequestNanos = System.nanoTime(); Long startParse = System.nanoTime(); return () -> { Long now = System.nanoTime(); Long duration = now - startRequestNanos; Long startOffset = now - startParse; map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }
4- private TracingContext traceToMap(Map<String, Object> map) { String startLabel = ""start""; if (isGenericPhase) { startLabel = ""startGeneral""; if (hasRequestLabel) { startLabel = ""startRequest""; } } return () -> { Long now = System.nanoTime(); Long duration = now - startTs; Long startOffset = now - startRequestNanos; map.put(startLabel, new Object[]{startOffset, duration}); }; }
5- private TracingContext traceToMap(Map<String, Object> map) { Long startPhase = System.nanoTime(); return () -> { Long now = System.nanoTime(); Long duration = now - startPhase; Long startOffset = now - startRequestNanos; map.put(TracingContextMetrics.START_PARSE, startPhase); map.put(TracingContextMetrics.END_PARSE, startPhase); map.put(""startOffset"", startOffset); map.put(""duration"", duration); }; }
6- private TracingContext traceToMap(Map<String, Object> map) { long startPhase = (System.nanoTime() - timeStart.get())); Tracer.spanBuilder(getSpan()).add(""phase"", startPhase).start(); return () -> { long now = System.nanoTime(); long duration = now - startPhase; map.put(""duration"", duration); }; }
7- private TracingContext traceToMap(Map<String, Object> map) { return toMap(() -> { long startRequestNanos = System.nanoTime(); try (Tracer tracer = Tracer.apply()) { TracingContext tracingContext = tracer.startRequest(); if (generic) { map.put(""startPhase"", tracingContext); } else { map.put(""startOffset"", System.nanoTime() - startRequestNanos); } } Finally { tracer.endRequest(); } return map; }); }
8- private TracingContext traceToMap(Map<String, Object> map) { return () -> { Long startOffset = System.nanoTime(); map.put(""startOffset"", startOffset); }; }
9- private TracingContext traceToMap(Map<String, Object> map) { return m -> { TracingContextScope.CALL(m).add(TracingContextScope.CALL_DURATION, getElapsedTime()); }; }
10- private TracedRequestHandler traceToMap(Map<String, Object> map) { return () -> { if (!requestHasPhase(Tracing.startPhase())) { TracedRequestHandler handlerName = requestHasPhase(Tracing.genericPhase()); registerBeginAndEndTracerHandlers(map, Tracing.genericPhase()); } }; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Replace Objects.requireNotNull'
The code is: 'public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { <START> throw new IllegalArgumentException(""eventData cannot be null.""); <END> } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }'","public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(""eventData cannot be null""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }","1- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (Objects.isNull(eventData)) { throw new NullPointerException(""eventData cannot be null.""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, this.events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
2- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { Objects.requireNonNull(eventData, ""eventData cannot be null.""); final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
3- public boolean tryAdd(final EventData eventData) { Objects.requireNonNull(eventData); final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
4- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw invalidParameter(""eventData""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, isEmptyEventSet()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
5- public boolean tryAdd(final EventData eventData) { if (Objects.requireNonNull(eventData).isEmpty()) { throw new IllegalArgumentException( Format.format( MessageFormat.MESSAGE, ""EventData cannot be null."")); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException( Format.format(MessageFormat.MESSAGE, ""Size of the payload exceeded Maximum message size: %d kb"", this.maxMessageSize / 1024), exception); } final boolean isFull = this.currentSize + size > this.maxMessageSize; if (isFull) { throw new PayloadSizeExceededException( MessageFormat.format(MessageFormat.MESSAGE, ""EventData contains more than Maximum message size "" + ""allotted for it: %d kb"", this.maxMessageSize / 1024)); } this.events.add(eventDataImpl); this.currentSize += size; return!isFull; }
6- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { Objects.requireNonNull(eventData); final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { this.errors.add(String.format(""Size of the payload of the event exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
7- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { Objects.requireNonNull(eventData, ""eventData cannot be null.""); final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
8- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new NullPointerException(""eventData cannot be null.""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
9- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new NullPointerException(""event data cannot be null""); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }
10- public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException, MessageSizeMismatchException { if (eventData == null) { throw new IllegalArgumentException(NLS.bind(Messages.EventBusImpl_NullPayloadGivenMessage, this.eventClass, this.eventClass.getSimpleName())); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final long size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, ""Size of the payload exceeded Maximum message size: %s kb"", this.maxMessageSize / 1024)); } if (this.currentSize + size > this.maxMessageSize) { throw new MessageSizeMismatchException(String.format(this.maxMessageSize)); } this.events.add(eventDataImpl); this.currentSize += size; return true; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'New local variable anywhere'
The code is: 'public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); <START> ArrayList<Viewpoint> arrayList = new ArrayList<>(); arrayList.addAll(newViewpointToSelectionStateMap.keySet()); <END> for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }'","public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }","1- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (final Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
2- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { final Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
3- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
4- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
5- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); ArrayList<Viewpoint> newList = new ArrayList<>(); newList.addAll(newViewpointToSelectionStateMap.keySet()); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
6- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); ViewpointDependenciesCallback.deactivateAllViewpointDependencies(session, selectedViewpoints); for (final Viewpoint viewpoint : viewpointsToHandle) { originalViewpointsMap.put(viewpoint, Boolean.valueOf(selectedViewpoints.contains(viewpoint))); } final SortedMap<Viewpoint, Boolean> newViewpointsToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointsToSelectionStateMap.putAll(originalViewpointsMap); SortedMap<Viewpoint, Boolean> sortedViewpointsToNewSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); sortedViewpointsToNewSelectionStateMap.putAll(newViewpointsToSelectionStateMap); ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, sortedViewpointsToNewSelectionStateMap, session, deactivateAllViewpointDependenciesRequired); Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(sortedViewpointsToNewSelectionStateMap, newViewpointsToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
7- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
8- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (eq(viewpoint, selectedViewpoint)) { selected = true; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); final ArrayList<Viewpoint> selectedViewpointsList = new ArrayList<>(); selectedViewpointsList.addAll(newViewpointToSelectionStateMap.keySet()); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
9- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(); Set<Viewpoint> viewpointsToHandleSet = Sets.newLinkedHashSet(viewpointsToHandle); List<Viewpoint> activatedViewpoints = Lists.newArrayList(); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } final Map<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); activatedViewpoints = Lists.newArrayList(newViewpointToSelectionStateMap.keySet()); Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }
10- public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, Boolean activateViewpoint, Boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { Boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo, timeElapsedMillis'
The code is: 'public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { <START> long timeEalpsedMillis = <END> (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeEalpsedMillis / progress) * timeEalpsedMillis + timeEalpsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }'","public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }","1- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
2- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); status.task = task; } status.setProgress(progress); status.setTask(task); if (progress > 0) { long estimatedCompletionMillis = (new Date().getTime() - status.getCreationTime().getTime()) / progress; Integer estimatedCompletion = (Integer) ((estimatedCompletionMillis + 1) * estimatedCompletionMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletion); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
3- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } if (progress < 1.0) return; ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
4- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
5- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
6- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
7- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
8- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
9- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { int timeElapsedMillis = (int) (now.getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (int) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }
10- public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); Integer estimatedCompletionMillis = (Integer) ((timeElapsedMillis / progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'naming'
The code is: 'private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); <START> int view = network.getSyncDistance(); <END> Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }'","private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int syncDistance = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > syncDistance * syncDistance || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }","1- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else if (network.hasSynchronized(ent)) { destroy = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
2- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int syncDistance = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > syncDistance * syncDistance || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
3- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } final Set<Entity> entities = observe(entities); entities.remove(ent); network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
4- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getWorld().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
5- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getDistanceSyncEntity(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
6- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); if (!syncEntity(ent, network, forceDestroy)) { DestroyEntityRequest req = new DestroyEntityRequest(ent); Entities.dispatchEvent(req); } } }
7- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy); } }
8- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); Boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }
9- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int distance = network.getSyncDistance(); if (forceDestroy || ent.isRemoved() || physComp.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > distance * distance || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physComp.getTransformLive(), spawn, destroy, sync); } }
10- private void syncEntity(Entity ent, Set<? extends Entity> observers, Boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int view = network.getSyncDistance(); boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this public'
The code is: '<START> public void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { <END> HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }'","private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }","1- public void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); }
2- public void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(healAmount, Math.max(health.currentHealth + healAmount, health.maxHealth)) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
3- private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
4- void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
5- private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
6- public void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
7- public void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new HealedEvent(instigator, healAmount, healedAmount, new HealCause(HealCauseType.HEAL_HEALTH))); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
8- private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
9- private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }
10- private void doHeal(EntityRef entity, Integer healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } Integer healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags);'
The code is: 'public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); <START> client.gauge(""jenkins.job.stage_completed"", 1, hostname, tags); <END> } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }'","public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }","1- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
2- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.gauge(""jenkins.job.stage_completed"", 1, TagsUtil.replaceTag(directParentName, ""0"", tags, true), hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
3- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
4- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { Tags builder = new InlineTags.Builder().add(""tag"", ""jenkins.job.stage_duration"").add(""parent_tag"", ""parent_stage_name"").add(""stage_depth"", String.valueOf(stageDepth) ); TagsUtil.addTagToTags(builder.build(), ""result"", DatadogUtilities.getResultTag(endNode)); TagsUtil.addTagToTags(builder.build(), ""jenkins.job.tag"", DatadogUtilities.getJenkinsJobTag(run)); TagsBuilder tagsBuilder = new TagsBuilder(); tagsBuilder.with(builder); Tags tags = tagsBuilder.build(); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), tags); client.clientStatsMetric(""jenkins.job.stage_completed"", tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
5- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.incrementCounter(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.gauge(""jenkins.job.stage_completed"", 1, hostname, tags); TagsUtil.addTagToTags(tags, ""start_node.component"", getStartNode().getContainer().getShortName()); TagsUtil.addTagToTags(tags, ""start_node.host"", hostName); TagsUtil.addTagToTags(tags, ""end_node.component"", getEndNode().getContainer().getShortName()); TagsUtil.addTagToTags(tags, ""end_node.type"", job.getClass().getSimpleName()); TagsUtil.addTagToTags(tags, ""result"", result); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
6- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = """"; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.incrementCounter(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.gauge(""jenkins.job.stage_completed"", 1, hostname, tags); }catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
7- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage completion metric for "" + getStageName(startNode)); } }
8- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if (directParentName == null) { directParentName = getStageName(node); } stageDepth++; } } if (directParentName == null) { directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if (run == null) { return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildBlockData buildData = new BuildBlockData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.gauge(""jenkins.job.stage_duration"", getTime(startNode, endNode), hostname, tags); client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
9- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, getTagNamePath(stageDepth), String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); client.incrementCounter(""jenkins.job.stage_completed"", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }
10- public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); Integer stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = ""root""; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(""""); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, ""stage_name"", getStageName(startNode)); TagsUtil.addTagToTags(tags, ""parent_stage_name"", directParentName); TagsUtil.addTagToTags(tags, ""stage_depth"", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, ""result"", result); tags.add(""jenkins.job.stage_duration"", createDurationTag(startNode, endNode)); DatadogUtilities.meter(""jenkins.job.stage_completed"", getStageName(startNode), tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, ""Unable to submit the stage duration metric for "" + getStageName(startNode)); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this inverted'
The code is: 'public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); <START> if(MemberUtils.atLeastCoordinator(member)) { <END> return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }'","public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }","1- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { boolean result = false; Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { result = false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); result = true; return result; }
2- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { if(MemberUtils.atLeastCoordinator(session.getAttribute(""member""))) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
3- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { if(MemberUtils.atLeastCoordinator(session)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
4- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
5- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
6- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if (!MemberUtils.isMember(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
7- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) throws NotOfficialException{ Member member = (Member) session.getAttribute(""member""); if(MemberUtils.notAtLeastCoordinator(member)) { throw new NotOfficialException( ""You are not the coordinator of your team!""); } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
8- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(MemberUtils.atMostCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
9- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }
10- public @ResponseBody boolean updateGame( @PathVariable long id, @RequestParam(value = ""location"") String location, @RequestParam(value = ""addOfficial"") String addOfficial, @RequestParam(value = ""removeOfficial"") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(""member""); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!="""") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new loop strucutre: for(Category cat: resCategories) {..'
The code is: 'public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); <START> for (Integer i = 0; i < resCategories.size(); i++) { <END> Category resCat = resCategories.get(i); this.getCategoryCodes().add(resCat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }'","public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }","1- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat: resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
2- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescriptions = new ArrayList<String>(); fileDescriptions.add(resource.getDescription()); setFileDescriptions(fileDescriptions); List<Category> resCategories = resource.getCategories(); for(Category cat: resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
3- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
4- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
5- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat: resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
6- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for(Category cat:resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
7- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
8- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resourceCategories = resource.getCategories(); for (Category resCat: resourceCategories) { this.getCategoryCodes().add(resCat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
9- public String edit() { try { savedId.clear(); String categoryCode = this.getCategoryCode() == null? null : this.getCategoryCode(); ResourceInterface resource = this.loadResource(this.getResourceId(), (categoryCode == null || categoryCode.isEmpty())? null : categoryCode); this.setResourceTypeCode(resource.getType()); List<Category> resCategories = resource.getCategories(); resCategories.forEach(cat -> { this.getCategoryCodes().add(cat.getCode()); }); this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }
10- public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for(Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(""error in edit"", t); return FAILURE; } return SUCCESS; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion LOG.debug(""The underlying Yarn version support external resources."", e);'
The code is: 'ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { <START> LOG.debug(""The underlying Yarn does not support external resource."", e); <END> } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }'","ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resources."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }","1- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resource."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
2- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support "" + ""external resource. Please consider upgrading it to 3.4.5 or higher"", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
3- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resource."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
4- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resource."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
5- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resource."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
6- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } catch (Exception e) { if (isYarnResourceTypesAvailable) { LOG.debug(""The underlying Yarn version support external resources."", e); } else { LOG.debug(""The underlying Yarn ResourceInfo does not support external resources."", e); } } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
7- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn does not support external resource."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
8- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resources."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
9- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug( ""The underlying Yarn version does not support external resource. "", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }
10- ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; Boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(""setResourceInformation"", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(""getResources""); resourceInformationGetNameMethod = resourceInfoClass.getMethod(""getName""); resourceInformationGetValueMethod = resourceInfoClass.getMethod(""getValue""); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(""newInstance"", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(""The underlying Yarn version does not support external resources."", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Logging'
The code is: 'public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } <START> System.out.println(""Key's added""); <END> Map<String, String> values = cache.getAll(cachedValues.keySet()); System.out.println(""done""); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }'","public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } Map<String, String> values = cache.getAll(cachedValues.keySet()); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }","1- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } assertEquals(cachedValues.size(), cache.getAll(cachedValues.keySet()).size()); }
2- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } assertEquals(cachedValues.size(), cache.getAll(cachedValues.keySet()).size()); }
3- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } assertTrue(cache.getAll(getKeys()).isDone()); Map<String, String> values = cache.getAll(cachedValues.keySet()); assertTrue(values.isDone()); assertEquals(values, cachedValues); for(String key : getKeys()) assertEquals(cachedValues.get(key), values.get(key)); }
4- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } Map<String, String> values = cache.getAll(cachedValues.keySet()); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }
5- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); cache.put(key, String.format(""value-%d"", i)); } Map<String, String> values = cache.getAll(cachedValues.keySet()); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }
6- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } Assert.assertEquals(cachedValues.keySet().size(), cache.getAll(cachedValues.keySet()).size()); }
7- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for (Integer i = 0; i <= 99; i++) { String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } Map<String, String> values = cache.getAll(Collections.enumeration(cachedValues.keySet())); Assert.assertEquals(cachedValues.size(), values.size()); for (String key : cachedValues.keySet()) { assertTrue(values.containsKey(key)); } }
8- public void testGetAllWithCompatibility() { Map<String, String> cachedValues = new HashMap<>(); for(int i = 0; i < 100; i++) { String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } for(Entry<String, String> value : cachedValues.entrySet()) { log.debugf(""Key-value pair key: %s cache: %s"", value.getKey(), value.getValue()); } Map<String, String> values = cache.getAll(cachedValues.keySet()); log.debugf(""values size %d"", values.size()); for(Entry<String, String> value : values.entrySet()) { log.debugf(""Value key: %s"", value.getKey()); assertEquals(value.getValue(), value.getValue()); } }
9- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } assertThat(cache.getAll(cachedValues.keySet()), is(cachedValues)); }
10- public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(Integer i=0; i<100; i++){ String key = String.format(""key-%d"", i); String value = String.format(""value-%d"", i); cache.put(key, value); cachedValues.put(key, value); } Map<String, String> values = cache.getAll(cachedValues.keySet()); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this line'
The code is: 'public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { <START> ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; <END> } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }'","public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }","1- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.ERROR, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
2- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } firstControl = false; controls.put(hoverControlCreator.getKey(), informationControl); } } }
3- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.PLUGIN_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
4- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } controls.put(hoverControlCreator.getKey(), informationControl); } else if (informationControl.getClass().getName().endsWith(AbstractTextHover.class.getName())) { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
5- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { throw new IllegalArgumentException(InformationControlUtils.getDisplayableName(informationControl.getClass()) + "" instances only work with AbstractInformationControl""); } } }
6- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); infoControlHandler.dispose(); infoControlHandler = hoverControlCreator.getValue().createInformationControlFactory().createInformationControl(parent.getShell()); infoControlHandler.dispose(); infoView.setLabelProvider(infoControlHandler.getLabelProvider()); } } }
7- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1,!isHideSeparator()); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover<?>, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers, and text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
8- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(0); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
9- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { GridData griddata = (GridData)children.get(0).getLayoutData(); griddata.verticalIndent = 0; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }
10- public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); Boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { ((GridData)children.get(0).getLayoutData()).verticalIndent = GridData.VERTICAL_INDENT; } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, ""Only text hovers producing an AbstractInformationControl can be aggregated; got a "" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I minimum is 1 for of these, matters here, good consistent'
The code is: 'private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); <START> int selectorThreads = connectorFactory.getSelectorThreads().orElse(0); <END> int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(0); return maxServerThreads - selectorThreads - acceptorThreads - 1; }'","private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }","1- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
2- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); List<Integer> workerThreads = connectorFactory.getWorkerThreads().orElseThrow(IllegalStateException::new); return maxServerThreads - workerThreads.get(0) - workerThreads.get(1) - 1; }
3- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
4- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads(); int acceptorThreads = connectorFactory.getAcceptorThreads(); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
5- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads(); int acceptorThreads = connectorFactory.getAcceptorThreads(); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
6- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
7- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
8- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); int selectorThreads = serverFactory.getSelectorThreads(); int acceptorThreads = serverFactory.getAcceptorThreads(); return Math.min(maxServerThreads / 6, selectorThreads + acceptorThreads); }
9- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); int selectorThreads = (Integer) serverFactory.getSelectorThreads().getOrDefault(0); int acceptorThreads = (Integer) serverFactory.getAcceptorThreads().getOrDefault(0); return maxServerThreads - selectorThreads - acceptorThreads - 1; }
10- private long computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, ""Unexpected serverFactory instance on TimeLockServerConfiguration.""); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), ""applicationConnectors of TimeLockServerConfiguration must not be null.""); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, ""applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.""); int acceptorThreads = serverFactory.getAcceptorThreads().map(Number::intValue).orElse(0); int selectorThreads = serverFactory.getSelectorThreads().orElse(0); int acceptorThreadsNumber = acceptorThreads + (selectorThreads? 2 : 0); return maxServerThreads - selectorThreads - acceptorThreadsNumber; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a warning info level message? happen'
The code is: 'void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { <START> Log.i(LOG_TAG, ""Caller error: geoPoint is null""); <END> return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }'","void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }","1- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.i(LOG_TAG, ""Caller wrong: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
2- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
3- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.i(LOG_TAG, ""GeoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
4- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { logger.w(""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
5- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.i(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } if (isMlsPointUpdate && obsPoint.time!= null) { setTime(obsPoint); } }
6- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
7- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.i(LOG_TAG, ""GeoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
8- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
9- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.d(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }
10- void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, ""Caller error: geoPoint is null""); return; } final Point point = pj.toPixels(geoPoint, null); final long size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java.util.Map.Entry -> Map.Entry -> Entry is enough (already in other places)'
The code is: 'public Set<java.util.Map.Entry<String, Object>> entrySet() { <START> return new AbstractSet<Map.Entry<String,Object>>() { <END> @Override public Iterator<Entry<String, Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String, Object> next() { Entry<String,Object> entry = iterator.next(); return new Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }'","public Set<Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Entry<String, Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String, Object> next() { Entry<String,Object> entry = iterator.next(); return new Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }","1- public Set<java.util.Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Map.Entry<String, Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Map.Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Map.Entry<String, Object> next() { Map.Entry<String,Object> entry = iterator.next(); return new Map.Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }
2- public Stream<Entry<String, Object>> streamEntrySet() { return vars.entrySet().stream().map(entry -> new Stream.StreamEntry(entry.getKey(), resolve(entry.getValue()))); }
3- public Set<Entry<String, Object>> entrySet() { return new AbstractSet<Entry<String,Object>>() { @Override public Iterator<Entry<String,Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String,Object> next() { Entry<String,Object> entry = iterator.next(); return new Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }
4- public Map.Entry<String,Object>[] entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Map.Entry<String,Object>> iterator() { Iterator<Map.Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Map.Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Map.Entry<String,Object> next() { Map.Entry<String,Object> entry = iterator.next(); return new Map.Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }
5- public Map<String,Object> entrySet() { final Map<String,Object> map = new HashMap<String,Object>(vars.size()); for (Entry<String,Object> entry : getVars().entrySet()) { putIfAbsent(map, toString(entry.getKey()), toString(entry.getValue())); } return Collections.unmodifiableMap(map); }
6- public Set<Entry<String, Object>> entrySet() { return new JDeadJarMetaMismatchEntrySet(); }
7- public Set<Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Entry<String, Object>> iterator() { Iterator<Map.Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Map.Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String,Object> next() { Entry<String,Object> entry = iterator.next(); return new Map.Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public void setValue(Object value) { Object previous = entry.setValue(value); resolve(previous); } }; } }; } @Override public long size() { return variables.size(); } }; }
8- public Set<Map.Entry<String, Object>> entrySet() { return vars.entrySet(); }
9- public Set<Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String, Object>>() { @Override public Iterator<Map.Entry<String, Object>> iterator() { Iterator<Map.Entry<String, Object>> iterator = vars.entrySet().iterator(); return new Iterator<Map.Entry<String, Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Map.Entry<String, Object> next() { Map.Entry<String, Object> entry = iterator.next(); return new SimpleEntry<>(entry.getKey(), resolve(entry.getValue())); } }; } @Override public long size() { return vars.size(); } }; }
10- public Set<java.util.Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Map.Entry<String,Object>> iterator() { Iterator<Map.Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Map.Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Map.Entry<String,Object> next() { Map.Entry<String,Object> entry = iterator.next(); return new Map.Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public long size() { return vars.size(); } }; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Lets VectorUtils.of(...)'
The code is: 'public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); <START> Vector observation = new DenseVector(new Double[] {-0.8, -1}); <END> Assert.assertEquals(one, model.apply(observation), PRECISION); }'","public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = VectorUtils.of(-0.8, -1); Assert.assertEquals(one, model.apply(observation), PRECISION); }","1- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, VectorUtils.of(one, -1)); data.put(2, VectorUtils.of(one, -2)); data.put(3, VectorUtils.of(one, -3)); data.put(4, VectorUtils.of(two, 1)); data.put(5, VectorUtils.of(two, 2)); data.put(6, VectorUtils.of(two, 3)); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<Integer, Double[]>( data, 2), (k, v) -> new Double[] {v[1], -v[0]}, (k, v) -> v[0] ); Vector observation = new DenseVector(new Double[] {-0.8, -1}); Assert.assertEquals(one, model.apply(observation), PRECISION); }
2- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, VectorUtils.of(-1., 1., 0., 0., 0., 0., 0., 3., 1., 3., 2., 6., 2., 3.).toArray()); data.put(2, VectorUtils.of(-2., -1., 1., 4, 5, 6, 7, 9, 2., -2., 1., -2., -7., 8., -7., -4.).toArray()); data.put(3, VectorUtils.of(-3., -2., 1., 0.).toArray()); data.put(4, VectorUtils.of(-1., 2., 1., 0.).toArray()); data.put(5, VectorUtils.of(-2., 3., 2., -5, 0.).toArray()); data.put(6, VectorUtils.of(2., -5., 6, -9, -4., 3.).toArray()); data.put(7, VectorUtils.of(3., -9., 4., -5, 6., 9., 2.).toArray()); data.put(8, VectorUtils.of(2., 2., 3., 0., 9, -3.).toArray()); data.put(9, VectorUtils.of(2., -1., 3.).toArray()); data.put(10, VectorUtils.of(2., -4., -3., -1., 2.).toArray()); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = new DenseVector(new Double[] {-0.8, -1., 1., 1., 5., -6., -3., -1.}); Assert.assertEquals(one, model.apply(observation), PRECISION); }
3- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); LocalDataset<Double[]> localDataset = new LocalDatasetBuilder<>(data, 2); GaussianNaiveBayesModel model = trainer.fit(localDataset, (k, v) -> new DenseVector(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0]); Vector observation = new DenseVector(new Double[] {-0.8, -1}); Assert.assertEquals(one, model.apply(observation), PRECISION); }
4- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = VectorUtils.of(-0.8, -1.); Assert.assertEquals(one, model.apply(observation), PRECISION); }
5- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( data, (k, v) -> random.randomDoubleArray(v.length), (k, v) -> v[0]); Double observation = random.randomDoubleArray(data.keySet().size() - 1).get(); Assert.assertEquals(one, model.apply(observation), PRECISION); }
6- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = new DenseMatrix(6,1); Assert.assertEquals(one, model.apply(observation.convertToVector()), PRECISION); }
7- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = new DenseVector(new Double[] {-0.8, -1.}); Assert.assertTrue(model.apply(observation).closeTo(one, PRECISION)); }
8- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit(new LocalDatasetBuilder<>(data, 2), new VectorPredictor<>( k -> Arrays.copyOfRange(v, 1, v.length), k -> v[0]), new VectorPredictor<>(k -> (new DenseVector(new Double[] {k[0] - 4.5, -5, 1, 3.5})).toArray())); Vector observation = new DenseVector(new Double[] {-0.8, -1}); Assert.assertEquals(one, model.apply(observation), PRECISION); }
9- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDataset<>(VectorUtils.of(data), 2, DenseVectorUtils.of(new Double[]{1, 1, 1}, new Double[]{1, 1, 1}), DenseVectorUtils.of(new Double[]{2, 1, 1}, new Double[]{1, 1, 1}))), (k, v) -> v[0] ); Vector observation = new DenseVector(new Double[] {-0.8, -1}); Assert.assertEquals(one, model.apply(observation), PRECISION); }
10- public void scikitLearnExample() { Map<Integer, Double[]> data = new HashMap<>(); Double one = 1.; Double two = 2.; data.put(0, new Double[] {one, -1, 1}); data.put(2, new Double[] {one, -2, -1}); data.put(3, new Double[] {one, -3, -2}); data.put(4, new Double[] {two, 1, 1}); data.put(5, new Double[] {two, 2, 1}); data.put(6, new Double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Double observation = 3.2; Vector p = model.apply( VectorUtils.of(0.8, -1.0, 1.0) ); Assert.assertEquals(one, p[0], ERROR); Assert.assertEquals(0.5, p[1], ERROR); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (s.isEmpty()) {'
The code is: 'private static boolean isJavaIdentifier(String s) { <START> if (s.length() == 0) { <END> return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }'",private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; },"1- private static boolean isJavaIdentifier(String s) { if (StringUtils.isEmpty(s)) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
2- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer len = s.length(); return len > JAVA_ID_LENGTH && Character.isJavaIdentifierPart(s.codePointAt(len - JAVA_ID_LENGTH)); }
3- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
4- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } int charCount = Character.charCount(start); for (int i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
5- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
6- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
7- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
8- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } int charCount = getCharCound(start); for (int i = charCount; i < s.length(); i += charCount) { int codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
9- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }
10- private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } Integer start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } Integer charCount = Character.charCount(start); for (Integer i = charCount; i < s.length(); i += charCount) { Integer codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'intentional error'
The code is: 'public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { <START> log.error(""Failed to initialize Vds on up."", e); <END> } } }); } return isSucceeded; }'","public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.debug(""Exception"", e); } } }); } return isSucceeded; }","1- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize vds on up"", e); } } }); } return isSucceeded; }
2- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up."", e); throw e; } } }); } return isSucceeded; }
3- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.errorFormat(""Failed to initialize Vds on up."", e); } } }); } return isSucceeded; }
4- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds before host pool init."", e); } } }); } return isSucceeded; }
5- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up."", e); } } }); } return isSucceeded; }
6- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, createMigrateVmToServerParametersList(vmsToMigrate, vds, ctx), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up."", e); } } }); } return isSucceeded; }
7- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to Initialize Vds on up "", e); } } }); } return isSucceeded; }
8- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up. Error message: {}"", e.getMessage(), e); } } }); } return isSucceeded; }
9- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.errorFormat(""Failed to initialize Vds on up. Vds id %1$s "", vds.getId(), e); } } }); } return isSucceeded; }
10- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.putExecutionContext(new EngineContext().setMonitorFailover(true)); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up."", e); } } }); } return isSucceeded; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logging infrastructure set log level accordingly? Include in log4j2.xml: <Logger name=""org.jabref.logic.importer.fetcher"" level=""DEBUG""> <AppenderRef ref=""CONSOLE""/> </Logger>'
The code is: 'private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); <START> System.out.println(""parsing xml""); <END> fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }'","private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }","1- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); System.out.println(""parsing xml with log level""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { try { long numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } catch (NumberFormatException nfe) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), nfe); } } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
2- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbiFetchURL(query)); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; }
3- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); stream = streamReader.next(); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
4- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); System.out.println(""parsing xml""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } break; } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
5- private void getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); System.out.println(""parsing xml using logging""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
6- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = fetchIDs; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); System.out.println(""parsing xml""); while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: String elementName = streamReader.getName(); if (elementName.equals(IDLIST)) { fetchIDs = true; firstOccurrenceOfCount = true; } if (elementName.equals(COUNT)) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (!fetchIDs && streamReader.getName()!= IDLIST) { streamReader.next(); continue; } if (streamReader.getName().equals(IDLIST) && numberOfResultsFound > 0) { while (streamReader.hasNext()) { streamReader.next(); idList.add(streamReader.getText()); } streamReader.next(); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().equals(IDLIST)) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
7- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); systemOutLog(""parsing xml""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
8- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); StreamLogger logger = StreamLogger.forLogger(LogManager.getLogger(this.getClass())).with(LogLevel.DEBUG).with().with().and(""Number of result in Pubmed:"", message -> streamLogger.log(message)).with(""Id List Count:"", message -> streamLogger.log(message)).with(""Id List:"", message -> streamLogger.log(message)); logger.start(this.fetchLoop(streamReader, idList)); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
9- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); System.out.println(""parsing xml""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { try { int numberOfResults = Integer.parseInt(streamReader.getText()); idList.addAll(buildIndexedIdList(numberOfResults)); } catch (NumberFormatException e) { NumberFormatException nfe = new NumberFormatException(""No number format is recognized to parse PubMed ID List"", e); logger.error(nfe); throw nfe; } streamReader.next(); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.close(); return idList; } break fetchLoop; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }
10- private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { Boolean fetchIDs = false; Boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); LOGGER.info(""parsing XML""); fetchLoop: while (streamReader.hasNext()) { Integer event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(""Count"")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(""IdList"")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(""IdList"")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(""Unable to get PubMed IDs"", Localization.lang(""Unable to get PubMed IDs""), e); } catch (XMLStreamException e) { throw new FetcherException(""Error while parsing ID list"", Localization.lang(""Error while parsing ID list""), e); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'copy-paste bug, frame.toImmutable()'
The code is: 'public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); <START> Tuple tupleFromFrame = tuple.toImmutable(); <END> assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }'","public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); Tuple tupleFromFrame = frame.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }","1- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); assertTrue(""equality tuple"", Objects.equals(tuple, tuple.toImmutable())); Tuple tupleFromTuple = tuple.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }
2- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); Tuple tupleFromFrame = tupleFromTuple.toMatchingFrame(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); }
3- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }
4- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); Tuple tupleFromFrame = (Tuple) frame.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }
5- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); Tuple tupleFromFrame = tuple.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }
6- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); for (int i=0; i<arity; ++i) { assertEquals(""equality tuple: i="" + i, tuple.get(i), frame.get(i)); assertEquals(""equality frame: i="" + i, frame, tuple.toImmutable()); } if (arity > 0) { frame.setValue(0, ""x""); assertFalse( ""equality frame for 0th tuple"", Objects.equals(frame, tuple.toImmutable())); } }
7- public void testToImmutable() { if (isNull) return; MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); assertTrue(""equality tuple"", Objects.equals(tuple, tuple.toImmutable())); assertTrue(""equality tuple"", Objects.equals(tuple.toImmutable(), tuple)); assertTrue(""equality frame"", Objects.equals(frame, tuple.toImmutable())); assertTrue(""equality frame"", Objects.equals(tuple.toImmutable(), frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tuple.toImmutable())); assertFalse(""equality frame"", Objects.equals(tuple.toImmutable(), frame)); } }
8- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); tuple.delete(0); } }
9- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(values); Tuple tuple = Tuples.tupleOf(values); assertFalse(""equality frame"", Objects.equals(frame, tuple)); assertFalse(""equality tuple"", Objects.equals(tuple, frame)); assertTrue(""equality frame"", Objects.equals(values, tuple)); assertTrue(""equality tuple"", Objects.equals(values, tuple)); if (arity > 0) { frame.setValue(0, ImmutableIndexValue.index(0)); assertFalse(""equality frame"", Objects.equals(frame, tuple)); assertFalse(""equality frame"", Objects.equals(tuple, frame)); assertFalse(""equality tuple"", Objects.equals(tuple, frame)); } }
10- public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (Integer i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); assertTrue(""equality tuple"", Objects.equals(tuple, tupleFromTuple)); assertTrue(""equality tuple"", Objects.equals(tupleFromTuple, tuple)); assertTrue(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertTrue(""equality frame"", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, ""x""); assertFalse(""equality frame"", Objects.equals(frame, tupleFromFrame)); assertFalse(""equality frame"", Objects.equals(tupleFromFrame, frame)); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a logger instead of System.out'
The code is: 'public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); <START> <END> Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }'","public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); LOGGER.info(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); LOGGER.info(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }","1- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInboundVariables(); System.out.println(""tagImageActionName inbound variables: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables: "" + inBoundVariables.values()); boolean expectedValue = (boolean) inBoundVariables.get(""expectedKey""); integrationContext.addInboundVariable(Constants.BOOLEAN_VARIABLE_NAME, expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
2- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); assertThat(inBoundVariables.keySet()).containsOnly(""expectedKey"", ""input-variable-name-2""); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
3- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); Map<String, Object> expectedValue = new HashMap<>(); expectedValue.put(""expectedKey"", true); expectedValue.put(""input-variable-name-1"", System.currentTimeMillis()); expectedValue.put(""input-variable-name-2"", ""input-variable-name-2""); expectedValue.put(""input-variable-name-3"", ""input-variable-name-3""); integrationContext.addOutBoundVariable(""approved"", expectedValue) ; return integrationContext; }; }
4- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
5- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
6- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); Assertion.assertThat(""expectedKey exists in inbound variables"", inBoundVariables.containsKey(""expectedKey"")).isTrue(); Assertion.assertThat(""input-variable-name-2 exists in inbound variables"", inBoundVariables.containsKey(""input-variable-name-2"")).isTrue(); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); return integrationContext; }; }
7- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedValue""); System.out.println(""expectedValue: "" + expectedValue); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
8- public Connector tagImageActionName() { return integrationContext -> { Boolean expectedValue = (Boolean) integrationContext.getInboundVariables().get(""expectedKey""); integrationContext.addOutboundVariable(""approved"", expectedValue); assertThat(integrationContext.getInboundVariables().get(""input-variable-name-2"")).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
9- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expected""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }
10- public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(""tagImageActionName inbound variables keys: "" + inBoundVariables.keySet()); System.out.println(""tagImageActionName inbound variables values: "" + inBoundVariables.values()); Boolean expectedValue = (Boolean) inBoundVariables.get(""expectedKey""); integrationContext.addOutBoundVariable(""approved"", expectedValue); assertThat(((String) inBoundVariables.get(""input-variable-name-2""))).isEqualTo(""input-variable-name-2""); return integrationContext; }; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Dimension.USED_JAVA_HEAP'
The code is: 'private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); <START> perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.CPU_TIME); <END> for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }'","private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }","1- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
2- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); pm.tagAsSummary(TEST_SUMMARY + MEMORY + ':' +'' + testName, USED_JAVA_HEAP, CPU_TIME); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
3- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.CPU_TIME, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
4- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName + '(' + Dimension.USED_JAVA_HEAP + ')', Dimension.CPU_TIME); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
5- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.JAVA_HEAP + "":"" + Dimension.CPU_TIME); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
6- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
7- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.CPU_TIME); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); perf.waitForCompletedMeters(TEST_ID + MEMORY + '#' + testName); }
8- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
9- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }
10- private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, Integer loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (Integer i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above, client needs closed'
The code is: 'public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client client = ResteasyClientBuilder.newClient(); <END> WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }'","public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }","1- public void testOneway() throws Exception { CountDownLatch latch = null; try { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); target.request().put(Entity.entity(""content"", ""text/plain"")); latch.await(2, TimeUnit.SECONDS); } finally { if(latch!= null) { latch.countDown(); } } }
2- public void testOneway() throws Exception { CountDownLatch latch = new CountDownLatch(1); WebTarget target = ResteasyClientBuilder.newClient().target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); latch.countDown(); try { response.close(); } catch (IOException ignored) { } }
3- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(ClientResponse.class, Client.class); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); client.close(); }
4- public void testOneway() throws Exception { CountDownLatch latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort()+""/oneway""); target.register(new ServletResponseException()); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }
5- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = client(true); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); }
6- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); Thread.currentThread().interrupt(); client.close(); response.close(); }
7- public void testOneway() throws Exception { CountDownLatch latch = new CountDownLatch(1); Client client = TestClientFactory.createClient(false); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); try (ClientResponse response = target.request().put(Entity.entity(""content"", ""text/plain""))) { latch.await(); response.close(); } }
8- public void testOneway() throws Exception { Client client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); client.close(); }
9- public void testOneway() throws Exception { latch = new CountDownLatch(1); Client client = ResteasyClientBuilder.newClient(logger); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); client.close(); }
10- public void testOneway() throws Exception { latch = new CountDownLatch(1); HttpClient client = ResteasyClientBuilder.newClient(); WebTarget target = client.target(""http://localhost:"" + TestPortProvider.getPort() + ""?oneway=true""); Long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(""content"", ""text/plain"")); Long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'toUpperCase() useless is done in ""WorkspaceImageFigure.isSvgImage(resourceExtension)""'
The code is: 'private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; <START> String resourceExtension = resource.getFileExtension().toUpperCase(); <END> if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }'","private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }","1- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFile().getFullPath().toString(); Option<File> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFile().getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
2- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
3- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
4- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension().toUpperCase(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString().toUpperCase(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
5- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; final String resourceExtension = WorkspaceImageFigure.isSvgImage(resource.getFileExtension())? ""svg"" : resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (remove!= null) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Option<Boolean> removed = new Option<>(DiagramUIPlugin.getPlugin(), new RegExp(""^"" + resourceExtension + ""$""), false); Boolean removedFromCache = removed.filter(DiagramUIPlugin.getPlugin::matches).filter(DiagramUIPlugin::exists); if (removedFromCache) { cacheUpdated = true; } } return cacheUpdated; }
6- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = ResourceExtensionExtractor.INSTANCE.getResourceExtensionOf(resource.getFile()); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
7- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (resourceExtension.equalsIgnoreCase(SVG.SVG)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
8- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension().toUpperCase(); if (WorkspaceImageFigure.hasSvgFileExtension(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
9- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }
10- private Boolean needClearCache(IResource resource) { Boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension().toUpperCase(Locale.ENGLISH); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(""Invalid uri : "" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); Boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Knock this protected (no need define public api here) - this provide a chance for subclasses smarter (for example WKTStratagy start recogning geometry column). this method is ugly/confusing :)'
The code is: '<START> public static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, <END> String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }'","protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }","1- protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
2- protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } int i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
3- protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
4- protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
5- protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers)  throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
6- static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; result.put(header, findSpecificType(header, value)); i++; } } return result; }
7- static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { for (int i = 0; i < csvReader.getFieldIndex(header); i++) { result.put(header, Integer.class); } } boolean shouldReadData = (csvReader.readRecord()!= null); while ((shouldReadData || (!csvReader.isAllDone())) && csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } if (!shouldReadData) { break; } } return result; }
8- public static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); if (record.length >= headers.length) { for (int i = 0; i < headers.length; i++) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(record[i]); } catch (NumberFormatException e) { try { Double.parseDouble(record[i]); type = Double.class; } catch (NoSuchValueException e2) { type = String.class; break; } } } else if (type == Double.class) { try { Double.parseDouble(record[i]); type = Double.class; break; } catch (NumberFormatException e) { break; } } else if (type == String.class) { break; } else { type = String.class; } try { result.put(header, type); } catch (Exception e) { result.put(header, String.class); } } } else { type = String.class; } } return result; }
9- public static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }
10- protected static <T> Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } Integer i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { type = Double.class; } } else if (type == Double.class) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove this, I fixed in a432e377a8d4e7dd04f2267bc59b1e66ea6d6656'
The code is: 'public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; <START> if(iconSizes != null) { <END> for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } } if (closestIndex > 0) { iconIndex = closestIndex; } } }'","public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }","1- public void calculateMip(double scale, double mapScale, double screenScale) { Double targetSz = 16 * scale * viewSize(); if (isTile) { targetSz *= mapScale; } if (icons.length > 1) { Double smallestSide = 1.0D * targetSz * screenScale; Double closestValue = Double.MAX_VALUE; Double closestIndex = -1; for (Double i = 0; i < iconSizes.length; i++) { if (icons[i].length < closestValue && icons[i].length > smallestSide) { closestValue = icons[i].length; closestIndex = i; } } if (closestIndex > icons.length - 1) { iconIndex = icons.length; } } }
2- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
3- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; for (int i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; } } if (closestValue > 0) { iconIndex = smallestSide / closesValue; } } }
4- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = getTextureScalePixels(); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = smallestTextureDim(size); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (int i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
5- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; if(iconSizes!= null) { for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } } if (closestIndex > 0) { iconIndex = closestIndex; } } else { iconIndex = 0; } }
6- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (aspectRatio > 1.) { size *= mapScale / viewScaleRatio; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
7- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
8- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
9- public void calculateMip(double scale, double mapScale, double screenScale) { Integer size = (Integer) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { Integer smallestSide = (Integer) (size * screenScale); Integer closestValue = Integer.MAX_VALUE; Integer closestIndex = -1; if (iconSizes!= null) { for (Integer i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } } if (closestIndex > 0) { iconIndex = closestIndex; } } }
10- public void calculateMip(double scale, double mapScale, double screenScale) { for (int i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < iconSizes[size][side]) { size *= scale; scale *= scale; side = 0; System.out.println(viewSize()); iconSizes[i] = iconSizes[size][side]; } } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This logically clearer: java if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); }'
The code is: 'private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if(!data.shouldShowLog(emailLogEntry)) { continue; } <START> emailLogs.add(emailLogEntry); <END> } return emailLogs; }'","private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }","1- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } String logEmailAddress = appLog.getEmailAddress(); Boolean shouldShowLog = data.shouldShowLog(logEmailAddress); if (!shouldShowLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); emailLogs.add(emailLogEntry); } return emailLogs; }
2- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }
3- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } boolean isEmailLog = logMsg.contains(""TEAMMATESEMAILLOG""); EmailLogEntry emailLogEntry = new EmailLogEntry(appLog,isEmailLog); if (!data.shouldShowLog(emailLogEntry)) { continue; } emailLogs.add(emailLogEntry); } return emailLogs; }
4- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); if (!(appLogMessageHasEmailLog(logMsg) || appLogMessageIsNotEmailLog(logMsg))) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (!data.shouldShowLog(emailLogEntry)) { continue; } emailLogs.add(emailLogEntry); } return emailLogs; }
5- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!(mailLogEntry = filterNotEmailLogLine(appLogLogAdapter, appLog, data)).isEmpty()); if (isNotEmailLog) { continue; } emailLogs.add(mailLogEntry); } return emailLogs; }
6- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (!logMsg.contains(""TEAMMATESEMAILLOG"")) { continue; } if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }
7- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAILLOG"")); if (isNotEmailLog) { continue; } emailLogs.add(new EmailLogEntry(appLog, appLogLines.indexOf(appLog))); } return emailLogs; }
8- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); emailLogs.addAll(data.filterLogsByMessage(emailLogEntry ->!emailLogEntry.isEmailLog())); if(!data.shouldShowLog(emailLogEntry)) { continue; } } return emailLogs; }
9- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); if (!logMsg.contains(""TEAMMATESEMAILLOG"")) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (!data.shouldShowLog(emailLogEntry)) { continue; } emailLogs.add(emailLogEntry); } return emailLogs; }
10- private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); Boolean isNotEmailLog = (!logMsg.contains(""TEAMMATESEMAIL"")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This capped max, so: byte[] nb = new byte[Math.min(buf.length * 2, max)];'
The code is: 'public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } <START> byte[] nb = new byte[buf.length * 2]; <END> System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }'","public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }","1- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { in.close(); } }
2- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[max]; System.arraycopy(buf, 0, nb, 0, buf.length); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
3- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
4- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (max == null) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < 0) { buf = new byte[(Integer) max]; continue; } throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } int n = in.read(buf, valid, buf.length - valid); if (n < 0) { break; } valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
5- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
6- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path, max)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path, max)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
7- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length, max_block_size)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
8- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
9- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { Integer next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } Integer n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }
10- public static final byte[] readFully(final File path, final Integer max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { Long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(Integer) sz]; Integer valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) if (max <= 64 /* int.maxValue() */) ((int) buf).putTo(0, buf, valid, MAXVALUE); else throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This check is adding removing problem / nodes. Returning true leads a prune of child-tree branch beneath node. this ""rule"" (skipping visited nodes) applied node types e.g. ExecTCs e.g. if parent is re-used in contexts, occurring multiple times a traversing run relevant problem cleanup new problem creation'
The code is: 'public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { <START> if (alreadyVisited) { return true; } <END> clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }'","public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }","1- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }
2- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (alreadyVisited) { return true; } clearChildNodesFromTestStyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } handleExecTestCases(node); return true; }
3- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (parent == null) { if (node.getChildren() == null ||!node.getChildren().hasNext()) { clearNodeFromTeststyleProblem(node); } } for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }
4- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = Integer.valueOf(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }
5- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (alreadyVisited) { return true; } clearNodeFromExecutionProblems(node); return true; }
6- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (alreadyVisited &&!ProblemCont.instance.getChecksFor(node).isEmpty()) { return true; } clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } return true; }
7- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (alreadyVisited) { return false; } clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }
8- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { if (alreadyVisited || node.isLeaf() || node.isAncestorOfType(ITestNGListener.TESTCASE_NODE_TYPE)) { return true; } clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node.isAncestorOfType(ITestNGListener.TESTCASE_NODE_TYPE)) { handleExecTestCase(node); } return true; }
9- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity == Status.OK) continue; node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return false; }
10- public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { if (!alreadyVisited) { Integer severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: again, error text'
The code is: 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START> assertNull(pathMetadata); <END> } }'","public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(""Kept files should be in the metastore after prune"", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(""Expired tombstones should be removed from metastore after "" + ""the prune."", pathMetadata); } }","1- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }
2- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); Assert.assertNull(pathMetadata); } }
3- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for(String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }
4- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for (String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for (String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if (allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for (String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }
5- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""dir1/fileK1"", ""dir1/fileK2"", ""dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""dir1/fileR1"", ""dir1/fileR2"", ""dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); String msg = AssertionMessages.getMessage(""PruneExpiredTombstoneTest.pathDoesNotExists"", pathMetadata.toString()); assertNull(pathMetadata, msg); } }
6- public void testPruneExpiredTombstones() throws Exception { List<PathMetadata> keepPaths = new ArrayList<>(Arrays.asList(PathMetadata.strToPath(""dir1/fileK1""), PathMetadata.strToPath(""dir1/fileK2""), PathMetadata.strToPath(""dir1/fileK3""))); List<PathMetadata> removePaths = new ArrayList<>( Arrays.asList(PathMetadata.strToPath(""dir1/fileR1""), PathMetadata.strToPath(""dir1/fileR2""), PathMetadata.strToPath(""dir1/fileR3""))); final Long cutoff = 9001L; ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_TOMBSTONE_LASTUPDATED, cutoff); assertThat(ms, Matchers.hasItems(keepPaths.toArray())); }
7- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } assertEquals(""Total number of files not updated"", 4, numUpdated); }
8- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""fileK2"", ""fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""fileR2"", ""fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } assertEquals(ms.getChildMetadatas(""/dir1/fileK1"").size(), 1); assertEquals(ms.getChildMetadatas(""/dir1/fileK2"").size(), 1); assertEquals(ms.getChildMetadatas(""/dir1/fileK3"").size(), 1); assertEquals(ms.getChildMetadatas(""/dir1/fileR1"").size(), 0); assertEquals(ms.getChildMetadatas(""/dir1/fileR2"").size(), 0); assertEquals(ms.getChildMetadatas(""/dir1/fileR3"").size(), 0); ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); assertEquals(ms.getChildMetadatas(""/dir1/fileK1"").size(), 0); assertEquals(ms.getChildMetadatas(""/dir1/fileK2"").size(), 0); assertEquals(ms.getChildMetadatas(""/dir1/fileK3"").size(), 0); for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }
9- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = makeFileStatus(fN, 1); pathMetadata.setDeleted(true); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = makeFileStatus(fN, 1); pathMetadata.setLastUpdated(9000L); pathMetadata.setDeleted(true); pathMetadata.setIsDeleted(true); pathMetadata.setIsPresent(false); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }
10- public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileK1"", ""/dir1/fileK2"", ""/dir1/fileK3"")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(""/dir1/fileR1"", ""/dir1/fileR2"", ""/dir1/fileR3"")); Long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); if (!allowMissing) { assertTrue(pathMetadata.isAvailable()); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setDeleted(true); ms.put(pathMetadata); if (!allowMissing) { assertFalse(pathMetadata.isAvailable()); } } if (!allowMissing) { assertEquals(0, ms.get(""dir1/foo/bar/dir2/bar2/baz2"").getMetadata().findPaths().size()); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(pathMetadata); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please this more deterministic sleeping'
The code is: 'public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); <START> Thread.sleep(1000); <END> assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(1000); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 2, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }'","public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 2, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }","1- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertEquals(""Flusher called"", 0, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); bookie.closeAndDeleteBkBookieDataDirs(); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); assertEquals(""Flusher called"", 2, flushTestSortedLedgerStorage.
2- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestsSortedGarbageValuedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); Bookie.NopWriteCallback callback = new Bookie.NopWriteCallback(); Bookie.AutoFlushCallback autoFlushCallback = bookie.getBookieAdmin().getAutoFlushCallback(); FlushTestsSortedGarbageValuedLedgerStorage flushTestsSortedGarbageValuedLedgerStorage = (FlushTestsSortedGarbageValuedLedgerStorage) bookie.ledgerStorage; Bookie.ManagedLedgerBookieStorage storage = (Bookie.ManagedLedgerBookieStorage) flushTestsSortedGarbageValuedLedgerStorage.bookieStorage; assertNotNull(""BookieStorage should not be null"", storage); createRandomValues(); testWriteThenForEachBkEntry(false); assertFalse(""EntryMemTable should not be empty for flush failure"", flushTestsSortedGarbageValuedLedgerStorage.snapshot.isEmpty()); assertEquals(""Flusher should call only one flush for failure"", 2, flushTestsSortedGarbageValuedLedgerStorage.getNumOfFlushSnapshotCalled()); assertEquals(""BookieStorage should be updated"", StorageComponentType.MEMORY, storage.getState()); assertFalse(""EntryMemTable should be empty after flush is complete"", flushTestsSortedGarbageValuedLedgerStorage.snapshot.isEmpty()); testWriteThenForEachBkEntry(true); assertNull(""EntryMemTable should be empty after flush is complete"", flushTestsSortedGarbageValuedLedgerStorage.snapshot); testEntryAddForEachBkEntry(false); testEntryAddForEachBkEntry(true); }
3- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable.snapshot.isEmpty()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable.snapshot.isEmpty()); }
4- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 0), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(1, 2), false, new Bookie.NopWriteCallback(), null, Utils.bytesToHexString(getFileContent(entry(1, 2))) ); bookie.addEntry(generateEntry(1, 3), false, new Bookie.NopWriteCallback(), null, Utils.bytesToHexString(getFileContent(entry(1, 3))) ); bookie.addEntry(generateEntry(1, 4), false, new Bookie.NopWriteCallback(), null, Utils.bytesToHexString(getFileContent(entry(1, 4))) ); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 6)); assertTrue(""Some entries have not been flushed."", flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled() > 0); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 6)); assertTrue(""Some entries have not been flushed."", flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled() > 1); }
5- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); MemTableSnapshot oldMemTableSnapshot = memTable.snapshot; flushingExceptionFlag = memTable.injectFlushException; flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); waitForLedgerFlushInProgress(1000); assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); assertTrue(""Even after flushing the memtable, there are pending insertions - memtable is not empty"",!memTable.isSnapshotEmpty(oldMemTableSnapshot)); memTable.setSnapshot(oldMemTableSnapshot); flushTestSortedLedgerStorage.setInjectFlushException(false, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); waitForLedgerFlushInProgress(1000); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable
6- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(1000); assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(1000); assertTrue(""EntryMemTable SnapShot is expected to be empty"", memTable.snapshot.
7- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); try { flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); } catch (SuspectedException | IOException | FileNotFoundException | BlockInfoException ex) { } flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(1000); assertEquals(""BlockInfoException caught"", 1, flushTestSortedLedgerStorage.getNumOfTimesBlockInfoExceptionCaught()); assertFalse(""EntryMemTable SnapShot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }
8- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); assertNotNull(flushTestSortedLedgerStorage); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); assertNotNull(flushTestSortedLedgerStorage.getCurrMemTable()); assertNotNull(memTable); assertEquals(1, memTable.currentSize); assertEquals(1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); waitOnGc(memTable, flushTestSortedLedgerStorage.getCurrMemTable().snapshot); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); assertEquals(2, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }
9- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(50L); assertEquals(""Memory usage should not change due to memtable snapshot operation"", flushTestSortedLedgerStorage.memTable.snapshot.size(), flushTestSortedLedgerStorage.memTable.memUsage); assertFalse(""EntryMemTable Snapshot is not expected to be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher called"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertEquals(""Memory usage should not change due to entry memory usage update"", flushTestSortedLedgerStorage.memTable.memUsage, flushTestSortedLedgerStorage.mem
10- public void testEntryMemTableParallelFlushWithFlushException() throws Exception { Integer gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, ""passwd"".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(4, 5)); assertTrue(""EntryMemTable SnapShot should be empty"", memTable.snapshot.isEmpty()); assertFalse(""Flusher did not call even at exception"", flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled() == 0); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(5, 1)); assertTrue(""EntryMemTable SnapShot should not be empty"", memTable.snapshot.isEmpty()); assertEquals(""Flusher did not call even at exception when allledgers"", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'end variable is once, hence, is inline it: qualifyingSet.setEnd(qualifyingSet.getEnd()); However, inlining shows variable statement necessary. remove these'
The code is: 'private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); <START> Integer end = qualifyingSet.getEnd(); <END> qualifyingSet.setEnd(end); Integer[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }'","private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); Integer[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }","1- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } boolean doFilterResult = false; if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); reader.updateTime(System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); qualifyingSet.setEnd(reader.getInputQualifyingSet().getEnd()); } else { qualifiedSet.compactInputNumbers(filterResults, numHits); } doFilterResult = true; if (reader.getFilter() == null && isFirstFunction) { reader.setFilter(qualifyingSet.getEnd()); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } doFilterResult = false; isFirstFunction = false; } return qualifyingSet; }
2- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); boolean hasInputNumbers = function.hasFilterableInputs(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet(), hasInputNumbers); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction && hasInputNumbers) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); long[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, inputNumbers.length); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } reader.checkInputAndResetIfNeeded(filterResults); reader.resetAndResetResultsIfNeeded(filterResults); isFirstFunction = false; } return qualifyingSet; }
3- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); Integer end = qualifyingSet.getEnd(); qualifyingSet.setEnd(end); qualifyingSet.setPositionStart(end); Integer[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
4- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); } if (reader.getFilter() == null && numHits > 0) { reader.setFilter(new FilterBlockBuilder(false).buildBlock()); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
5- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); Integer end = qualifyingSet.getEnd(); qualifyingSet.setEnd(end); } else { qualifyingSet.compactInputNumbers(filterAggregatedFunctionResults, numHits); } reader.compactValues(filterAggregatedFunctionResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
6- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
7- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Block[] inputBlocks = getFilterFunctionInputs(blocks, channels, qualifyingSet); if (filterResults == null || filterResults.length < inputBlocks.length) { filterResults = new Integer[inputBlocks.length + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(inputBlocks.length, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(inputBlocks.length, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); Integer end = qualifyingSet.getEnd(); qualifyingSet.setEnd(end); int[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, inputBlocks.length, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
8- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyTo(reader.getInputQualifyingSet()); } else { qualifyingSet.compactInput(filterResults, numRowsInResult, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
9- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); qualifyingSet.setEnd(qualifyingSet.getEnd()); Integer[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }
10- private QualifyingSet evaluateFilterFunction(Integer streamIdx, QualifyingSet qualifyingSet) { Boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { Integer[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; Integer numRows = qualifyingSet.getPositionCount(); for (Integer channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new Integer[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); Integer numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null &&!isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this. required'
The code is: 'public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); <START> if (this.pQueue.size() > this.threshold) { <END> pQueue.poll(); } } return this; }'","public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (pQueue.size() > threshold) { pQueue.poll(); } } return this; }","1- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); theRunnables.add(() -> { final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } } }); pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); pQueue.poll(); return this; }
2- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); pQueue.poll(threshold); } return this; }
3- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } if (pQueue.size() > this.threshold) { for (Iterator<DimValHolder.Builder> iterator = pQueue.iterator(); iterator.hasNext(); ) { iterator.next().poll(); } } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); return this; } return this; }
4- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (this.threshold > 0 && pQueue.size() > this.threshold) { pQueue.poll(); } } return this; }
5- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + metricVals.length); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (pQueue.size() > pQueue.getCapacity() || pQueue.size() > threshold) { pQueue.poll(); } } return this; }
6- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); pQueue.pollIfSizeGreaterThan(this.threshold); } return this; }
7- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (pQueue.size() > pQueue.peek().hashCode()) { pQueue.poll(); } } return this; }
8- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); } return this; }
9- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put( dimSpec.getOutputName(), dimName ); additionalSegmentRanks.add(Arrays.asList(metricVals)); Arrays.stream(aggFactoryNames).forEach(aggFactory -> metricValues.put(aggFactory, metricVals[aggFactory])); addToPQueue(dimName, metricValues); pQueue.poll(); } return this; }
10- public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final Integer extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (Integer i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (pQueue.size() > this.threshold) { pQueue.poll(); } } return this; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename p prop'
The code is: 'private Boolean overwrite(String name) { for (Object <START> propertie : <END> getProperties()) { Property property = (Property) propertie; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }'","private Boolean overwrite(String name) { for (Object prop : getProperties()) { Property property = (Property) prop; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }","1- private void overwrite(String name) { getProperties().stream().filter(p -> p.getName().equals(name)).findFirst().ifPresent(p -> ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(p)); }
2- private Boolean overwrite(String name) { for (Object prop : properties) { Property property = (Property) prop; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { prop.getName(), property.getLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }
3- private boolean overwrite(String name) { for (Object p : getProperties()) { Property property = (Property) p; if (property.getName().equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_26, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_27, new Object[] { property.getName() })); return false; } boolean isOverwrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_25, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_24, new Object[] { name })); if (!isOverwrite) { return false; } removeNode(property); break; } } return true; }
4- private Boolean overwrite(String name) { for (Object prop : getProperties()) { Property property = (Property) prop; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }
5- private Boolean overwrite(String name) { for (Property p : getProperties()) { if (name.equals(p.getName())) { if (overwrite(p)) { return true; } else { break; } } } return false; }
6- public Boolean overwrite(String name) { for (Object prop : getProperties()) { Property property = (Property) prop; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }
7- private Boolean overwrite(String name) { for (Object property : getProperties()) { Property property = (Property) property; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }
8- private Boolean overwrite(String name) { for (Object p : getProperties()) { Property property = (Property) p; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }
9- private Boolean overwrite(String name) { for (Property p : getProperties()) { String propertyName = p.getName(); if (propertyName.equals(name)) { if (p.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, Messages.getString(""AntPropertiesBlock.msg18"", new Object[] { propertyName, p.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, Messages.getString(""AntPropertiesBlock.msg16"", new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(p); break; } } return true; }
10- private Boolean overwrite(String name) { for (Object pprop : getProperties()) { Property prop = (Property) pprop; String propertyName = prop.getName(); if (propertyName.equals(name)) { if (prop.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, prop.getPluginLabel() })); return false; } Boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) prop.getContentProvider()).remove(prop); break; } } return true; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tritto'
The code is: 'public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); <START> bounds.x = 0; bounds.y = 0; bounds.height = 1000; bounds.width <END> = 1000; Integer x0 = 100; Integer y0 = -10000; Integer x1 = 100; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }'","public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); Integer x0 = 100; Integer y0 = -10000; Integer x1 = 100; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }","1- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.x = 0; bounds.y = 0; bounds.height = 1000; bounds.width = 1000; Integer x0 = 100; Integer y0 = -10000; Integer x1 = 100; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
2- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.x = 0; bounds.y = 0; bounds.height = 1000; bounds.width = 1000; Integer x0 = 100; Integer y0 = -10000; Integer x1 = 100; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
3- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.height = 1000; bounds.width = 1000; Rectangle rect = LineClipper.clip(bounds, x0, y0, t1, v); assertEquals(new Rectangle(100, 0, 1000, 1000), rect); }
4- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); Rectangle rect = LineClipper.clip(bounds, 100, -10000, 100, 10000); assertEquals(new Rectangle(100, 50, 100, 1000), rect); }
5- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.setX((int) bounds.getX()); bounds.setY((int) bounds.getY()); bounds.setHeight(bounds.getHeight()); bounds.setHeight(bounds.getHeight()); Integer x0 = 100; Integer y0 = -10000; Integer x1 = 100; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
6- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.x = 500; bounds.y = 500; bounds.height = 1000; bounds.width = 1024; Integer x0 = 100; Integer y0 = 0; Integer x1 = 100; Integer y1 = 1000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
7- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.x = 500; bounds.y = 500; bounds.width = 100; bounds.height = 100; Integer x0 = 501; Integer y0 = -10000; Integer x1 = 501; Integer y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(500, 500, 0, 100), rect); }
8- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); bounds.x = 0; bounds.y = 0; bounds.height = 1000; bounds.width = 1000; Integer x0 = 100; Integer y0 = -10000; Integer x1 = 135; Integer y1 = 10000; Integer width = 1000; Integer height = 1000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1, width, height); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
9- public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); Integer x = 0; bounds.setX(x); bounds.setY(0); Integer width = 1000; bounds.setWidth(width); bounds.setHeight(1000); Integer height = 1000; bounds.setHeight(height); Integer topLeft = 100; Integer topRight = 0; bounds.setTopLeft(topLeft); bounds.setTopRight(topRight); Integer bottomLeft = -10000; Integer bottomRight = -1; bounds.setBottomLeft(bottomLeft); bounds.setBottomRight(bottomRight); Integer bottom = 0; Rectangle rect = LineClipper.clip(bounds, width, height, width, height); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }
10- public void verticalTest() { Integer y0 = -10000; Integer y1 = 10000; Rectangle rect = LineClipper.clip(new Rectangle(0, 0, 1000, 1000), 100, y0, 100, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this semicolon doing'
The code is: 'private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); <START> ; <END> private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }'","private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }","1- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); } @Override public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
2- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } @Override public long getBufferSize() { return channel.getBufferSize(); } }; }
3- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } private long sizeRemaining; @Override public long bytesLeft() { return (int) (sizeRemaining - currOffset); } { } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > sizeRemaining()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, sizeRemaining()); } sizeRemaining -= numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
4- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; private long bytesLeft = 0; { closest.register(out); closest.register(channel); } @Override public void close() throws IOException { closest.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (writerCurrentlyInUse) { mergeWithSmoosher(); } } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } bytesLeft -= numBytesWritten; currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
5- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out; private final GatheringByteChannel channel; StreamSegmentator segmentator = new StreamSegmentator() { @Override public Map<String, Long> getFilesAndSizes(long position) { final Map<String, Long> result = Maps.newHashMap(); for (File file : filesInProcess) { long currentPosition = position - file.length(); if (writeAndTrackSlice(file, currentPosition, result)) { return result; } } return null; } }; @Override public void close() throws IOException { out.close(); completedFiles.add(tmpFile); try { segmentator.addSlice(tmpFile, out, bytesLeft()); } catch (Exception e) { logger.error(e, ""Failed to add Slices to file: [%s], size: [%d]"", tmpFile.getAbsolutePath(), bytesLeft()); } filesInProcess.remove(tmpFile); if (writerCurrentlyInUse) { mergeWithSmoosher(); } } @Override public long bytesLeft() { return bytesLeft; } @Override public long write(ByteBuffer buffer) throws IOException { return bytesWritten(buffer, out); } @Override public long write(InputStream in) throws IOException { return bytesWritten(in, out); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return bytesWritten(srcs, offset, length, out); } private long bytesWritten(ByteBuffer[] srcs, int offset, int length, GatheringByteChannel channel) throws IOException { final Map<String, Long> fileAndSizes = segmentator.getFilesAndSizes(0); long size = 0; for (ByteBuffer buffer : srcs) { size += buffer.remaining(); if (offset + length > fileAndSizes.size() || offset < 0 || length < 0) { break; } size += Streams.copy(buffer, fileAndSizes.get(buffer.toString()), offset, length, channel); } return size; } @Override public long write(ByteBuffer[] srcs) throws IOException { return bytesWritten(srcs, out); } @Override public long write(ByteBuffer src) throws IOException { return bytesWritten(src, out); } public long write(InputStream in) throws IOException { return bytesWritten(in, out, ""InputStream"", null); } private long bytesWritten(InputStream in, GatheringByteChannel channel) throws IOException { long result = 0; while
6- private SmooshedWriter delegateSmooshedWrite(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; private long bytesLeft = size; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return bytesLeft; } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
7- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } @Override public void flush() throws IOException { channel.flush(); } }; }
8- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(currentChannel, buffer); } private long addToOffset(GatheringByteChannel channel, ByteBuffer buffer) throws IOException { return currOffset += channel.write(buffer); } @Override public long write(InputStream in) throws IOException { return addToOffset(new Channels.WriteOutBuffer(Channels.newChannel(in))); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(sources, offset, length); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(srcs); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
9- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); @Override public void close() throws IOException { closer.addCloseable(channel); closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }
10- private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private long currOffset = 0; { cleaner.addLocalFile(tmpFile); } public long bytesLeft() { return (int) (size - currOffset); } @Override public long write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public long write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public long addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(""Wrote more bytes[%,d] than available[%,d]. Don't do that."", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a lot of logic in this method hard debug in future... work? management of currentWork, emitting next work in a single place, drainQueue method. java @Override protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }'
The code is: '<START> protected void hookOnNext(ServiceBusReceivedMessageContext message) { <END> Boolean delivered = false; if (currentWork == null) { currentWork = getNextWorkAndRequest(); logger.verbose(""No current work, Picked up next receive request.""); } if (currentWork != null) { currentWork.next(message); delivered = true; remaining.decrementAndGet(); if (currentWork.isTerminal()) { currentWork.complete(); if (timeoutOperation != null && !timeoutOperation.isDisposed()) { timeoutOperation.dispose(); } currentWork = getNextWorkAndRequest(); logger.verbose(""Current work is terminal, Picked up next receive request.""); } } if (currentWork == null) { if (wip.decrementAndGet() != 0) { logger.warning(""There is another worker in drainLoop. But there should only be 1 worker.""); } if (!delivered) { bufferMessages.add(message); } } }'",protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); },"1- protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }
2- protected void hookOnNext(ServiceBusReceivedMessageContext message) { if (bufferMessages.contains(message)) { bufferMessages.remove(message); if (logger.isVerboseEnabled() && bufferEvents.size() > 0) { logger.verbose(""Dropped {} of {}"", bufferEvents.size(), bufferEvents.keySet().size()); } return; } Boolean delivered = false; if (currentWork == null) { currentWork = getNextReceiveWorkAndRequest(); logger.verbose(""No current work, Picked up next receive request.""); } if (currentWork!= null) { currentWork.next(message); delivered = true; remaining.decrementAndGet(); if (currentWork.isTerminal()) { currentWork.complete(); if (timeoutOperation!= null &&!timeoutOperation.isDisposed()) { timeoutOperation.dispose(); } currentWork = getNextReceiveWorkAndRequest(); logger.verbose(""Current work is terminal, Picked up next receive request.""); } } if (currentWork == null) { if (wip.decrementAndGet()!= 0) { logger.warning(""There is another worker in drainLoop. But there should only be 1 worker.""); } if (!delivered) { bufferEvents.put(message, new ConsumedEvent(currentWork)); } } else { bufferEvents.put(message, new DeliveredEvent(currentWork)); } }
3- protected void hookOnNext(ServiceBusReceivedMessageContext message) { while (true) { if (drainQueue()) { drain(); break; } else { logger.verbose(""No current work, Picked up next receive request.""); } } }
4- protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); tryComplete(); }
5- protected void hookOnNext(ServiceBusReceivedMessageContext message) { boolean delivered = false; Boolean sent = null; if (!complete.get()) { delivered = false; sent = false; if (pendingBuffers.size() > 0) { try { sent = bufferMessages.add(message); } catch (IllegalStateException ex) { logger.error(""Pending message queues full: Ignoring message: {} "", message, ex); } if (sent) { if (timeoutOperation!= null &&!timeoutOperation.isDisposed()) { scheduleTimeouts(); } if (ex) { completedWork.completeExceptionally(ex); } if (doneWork.isDisposed() && hasBeenDrained()) { complete.set(true); return; } } } else { sent = true; delivered = true; } } logger.debug(""OnNext event. Sender: {}, Delivered: {}, Sent: {}, Buffer Queue size: {}"", message.getCreationTime(), delivered, sent, pendingBuffers.size()); }
6- protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }
7- protected void hookOnNext(ServiceBusReceivedMessageContext message) { Boolean delivered = false; manager.invokeLazily(""Pickup next message: "" + message, () -> { if (currentWork == null) { currentWork = getNextWorkAndRequest(); logger.verbose(""No current work, Picked up next receive request.""); } if (currentWork!= null) { currentWork.next(message); delivered = true; remaining.decrementAndGet(); if (currentWork.isTerminal()) { currentWork.complete(); if (timeoutOperation!= null &&!timeoutOperation.isDisposed()) { timeoutOperation.dispose(); } currentWork = getNextWorkAndRequest(); logger.verbose(""Current work is terminal, Picked up next receive request.""); } } }); if (currentWork == null) { if (wip.decrementAndGet()!= 0) { logger.warning(""There is another worker in drainLoop. But there should only be 1 worker.""); } if (!delivered) { bufferMessages.add(message); } } }
8- void hookOnNext(ServiceBusReceivedMessageContext message) { emitIfNotComplete(message); }
9- @Override protected void hookOnNext(ServiceBusReceivedMessageContext message) { if (currentWork!= null) { currentWork.next(message); } if (currentWork == null) { if (wip.decrementAndGet()!= 0) { logger.warning(""There is another worker in drainLoop. But there should only be 1 worker.""); } logger.verbose(""Buffering message, Picked up next receive request.""); bufferMessages.add(message); } else { logger.verbose(""Current work is not finished, Picked up next receive request.""); remaining.decrementAndGet(); if (currentWork.isTerminal()) { currentWork.complete(); if (timeoutOperation!= null &&!timeoutOperation.isDisposed()) { timeoutOperation.dispose(); } currentWork = getNextWorkAndRequest(); logger.verbose(""Current work is terminal, Picked up next receive request.""); } } }
10- protected void hookOnNext(ServiceBusReceivedMessageContext message) { if (drainQueue!= null) { drainQueue.add(new Work<>(message)); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'default of timestamp -1, consistent KeyValue class'
The code is: 'public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; <START> Long timestamp = 0; <END> byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }'","public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = -1; byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }","1- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = -1; byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
2- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); ByteBuffer offset = ByteBuffer.allocate(4); ByteBuffer timestamp = ByteBuffer.allocate(Long.BYTES); byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset.clear(); offset.putInt(unpacker.unpackLong()); offset = offset.duplicate(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp.clear(); timestamp.putLong(unpacker.unpackLong()); timestamp = timestamp.duplicate(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); offset.position(4); timestamp.position(Long.BYTES); return new KeyValue(offset.duplicate(), keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
3- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = mTimestamp; byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
4- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = -1; byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
5- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = -1; byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
6- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; Long timestamp = mTimestamp - 1; byte[] keyBytes = keyBytes; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }
7- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { Integer mapSize = mReader.mapSize(); if (mapSize!= KEY_VALUE_MAP_NOT_SET) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Long offset = 0; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: Long timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); byte[] keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, new byte[0], Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } } else { return null; } }
8- public KeyValue next() throws IOException, KafkaSecurityException { if (mReader.next(mKey, mValue)) { if (mKey.length!= 0) { byte[] kBytes = mKey.getBytes(StandardCharsets.UTF_8); kBytes = kBytes.length == 1? kBytes[0] : EMPTY_BYTES; } Long offset = mReader.getOffset(); long timestamp = mReader.getTimestamp(); MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mValue.getBytes()); int mapSize; if (mValue.getLength() > 0) { mapSize = mValue.getLength() - keySizeInt(); } else { mapSize = -1; } ByteBuffer buffer = ByteBuffer.allocate(4).putInt(mapSize).array(); byte[] kBytes2 = unpacker.unpackArrayHeader(); int payloadOffset = kBytes.length; if (mKey.length!= 0) { kBytes2 = kBytes2.length == 1? kBytes2[0] : EMPTY_BYTES; } unpacker.readPayload(kBytes2); int kSize = kBytes2.length - payloadOffset; if (mapSize > 0 && kSize > mapSize || kSize > 0 && timestamp < kSize * maxKeySize) { kSize = 0; } unpacker.unpackMapHeader(kSize); unpacker.close(true); return new KeyValue(offset, new byte[kSize], Arrays.copyOfRange(mValue.getBytes(), keySize, mValue.getLength())); } else { return null; } }
9- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); Integer mapSize = unpacker.unpackMapHeader(); Long offset = 0; try { Long timestamp = unpacker.readTimestampOrUnknown(); byte[] keyBytes = EMPTY_BYTES; for (Integer i = 0; i < mapSize; i++) { Integer key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP_OR_UNKNOWN: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: Integer keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } return new KeyValue(offset, keyBytes, Arrays.copyOfRange( mValue.getBytes(), 0, mValue.getLength()), timestamp); } finally { unpacker.closeUnpacker(false); } } else { return null; } }
10- public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { byte[] keyBytes = EMPTY_BYTES; if (mKeyFormatClassName!= null) { MessageUnpacker unpacker = MessagePack.newUnpacker(mKeyString); Long timestamp = unpacker.readMapHeader(); mKey = TextFormatSerializer.readStringAndDeserialize(unpacker.readMapHeader(), mKeyFormatClassName); keyBytes = TextFormatSerializer.serialize(mKeyToString()); offset += mKey.getBytes().length; } MessageUnpacker unpacker = MessagePack.newUnpacker(mValue.getBytes()); byte[] payloadBytes = EMPTY_BYTES; if (mPayloadKeyClass!= null) { Long payloadTimestamp = unpacker.readMapHeader(); payloadBytes = unpacker.readPayload(TextFormatSerializer.class.getName() + ""."" + mPayloadKeyClassName); } return new KeyValue(offset, keyBytes, payloadBytes, unpacker.unpackLong()); } else { return null; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'More weird union() usage for setting min-max values. min-max constructor. suggestion BlockRegion region = new BlockRegion(mins.get(i), max.get(i));'
The code is: 'public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { <START> BlockRegion region = new BlockRegion().union(mins.get(i)).union(max.get(i)); <END> assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }'","public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }","1- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }
2- public void testCreateRegionWithMinMax() { BlockRegion min = new BlockRegion(mins.get(0), max.get(0)); BlockRegion max = new BlockRegion(mins.get(1), max.get(1)); BlockRegion region = new BlockRegion(min).union(max); assertEquals(min, region.getMin(new Vector3i())); assertEquals(max, region.getMax(new Vector3i())); assertEquals(expectedSize, region.getSize(new Vector3i())); }
3- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }
4- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(""Invalid min/max result"", mins.get(i), region.getMin(new Vector3i())); assertEquals(""Invalid min/max result"", max.get(i), region.getMax(new Vector3i())); assertEquals(""Invalid min/max result"", expectedSize.get(i), region.getSize(new Vector3i())); } }
5- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < minList.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(minList.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }
6- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); assertThrowsWithMessage(""min and max should equal each other"")(() -> BlockRegion.create(mins).min(new Vector3i())); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }
7- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); BlockRegion actual = new BlockRegion(); actual.setMin(mins.get(i)); actual.setMax(max.get(i)); assertEquals(region, actual); } }
8- public void testCreateRegionWithMinMax() { List<Vector3i> vec3is = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 3), new Vector3i(3, 4, 6)); List<Vector3i> vec3isExpected = Arrays.asList(new Vector3i(1, 1, 3), new Vector3i(3, 3, 3), new Vector3i(8, 8, 8)); BlockRegion blockRegion = new BlockRegion(vec3is); for (Vector3i min : vec3is) { blockRegion = blockRegion.union(min); assertEquals(vec3is.get(0), blockRegion.getMin(new Vector3i())); assertEquals(vec3isExpected.get(0), blockRegion.getMax(new Vector3i())); assertEquals(vec3isExpected.get(0), blockRegion.getSize(new Vector3i())); } }
9- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }
10- public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (Integer i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'message: ""Hashing a column of type "" + column.getType() + "" is unsupported""'
The code is: 'private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: <START> throw new UnsupportedOperationException(""Hashing a column of type "" + column.getType()); <END> } }'","private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException( ""Hashing a column of type "" + column.getType() + "" is unsupported""); } }","1- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new IAE(""Hashing a column of type %s is unsupported"", column.getType()); } }
2- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { if (column.getType() instanceof Array) { Array array = (Array) column.getType(); Hasher innerH = addValue(hasher, array.getArray(row), 0); hasher.mergeHashers(indices -> { Hasher value = new Hasher(innerH.nextHasher()); for (int i = 0; i < indices; ++i) { Object value_i = array.getArrayElementAt(row, i); value.addValue(addValue(value_i, column.getType()[indices - i - 1] + ""."" + column.getType().getName()), row); } return value; }); } else { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Hashing a column of type "" + column.getType()); } } }
3- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(null, TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Hashing a column of type "" + column.getType() + "" is unsupported""); } }
4- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Hashing a column of type "" + column.getType() + "" is not supported""); } }
5- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new IllegalArgumentException( ""Hashing a column of type "" + column.getType() + "" is unsupported""); } }
6- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new IllegalArgumentException(""Hashing a column of type "" + column.getType() + "" is not supported""); } }
7- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Hashing a column of type ["" + column.getType() + ""] is unsupported. "" + ""Only primitive types and maps can be used as values for hashed column.""); } }
8- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new SerializationException(""Hashing a column of type "" + column.getType() + "" is not supported""); } }
9- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Hashing a column of type "" + column.getType() + "" is unsupported""); } }
10- private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final long row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putBigString(column.getString(row).toBytes(), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException(""Column type "" + column.getType() + "" is unsupported""); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add empty string'
The code is: 'private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); <START> xVals.add(date + """"); <END> } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }'","private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }","1- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
2- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); xVals.add(""""); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
3- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.getDateString(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
4- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = presenter.parseWeight(presenter.getWeightReadings().get(i).toString(), presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(xValues, generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
5- private LineData generateWeightData() { LineDataSet dataSet = generateWeightDataSet(presenter.getWeightReadings()); if (dataSet!= null) { return new LineData(dataSet); } else { return null; } }
6- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); String dataString = (presenter.getWeightReadings().size() + 1) + "" \u2026 ""; List<Entry> yVals = new ArrayList<>(); for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); dataString += String.valueOf(val); dataString += "" \u2026 ""; yVals.add(new Entry(i, val)); } dataString = dataString.replaceAll("" \u2026 "", """"); dataString = dataString.replaceAll("" \\t"",""""); dataString = dataString.replaceAll("" \t"",""""); yValues = yVals; xValues = dataString.split("" \u2026 ""); return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
7- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDateTimeShort(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
8- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add("" "" + date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
9- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date + """"); } xValues = xValues.stream().collect(Collectors.toList()); return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }
10- private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); Integer k = 0; for (Integer i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { Float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (Integer i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'mind naming variable aggregatedFieldsQueryBuilder instead of builder'
The code is: 'public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { <START> BooleanQuery.Builder builder = new BooleanQuery.Builder(); <END> for ( FieldContext fieldContext : fieldContexts ) { builder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( builder.build() ).createQuery(); } }'","public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }","1- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { final BooleanQuery conversionQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { final Query query = createQuery( fieldContext, conversionContext ); if ( query!= null ) { conversionQueryBuilder.add( query, BOOLEAN_QUERY_COMPARISON_OPTION )-> BooleanClause.Occur.NONE; } } return queryCustomizer.setWrappedQuery( conversionQueryBuilder.build() ).createQuery(); } }
2- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { BooleanQuery aggregatedFieldsQuery = new BooleanQuery.Builder().addAll( fieldContexts.stream().map( fieldContext -> createQuery( fieldContext, conversionContext ).createQuery() ).collect( Collectors.toList() ) ).build(); return queryCustomizer.setWrappedQuery( aggregatedFieldsQuery ).createQuery(); } }
3- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { final BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
4- public Query createQuery() { final long size = fieldsContexts.size(); checkState( size == 1, ""This query can only be created with exactly one field context""); return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), null ) ).createQuery(); }
5- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { final BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
6- public Query createQuery() { final long size = fieldContexts.size(); final long numOfConversionBasedFilterFields = size - 1; final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
7- public Query createQuery() { BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); final long size = fieldContexts.size(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), aggregatedFieldsQueryBuilder ) ).createQuery(); } else { Iterator<FieldContext> fieldContextsIterator = fieldContexts.iterator(); Iterator<BooleanClause> clausesIterator = aggregatedFieldsQueryBuilder.add( createQuery( fieldContextsIterator.next(), aggregatedFieldsQueryBuilder ), BooleanClause.Occur.SHOULD ).iterator(); return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
8- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper( query.getAggFieldToExpression() ); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { final AggregatedFieldsQuery.Builder aggregatedFieldsQueryBuilder = new AggregatedFieldsQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { final Expression expression = createQuery( fieldContext, conversionContext ).getQuery().getBoostQuery(); aggregatedFieldsQueryBuilder.addAggregatedField( aggregateFieldName, expression, true ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
9- public Query createQuery() { final long size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { final BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }
10- public Query createQuery() { final QueryBuilder aggregatedFieldsQueryBuilder = this.queryBuilder; final long size = fieldContexts.size(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), aggregatedFieldsQueryBuilder.getConversionContext() ) ).createQuery(); } else { final List<QueryBuilder> queries = new ArrayList<>(); for ( int i = 0; i < size; i++ ) { final FieldContext fieldContext = (i == size - 1)? fieldContexts.get( i ) : fieldContexts.get( i - 1 ); queries.add( createQuery( fieldContext, aggregatedFieldsQueryBuilder.getConversionContext() ) ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.setQueries( queries ) ).createQuery(); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Drop logging line'
The code is: 'public void start() { <START> System.out.println(""ServerSideSession Start""); <END> instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }'","public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }","1- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
2- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); }
3- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { throw new SessionException(""Unable to connect to WD hub. Make sure "" + ""your browser is configured to open https://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub"", e); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
4- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (final Exception e) { e.printStackTrace(); } if (url == null) { log.warning(""Unable to start Session""); return; } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(ModeType.Remote); getRemoteWebDriver().get(""about:blank""); } }
5- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""stopping server-side session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); url = new URL(url.toExternalForm().replace(""\\"" + getSessionId().toString(), "" "")); } catch (URISyntaxException e) { throw new RuntimeException(e); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
6- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { throw new RuntimeException(e); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
7- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { hardForceStopSession(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""Safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
8- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); }
9- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(""forcing stop session that has been running for "" + sessionTimeoutMillis / 1000 + "" seconds""); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(""http://localhost:"" + driver.getHostInfo().getPort() + ""/wd/hub""); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (""safari"".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(""about:blank""); } }
10- public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final long sessionTimeoutMillis = options.getSessionTimeoutMillis(); if (shouldStartSessionTimer()) { stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.info(""ServerSideSession stopped""); setMode(WorkingMode.Null); hardForceStop(); } }, sessionTimeoutMillis); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I verifying this patch. vdsUpEvent called. called host status is UP. host status glusterd service is started. I move this logic ActivcateVdsCommand'
The code is: 'public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } <START> if (isSucceeded && vds.getVdsGroupSupportsGlusterService()) { <END> isSucceeded = resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart"")).getSucceeded(); } return isSucceeded; }'","public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } return isSucceeded; }","1- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } if (vds.getVdsGroupSupportsGlusterService() && isSucceeded && resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart"")).getSucceeded()) { isSucceeded = true; } return isSucceeded; }
2- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params); return vds.getVdsGroupSupportsGlusterService() && resourceManagerProvider.get().isGlusterServiceRunning(vds.getId()); }
3- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } return isSucceeded && vds.getVdsGroupSupportsGlusterService()? isSucceeded : null; }
4- public boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } if (vds.getVdsGroupSupportsGlusterService()) { isSucceeded = resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart"")).getSucceeded(); } return isSucceeded; }
5- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (!isSucceeded) { List<GlusterVolumeEntity> volumes = DbFacade.getInstance().getGlusterVolumeDao().getVolumesByVolumeId(makeVdsId(vds)); if (volumes.size() > 0) { if ((getGlusterService().shutdown(vds)) && isSucceeded) { isSucceeded = backend.runInternalAction(VdcActionType.ReinitGlusterVolume, new ReinitGlusterVolumeVDSParameters(vds, Arrays.asList(volumes))).getSucceeded(); } } else { log.errorFormat(""Failed to execute 'init_vds_up' due to 'vds_not_up' or volume-not-found fault message""); return false; } } if (isSucceeded && vds.getVdsGroupSupportsGlusterService()) { isSucceeded = resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart"")).getSucceeded(); } return isSucceeded; }
6- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } backend.runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart""), null).setSucceeded(isSucceeded); return isSucceeded; }
7- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Frontend.getInstance().runAction(VdcActionType.vdsUpOnUp, params); return params.isUp(); }
8- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } }
9- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); return; } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } if (vds.getVdsGroupSupportsGlusterService()) { isSucceeded = resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(""glusterd""), ""restart"")).getSucceeded(); } return isSucceeded; }
10- public Boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); Boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(""Failed to initialize Vds on up: {}"", e.getMessage()); log.error(""Exception"", e); } } }); } setVdsStatus(vds, VdsStatus.Online, true, true); return isSucceeded; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Replace Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size());'
The code is: 'private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); <START> Map<Integer, String> sectionDescriptions = new HashMap<>(); <END> for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }'","private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }","1- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
2- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
3- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
4- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
5- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.keySet().size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
6- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
7- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (Integer key : jsonSectionDescriptions.keySet()) { sectionDescriptions.put((Integer) jsonSectionDescriptions.get(key).get(""sectionNumber"").isNumber().doubleValue(), jsonSectionDescriptions.get(key).get(""sectionName"").isString().stringValue()); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (int i = 0; i < fields.size(); i++) { JSONObject field = fields.get(i).get(""field""); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); f.setDescription(pluginName + "" "" + descr); desc.getConfigurableFields().add(f); } return desc; }
8- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, new HashMap<>(jsonSectionDescriptions.size())); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
9- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, jsonSectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }
10- private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(""pluginDescription"").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(""sectionDescriptions"").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { Integer sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(""configurableFields"").isArray(); for (Integer j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(""name"").isString().stringValue(); String value = field.get(""value"").isString().stringValue(); JSONObject meta = field.get(""meta"").isObject(); String metaType = meta.get(""type"").isString().stringValue(); String descr = meta.get(""description"").isString().stringValue(); Boolean dynamic = meta.get(""dynamic"").isBoolean().booleanValue(); Integer sectionSelector = (Integer) meta.get(""sectionSelector"").isNumber().doubleValue(); Boolean password = false; Boolean credentials = false; Boolean file = false; Boolean textArea = false; if (metaType.equalsIgnoreCase(""password"")) { password = true; } else if (metaType.equalsIgnoreCase(""fileBrowser"")) { file = true; } else if (metaType.equalsIgnoreCase(""credential"")) { credentials = true; } else if (metaType.equalsIgnoreCase(""textArea"")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '> find'
The code is: 'public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { <START> log.error(""Did not found any TaskLock [%s] to remove"", taskLockToRemove); <END> } }'","public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error(""Did not find any TaskLock [%s] to remove"", taskLockToRemove); } }","1- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksForTask(taskid); Boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error(""Could not find any TaskLock [%s] to remove"", taskLockToRemove); } }
2- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); TaskLocks.TaskLockHolder taskLockHolder = findTaskLockHolder(taskid); if (taskLockHolder == null) { throw new IllegalStateException(""Cannot find task with id[%s]"", taskid); } TaskLocks taskLocks; if (taskLockHolder.getLocks()!= null) { taskLocks = taskLockHolder.getLocks(); } else { taskLocks = Collections.emptyMap(); } taskLockToRemove.getLocks().forEach(lock-> { try { removeLock(taskid, lock, taskLocks); } catch (IOException e) { log.error(""Cannot remove lock [%s]"", lock); throw new RuntimeException(""Unexpected exception occurred during removing locks"", e); } }); }
3- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); final boolean removed =!taskLocks.containsKey(taskLockToRemove.getId()); if (!removed) { log.error(""Did not find any TaskLock with Id [%d] to remove"", taskLockToRemove.getId()); } else { log.info(""Removing TaskLock with Id[%d]: %s"", taskLockToRemove.getId(), taskLockToRemove); handler.removeLock(taskLockToRemove.getId()); } }
4- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Optional<TaskLock> taskLockOptional = Optional.ofNullable(taskLocks.entrySet().stream().filter(mapEntry -> mapEntry.getValue().equals(taskLockToRemove)).findFirst()); if (taskLockOptional.isPresent()) { handler.removeLock(taskLockOptional.get().getKey()); } }
5- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> lockWithIds = getLocksByTaskId(taskid); final boolean removedDelegatingToCurrentThread = lockWithIds.remove(taskLockToRemove.getId()) > 0; if (removedDelegatingToCurrentThread) { return; } for (final Map.Entry<Long, TaskLock> taskLockWithId : lockWithIds.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removedDelegatingToCurrentThread = true; } } if (!removedDelegatingToCurrentThread) { log.warning(""Did not find any TaskLock to remove""); } }
6- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Removing TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error(""Did not find any TaskLock[%s] to remove"", taskLockToRemove); } }
7- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error(""Did not find any TaskLock [%s] to remove"", taskLockToRemove); } }
8- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); Boolean removed = false; for (final Map<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error( ""Did not find any TaskLock[%s] with id[%s] to remove"", taskLockToRemove, taskid); } }
9- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); final Set<Long> removedLockIds = new HashSet<>(); for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { removedLockIds.add(id); handler.removeLock(id); } } if (removedLockIds.isEmpty()) { log.error(""Did not find any TaskLock [%s] to remove"", taskLockToRemove); } else { log.info(""Deleted ["" + removedLockIds.size() + ""] TaskLock(s) with ids[%s]."", joinedTaskLockDescription(removedLockIds)); } }
10- public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, ""taskid""); Preconditions.checkNotNull(taskLockToRemove, ""taskLockToRemove""); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final Long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(""Deleting TaskLock with id[%d]: %s"", id, taskLock); handler.removeLock(id); removed = true; } } final TaskLock taskLockToRemoveCopy = taskLockToRemove; if (!removed) { log.error(""Did not find any TaskLock [%s] to delete"", taskLockToRemoveCopy); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'be: java logger.error(""Cannot publish topic: {}"", topic, e);'
The code is: 'private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { <START> logger.error(""Cannot publish topic: {}"" + topic, e); <END> } }'","private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Cannot publish topic: {}"", topic, e); } }","1- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { this.setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { this.setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { this.setPoint = 6.0F; } if (this.temperature + tempIncr < this.setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error( ""Cannot publish topic: {}, check if the specified topic is invalid"" + "", or check that your server has not reached the maximum number of retry attempts ({})!"", topic, e); } }
2- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Cannot publish topic: {} exception: {}"", topic, e); } }
3- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to: {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Cannot publish topic: {}"", topic, e); } }
4- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Could not publish topic: "" + topic, e); } }
5- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Cannot publish topic: {}"", topic, e); } }
6- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); this.logger.info(""Published to topic: {} message: {}"", topic, payload); } catch (Exception e) { this.logger.error(""Cannot publish topic: {} error: {}, "", topic, e); } }
7- private void doPublish() { String topic = (String)this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_PROPERTY_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_PROPERTY_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0f; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } if (this.isPublishErrorLog) { logger.error(""Could not publish: {}"", topic); } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5F); payload.addMetric(""temperatureExhaust"", 30F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try (OutputStream os = this.server.sendPublish(topic, payload, qos, retain)) { } catch (Exception e) { logger.error(""Could not publish: {}"", topic, e); } }
8- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); Boolean shouldRetain = (Boolean) this.properties.get(RETAIN_VALUE_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMPERATURE_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } try { this.cloudClient.publish(topic, payload, qos, retain, shouldRetain); logger.info(""Published to {} message: {}"", topic, payload); } catch (Exception e) { logger.error(""Cannot publish topic: {{}}"", topic, e); } }
9- private void doPublish() throws Exception { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(""errorCode"", code); } else { payload.addMetric(""errorCode"", 0); } logger.info(""Publishing to {} {}"", topic, payload); try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Publishing to {} successfully"", topic); } catch (Exception e) { logger.error(""Cannot publish topic: {}"", topic, e); throw e; } }
10- private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); Float setPoint = 0; if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } Float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); this.temperature += tempIncr; if (this.temperature <= this.temperatureSetPoint) { logger.info(""Temperature is set to: {}"", this.temperature); } else { logger.info(""Temperature is set to: {}; but not to the setpoint"", this.temperature); } final KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(""temperatureInternal"", this.temperature); payload.addMetric(""temperatureExternal"", 5.0F); payload.addMetric(""temperatureExhaust"", 30.0F); Integer code = this.random.nextInt(); payload.addMetric(""errorCode"", code); try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(""Published to {} message: {}"", topic, payload); } catch (ClientException te) { logger.error(""cannot publish: {}"", topic, te); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'writeLong(Double.doubleToLongBits(v)) avoid code duplication'
The code is: 'public void writeDouble(double v) { <START> final Long bits = Double.doubleToLongBits(v); <END> Integer newcount = ensureCapacity(8); final Integer s = pos; bytes[s] = (byte) (bits >> 56L); bytes[s+1] = (byte) (bits >> 48L); bytes[s+2] = (byte) (bits >> 40L); bytes[s+3] = (byte) (bits >> 32L); bytes[s+4] = (byte) (bits >> 24L); bytes[s+5] = (byte) (bits >> 16L); bytes[s+6] = (byte) (bits >> 8L); bytes[s+7] = (byte) bits; pos = newcount; }'",public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); },"1- public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }
2- public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }
3- public void writeDouble(double v) { pos = writeLong(Double.doubleToLongBits(v)); }
4- public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }
5- public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }
6- public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }
7- public void writeDouble(double v) { final Long bits = Long.doubleToLongBits(checkedCast(bpm, v)); Integer newcount = ensureCapacity(8); final Integer s = pos; bytes[s] = (byte) ((bits >>> 56) & 255); bytes[s + 1] = (byte) ((bits >>> 48) & 255); bytes[s + 2] = (byte) ((bits >>> 40) & 255); bytes[s + 3] = (byte) ((bits >>> 32) & 255); bytes[s + 4] = (byte) ((bits >>> 24) & 255); bytes[s + 5] = (byte) ((bits >>> 16) & 255); bytes[s + 5] = (byte) ((bits >>> 8) & 255); bytes[s + 6] = (byte) bits & 255; bytes[s + 7] = (byte) (bits >>> 32); pos = newcount; }
8- public void writeDouble(double v) { position += DOUBLES_TO_BYTES * 8; bytes[position] = (byte) (Double.doubleToLongBits(v) >>> 56); bytes[position+1] = (byte) (Double.doubleToLongBits(v) >>> 48); bytes[position+2] = (byte) (Double.doubleToLongBits(v) >>> 40); bytes[position+3] = (byte) (Double.doubleToLongBits(v) >>> 32); bytes[position+4] = (byte) (Double.doubleToLongBits(v) >>> 24); bytes[position+5] = (byte) (Double.doubleToLongBits(v) >>> 16); }
9- public void writeDouble(double v) { final long bits = Double.doubleToLongBits(v); Integer newcount = ensureCapacity(8); final Integer s = pos; bytes[s] = (byte) (bits >> 56L); bytes[s+1] = (byte) (bits >> 48L); bytes[s+2] = (byte) (bits >> 40L); bytes[s+3] = (byte) (bits >> 32L); bytes[s+4] = (byte) (bits >> 24L); bytes[s+5] = (byte) (bits >> 16L); bytes[s+6] = (byte) (bits >> 8L); bytes[s+7] = (byte) bits; pos = newcount; }
10- public void writeDouble(double v) { Long bits = Double.doubleToLongBits(v); bytes[pos] = bits; pos += 8; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'String'
The code is: 'protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; <START> StringBuilder category = new StringBuilder(); <END> if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; category.append(""ERROR""); } else { priority = Priority.NORMAL; category.append(""Warning""); } Warning warning = createWarning(fileName, lineNumber, category.toString(), message, priority); return warning; }'","protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; String category; if (""err"".equalsIgnoreCase(matcher.group(4))) { priority = Priority.HIGH; category = ""ERROR""; } else { priority = Priority.NORMAL; category = ""Warning""; } return createWarning(fileName, lineNumber, category, message, priority); }","1- public Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); String lineNumber = matcher.group(2); String message = matcher.group(7); Priority priority; if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; return Warning.buildWith(fileName, lineNumber, priority, MessageCategory.ERROR, message); } return Warning.buildWith(fileName, lineNumber, priority, MessageCategory.WARN, message); }
2- private Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; String category = matcher.group(4).equalsIgnoreCase(""err"")? ""ERROR"" : ""Warning""; Warning warning = createWarning(fileName, lineNumber, category, message, priority); return warning; }
3- protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String categoryMessage = matcher.group(7); String message; Priority priority; if (fileName!= null) { Integer priorityIndex; String messagePriority; if (categoryMessage == null) { message = fileMessage(matcher.group(1), matcher.group(2)); message = message.isEmpty()? ""\n"" : message + ""\n""; priorityIndex = Integer.valueOf(matcher.group(3)); messagePriority = messagePriorityIndex(matcher.group(4)); } else { message = categoryMessage(fileName, lineNumber); priorityIndex = Integer.valueOf(matcher.group(3)); messagePriority = messagePriorityIndex(categoryMessage); } priority = Priority.valueOf(matcher.group(5).trim()); message = message!= null? message.trim() : """"; if (message.isEmpty()) { message = ""This message is unavailable""; } return createWarning(message, priorityIndex, messagePriority, message, priority); } else { Priority priority; String message; if (categoryMessage!= null) { message = fileMessage(matcher.group(1), matcher.group(2)); message = messagePriorityIndex(matcher.group(4)); if (message == null) { message = ""A "" + categoryMessage + "" error occurred in line ""+ lineNumber + "" of file "" + fileName; } } else { message = ""Unknown file: "" + fileName; } priority = Priority.NORMAL; return createWarning(fileName, lineNumber, priority.toString(), message, priority); } }
4- protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); if (matcher.group(4).equalsIgnoreCase(""err"")) { return createWarning(fileName, lineNumber, Priority.HIGH, message); } return createWarning(fileName, lineNumber, message, Priority.NORMAL); }
5- @Override protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; } else { priority = Priority.NORMAL; } String category = matcher.group(5); Warning warning = createWarning(fileName, lineNumber, category, message, priority); return warning; }
6- protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; if (isErr(matcher.group(4))) { priority = Priority.HIGH; } else { priority = Priority.NORMAL; } Warning warning = createWarning(fileName, lineNumber, message, priority); return warning; }
7- protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; StringBuilder category = Strings.empty(null); if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; category = Strings.empty(); } else { priority = Priority.NORMAL; category = Strings.empty(); } Warning warning = createWarning(fileName, lineNumber, category.toString(), message, priority); return warning; }
8- protected Warning createWarning(final Matcher matcher) { String fileName = getString(matcher.group(1)); Integer lineNumber = getInt(matcher.group(2)); String category = getString(matcher.group(6)); String message = getString(matcher.group(13)); Priority priority; if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; category = ""ERROR""; } else { priority = Priority.NORMAL; category = ""Warning""; } Warning warning = new Warning(fileName, lineNumber, category, message, priority); return warning; }
9- private Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; String category = matcher.group(4).equalsIgnoreCase(ERR_HIGH)? ""ERROR"" : matcher.group(4).equalsIgnoreCase(ERR_NORMAL)? ""Warning"" : null; return createWarning(new File(filename), lineNumber, category, message, priority, fileName); }
10- protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); Integer lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; String category; if (matcher.group(4).equalsIgnoreCase(""err"")) { priority = Priority.HIGH; category = ""ERROR""; } else { priority = Priority.NORMAL; category = ""Warning""; } Warning warning = createWarning(fileName, lineNumber, category.toString(), message, priority); return warning; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'bit nicer assertThatThrownBy'
The code is: 'public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); try { <START> programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE); <END> fail(""No sv indexed should not generate a program state for ""); } catch (NullPointerException npe) { assertThat(npe).hasMessage(""Loading a symbolic value unindexed""); } } }'","public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).hasMessage(""Loading a symbolic value unindexed""); } }","1- public void test_load() throws Exception { List<SymbolicValue> svs = new ArrayList<>(); Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); svs.add(loadRef); } testMixed(svs, false, 0); testMixed(svs, false, 1); testMixed(svs, true, 0); testMixed(svs, true, 1); }
2- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).isInstanceOf(NonDeterministic.class); } }
3- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); try { assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).isInstanceOf(NullPointerException.class).hasMessage(""No sv indexed""); } catch (NullPointerException npe) { fail(""No sv indexed should not generate a program state for ""); } } }
4- public void test_load() throws Exception { for (Integer loadRefOpcode : new Integer[]{Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); try { assertThatThrownBy(() -> { programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE); }).hasMessage(""No sv indexed should not generate a program state for ""); assertThatThrownBy(() -> { programState = execute((Instruction) loadRef.getInstruction(), ProgramState.EMPTY_STATE); }).hasMessage(""No sv indexed should not generate a program state for ""); assertThatThrownBy(() -> { programState = execute(new MethodInvocation(loadRef.getSymbolicMethodReference(), Collections.emptyList(), 0), ProgramState.EMPTY_STATE); }).hasMessage(""No sv indexed should not generate a program state for ""); }catch(Throwable t) { throw Throwables.propagate(t); } } } }
5- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).hasMessage(""No sv indexed should not generate a program state for ""); } }
6- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).isExactlyInstanceOf(NullPointerException.class).hasMessage(""No sv indexed should not generate a program state for ""); } }
7- public void test_load() throws Exception { for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).hasMessage(""No sv indexed should not generate a program state for ""); } }
8- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).isInstanceOf(IllegalArgumentException.class).hasMessage(""Load value must be indexed for sv: 0:il""); } }
9- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); loadRef.markIndeependent(); boolean wasSaved = false; try { programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE); assertThatThrownBy(() -> programState.peekValue().markIndependent()).isInstanceOf(IllegalStateException.class); wasSaved = true; } finally { if (!wasSaved) { saveSlot(programState); } } assertThatThrownBy(() -> programState.peekValue().markIndependent()).isInstanceOf(IllegalStateException.class); } }
10- public void test_load() throws Exception { Integer[] loadRefOpcodes = new Integer[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (Integer loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); } try { execute(new Instruction(Opcodes.NEWARRAY, 0), ProgramState.EMPTY_STATE); fail(); } catch (NullPointerException npe) { assertThat(npe).hasMessage(""indexed NEWARRAY op code must contain 1 or more indexed symbols""); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'random a member variable of this class instead of constructed in methods'
The code is: 'private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); <START> Random random = new Random(); <END> for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }'","private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }","1- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
2- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
3- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<MongoDataNode> hostPorts = (ArrayList<MongoDataNode>) exceptionHostPorts.clone(); for (int i = 0; i < count; i++) { MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(random.nextInt(hostPorts.size()))); mockDataNode.setDeleteException(errorCode); hostPorts.remove(random.nextInt(hostPorts.size())); } }
4- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = exceptionHostPorts; List<Integer> nonExistentHostPorts = (ArrayList<Integer>) exceptionNonExistentHostPorts.clone(); for (int i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } for (Integer nonExistentHostPort: nonExistentHostPorts) { MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, nonExistentHostPort); mockDataNode.setDeleteException(errorCode); } }
5- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
6- void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); Random random = new Random(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
7- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random().nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
8- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
9- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextRandom = random.getRandomInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }
10- private void induceDeleteFailure(Integer count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (Integer i = 0; i < count; i++) { Integer nextPort = randomPortSelector.next(); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextPort)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextPort); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '""next""'
The code is: 'protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore <START> nextStore = <END> (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(nextStore.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }'",protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore buttonPreferenceStore = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(buttonPreferenceStore.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); },"1- protected void performDefaults() { String key; for (Integer i= 0; i < fCheckBoxes.size(); i++) { key = (String) fCheckBoxes.get(i).getData(); IPreferenceStore store = (IPreferenceStore) fCheckBoxes.get(i).getData(PREFERENCE_STORE_KEY); if(store.getDefaultBoolean(key)) { fCheckBoxes.get(i).setSelection(true); } else { fCheckBoxes.get(i).setSelection(false); } } if (fCheckBoxes.get(fCheckBoxes.size() - 1).getSelection()) { IPreferenceStore store = (IPreferenceStore) fCheckBoxes.get(fCheckBoxes.size() - 1). getData(PREFERENCE_STORE_KEY); fRadioButtons.get(fRadioButtons.size() - 1).setSelection(false); } String key; for (Integer i= 0; i < fRadioButtons.size(); i++) { key = (String) fRadioButtons.get(i).getData(); if(fRadioButtons.get(i).getSelection()) { fRadioButtons.get(i).setSelection(false); } } fTextControls.get(fTextControls.size() - 1).setText(getText()); }
2- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore nextPreferenceStore= (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(nextPreferenceStore.getDefaultBoolean(key)); } super.performDefaults(); }
3- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore store = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(store.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String key= (String) button.getData(); button.setSelection(button.getSelection().equals(store.getDefaultString(key))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
4- protected void performDefaults() { refreshDefaultValues(); for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); button.setText(getPreferenceStore().getDefaultString(key)); IDataStore store= getStore(button); button.setSelection(store == null? false :!store.getBoolean(key)); } super.performDefaults(); }
5- protected void performDefaults() { for (int i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore store = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(store.getDefaultBoolean(key)); } for (int i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(Arrays.asList(info).contains(store.getDefaultString(info[0]))); } for (int i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
6- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore store= getPreferenceStore(); button.setSelection(store.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
7- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IWorkbenchPreferenceStore store= (IWorkbenchPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(store.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
8- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore defaultStore = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(defaultStore.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
9- protected void performDefaults() { for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore store = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(store.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (Integer i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }
10- protected void performDefaults() { int textLength= 0; for (Integer i= 0; i < fTextBoxes.size(); i++) { if (fTextBoxes.get(i) instanceof Text) textLength= fTextBoxes.size(); else break; } for (Integer i= 0; i < fTextControls.size(); i++) { if (fTextControls.get(i) instanceof Text) { int boxLength= textLength; int textLength= Integer.max(textLength, ((Text) fTextControls.get(i)).getCharsAvailable()); ((Text) fTextControls.get(i)).setColumns(textLength); } } for (Integer i= 0; i < fComboBoxes.size(); i++) { ComboBox box= fComboBoxes.get(i); String key= (String) box.getData(); box.setSelection(getPreferenceStore().getDefaultInt(key)); } for (Integer i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); button.setSelection(getPreferenceStore().getDefaultBoolean(key)); } for (Integer i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(getPreferenceStore().getDefaultString(info[0]))); } super.performDefaults(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Integer.valueOf(100) purely for consistency reasons'
The code is: 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); <END> assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }'","public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""clearOnFlush"", Boolean.class)); }","1- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
2- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(100), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); final Integer flushSize = TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class); assertEquals(new Integer(100), flushSize); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
3- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); Integer flushSize = TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class); assertEquals(Integer.valueOf(Integer.MAX_VALUE / 2), flushSize); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
4- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(100), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
5- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = testUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = testUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = testUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = testUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100L, sendTimeout); assertFalse(testUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", boolean.class)); final JpaExecutor jpaExecutor = testUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = testUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = testUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = testUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = testUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = testUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), testUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(testUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", boolean.class)); }
6- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(100), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
7- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.JpaEntity"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(2, order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
8- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(2, order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
9- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(1000, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(100, order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }
10- public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(""JpaOutboundGatewayParserTests.xml"", getClass(), ""updatingJpaOutboundGateway""); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, ""inputChannel"", AbstractMessageChannel.class); assertEquals(""in"", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, ""handler"", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, ""gatewayType"", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); Long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, ""messagingTemplate.sendTimeout"", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, ""requiresReply"", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, ""handler.jpaExecutor"", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, ""entityClass"", Class.class); assertEquals(""org.springframework.integration.jpa.test.entity.StudentDomain"", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, ""jpaOperations"", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, ""usePayloadAsParameterSource"", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, ""order"", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, ""persistMode"", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, ""flushSize"", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, ""cleanOnFlush"", Boolean.class)); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simply return tid'
The code is: 'public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } <START> if (tid != null) { <END> return tid; } return null; }'","public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }","1- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid == null? null : tid; }
2- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
3- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value!= NullStateValue.INSTANCE) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
4- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue stateValue = stateSystem.querySingleState(time, cpuQuark); if (stateValue.getType() == Type.INTEGER) { tid = stateValue.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); return null; } return tid; }
5- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
6- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
7- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(cpu.toString()); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
8- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
9- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { Integer cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }
10- public @Nullable Integer getThreadOnCpuAtTime(Integer cpu, long time) { ITmfStateSystem ss = getStateSystem(); if (ss == null) { return null; } Integer tid = null; try { Integer cpuQuark = ss.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = ss.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } if (tid!= null) { return tid; } return null; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I prefer formatter, message easily readable reviewing: java String.format(""Split this %d characters long line (which is greater %d authorized)."", length, maximumLineLength)'
The code is: 'public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, <START> ""Split this "" + length + "" characters long line (which is greater than "" + maximumLineLength + "" authorized)."", <END> Collections.emptyList()); } lineNumber++; } }'","public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(""Split this %d characters long line (which is greater than %d authorized)."", length, maximumLineLength), Collections.emptyList()); } lineNumber++; } }","1- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format( ""Split this line%s, which is too long for the "" + ""authorized maximum of %d characters."", (length > maximumLineLength)? "" longer than"" : """", maximumLineLength)); } lineNumber++; } }
2- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format( ""Split this %d characters long line (which is greater than %d authorized)."", length, maximumLineLength)); } lineNumber++; } }
3- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = Utils.trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(""Split this %d characters long line (which is greater than %d allowed)."", length, maximumLineLength)); } lineNumber++; } }
4- void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(""Split this %d characters long line (which is greater %d authorized)."", length, String.valueOf(maximumLineLength))); } lineNumber++; } }
5- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(""Split this %d characters long line (which is greater than %d authorized). "", length, maximumLineLength), Collections.emptyList()); } lineNumber++; } }
6- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber - 1, trimLine.length()); reportIssue(textRange, ""Split this "" + length + "" characters long line (which is greater than "" + maximumLineLength + "" authorized).""); break; } lineNumber++; } }
7- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, PLAIN_TEXT, lineNumber, trimLine.length()); reportIssue(textRange, String.format(""Split this %d characters long line (which is greater than %d authorized)."", length, maximumLineLength)); } lineNumber++; } }
8- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = newXmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(LOCALIZED_MESSAGE, length, maximumLineLength)); } lineNumber++; } }
9- public void scanFile(XmlFile file) { Integer lineNumber = 1; ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try { IO.appendTo(file.getContents(), buffer); } catch (IOException e) { LOG.warn(""I/O error."", e); return; } String string = buffer.toString(StandardCharsets.UTF_8.name()); Buffer buffered = new Buffer(string); for (int i = 0; i < buffered.size(); i++) { int newLinePos = i; int offset = 0; boolean isEndOfLine = false; for (; i < buffered.size(); i++) { String character = buffered.getRawBuffer()[i + offset]; if (character.trim().length() > 0) { if (isEndOfLine) { offset = i; continue; } else { isEndOfLine = true; } String linePart = String.format("" %s"", character); while (linePart.length() > 0) { if (linePart.length() > MAX_LINE_LENGTH) { reportLine(new TextRange(newLinePos, offset + 1), errorMessage(linePart)); break; } ++newLinePos; linePart = String.format(""%s "", character); } } } } buffered.flush(); IO.reset(buffered); } finally { IO.close(buffer); } }
10- public void scanFile(XmlFile file) { Integer lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); Integer length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, ""Split this "" + length + "" characters long line, which is greater than "" + maximumLineLength + "" authorized"", Collections.emptyList()); } lineNumber++; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(optional)'
The code is: 'public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); <START> try (final ObjectReader curs = clp.getRepository().newObjectReader()) { <END> p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }'","public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader curs = clp.getRepository().newObjectReader()) { p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }","1- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id instanceof CanonicalTreeParser.CachedObjectId) { return parseCanonicalObjIntoParsable(params, id).longValue(); } else { final CanonicalTreeParser p = new CanonicalTreeParser(); try (final ObjectReader curs = clp.getRepository().newObjectReader()) { p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; } }
2- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); return parseArguments(name, params.getStrings(PARAM_ARGS)); }
3- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try { p.reset(new ObjectReader((ObjectId) id, clp.getRevWalk().newReader()), false); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }
4- public long parseArguments(final Parameters params) throws CmdLineException { CheckArg.isAtLeastOneOf(params, FORMAT_PARAMETER_ARGS); final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try (final ObjectReader curs = clp.getRepository().newObjectReader()) { p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }
5- public long parseArguments(final Parameters params) { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try(ObjectReader objectReader = clp.getRepository().newObjectReader(); Repository r = objectReader.openRepository(); RepositoryWalk walk = r.newWalk().setTreeFilter(id).setObjectReader(objectReader);) { p.reset(walk, walk.parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }
6- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { FileTreeIterator it = null; try { it = new FileTreeIterator( new File(name)); setter.addValue(it); return 1; } finally { if (it!= null) { try { it.close(); } catch (IOException e) { } } } } final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } setter.addValue(new DirCacheIterator(dirc)); return 1; }
7- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try (final Repository repo = clp.newReader()) { p.reset(repo.newObjectReader(), clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage()), e); } setter.addValue(p); return 1; }
8- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try (final ObjectReader curs = clp.getRepository().newObjectReader()) { } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }
9- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); } else if (new File(name).isFile()) { setter.addValue(new DirCacheIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(ConfigUI.WorkTreeOptions))); } return 1; }
10- public long parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } setter.addValue(new DirCacheIterator(DirCache.read(new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY)))); return 1; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If more thread waiting in take() blockingPeek(), this wake of them. signalAll()'
The code is: 'public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { <START> fNotEmpty.signal(); <END> } finally { fOutputLock.unlock(); } } }'","public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fNotEmpty.signalAll(); } finally { fOutputLock.unlock(); } } }","1- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fNotEmpty.signalAll(); } finally { fOutputLock.unlock(); } } }
2- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fQueueNotEmpty.signal(); } finally { fOutputLock.unlock(); } } }
3- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { flushBufferedToInnerQueue(); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fNotEmpty.signal(); if (!fOutputQueue.isEmpty()) { flushOutputBuffer(); } } finally { fOutputLock.unlock(); } } }
4- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); fNotEmpty.signal(); fOutputLock.unlock(); } }
5- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException | SynchronousQueueFullException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fTobeSent.signalAll(); } finally { fOutputLock.unlock(); } } }
6- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); if (signal) { fNotEmpty.signalAll(); } } }
7- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInputBuffer.drainTo(fInnerQueue); fInputBuffer.removeAll(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { signalAll(); } }
8- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fBufferedNotEmpty.signal(); } finally { fOutputLock.unlock(); } } }
9- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { if (fOutputLock.isHeldByCurrentThread()) { return; } fOutputLock.lock(); try { fNotEmpty.signal(); } finally { fOutputLock.unlock(); } } }
10- public void flushInputBuffer() { Boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(""Buffered queue interrupted"", e); } finally { fInputLock.unlock(); } if (signal) { signalAll(); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change debug level'
The code is: 'private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; <START> Logger.info(""Line: {}, character: {} from actual cursor: "", line, character, cursor); <END> return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }'","private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: "", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }","1- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: {}"", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
2- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; final String lineText = beforeCursor.substring(0, line); Logger.debug(""Line: {}, character: {}, lineText: {} from actual cursor: {}"", line, character, lineText, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
3- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from cursor: {}"", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
4- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: "", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
5- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: "", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
6- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final String input = buf.substring(0, cursor); final String toComplete = StringUtil.splitLines(input); final TextDocumentIdentifier documentIdentifier = new TextDocumentIdentifier(ANY_URI); final Position position = new Position(toComplete.length(), Arrays.asList(toComplete.split(""\n"")).size()); Logger.info(""Input: {}, input lines: {} from actual cursor: {}, Lines: {} at position: "", input, toComplete.split(""\n"").length, cursor, Arrays.asList(toComplete.split(""\n"")).size(), position); return new CompletionParams(documentIdentifier, position); }
7- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; LoggerFactory.getLogger(AbstractCompletion.class).debug( ""Line: {}, character: {} from actual cursor: "", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
8- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: {}"", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
9- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: {}"", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }
10- private static CompletionParams getCompletionParams(String buf, Integer cursor) { final Integer actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final Integer line = countLines(beforeCursor) - 1; final Integer character = beforeCursor.length() - beforeCursor.lastIndexOf(""\n"") - 1; Logger.debug(""Line: {}, character: {} from actual cursor: {}, before cursor: {}"", line, character, cursor, buf.substring(0, cursor)); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Huh?!?!? wrong before? (Well, logic is a bit weird is fault do need extract out a local variable first?)'
The code is: 'public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { <START> Throwable cause = exception.getCause(); <END> if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }'","public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { if (exception.getCause() instanceof WebApplicationException) { throw (WebApplicationException) exception.getCause(); } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }","1- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { Throwable cause = exception.getCause(); if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } if (cause instanceof EOFException) { throw (EOFException) cause; } throw Throwables.propagate(exception); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }
2- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } final TimeUtil timeUtil = metricRegistry.time().time(); metricRegistry.histogram(""card-executor.delay"").record(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } return null; }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (Exception e) { return new Pair<>(ERROR, null); } }
3- public CompletionStage<T> execute(Supplier<T> callable) { Callable<T> task = callable::get; if (executor!= null) { return executor.submit(task); } CompletableFuture<T> futureObject = CompletableFuture.supplyAsync(() -> { xrayUtils.beginSegment(); T value = task.call(); xrayUtils.endSegment(); return value; }, threadContext.getExecutor()); return futureObject; }
4- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } Long requestTotalWaitTime = System.currentTimeMillis(); try { return task.call(); } catch (ExecutionException exception) { requestTotalWaitTime = System.currentTimeMillis(); throw (ExecutionException)exception.getCause(); } finally { xrayUtils.endSegment(); } return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); }}); return Pair.of(requestTotalWaitTime, callable, this.executor); }
5- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Runnable taskRunnable = () -> task.call(); Future<T> futureObject = executor.submit(taskRunnable); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException executionException) { Throwable cause = ExecutorUtils.getCause(executionException); executeError(executionException, taskRunnable, callable, cause); return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { logger.warn(""TimeoutException occured, so execution status is IN PROGRESS and nothing is returned""); return Pair.of(IN_PROGRESS, null); } }
6- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { try { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { Throwable cause = exception.getCause(); if(cause instanceof WebApplicationException) { throw(WebApplicationException) cause; } return Pair.of(FAILED, null); } }
7- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } Pair<ExecutionStatus, T> result = Pair.of(COMPLETED, awaitFutures.get(task, () -> task.call())); awaitFutures.remove(task); metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); return result; }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { Throwable cause = exception.getCause(); if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }
8- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { Throwable cause = ExceptionUtils.getRootCause(exception); if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } throw ExceptionUtils.getRootCause(exception); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }
9- public HttpServletResponse execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS_INSIDE_SEGMENT) { logger.warn(""Card operation task spent {} ms in queue inside {} segment"", totalWaitTime, xrayUtils.getCurrentSegmentId()); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { if (exception instanceof WebApplicationException) { throw (WebApplicationException) exception; } throw new RuntimeException(exception.getMessage(), exception); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }
10- public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final Long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); Long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(""Card operation task spent {} ms in queue"", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(""CardExecutor Service delay - queue_wait_time={}"", totalWaitTime); } metricRegistry.histogram(""card-executor.delay"").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { final Throwable cause = exception.getCause(); if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a debugging print removed'
The code is: 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); <START> System.out.println(""json:"" + json); <END> ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }'","public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }","1- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }
2- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); when(response.getWriter()).thenReturn(pw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); assertNotNull(savedConnections); Integer len = savedConnections.size(); assertEquals(len, 1); }
3- public void testDoPost() throws IOException { when(request.getParameter(""connectionName"")).thenReturn(EXISTING_CONFIG_DB_NAME); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(dbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn(String.valueOf(dbConfig.getDatabasePort())); when(request.getParameter(""databaseUser"")).thenReturn(dbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(dbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(dbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); assertNotNull(savedConnections); Integer len = savedConnections.size(); assertEquals(len, 1); }
4- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }
5- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); Assert.assertNotNull(json); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }
6- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); SUT.doPost(request, response); }
7- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); when(request.isMultipartFormData()).thenReturn(false); String requestBody = ServletUtils.getRequestBody(request); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); Assert.assertNotNull(result); Assert.assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }
8- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); assertNotNull(savedConnections); Integer len = savedConnections.size(); assertEquals(len, 1); }
9- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); Assert.assertNotNull(json); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); Assert.assertNotNull(savedConnections); Integer len = savedConnections.size(); Assert.assertEquals(len, 1); }
10- public void testDoPost() throws IOException, ServletException { when(request.getParameter(""connectionName"")).thenReturn(""test-db-name""); when(request.getParameter(""databaseType"")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(""databaseServer"")).thenReturn(null); when(request.getParameter(""databasePort"")).thenReturn("""" + testDbConfig.getDatabasePort()); when(request.getParameter(""databaseUser"")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(""databasePassword"")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(""initialDatabase"")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), ""Valid response Message expected!""); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(""savedConnections""); assertNotNull(savedConnections); int foundConnectionIndex = -1; for (int i = 0; i < savedConnections.size(); i++) { ObjectNode obj = (ObjectNode) savedConnections.get(i); assertEquals(connectionName, obj.get(""connectionName"").asText()); int index = savedConnections.indexOf(obj); assertTrue(index > foundConnectionIndex); foundConnectionIndex = index; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: a line'
The code is: '<START> @Test public void test() { <END> byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }'","public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }","1- public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }
2- @Test void test() { byte[] key = new byte[1024]; Integer[] index = new Integer[slots.size()]; Integer length = ScanUtil.setKey(schema, slots, null, index, 0, key, 0, 0, slots.size() * 4); byte[] actualKey = new byte[length]; System.arraycopy(key, 0, actualKey, 0, length); assertArrayEquals(expectedKey, actualKey); }
3- private void test() { byte[] key = new byte[1024]; int[] position = new int[slots.size()]; int offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = Bytes.copy(key, 0, offset); System.arraycopy(position, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }
4- public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }
5- public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }
6- @Test public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey) ; }
7- @Test public void test() { byte[] key = keyBytes(false); Integer[] position = new Integer[]{0}; Integer[] nullPointerPosition = {null}; Integer[] nullSizeDataType = {null}; Integer[] nullSpans = {null, null, null}; Integer[] slotsIndex = {0, 1, 2}; Integer[] nullSlotsInd = {0, 1, 2}; byte[] expectedKey = keyBytes(false); byte[] actualKey = setKey(schema, slots, getDefaultSlotSpans(slots.size()), position, null, key, 0, nullPointerPosition, slots.size()); assertArrayEquals(expectedKey, actualKey); }
8- @Test public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); final Schema schema = Schema.create(null, new String[]{""col""}); final List<KeyValue> expected = new ArrayList<>(); expected.add(new KeyValue(""col="" + ByteUtil.toString(key, 0, offset), ByteUtil.toString(key, offset + 138, offset + 139), ScanTestUtils.STRING_WILDCARD, TIMESTAMP_0, 1, ""row11"", ""family2"")); final List<KeyValue> res = new ArrayList<>(); res.add(new KeyValue(""col="" + ByteUtil.toString(actualKey, 0, offset), ByteUtil.toString(actualKey, offset + 138, offset + 139), ScanTestUtils.STRING_WILDCARD, TIMESTAMP_0, 1, ""row11"", ""family2"")); assertEquals(res, expected); }
9- public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }
10- public void test() { byte[] key = new byte[1024]; Integer[] position = new Integer[slots.size()]; Integer offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's == null'
The code is: 'public static boolean isNormalSequence(final String s) { <START> if (s.length() == 0) { <END> return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }'",public static boolean isNormalSequence(final String s) { if (s == null || s.length() == 0) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; },"1- private static boolean isNormalSequence(final String s) { if (s == null) { return false; } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == G || ch == a || ch == t || ch == d || ch == n || ch == N) { ; } else { return false; } } return true; }
2- public static boolean isNormalSequence(final String s) { if (s == null) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
3- public static boolean isNormalSequence(final String s) { if (s == null) { return false; } if (s.length() == 0) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
4- public static boolean isNormalSequence(final String s) { if (s!= null && s.length() == 0) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
5- public static boolean isNormalSequence(final String s) { if (s == null) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
6- public static boolean isNormalSequence(final String s) { if (s.length() == 0) { return true; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
7- public static boolean isNormalSequence(final String s) { return (s == null || s.length() == 0)? false : for (char ch : s.toCharArray()) { if (ch == 'A' || ch == 'T' || ch == 'C' || ch == 'G' || ch == 'a' || ch == 't' || ch == 'c' || ch == 'g' || ch == 'n' || ch == 'N') { ; } else { return false; } }; }
8- public static boolean isNormalSequence(final String s) { if (s == null) { return false; } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
9- public static boolean isNormalSequence(final String s) { if ((s == null) || (s.length() == 0)) { return false; } for (Integer i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }
10- public static boolean isNormalSequence(final String s) { if (s.isEmpty()) { return false; } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (!isInvariantCharacter(ch)) { return false; } } return true; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'skip loop now'
The code is: 'private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); Boolean match = false; for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")) { <START> match = true; <END> } } } return match; }'","private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); Boolean match = false; for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")) { match = true; break; } } } return match; }","1- private HttpServletResponse isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); return new ResponseBuilder().statusCode(SUCCESS).build(layersParam.equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"") || isLayerOfType(layersParam, all)); }
2- private boolean isAllowed(MutableHttpServletRequest request, String paramName) { List<Layer> all = layerService.findAll(); String layersParam = request.getParameterIgnoreCase(paramName); if (layersParam == null || layersParam.isEmpty()) { return false; } for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); String urlSpec = source.getUrl(); try { if (""^"" + layersParam.replaceAll(""\\*"", ""\\\\*"") + ""$"".equalsIgnoreCase(urlSpec)) { return true; } } catch (PatternSyntaxException e) { throw new RuntimeException(e); } } } return false; }
3- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); return layersParam!= null &&!layersParam.isEmpty() && all.stream().anyMatch(layer -> layer.getSource() instanceof ImageWmsLayerDataSource && layer.getSource().getLayerNames().equals(layersParam) && layer.getSource().getUrl().equalsIgnoreCase(request.getContextPath() + Constants.GZ_ACTION_PATH)); }
4- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { for (Layer layer : layerService.findAll()) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); String layerName = getLayerNameFilter(source); if (layerName!= null && layerName.equalsIgnoreCase(request.getParameterIgnoreCase(paramName).toLowerCase())) { return true; } if (source.getLayerNames().equalsIgnoreCase(request.getParameterIgnoreCase(paramName).toLowerCase())) { return true; } } } return false; }
5- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); for (Layer layer : all) { boolean foundSource = false; if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")) { foundSource = true; } } if (foundSource) { return true; } } return false; }
6- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); Boolean match = true; for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (!source.getLayerNames().equalsIgnoreCase(layersParam) &&!source.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")) { match = false; } } } return match; }
7- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); return new LayerDAO().findAll().stream().map(layer -> { if (layer.getSource() instanceof ImageWmsLayerDataSource) { return new ImageWmsLayerDataSource(layer.getName(), layer.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")); } return null; }).filter(l -> l!= null).findFirst().map(l -> l.toString()).map(layer -> { if (layer.equalsIgnoreCase(layersParam)) { return true; } else { return new Optional<>(); } }).orElseGet(Optional::empty).orElseThrow().isPresent(); }
8- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = UtilMethods.newStreamedReader(request.getReader()).line(request.getParameter(paramName)); List<Layer> all = layerService.findAll(); if (layerService.findBySource(src -> src.getSource() instanceof ImageWmsLayerDataSource && (layersParam == null || layersParam.equalsIgnoreCase(src.getLayerNames())))!= null) { return true; } return false; }
9- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); return all.stream().anyMatch(l -> l.getSource() instanceof ImageWmsLayerDataSource && layersParam == request.getContextPath() + ""/geoserver.action"" && l.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")); }
10- private Boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); Layer layer = null; for (Layer layerObject : all) { if (layerObject.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layerObject.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + ""/geoserver.action"")) { return true; } } } return false; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suppress exception here'
The code is: 'public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { <START> metrics.incrementFailedPersists(); <END> } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }'","public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); throw e; } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }","1- public void persist(final Runnable commitRunnable) { log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); } metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } ); }
2- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = StartWarrior.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); catchLogger.warn(""An exception occurred while waiting to schedule a persist, this message will be logged."", e); } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
3- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Integer persistInterval = getPersistInterval(indexSpec); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); } } } ); final Stopwatch stopwatch = Stopwatch.createStarted(); metrics.create(persistentIndexMetrics()); persistTimer.updateTimer(); stopwatch.update(persistInterval, TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureTime(stopwatch.elapsed(TimeUnit.MILLISECONDS)); metrics.persistDurationStat(persistInterval, stopwatch.elapsed(TimeUnit.MILLISECONDS)); persistTimer.updateTimer(); persistIntervalStat.ifPresent( stat -> stat.update(persistInterval, stopwatch.elapsed(TimeUnit.MILLISECONDS))); commitRunnable.run(); }
4- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Throwable e) { Preconditions.checkNotNull(e); if (!(e instanceof Error)) { metrics.incrementFailedPersists(); metrics.incrementExceptionCount(); metrics.incrementExceptionType(1); Preconditions.checkState(!e.getMessage().isEmpty()); metrics.incrementMessageCount(1); metrics.incrementMessageType(e.getMessage()); String messageInJson = e.getMessage(); metrics.incrementError(messageInJson); log.info(""Error during ingestion persistence for dataSource[%s]: %s"", schema.getDataSource(), messageInJson); } } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
5- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Throwable e) { metrics.incrementNumPersistsWithException(); catchAndRollback(e); } catch (Exception e) { metrics.incrementNumPersistsWithException(); catchAndRollback(e); finally { metrics.incrementFailedPersists(); metrics.incrementNumFailedPersists(1); metrics.incrementNumPersistAttempts(1); metrics.incrementNumPersistAttemptsFailure(); persistStopwatch.stop(); } } commitRunnable.run(); } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
6- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementNumAndViolateFailPersistsLimit(1); metrics.incrementFailedPersists(); } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
7- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); } metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
8- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); log.makeAlert(e, ""Failed to persist hydrant: %s, interval: %s"", pair.lhs, pair.rhs).emit(); } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
9- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(""%s-incremental-persist"", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } try { runExecStopwatch.reset(); commitRunnable.run(); } catch (Exception e) { persistRunnableFailureRate.mark(); metrics.incrementFailedPersists(); runExecStopwatch.stop(); throw new RuntimeException(""Error committing hydrants"", e); } finally { runExecStopwatch.stop(); metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } catch (Throwable e) { persistRunnableFailureRate.mark(); metrics.incrementFailedPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); metrics.incrementPersistTimeMillis(runExecStopwatch.elapsedMillis(TimeUnit.MILLISECONDS)); throw new RuntimeException(""Error committing hydrants"", e); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(""Ingestion was throttled for [%,d] millis because persists were pending."", startDelay); } runExecStopwatch.stop(); }
10- public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(""Submitting persist runnable for dataSource[%s]"", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadNameRenamer(""incremental-persist-runner-"" + schema.getDataSource()) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { log.error(""Caught exception while running incremental persist on stream [%s]."", schema.getDataSource(), e); metrics.incrementFailedPersists(); return; } log.info(""Commit of incremental persistent stream was successful""); try { metrics.incrementPersistCntAndPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); } catch (IllegalMetricException e) { log.error(String.format(""Error while persisting. Incremental persist time for stream [%s] not recorded"", schema.getDataSource()), e); } } } ); final Long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); log.info(""Incremental persist throttled because persistent streams were pending [%,d] millis."", startDelay); runExecStopwatch.stop(); persistStopwatch.stop(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'turn-around equal check for avoiding NPEs ? For ex: ""something"".equals(string)'
The code is: 'public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; <START> if (key.equals(""sample1.txt"")) { <END> fileToUndeploy = new File(testDir + File.separator + key); } else if (key.equals(""sample2.txt"")) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }'","public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1.txt"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (""sample2.txt"".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }","1- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (""sample2"".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }
2- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + "" is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; String content = null; if (key.equals(SampleFile_1)) { fileToUndeploy = new File(testDir + File.separator + SampleFile_1); } else if (key.equals(SampleFile_2)) { fileToUndeploy = new File(testDir2 + File.separator + SampleFile_2); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + "" value not matched""); } if (fileToUndeploy!= null && fileToUndeploy.exists()) { try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { if (fis.available() == 23); int x; byte b[] = new byte[x = fis.available()]; fis.read(b); String content2 = new String(b); try { content = content2.contains(""test"")? content2 : null; } catch (NullPointerException e) { content = null; } if(!(content!= null && content.contains(""Deployed Successfully""))) { logger.error(""Error while Un Deploying : "" + key); } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } }
3- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while undeploying: "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (key.equals(""sample1.txt"")) { fileToUndeploy = new File(testDir + File.separator + key); } else if (key.equals(""sample2.txt"")) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Undeployment: "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); String content; try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); content = new String(b); boolean deployed = content.contains(""sample1"") || content.contains(""sample2""); if (!deployed) { logger.info(""Undeploy done : "" + key); } } catch (IOException e) { throw new CarbonDeploymentException(""Error while trying to undeploy : "" + key); } }
4- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1.txt"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (""sample2.txt"".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }
5- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Undeploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1"".equals(key) || ""sample2"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Undeploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Undeploying : "" + key, e); } }
6- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File file; if (key.equals(""sample1.txt"")) { file = new File(testDir + File.separator + key); } else if (key.equals(""sample2.txt"")) { file = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + file.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(file)) { int x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }
7- public void undeploy(Object key) throws CarbonDeploymentException { String deployFileName = null; if (key!= null) { deployFileName = (String) key; } if (deployFileName == null || deployFileName.equals("""")){ return; } String fileName = deployFileName; logger.info(""Undeploying : "" + fileName); File fileToDeploy; try { fileToDeploy = new File(testDir + File.separator + fileName); } catch (FileNotFoundException e) { logger.warn(""Error while getting deploy dir : "" + fileName + "", Not found""); return; } logger.info(""File to undeploy :"" + fileToDeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToDeploy)) { byte b[] = new byte[1000]; fis.read(b); if (content.equals(""sample1"")) { sample1Deployed = false; } else if (content.equals(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while undeploying : "" + fileName, e); } }
8- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1.txt"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (""sample2.txt"".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); logger.info(""File is "" + fileToUndeploy.getAbsolutePath() + ""is of "" + fileToUndeploy.getPath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }
9- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (key.equals(""sample1.txt"")) { fileToUndeploy = new File(testDir + File.separator + ""sample1.txt""); } else if (key.equals(""sample2.txt"")) { fileToUndeploy = new File(testDir2 + File.separator + ""sample1.txt""); } else { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""sample1"")) { sample1Deployed = false; } else if (content.contains(""sample2"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while Un Deploying : "" + key, e); } }
10- public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(""Error while undeploying : "" + key + ""is not a String value""); } logger.info(""Undeploying : "" + key); File fileToUndeploy; if (""sample1.txt"".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (""sample2.txt"".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(""Error while undeploying : "" + key); } logger.info(""File to undeploy : "" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { Integer x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(""test"")) { sample1Deployed = false; } else if (content.contains(""second_test"")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(""Error while undeploying : "" + key, e); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this status permanently 99%. I want Math.min(progress, 99.9)'
The code is: 'public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; <START> status.progress = Math.max(progress, 99.0); <END> } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }'","public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }","1- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = entries.getValue().getStatus(); log.trace(""Adding log processor status %s"", status); status.progress = new ProgressStatus(status.progress, Math.min(progress, 99.9), status.name); result.add(status); } return result; } }
2- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesRead() / walBlockSize; status.progress = Math.min(progress, 99D); status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } catch (IOException ex) { log.warn(""Error getting bytes read""); } } return result; } }
3- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }
4- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.0); status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } catch (IOException ex) { log.warn(""Error getting bytes read""); } } return result; } }
5- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); status.progress = (int) entries.getValue().getRuntime(); try { double p = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, p); status.progress = Math.max(status.progress, 99.0); } catch (IOException ex) { log.warn(""Error getting bytes read""); } result.add(status); } return result; } }
6- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }
7- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); status.progress = Math.max(status.progress.longValue(), 0.0); } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }
8- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; boolean is99 = progress <= 99.9; status.progress = Math.min(progress, 99.9, is99); status.completedByte = walBlockSize / entries.getValue().getFileCount(); status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } catch (IOException ex) { log.warn(""Error getting bytes read""); } } return result; } }
9- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); status.status = WalLog.ProgressStatus.NORMAL; } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }
10- public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { Double progress = entries.getValue().getBytesCopied() / walBlockSize; status.progress = Math.min(progress, 99.9); } catch (IOException ex) { log.warn(""Error getting bytes read""); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Minor typo in variable name; extra unneeded ""m""'
The code is: 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); <START> String actualErrorMmessage = foreignAchErrorMessages.get(0); <END> assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMmessage); }'","void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }","1- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualError = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualError); }
2- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertTrue(foreignAchItems.isEmpty()); }
3- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); cmbVendorAddressCountryOption.setSelectedItem(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualForeignAchErrorMessage = foreignAchErrorMessages.get(0); assertThat(actualForeignAchErrorMessage, containsString(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"")); }
4- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBankBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(actualErrorMessage, ACHConstants.ERROR_REPORT_A_ACH_REVENUE_CANADIAN_ACCOUNT_WITH_NON_US_BANK_ADRESS); }
5- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualError = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualError); }
6- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create "" + ""ACH records for banks that have a US address"", actualErrorMessage); }
7- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }
8- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); mVendorAccountService.setIssuingBankInfo(buildPaymentWorksIssuingBank()); Integer actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage; if (IssuingBankUtils.BANKCODE_CANADA_IS_ISSUER) { actualErrorMessage = foreignAchErrorMessages.get(0); } else { actualErrorMessage = foreignAchErrorMessages.get(0).replace(""Canadian Bank Card processing"", ""American Bank Card processing""); } assertEquals(""The issuer has a country code of [Canada]. We can only create ACH records for issuers that have a US address"", actualErrorMessage); }
9- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); Optional<Boolean> actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertTrue(actualIsUsBankAccount.isPresent()); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a PaymentWorks for foreign country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }
10- void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean isUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(isUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(""The bank has a country code of Canada. We can only create ACH records for banks that have a US address"", actualErrorMessage); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This if do'
The code is: 'public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } <START> if (!recentlyCompletedDriverGroups.isEmpty()) { <END> for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } return newDriverGroupReady; }'","public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } return newDriverGroupReady; }","1- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); synchronized (this) { List<Lifespan> recentlyCompletedDriverGroups; recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } return newDriverGroupReady; }
2- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { return scheduleNextLifespan(scheduler); }
3- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); this.newDriverGroupReady = SettableFuture.create(); } try { if (!recentlyCompletedDriverGroups.isEmpty()) { for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } } finally { this.newDriverGroupReady = null; } return newDriverGroupReady; }
4- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } return newDriverGroupReady; }
5- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } if (!recentlyCompletedDriverGroups.isEmpty()) { for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupIdIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupIdIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupIdIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } return newDriverGroupReady; }
6- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan previouslyCompletedDriverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(previouslyCompletedDriverGroup.getId())); if (driverGroupsIterator.hasNext()) { Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.restartLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } return newDriverGroupReady; }
7- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } SettableFuture<Void> driverFuture = scheduler.startLifespan( driverGroup, partitionHandles.get(driverGroupsIterator.nextInt())); DriverHandle driverHandle = driverGroupsIterator.getDriverHandle(); nodeToDriverHandleMap.put(driverHandle, driverGroupToNodeMap.get(driverHandle.getId())); driverHandleToPartitionHandles.put(driverHandle, driverGroupsIterator.nextInt()); } return SettableFuture.create(); }
8- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } IntGroup intGroup = driverGroupsIterator.next(); scheduler.startLifespan(Lifespan.driverGroup(intGroup.getNumber()), intGroup.getSources().stream().map(PCollectionImpl::getId).collect(Collectors.toList())); } return newDriverGroupReady; }
9- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); synchronized (this) { if (!this.recentlyCompletedDriverGroups.isEmpty()) { List<Lifespan> recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } Integer driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } } return newDriverGroupReady; }
10- public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = this.recentlyCompletedDriverGroups; this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } recentlyCompletedDriverGroups.stream().flatMap(lifespans -> lifespans.stream()).map(lifespan -> { if (lifespan.isDriver()) { scheduler.startLifespan(LIFESPAN, partitionHandles.get(lifespan.getId())); } else { scheduler.finishLifespan(lifespan.getId()); } return null; }).forEachRemaining(driverGroupTask -> scheduler.addSplits(toIntList(driverGroupTask.getSubtaskSpec().getSplitSource()), driverGroupTask.getPlan().getDriverContext().getSourceId())); return newDriverGroupReady; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'original exception propagate logged; drop this catch clause'
The code is: 'private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } catch (Exception e) { <START> Logger.error(LOG_TAG, ""Unknown exception thrown while recording daily last value."", e); <END> } } }'","private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }","1- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {day.toString(), envString.toString(), fieldIDString.toString()}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException ex) { throw new IllegalStateException(""Event did not reference existing an environment or field."", ex); } catch (Exception ex) { Logger.error(LOG_TAG, ""Unknown exception thrown while recording daily last value."", ex); } } }
2- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
3- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
4- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); if (0 == this.refCount.decrementAndGet() &&!(this.closeLocked == false)) { try { db.close(); } catch (Throwable e) { } this.closeLocked = true; this.isForceClosed = true; if (0 < this.refCount.get() && ((closeLocked = true) ||!(this.closeLocked == false))) { this.helper = new DatabaseHelper(getContext()); this.recordClose(); } return; } final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); this.recordRefCountIncremented(); if (0 < this.refCount.get() && ((closeLocked = true) ||!(this.closeLocked == false))) { this.recordClose(); } } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
5- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { throw new IllegalArgumentException(""Environment must be greater than -1!""); } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
6- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
7- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
8- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
9- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }
10- private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, ""Refusing to record with environment = -1.""); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final long updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(""env"", env); v.put(""field"", field); v.put(""date"", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(""Event did not reference existing an environment or field."", e); } } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'obvious 102L is 0B1100110L..'
The code is: 'public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, <START> Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L}; <END> Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }'","public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 0b1100110L}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }","1- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110L, -1L, 42L, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 42L, 0xFFL, 0b11010010_01101001_10010100_10010010L}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertEquals(""x"".equals(variableTree.simpleName().name()), expectedIntegerValues[i++]); final String name = variableTree.simpleName().name(); LiteralUtils.checkLongLiteral(variableTree.initializer()); assertEquals("""".equals(name), expectedLongValues[j++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertTrue(""y"".equals(variableTree.simpleName().name()), expectedLongValues[j++] == Long.valueOf(Long.MAX_VALUE).longValue()); assertEquals("""".equals(variableTree.simpleName().name()), expectedLongValues[j++]); } } }
2- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, 0b1100110L, Long.MAX_VALUE}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }
3- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110L, null}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, 0b110011010010010L, 10010L, 0xFFL, 102L, 0xFFL}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }
4- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, 0b1100110, 2L, 1L, 1L, 0b1100110L}; Integer x = 0; Integer y = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[x++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[y++]); } } }
5- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110L, 102L, Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 0b1100110L}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, null, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }
6- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L, 102L}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, 10010L, 10010L, 0b11010010_01101001_10010100_10010010L, 0b11010010_01101001_10010100_10010010L, 102L}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }
7- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, 42, -7, -7, 3, null, null, 0xFF, 0xFF, 0xFF, 0xFFL, 0xFFL, 0b1100110}; Long[] expectedLongValues = {{42L}, {42L}, {42L}, {+3L}, {+3L}, null, null, {0xFFL}, {0xFFL}, Long.BYTES, Long.BYTES}; int testCaseIndex = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[testCaseIndex++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[testCaseIndex++]); } } }
8- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110L}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }
9- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110, 102L, 102L}; Integer i = 0; Integer expectedValue; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { String javaType = variableTree.simpleName().name(); assertThat((javaType == null? null : literalAnnotations.get(variableTree).get(javaType)).toString()).isEqualTo(expectedIntegerValues[i++].toString()); } else if (variableTree.simpleName().name().startsWith(""y"")) { String javaType = variableTree.simpleName().name(); assertThat((javaType == null? null : literalAnnotations.get(variableTree).get(javaType)).toString()).isEqualTo(expectedIntegerValues[i++].toString()); } } assertThat(expectedIntegerValues.length - i).asLong().isEqualTo(expectedIntegerValues.length); Integer j = 0; for (VariableTree variableTree : variables) { String javaType = variableTree.simpleName().name(); assertThat((javaType == null? null : literalAnnotations.get(variableTree).get(javaType)).toString()).isEqualTo(expectedIntegerValues[j++].toString()); } assertThat(expectedIntegerValues.length - j).asLong().isEqualTo(expectedIntegerValues.length); }
10- public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null}; Integer i = 0; Integer j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(""x"")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(""y"")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change this List<PartitionId>'
The code is: 'public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } <START> List<? extends PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); <END> assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }'","public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }","1- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertNotNull(partitionIds); assertFalse(partitionIds.isEmpty()); for (PartitionId partitionId : partitionIds) { assertNotNull(partitionId); assertNotNull(partitionId.getReplicaIds()); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertNotNull(fetchedPartitionId); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertNotSame(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertNotNull(dataNodeId); assertNotNull(dataNodeId.getDataCenterId()); assertEquals(dataNode.getHostname(), dataNodeId.getHostname()); assertEquals(dataCenter.getId(), dataNodeId.getDataCenterId()); assertNotNull(dataNodeId.getDataNodeId()); assertNotNull(dataNode.getPort()); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertNotNull(replicaId); assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
2- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (PartitionId partitionId : partitionIds) { assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
3- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<? extends PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (PartitionId partitionId : partitionIds) { assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { throw new IllegalStateException(); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
4- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
5- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout( ""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); assertEquals(testHardwareLayout.getServerCount(), clusterMapManager.getServerCount()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), partitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), partitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : partitionLayout.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
6- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); assertEquals(clusterMapManager.getMetricRegistry().getNames(), testPartitionLayout.getMetricNames()); List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); assertEquals(partitionIds, testPartitionLayout.getWritablePartitionIds()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
7- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartition = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartition); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
8- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (PartitionId partitionId : partitionIds) { assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
9- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(partitionLayout.getNames()); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); assertEquals(clusterMapManager.getMetricRegistry().getMBeanName(), MapManagerImpl.MBEAN_NAME); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream( ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertTrue(false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicas(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }
10- public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(""Alpha""); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (Integer i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ok move lines BBCTTestUtil.removeCard'
The code is: 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }'","public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }","1- public void testDeleteCardUsingFilter() throws Throwable { test_filters(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; BBCTTestUtil.filterCards(this.test_filters, yearPred); View deleteMenu = this.getCardDeleteMenu(); Assert.assertNotNull(deleteMenu); this.deleteCard(deleteMenu); ListView lv = (ListView) this.getCurrentCardAdapterView().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.filtered_cards, lv); }
2- public void testDeleteCardUsingFilter() throws Throwable { final long year = 1988; this.expectedCards = BBCTTestUtil.filterList(this.allCards, Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }); this.solo.clickOnCheckBox(3); this.solo.clickOnCheckBox(15); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); Assert.assertTrue(BBCTTestUtil.assertListCount(this.expectedCards.size, lv)); }
3- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); TouchUtils.clickView(this, BBCTTestUtil.DELETE_MESSAGE_VIEW); this.solo.waitForView(R.id.delete_menu); View deleteMenu = this.activity.findViewById(R.id.delete_menu); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list)); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); }
4- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); this.expectedCards = BBCTTestUtil.filterList(this.allCards, new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == 1993; } }); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(2 + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
5- public void testDeleteCardUsingFilter() throws Throwable { int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); BBCTTestUtil.removeCard(this, cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
6- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); this.expectedCards = BBCTTestUtil.filterList(this.allCards, PREDICATE_THAT_DISCOVER_CARD_YEAR_IS_THAT_GIVEN_YEAR); BBCTTestUtil.removeTestCard(BBCTTestUtil.testCardAtIndex(this.expectedCards, CARD_INDEX)); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(BBCTTestUtil.testCardAtIndex(this.expectedCards, CARD_INDEX + 1)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView activityList = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); Assert.assertTrue(BBCTTestUtil.containsListItems(this.expectedCards, activityList)); }
7- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final int cardIndex = 2; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); Assert.assertTrue(this.solo.clickOnCheckBox(cardIndex + 1)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); Assert.assertTrue(this.solo.waitForToast(BBCTTestUtil.DELETE_MESSAGE)); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
8- public void testDeleteCardUsingFilter() throws Throwable { long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex + 1); final int cardIndex2 = this.expectedCards.size(); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); deleteMenu.performClick(); DeleteCardActivityBase deleteCardActivityBase = (DeleteCardActivityBase) this.activity; Assert.assertEquals(4, deleteCardActivityBase.mDeleteCardConfirmationItems.size()); deleteCardActivityBase.deleteCard(); Assert.assertEquals(deleteCardActivityBase.mDeleteCardConfirmationItems.size(), cardIndex2); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }
9- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); final long year = 1993; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(firstCardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); Assert.assertTrue(this.solo.clickOnCheckBox(1)); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); Assert.assertTrue(BBCTTestUtil.toastPresent(this.solo)); this.getTestResult(); String testResult = getTestResult(); Assert.assertEquals(testResult, """"); }
10- public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final long year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.solo.uncheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrong type. List<String>'
The code is: 'public static List<String> getReferencedTypes(final File file) { <START> ArrayList<String> <END> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }'","public static List<String> getReferencedTypes(final File file) { List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }","1- public static List<String> getReferencedTypes(final File file) { List<String> references = null; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); if (references == null) { references = new ArrayList<>(); } references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
2- public static List<TypeReference> getReferencedTypes(final File file) { ArrayList<TypeReference> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); String package; package = n.getAttributes().getNamedItem(LibraryElementTags.PACKAGE_ATTRIBUTE).getNodeValue(); references.add(new TypeReference(type, package)); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
3- public static List<String> getReferencedTypes(final File file) { List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); DocumentBuilder db; Document document; db = dbf.newDocumentBuilder(); document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } return references; }
4- public static List<String> getReferencedTypes(final File file) { ArrayList<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (IOException e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
5- public static List<String> getReferencedTypes(final File file) { ArrayList<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(LibraryModuleConstants.BOOLEAN_PROTOTYPE_OPTION, Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); Element element = (Element) n; if (LibraryModuleConstants.RESOURCE_ELEMENT.equals(element.getNodeName())) { Node childNodesElem = element.getFirstChild(); if (childNodesElem!= null) { String type = ""<LINK_0>""; String attributeElementName = LibraryModuleConstants.TYPE_ATTRIBUTE; Node attributeElement = childNodesElem.getAttributes()[0]; if (attributeElement!= null) { type = attributeElement.getNodeValue(); NodeList attributeChildNodesElem = attributeElement.getChildNodes(); for (Integer j = 0; j < attributeChildNodesElem.getLength(); j++) { Node attributeChildNodesElemNode = attributeChildNodesElem.item(j); if (attributeChildNodesElemNode!= null) { String valueAttribute = attributeChildNodesElemNode.getAttributes()[attributeElementName].getNodeValue(); if (valueAttribute!= null) { type += valueAttribute; } } } } } } else if (LibraryModuleConstants.METADATA_ELEMENT.equals(element.getNodeName())) { references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
6- public static List<String> getReferencedTypes(final File file) { return getReferencedTypes(file, null); }
7- public static List<String> getReferencedTypes(final File file) { List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(DTD_VALIDATION_MODE_ATTRIBUTE, DTD_VALIDATION_MODE_DISABLE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (ParserConfigurationException | SAXException | IOException e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
8- public static List<ElementInfo> getReferencedTypes( final File file) { List<ElementInfo> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""org.eclipse.core.filesystempackage"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(new ElementInfo(type)); } } } catch (Exception e) { LogDisplay.logError(e.getMessage(), e); } return references; }
9- public static List<String> getReferencedTypes(final File file) { final ArrayList<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }
10- public static List<String> getReferencedTypes(final File file) { List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(""<LINK_0>"", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (Integer i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = """"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List<String> lines = Files.readAllLines(filePath);'
The code is: 'public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); <START> List<String> lines = Files.lines(filePath).collect(Collectors.toList()); <END> for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }'","public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }","1- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
2- public void testLargeGeometryToBingTiles() throws Exception { try (InputStream stream = this.getClass().getClassLoader().getResourceAsStream(""large_polygon.txt""); BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) { String line; StringBuilder builder = new StringBuilder(); while ( (line = reader.readLine())!= null) { builder.append(line).append(""\n""); } String str = builder.toString(); Map<String, Object> properties = ImmutableMap.of(""wkt"", str); String geometry = (String) property(properties, ""geom""); Object result = functionManager().functionSignature(""geometry_to_bing_tiles"", geometry).getLength(1); Map<String, Object> parameters = ImmutableMap.of(""zoom_level"", 15); Bigint tileCount = (Bigint) property(result, ""num_tiles""); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + geometry + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
3- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
4- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
5- public void testLargeGeometryToBingTiles() throws Exception { Set<Long> count; count = readLinesFromFile(PROJECT_PATH + ""/tilebox/tilebox/testdata/large_polygon.txt"").collect(toLongMap(Function.identity(), key -> tilesetIdExtractor.extract(key))); assertThat(count).containsOnly(Tile.of(33, 22), Tile.of(32, 2), Tile.of(31, 1)); }
6- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); final String hexString = String.valueOf(new BigInteger(tileCount.longValue(), 16).hashCode()); assertFunction(""cast(geojson_from_geocode('POINT("" + wkt + "" POINT (0 0))') as geography)"", GEOGRAPHY, HEX.toHumanFriendly(hexString)); } }
7- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
8- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); Long tileCount = Long.parseLong(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }
9- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(""large_polygon.txt"").getPath()); List<String> lines = Files.readAllLines(filePath); int zoomLevels = Integer.parseInt(lines.get(0).split(""\\|"")[1]); long tileCounts = Long.parseLong(lines.get(1).split(""\\|"")[2]); long actualTileCount = cardinality(geometryToBingTiles(ST_GeometryFromText(""POLYGON ((947934.21637033094 5580532.2906191705, 4355667.0246186664 5580532.2906191705, 4259769.7909260805 5580532.2906191705, 9929530.4255409816 5580532.2906191705, 10704079.5431503906 5580532.2906191705, 947934.21637033094 5580532.2906191705)))), ""10""))); assertEquals(tileCounts, actualTileCount); }
10- public void testLargeGeometryToBingTiles() throws Exception { Path filePath = paths.get(""large_polygon.txt""); List<String> lines = Files.lines(filePath).collect(Collectors.toList()); for (String line : lines) { String[] parts = line.split(""\\|""); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); int tileCount = Integer.parseInt(parts[2]); assertFunction(""cardinality(geometry_to_bing_tiles(ST_GeometryFromText('"" + wkt + ""'), "" + zoomLevel + ""))"", BIGINT, tileCount); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success'
The code is: 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync) .andThen(after -> after.map(modelSimpleResponse -> { <START> throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); <END> return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }'","beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }","1- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist)), (receipts, context) -> StreamTransformer.mapToModel(receipts, receiver -> new OperationReceipt(receiver)) ); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
2- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
3- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { recognizeReceiptResult(modelSimpleResponse); return toRecognizedForm(modelSimpleResponse.getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
4- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> monoError(logger, new RuntimeException(""Analyze status invalid""))).doFinally(() -> responseMapper.mapToRecognizedForm(modelSimpleResponse.getValue()))) ); }
5- Flux<RecognizedForm> beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { return beginRecognizeReceiptsWithDeserializedHeaders(recognizeOptions).map(analyzeResponse -> toRecognizedForm(analyzeResponse, true)); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
6- beginReceiptRecognition(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new Poller<List<RecognizedForm>>((contentType, receipt, recognizeOptions) -> { try { return service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).toCompletableFuture().get(); } catch (RuntimeException ex) { throw ex; } }, receipt, recognizeOptions.getContentType()), (contentType, receipt, recognizeOptions) -> operation(Pollers.mapWithDefaultCompletableFuture(service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements), new TypeToken<List<RecognizedForm>>(){}, response -> response.getValue()), receipt, service.analyzeReceiptResultWithResponseAsync(), (activationResponse, context) -> { if (service.getAnalyzeReceiptResultWithResponseAsync(activationResponse.resourceId())!=  Observable.just(null)) { return Mono.empty(); } return Mono.empty(); }, fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements)))); } catch (RuntimeException ex) { throw ex; } }
7- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { if (!analyzeStatusSuccessful(modelSimpleResponse.getValue())) { throw new RuntimeException(""The stream is not analyzed successfully. Cancel the stream.""); } return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist)), logger).onErrorMap(context -> context.getError().map(t -> toHttpResponseException(logger.error(t, ""Cancellation is not supported""))).orElseGet(() -> new RuntimeException(""The stream canceled at end of the recognition.""))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }
8- PollerFlux<RecognizedReceipt> beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); try { recognizeOptions = getRecognizedReceiptFields(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), true, (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(result -> { try { return toRecognizedForm(result.getAnalyzeResult(), result.isAnalyzeResultSuccess()); } catch (Exception ex) { return toErrorResponse(ex); } }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (Exception exception) { return PollerFlux.error(exception); } } catch (RuntimeException ex) { return PollerFlux.<RecognizedReceipt>error(ex); } }
9- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { final ReceiptResult receiptResult = modelSimpleResponse.getValue(); if (receiptResult.getResult().error().isPresent()) { if (responseTypeMapperMap.containsKey(receiptResult.getResult().error().get())) { updateContentIdHeader(receiptResult.getResult().error().get(), responseTypeMapperMap.get(responseTypeMapperMap.entrySet().iterator().next().getValue())); } throw receiptResult.getResult().error().get(); } return toRecognizedForm(receiptResult.getResult().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist)), activateErrorHandler(isIncludeFieldElements)); } catch (RuntimeException ex) { return PollerFlux.error(ex); } catch (Exception ex) { return PollerFlux.error(ex); } }
10- beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, ""'receipt' is required and cannot be null.""); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final Boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new OperationException(""Cancellation is not supported"")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync).andThen(after -> after.map(modelSimpleResponse -> { if (responseIsInvalid(modelSimpleResponse.getValue())) { return responseMessageTransformer.transformResponseError(modelSimpleResponse.getValue()); } return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Functions.ifThenElse(Exception::wrap, Utility::mapToHttpResponseExceptionIfExist))), Throwable::withStackTrace ); } catch (Exception ex) { return PollerFlux.error(ex); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null == adapter'
The code is: 'public Adapter getContentAdapter() { if <START> (adapter == null) { <END> adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }'",public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; },"1- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
2- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
3- public Adapter getContentAdapter() { if (adapter == null) { adapter = new AdapterImpl(); } return adapter; }
4- public Adapter getContentAdapter() { if (adapter == null) { adapter = new AdapterImpl() { @Override public synchronized void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
5- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
6- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
7- public Adapter getContentAdapter() { if (null!= adapter) { return adapter; } adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @SuppressWarnings(""synthetic-access"") @Override public void run() { notifyChildListUpdated(); } }); break; case Notification.SET: break; } } }; return adapter; }
8- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(notification); } }); break; case Notification.SET: default: log.error(""Unknown content notification type""); break; } } }; } return adapter; }
9- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }
10- public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Null check ryaInstance'
The code is: 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); <START> <END> final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }'","public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }","1- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); requireNonNull(ryaInstance); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
2- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); try { final KafkaProducer<String, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final KafkaConsumer<String, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; } catch (final IOException e) { throw new RuntimeException(""Failed to create a KafkaProducer,QueryConsumer,QueryRepository,KafkaGetQueryResultStream on "" + kafkaHostname, e); } }
3- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaUtils.getChangeLogRyaTopic( ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
4- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)); }
5- public static RyaStreamsClient make(final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); requireNonNull(ryaInstance); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
6- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); requireNonNull(ryaInstance); final List<Consumer<KafkaQueryChangeLog, QueryChange>> consumerList = kafkaProducers.getUnmodifiableList(); if (consumerList.isEmpty()) { throw new IllegalArgumentException(""kafkaProducers List is empty""); } final boolean useCustomSerializer = ryaInstance.contains(""rya"") || ryaInstance.contains(""dre""); final Config config = new Config(); final Set<Class<?>> serializers = new HashSet<Class<?>>(); serializers.add(StringSerializer.class); serializers.add(QueryChangeSerializer.class); serializers.add(StringDeserializer.class); serializers.add(QueryChangeDeserializer.class); serializers.add(QuerySerializer.class); serializers.add(StatementSerializer.class); if (useCustomSerializer) { config.addDefaultSerDeInstance(SerializerFactory.STRING_SERDE_CLASS); } config.setProp(Config.RHINO_LOG_CACHE_SIZE, Integer.toString(NUM_CACHE_ENTRIES)); for (final Consumer<KafkaQueryChangeLog, QueryChange> consumer : consumerList) { consumer.init(config, serializers.iterator()); } final Producer<KafkaQueryChangeLog, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, useCustomSerializer? StringSerializer.class : QueryChangeSerializer.class, consumerList); final Consumer<KafkaQueryChangeLog, QueryChange>queryConsumer = fromStartingConsumer(kafkaHostname, kafkaPort, useCustomSerializer? StringSerializer.class : VisibilityStatementSerializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient(new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, useCustomSerializer? VisibilityStatementDeserializer.class : VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.
7- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange> queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
8- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(ryaInstance); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(null, null, changeLogTopic); return new RyaStreamsClient( new DefaultAddQuery(null), new DefaultGetQuery(null), new DefaultDeleteQuery(null), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(null), new DefaultStartQuery(null), new DefaultStopQuery(null)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
9- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); requireNonNull(ryaInstance); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }
10- public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final long kafkaPort) { requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, Optional.of(QueryChangeSerializer.class), Optional.of(QueryChangeDeserializer.class)); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, Optional.of(StringDeserializer.class), Optional.of(QueryChangeDeserializer.class)); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, """" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(""Couldn't close a QueryRepository."", e); } } }; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant parentheses'
The code is: 'public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); <START> if ((bridge.bridgeCommunicate(bcp)) && (bcp.isCommunicationSuccessful())) { <END> logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }'","public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }","1- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); bcp.setNodeAndMainParameter(nodeId, value.getPositionAsVeluxType()); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
2- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) throws TechnicalException { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); boolean status = bridge.bridgeCommunicate(bcp); if (status) { logger.debug(""sendCommand() finished successfully""); return true; } else { logger.debug(""sendCommand() finished with failure""); return false; } }
3- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
4- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.addDeviceParameter(nodeId); bcp.setNodeAndMainParameter(nodeId, veluxValue.floatValue()); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
5- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
6- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
7- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
8- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && (bcp.isCommunicationSuccessful())) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
9- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }
10- public boolean sendCommand(VeluxBridge bridge, Integer nodeId, VeluxProductPosition value) { logger.trace(""sendCommand(nodeId={},value={}) called."", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); Integer veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(""sendCommand() finished successfully.""); return true; } else { logger.trace(""sendCommand() finished with failure.""); return false; } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move toString() clickOrdersTableColumn() method for OrdersTable.ELEM.toString() calls'
The code is: 'public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); <START> orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); <END> List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }'","public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }","1- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrderByTotalPriceAsc(); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrderByTotalPriceDesc(); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }
2- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrdersTablePage ordersTablePage = userInfoPage.clickOrdersTableTab(); List<Order> tableFromView = ordersTablePage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); ordersTablePage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPrice = ordersTablePage.getTableFromView(); Assert.assertTrue(sortedTableByTotalPrice.equals(tableFromView.sort(Comparator.comparing(Order::getTotalPrice))), ""Sorting by total price doesn't work.""); ordersTablePage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); sortedTableByTotalPrice = ordersTablePage.getTableFromView(); Assert.assertTrue(sortedTableByTotalPrice.equals(tableFromView.sort(Comparator.comparing(Order::getTotalPrice))), ""Sorting by total price doesn't work.""); }
3- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableSortColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }
4- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); Sort<Order> orderingSort = orderingPage.clickOrderTotals(); tableFromView.sort(orderingSort); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingSort = orderingPage.clickOrderTotals(); tableFromView.sort(orderingSort); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }
5- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrderingTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrderingTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); testTotalPriceSorting(tableFromView, sortedTableByTotalPriceAsc, sortedTableByTotalPriceDesc); }
6- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }
7- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); String totalPrice = OrdersTable.TOTAL_PRICE.toString(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(totalPrice); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(totalPrice); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), ""Sorting by total price doesn't work.""); } }
8- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (Integer i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), ""Sorting by total price doesn't work.""); } for (Integer i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice())); } }
9- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.NUMBER_OF_ITEMS.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.NUMBER_OF_ITEMS.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.ESTIMATED_DELIVERY_TIME.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); orderingPage.clickOrdersTableColumn(OrdersTable.ESTIMATED_DELIVERY_TIME.toString()); orderedResult = orderingPage.getSortedTable(); user.expectTableSorted(); }
10- public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); verifyOrderingData(Order.class, orderingPage); OrderingPage totalPriceSortPage = orderingPage.changeSorting(Comparator.comparing(Order::getTotalPrice)); totalPriceSortPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); verifyOrderingTotalPriceData(Order.class, orderingPage); totalPriceSortPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); verifyOrderingTotalPriceData(Order.class, orderingPage); totalPriceSortPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); verifyOrderingTotalPriceData(Order.class, orderingPage); totalPriceSortPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); verifyOrderingTotalPriceData(Order.class, orderingPage); totalPriceSortPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); verifyOrderingTotalPriceData(Order.class, orderingPage); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I noticed finishCommit is passed cd2. Of works fine because, cd cd2 same. This simplify code remove CommitData param OnSuccessInterface.onSuccess(). this code written : java addCallback(cfuture, cd, result -> finishCommit(cd, commitTs));'
The code is: 'private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); <START> addCallback(cfuture, cd, (cd2, result) -> finishCommit(cd, commitTs)); <END> }'","private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }","1- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }
2- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, (cd2, result) -> finishCommit(cd, commitTs)); }
3- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isDelete(colUpdates.getValue()), isWrite(colUpdates.getValue()), isLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, (cd2, result) -> finishCommit(cd, false)); }
4- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }
5- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, OnSuccessInterface.onSuccess(cfuture, result -> finishCommit(cd, commitTs))); }
6- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }
7- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, (cd2, result) -> finishCommit(cd2, commitTs)); }
8- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, update -> finishCommit(cd, commitTs)); }
9- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerValue(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, OnSuccessInterface.onSuccess(), (cd2, result) -> finishCommit(cd, commitTs)); }
10- private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); Boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, (cd2, result) -> finishCommit(cd, commitTs)); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: need new Object[] for current version of slf4j'
The code is: 'public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", <START> new Object[] { timedOutOperations, channel, addr }); <END> } }'","public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }","1- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized(this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
2- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
3- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); ++timedOutOperations; } } } if (timedOutOperations > 0) { LOG.warn(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr, (timedOutOperations == 1)? """" : ""s""); } }
4- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); ++timedOutOperations; } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
5- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
6- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } LOG.info( ""Timed-out {} operations to channel {}. Remotely timed-out {} operations will be retransmitted to {}"", timedOutOperations, channel, timedOutOperations, Address.getAddressString(addr)); }
7- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timeout on pending operations on channel {} (version: {}) for {} entries on address {}"", channel, getVersion(), timedOutOperations, addr); } }
8- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
9- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }
10- public void checkTimeoutOnPendingOperations() { Integer timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(""Timed-out {} operations to channel {} for {}"", timedOutOperations, channel, addr); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@lbergelson @nh13 in case, put 0L here'
The code is: 'public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { <START> counts.put(contingencyState, (Long)0); <END> } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }'","public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }","1- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final CallState callState : CallState.values()) { final TruthState truthState = SchemeUtils.getContingencyStateFromCallState(callState); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, Long.valueOf(0L)); } final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState); counts.put(contingencyState, newCount!= null? newCount : 0L); } } return counts; }
2- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { counts.put(contingencyState, getCount(truthAndCallStates) + counts.getOrDefault(contingencyState, 0L)); } } } return counts; }
3- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
4- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) counts.put(containingState, Long.valueOf(0)); for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
5- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
6- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
7- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, MINUS_ONE_L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
8- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStates = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStates) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
9- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, LONG_ZERO); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }
10- public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final Long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again: Capture, test. getGenericParams is expensive'
The code is: 'public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { <START> List<HaxeGenericParamModel> genericParams = model.getGenericParams(); <END> if (genericParams != null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } } return specifics; }'","public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (nonNull(genericParams)) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } return specifics; }","1- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = nameAndConstraints.remove(specifics[i].getType()); specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi(), name, model.getPriority()).createHolder(); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } } } } return specifics; }
2- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { GenericParam[] genericParams = model.getGenericParams(); Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (ResultHolder holder : specifics) { if (holder instanceof HaxeGenericParamReference) { HaxeGenericParamReference genericParamReference = (HaxeGenericParamReference) holder; GenericParamModel genericParamModel = genericParamReference.getGenericParamModel(); String genericParamName = genericParamModel.getName(); boolean isPresent = genericParams.stream().anyMatch(genericParam -> genericParam.getName().equalsIgnoreCase(genericParamModel.getName())); if (nameAndConstraints.containsKey(genericParamName) && isPresent &&!specifics.contains(genericParamReference)) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder().createHolder(); nameAndConstraints.put(genericParamName, wrapType(dynamicType, holder.getElementContext(), true).createHolder()); specifics.set(specifics.indexOf(holder), genericParamReference); ; } if (specifics.contains(genericParamReference) && genericParamModel.isArray() &&!isPresent) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder().createHolder(); specifics.set(specifics.indexOf(holder), null); nameAndConstraints.put(genericParamModel.getFullName(), dynamicType); } } } } return specifics; }
3- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(model.getGenericParams()); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } return specifics; }
4- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); ResultHolder resolvedType = nameAndConstraints.get(name); List<String> listOfGenericParameterNames = model.getGenericParams().get(genericParams.indexOf(GenericParamModel.fromString(name))).getGenericParameterNames(); SpecificTypeReference.setGenericParameterNames( listOfGenericParameterNames, resolutionResult, resolvedType); resolvedType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(resolvedType, specifics[i].getElementContext(), true); } else if (specifics[i].getClassType().isEnumValueClass()) { SpecificTypeReference.setGenericParameterNames( genericParams.subList(genericParams.indexOf(GenericParamModel.fromString(name)), genericParams.size()), resolutionResult, specifics[i].getElementContext(), true); specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } else { specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } return specifics; }
5- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(genericParam -> genericParam.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } } return specifics; }
6- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<Capture> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } } return specifics; }
7- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { Map<String, ResultHolder> genericParamsByName = getGenericTypeParametersByName(model.getGenericParams()); if (genericParamsByName!= null) { for (int i = 0; i < specifics.length; i++) { HaxeGenericParamModel[] genericParams = model.getGenericParams(); ResultHolder typeHolderSpecific = genericParamsByName.get(genericParams[i].getName()); boolean wasEnum = typeHolderSpecific!= null && typeHolderSpecific.getElementContext() instanceof HaxeEnum; if (wasEnum) { if (!specifics[i].getClassType().isEnumValueClass()) { specifics[i] = wrapEnumValue(genericParamsByName.get(genericParams[i].getName()), specifics[i]); } continue; } specifics[i] = genericParamsByName.get(genericParams[i].getName()); } } } return specifics; }
8- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { Map<String, ResultHolder> nameToResultHolder = getGenericTypeParametersByName(model.getGenericParams()); for (ResultHolder specific : specifics) { String name = specific.getClassType().getClassName(); if (nameToResultHolder.containsKey(name)) { specific = nameToResultHolder.get(name); if (specific.getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specific = wrapType(dynamicType, specific, true); } } } } return specifics; }
9- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); if (nameAndConstraints!= null) { Set<ResultHolder> seen = new HashSet<>(); boolean changedAny = false; for (ResultHolder specific : specifics) { changedAny = true; for (ResultHolder entry : specific.getConstraints()) { String name = entry.getClassMemberType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (seen.contains(name)) { continue; } seen.add(name); ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); ResultHolder copy = wrapType(dynamicType, entry, true).createHolder(); if (!copy.getClassMemberType().isEnumValueClass()) { specific = wrapType(copy, entry, false).createHolder(); } else if (ModelUtil.hasImplicitEnum(entry.getClassMemberType())) { specific = copy; } else { newLog.fine(""This is an enum but no copy is available""); } changedAny = true; } } } if (changedAny) { specifics = adjustConstraintsByValue(specifics, seen); } } return specifics; } } return specifics; }
10- public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (genericParams!= null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); Boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass() &&!ResultHolder.ARRAY_SPECIFICATION.equals(specifics[i])) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } return Arrays.copyOf(specifics, specifics.length); } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } } return specifics; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I of stay non-final provide more efficient implementations in subclasses'
The code is: 'public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; <START> public final List<T> peek(Integer max) throws IOException { <END> Integer end = Math.min(max, size()); List<T> subList = new ArrayList<T>(end); Iterator<T> iterator = iterator(); for (Integer i = 0; i < end; i++) { subList.add(iterator.next()); } return Collections.unmodifiableList(subList); }'","public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public List<T> peek(Integer max) throws IOException { Integer end = Math.min(max, size()); List<T> subList = new ArrayList<T>(end); Iterator<T> iterator = iterator(); for (Integer i = 0; i < end; i++) { subList.add(iterator.next()); } return Collections.unmodifiableList(subList); }","1- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public ArrayList<T> peek(Integer max) throws IOException { return PeekIterator.read(this, max); }
2- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final T peekAfter(Integer after) throws IOException { return peek(after + 1); }
3- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public Iterator<T> iterator() { return (Iterator<T>) list; }
4- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final List<T> peek(final Integer max) throws IOException { int end = Math.min(max, size()); if (end >= 0) { return new ArrayList<T>(end); } else { return Collections.emptyList(); } }
5- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final List<T> peek(Integer max) throws IOException { List<T> subList = new ArrayList<T>(max); Iterator<T> iterator = iterator(); for (Integer i = 0; i < max; i++) { subList.add(iterator.next()); } return Collections.unmodifiableList(subList); }
6- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final List<T> peek(Integer max) throws IOException { int end = Math.min(max, size()); List<T> subList = new ArrayList<T>(end); if (end == 0) { return Collections.unmodifiableList(emptyIterator()); } else { Iterator<T> iterator = iterator(); for (int i = 0; i < end; i++) { subList.add(iterator.next()); } return subList; } }
7- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final List<T> peek(Integer max) { List<T> result = new ArrayList<T>(max); Iterator<T> iterator = iterator(); for (int i = 0, j = 0; i < max && j < result.size(); i++, j++) { result.set(j, iterator.next()); } return result; }
8- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public abstract T poll() throws IOException; @Override default void reset() { size = 0; iterator = iterator(); }
9- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public final List<T> peek(int max) throws IOException { Integer end = Math.min(max, size()); List<T> sub = new ArrayList<T>(end); Iterator<T> iterator = iterator(); for (Integer i = 0; i < end; i++) { sub.add(iterator.next()); } return Collections.unmodifiableList(sub); }
10- public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public abstract List<T> peek(int size) throws IOException; public final int max() { return size(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Arrays.asList'
The code is: 'public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); <START> List<String> userNames = new ArrayList<String>() {{ <END> add(""john""); add(""joan""); }}; userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); Boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }'","public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<String> userNames = Arrays.asList(""john"", ""joan""); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); Boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }","1- public void shouldDeleteUsers() { User john = new User(USER_NAME); john.disable(); User joan = new User(USER_NAME); joan.disable(); List<String> userNames = new ArrayList<String>()->add(USER_NAME); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); Boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
2- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); Arrays.asList(""john"", ""joan"").forEach(userName = null); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
3- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<User> userNames = Arrays.asList(john, joan); userDao.saveOrUpdate(john, joan); boolean result = userDao.deleteUsers(userNames); assertTrue(result); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
4- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<String> userNames = Arrays.asList(""john"", ""joan""); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); Boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
5- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<String> userNames = Arrays.asList(""john"", ""joan""); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
6- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<String> userNames = Arrays.asList(""john"", ""joan""); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); Boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
7- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<User> users = Arrays.asList(john, joan); userDao.saveOrUpdate(users); users.clear(); boolean result = userDao.deleteUsers(users); assertThat(result, is(true)); Users users2 = userDao.allUsers(); assertThat(users2, is(empty())); }
8- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<User> users = Arrays.asList(asUser(""john""), asUser(""joan"")); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); boolean result = userDao.deleteUsers(users); assertThat(result, is(true)); Users usersInUserDao = userDao.allUsers(); assertThat(usersInUserDao, is(empty())); }
9- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); Arrays.asList(""john"", ""joan"").forEach(u -> { User user = userDao.find(u); user.disable(); userDao.saveOrUpdate(user); }); Boolean result = userDao.deleteUsers(new ArrayReader<>(Arrays.asList(""john"", ""joan""))); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }
10- public void shouldDeleteUsers() { User john = new User(""john""); john.disable(); User joan = new User(""joan""); joan.disable(); List<User> johns = new ArrayList<User>() {{ add(john); }}; User joans = new User(""joan""); Collection<User> johnsCollection = Arrays.asList(johns); List<User> joansCollection = Arrays.asList(joans); Boolean result = userDao.deleteUsers(johnsCollection); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a constant'
The code is: 'public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); <START> Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, 100); <END> ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }'","public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, Conglomerate.Priority.HIGH); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }","1- public void run() { try { ContextManager cm = ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti = coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties = new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate = ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate = createConglomerate(tc, rowTemplate, heapProperties, 100); ti.setHeapConglomerate(conglomerate); coreInfo[coreCtr].setState(DictionaryTableState.STOP); coreInfo[coreCtr].setConglomerate(conglomerate); } catch (Exception e) { e.printStackTrace(); if (log!= null) { log.severe(e.toString()); } } }
2- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, DEFAULT_CACHED_ROW_SIZE); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }
3- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, catalogDefaultRows); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ SanityManager.THROWASSERT(""Failed to create the congromere for dictionary table""+coreCtr,e); } }
4- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, DEFAULT_NUM_ROWES); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }
5- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties,HEAPCONGLOMERATEDEFAULTSIZE); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ throw new RuntimeException(e); } }
6- public void run() { try { ContextManager cm = ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti = coreInfo[corectr]; String version = catalogVersions.get(corectr); Properties heapProperties = new Properties(); String tableDisplayName = ti.getTableName(); Long conglomerate = createConglomerate(tc, ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(), heapProperties, 100); ti.setHeapConglomerate(conglomerate); } catch (Exception e) { LOGGER.log(Level.SEVERE, ""Dictionary table failure"", e); PrintableException pex = new PrintableException( e.getMessage()); while (true) { JythonEngine jython = JythonEngine.getForCore(); String code = pex.getCode(); jython.setLocalLanguage(code); jython.runInterpreter(code); } } }
7- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); HeapConglomerate conglomerate=createHeapConglomerate(tc,rowTemplate,heapProperties, 100); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }
8- public void run(){ try{ ContextFactory.setCatalog(ec); ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, 100); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }
9- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, conglomerateSize); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ str.setFailureMessage(e.getMessage()); } }
10- public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(""tableDisplayName"", ti.getTableName()); heapProperties.setProperty(""catalogVersion"", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); Long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, CREATION_LIMIT); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(""Dictionary Table Failure - exiting ""); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename listIterator'
The code is: 'private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { <START> private final Iterator<String> l_it = values.iterator(); <END> @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }'","private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final Iterator<String> listIterator = values.iterator(); @Override public Boolean hasNext() { return listIterator.hasNext(); } @Override public String next() { return listIterator.next(); } }; } }; }","1- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final Iterator<String> listIterator = values.iterator(); @Override public Boolean hasNext() { return listIterator.hasNext(); } @Override public String next() { return listIterator.next(); } }; } }; }
2- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final Iterator<String> l_it = values.listIterator(); @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }
3- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final ListIterator<String> l_it = values.listIterator(); @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }
4- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private Iterator<String> listIterator; @Override public Boolean hasNext() { return listIterator.hasNext(); } @Override public String next() { return listIterator.next(); } }; } }; }
5- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final ListIterator<String> l_it = values.listIterator(); @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }
6- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean iteratorCreated = false; @Override public Iterator<String> iterator() { if (iteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); iteratorCreated = true; return new Iterator<String>() { private final Iterator<String> itr = values.iterator(); @Override public boolean hasNext() { return itr.hasNext(); } @Override public String next() { return itr.next(); } }; } }; }
7- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private final Iterator<String> l_it = values.stream().iterator().peek(i-> ThreadLocalRandomnessCheck::check()); @Override public Iterator<String> iterator() { if (l_it.hasNext()) { return l_it; } return new Iterator<String>() { @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { if (ThreadLocalRandomnessCheck.check()) throw new IllegalStateException(""Stream elements should be drawn in the same order they "" + ""were created.""); return l_it.next(); } }; } }; }
8- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(""Cannot create two iterators on a singly-iterable sequence""); isIteratorCreated = true; return new Iterator<String>() { private final ListIterator<String> l_it = values.listIterator(); @Override public Boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }
9- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Set<String> iterator = Sets.newLinkedHashSet(); @Override public Iterator<String> iterator() { if (this.iterator.get() == null) return new Iterator<String>() { @Override public Boolean hasNext() { return iterator.add(null).isEmpty(); } @Override public String next() { throw new UnsupportedOperationException(); } }; return this.iterator.set(new SinglyIterator<String>(this.iterator)); } }; }
10- private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private Boolean hasIterator; @Override public Iterator<String> iterator() { if (!hasIterator) { hasIterator = createIterator(values); } return hasIterator; } }; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do java Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; slightly easier read for loop'
The code is: 'private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { <START> Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.size()); <END> for (Iterator<FileRef> iterator = filesToCompact.keySet().iterator(); iterator.hasNext();) { smallestFiles.add(iterator.next()); iterator.remove(); } return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }'","private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }","1- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef> (filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) { return o1.getFirst().compareTo(o2.getFirst()); } if (o1.getSecond() < o2.getSecond()) { return -1; } return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
2- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(fileHeap.size()); while (!fileHeap.isEmpty() && smallestFiles.size() < maxFilesToCompact) { Pair<FileRef,Long> pair = fileHeap.remove(); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
3- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.size()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
4- private Map<FileRef,DataFileValue> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { return filesToCompact; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Map<FileRef,DataFileValue> smallerFiles = new HashMap<FileRef,DataFileValue>(filesToCompact); while (fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); smallerFiles.put(pair.getFirst(), pair.getSecond() == 0? null : dataFileValueFactory.createDataFileValue(pair.getSecond(), pair.getFirst(), false); } return smallerFiles; }
5- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
6- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { return Utils.removeSmallestAndReturnSet(filesToCompact, maxFilesToCompact, new Comparator<FileRef>(){ @Override public int compare(FileRef o1, FileRef o2) { long size1 = o1.getSize(); long size2 = o2.getSize(); if (size1 == size2) return 0; return (int) (size1 < size2? -1 : 1); } }); }
7- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { for (Iterator<FileRef> iterator = filesToCompact.keySet().iterator(); iterator.hasNext();) { iterator.remove(); } return filesToCompact.keySet(); } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public long compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
8- private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { Set<FileRef> removeFromToCompact = new HashSet<FileRef>(); for (Entry<FileRef,DataFileValue> entry : filesToCompact.entrySet()) { if (removeFromToCompact.size() > maxFilesToCompact) return new HashSet<FileRef>(filesToCompact.keySet()); removeFromToCompact.add(entry.getKey()); } return removeFromToCompact; }
9- private static Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new FileComparator()); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }
10- private Map<FileRef,DataFileValue> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { LinkedList<FileRef> smallestFiles = new LinkedList<>(); filesToCompact.remove(null); for (FileRef file : filesToCompact.keySet()) { if (filesToCompact.get(file).getSize() / 1024 < maxFilesToCompact) { if (smallestFiles.indexOf(file) < 0) { smallestFiles.add(file); } } else { smallestFiles.remove(file); } } Map<FileRef,DataFileValue> result = new HashMap<FileRef,DataFileValue>(filesToCompact); result.remove(null); result.putAll(smallestFiles); return result; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this'
The code is: 'private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { <START> System.out.println(""brokerRequest = "" + brokerRequest.toString()); <END> BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }'","private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }","1- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
2- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTotalTime(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
3- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
4- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
5- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { System.out.println(TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - compilationStartTimeNs)); BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
6- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
7- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
8- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) { BrokerResponseNative brokerResponse = new BrokerResponseNative(); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); List<Object> results = new ArrayList<>(brokerRequest.getPinotQuery().getSelectList().size()); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { results.addAll(computeResultsForExpression(e)); } DataSchema dataSchema = new DataSchema(brokerRequest.getPinotQuery().getColumnNames().toArray(new String[0]), new DataSchema.ColumnDataType[brokerRequest.getPinotQuery().getColumnDataTypes().size()]); ResultTable resultTable = new ResultTable(dataSchema, results); brokerResponse.setResultTable(resultTable); brokerResponse.setTotalTimeMS(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
9- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }
10- private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, Long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); Long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want remove legacy this name also'
The code is: 'private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); <START> if (config.isLegacyReservedPoolEnabled()) { <END> builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }'","private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); if (config.isReservedPoolEnabled()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }","1- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { checkArgument(config.getMaxQueryTotalMemoryPerNode().toBytes() <= config.getMaxQueryMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = min(maxMemory.toBytes(), availableMemory.toBytes()); verify(generalPoolSize > 0 || 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
2- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); long generalPoolSize = maxMemory.toBytes(); if (!config.getReservedSpoolBufferSize().isEmpty()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, dataSize(config.getReservedSpoolBufferSize()))); generalPoolSize -= config.getReservedSpoolBufferSize().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, dataSize(generalPoolSize))); this.pools = builder.build(); }
3- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
4- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); if (isReservedMemoryEnabled()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
5- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); if (config.isReservedPoolEnabled()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
6- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); if (config.isReservedPoolEnabled()) { Long reservedPoolSize = maxMemory.toBytes(); builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, new DataSize(reservedPoolSize, BYTE))); reservedPoolSize = config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(reservedPoolSize >= 0, ""reserved memory pool size is 0""); builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, new DataSize(reservedPoolSize, BYTE))); this.pools = builder.build(); }
7- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); if (config.getMaxQueryTotalMemory().toBytes() > 0) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemory())); generalPoolSize -= config.getMaxQueryTotalMemory().toBytes(); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
8- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); Optional<Long> maxQueryMemoryPerNode = Optional.ofNullable(config.getMaxQueryMemoryPerNode().toBytes()); if (maxQueryMemoryPerNode.isPresent()) { checkArgument( maxQueryMemoryPerNode.get() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); } ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }
9- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPool.MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); for (MemoryPool.MemoryPoolId pool : config.getMemoryPools()) { pool.setMaxMemory(new DataSize(maxMemory.toBytes(), BYTE)); } for (MemoryPool.MemoryPoolId pool : config.getMemoryPools()) { builder.put(pool, new MemoryPool(pool, new DataSize(config.getMaxQueryMemoryPerNode().toBytes(), BYTE))); generalPoolSize -= config.getMaxQueryMemoryPerNode().toBytes(); checkArgument(generalPoolSize > 0, ""general memory pool size is 0""); } pools = builder.build(); verify(generalPoolSize > 0, ""general memory pool size is 0""); }
10- private void configureMemoryPools(NodeMemoryConfig config, Long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), ""Max query memory per node (%s) cannot be greater than the max query total memory per node (%s)."", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); Long generalPoolSize = maxMemory.toBytes(); if (config.isReservedQueryMemoryEnabled()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode(), getPageWithoutBuffer())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } else { maxMemory = maxMemory.withoutBuffer(new DataSize(config.getMaxQueryTotalMemoryPerNode().toBytes())); } verify(generalPoolSize > 0, ""general memory pool size is 0""); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static'
The code is: 'private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } <START> Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; <END> PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }'","private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }","1- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); filter.filter(new BlockCursor(inputs), filterResults, errors); if (errors.isEmpty()) { qualifyingSet.compactPositionsAndErrors(filterResults, numPositions); } else { qualifyingSet.getOrCreateErrorSet().appendError(errors); } }
2- private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }
3- private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }
4- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Block[] filterResults = new Block[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); int numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }
5- private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }
6- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.computeErrors(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionAndErrors(filterResults, numHits); }
7- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Block[] filterResults = new Block[qualifyingSet.getRows()]; Integer[] errors = qualifyingSet.getOrCreateErrorSet(); PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); for (Integer row = 0; row < filterResults.length; row++) { Block filtered = filter.filter(new Block[][] { new int[] { 0 }, inputs }, filterResults); errors.add(new Integer(row)); if (filtered.getPositionCount() == 0) { filterResults[row] = null; } else { filterResults[row] = filtered; } } qualifyingSet.compact(filterResults); }
8- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } int numHits = filter.filter(new Page(qualifyingSet.size()), new BlockArray(inputs), new ErrorSet()); qualifyingSet.compactPositionsAndErrors(numHits); }
9- private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (Integer i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }
10- private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { Integer[] inputChannels = filter.getInputChannels(); Block[] inputs = new Block[inputChannels.length]; for (Integer i = 0; i < inputChannels.length; i++) { inputs[i] = constantBlocks[inputChannels[i]]; } Integer[] filterResults = new Integer[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); Integer numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@tmjee is a big sense declaring one-time variable (especially names). inline put checkstyle suppression'
The code is: 'public void validatesXmlForSchemaValidity() throws Exception { <START> final Integer zero = 0; <END> final Integer ten = 10; final Integer hundred = 100; final Integer fifty = 50; final Random rand = new SecureRandom(); final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(hundred); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }'","public void validatesXmlForSchemaValidity() throws Exception { final Integer timeout = 10; final Integer random = 100; final Integer loop = 50; final Random rand = new SecureRandom(); final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(random); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = 0; count < loop; count = count + 1) { executorService.submit(callable); } executorService.shutdown(); MatcherAssert.assertThat( executorService.awaitTermination(timeout, TimeUnit.SECONDS), Matchers.is(true) ); executorService.shutdownNow(); }","1- public void validatesXmlForSchemaValidity() throws Exception { Validator validator = new Validator( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", fifty), ""</r>"" ) ).node() ), new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer' minOccurs='0' maxOccurs='unbounded'/></xs:sequence></xs:complexType></xs:element>"" ""</xs:schema>"" ) ) ); int nbValidationError = 0; for (Object[] row : validator.getErrors()) { nbValidationError += Arrays.asList(row).size(); } Assert.assertEquals(nbValidationError, 0); }
2- public void validatesXmlForSchemaValidity() throws Exception { final Integer zero = 0; final Integer ten = 10; final Integer hundred = 100; final Integer fifty = 50; final Integer five = new Integer(5); final Random rand = new SecureRandom(); final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final int cnt = rand.nextInt(hundred); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ) ).node() ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }
3- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", 10), ""</r>"" ) ).node() ) ), Matchers.hasSize(10 << 1) ); }
4- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(100); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; MatcherAssert.assertThat( ExecutorTestUtils.executeAndFail( Executors.newSingleThreadExecutor( Threads.daemon() ), callable ), instanceOf(TimeoutException.class) ); }
5- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = randomGenerator.nextInt(hundred); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = 0; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }
6- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer' minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer count = rand.nextInt(hundred); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }
7- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Map<Integer, XSISEmptyElement> map = new HashMap<>(); while (true) { final Integer cnt = rand.nextInt(100); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); final Integer x = cnt << 1; if (map.containsKey(x)) { assertThat(map.get(x), not(contains(cnt))); } else { map.put(x, new XSISEmptyElement().getElement()); } } assertThat(map.entrySet(), hasSize(cnt) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (final Integer count : Arrays.asList(zero, ten, fifty, fifty, fifty, fifty)) { executorService.submit(callable); } executorService.awaitTermination(10, TimeUnit.SECONDS); executorService.shutdown(); }
8- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer' "", ""minOccurs='0' maxOccurs='unbounded'/></xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(TEN); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = ZERO; count < FIFTY; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(TEN, TimeUnit.SECONDS); executorService.shutdown(); }
9- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer' />"", ""</xs:sequence></xs:complexType></xs:element>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(ten); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt), ""</r>"" ) ) ).node() ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }
10- public void validatesXmlForSchemaValidity() throws Exception { final XSD xsd = new XSDDocument( StringUtils.join( ""<xs:schema xmlns:xs ='<LINK_0>' >"", ""<xs:element name='r'><xs:complexType>"", ""<xs:sequence>"", ""<xs:element name='x' type='xs:integer'"", "" minOccurs='0' maxOccurs='unbounded'/>"", ""</xs:sequence></xs:complexType></xs:element>"", ""</xs:schema>"" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final Integer cnt = rand.nextInt(Integer.MAX_VALUE); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.repeat( ""<r>"", StringUtils.repeat(""<x>hey</x>"", cnt) ) ).node() )), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (Integer count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); executorService.shutdown(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove explicit setting of purgeLessThanEqualTo'
The code is: 'public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", -2L, purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", -1, purgeLessThanEqualTo.longValue()); Long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 8, purgeLessThanEqualTo.longValue()); <START> purgeLessThanEqualTo.setValue(-2); <END> Long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9, purgeLessThanEqualTo.longValue()); Assert.assertEquals(""time bucket"", -1, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9, purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }'","public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", -2L, purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", -1, purgeLessThanEqualTo.longValue()); Long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 8, purgeLessThanEqualTo.longValue()); Long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9, purgeLessThanEqualTo.longValue()); Assert.assertEquals(""time bucket"", -1, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9, purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }","1- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { if (purgeLessThanEqualTo.getValue()!= getTimeBucketKeyExpiry(timeBucket, testMeta.timeBucketAssigner)) { throw new AssertionError(""purgeLessThanEqualTo.getValue() == getTimeBucketKeyExpiry()""); } purgeLessThanEqualTo.setValue(timeBucket); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", -2L, purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); testMeta.timeBucketAssigner.teardown(); }
2- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(TimeBucketKey.NEXT_BUCKET, testMeta.timeBucketAssigner.getNextBucket()); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(TimeBucketKey.PENDING, testMeta.timeBucketAssigner.getNextBucket()); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(TimeBucketKey.PENDING, testMeta.timeBucketAssigner.getNextBucket()); testMeta.timeBucketAssigner.teardown(); }
3- public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", -2L, purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", -1, purgeLessThanEqualTo.longValue()); Long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", -1, purgeLessThanEqualTo.longValue()); Long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 1, purgeLessThanEqualTo.longValue()); Assert.assertEquals(""time bucket"", 9, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 1, purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }
4- public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", -2L, purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", -1L, purgeLessThanEqualTo.longValue()); Long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 8L, purgeLessThanEqualTo.longValue()); purgeLessThanEqualTo.setValue(-2); Long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9L, purgeLessThanEqualTo.longValue()); Assert.assertEquals(""time bucket"", -1, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 9L, purgeLessThanEqualTo.longValue()); testMeta.time
5- public void testTimeBucketKeyExpiry() { setExpireBeforeTimeBucket(4); setBucketSpanTimeBucket(2); setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { purgeTimeBucket.setValue(timeBucket); } }); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeTimeBucket"", 2, testMeta.timeBucketAssigner.getTimeBucket(referenceTime + 1)); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeTimeBucket"", 1, purgeTimeBucket.longValue()); testMeta.timeBucketAssigner.setExpireBeforeTimeBucket(referenceTime + 5); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeTimeBucket"", 4, purgeTimeBucket.longValue()); testMeta.timeBucketAssigner.setBucketSpanTimeBucket(referenceTime + 7); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeTimeBucket"", 3, purgeTimeBucket.longValue()); testMeta.timeBucketAssigner.teardown(); }
6- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(-1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.seconds(-10)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { numPurges.incrementAndGet(); } }); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEvictionsMatch(numPurges::get, true, ""purgeLessThanEqualTo""); Long time0 = Duration.seconds(-1).getMillis() + referenceTime; Assert.assertTrue(testMeta.timeBucketAssigner.isExpired(time0)); testMeta.timeBucketAssigner.endWindow(); Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time0)); testMeta.timeBucketAssigner.endWindow(); Assert.assertTrue(testMeta.timeBucketAssigner.isExpired(time0)); testMeta.timeBucketAssigner.endWindow(); Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time0)); Long time1 = Duration.seconds(9).getMillis() + referenceTime; Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time1)); testMeta.timeBucketAssigner.endWindow(); Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time1)); testMeta.timeBucketAssigner.endWindow(); Assert.assertTrue(testMeta.timeBucketAssigner.isExpired(time1)); testMeta.timeBucketAssigner.endWindow(); Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time1)); Assert.assertEquals(0, numPurges.get()); testMeta.timeBucketAssigner.endWindow(); Assert.assertTrue(testMeta.timeBucketAssigner.isExpired(time0)); testMeta.timeBucketAssigner.endWindow(); Assert.assertFalse(testMeta.timeBucketAssigner.isExpired(time0)); testMeta.timeBucketAssigner.endWindow(); Assert.assertTrue(testMeta.timeBucketAssigner.is
7- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setTimeAssigner(new LongTimeAdapter()); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); Long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgeLessThanEqualTo"", 0L, testMeta.timeBucketAssigner.purgeLessThanEqualTo.longValue()); Long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 0, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 0L, testMeta.timeBucketAssigner.purgeLessThanEqualTo.longValue()); Long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 0, testMeta.timeBucketAssigner.purgeLessThanEqualTo.longValue()); Long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(""time bucket"", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgeLessThanEqualTo"", 1, testMeta.timeBucketAssigner.purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }
8- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); testMeta.timeBucketAssigner.endWindow(); testMeta.timeBucketAssigner.teardown(); }
9- public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testTimeBucketKeyExpiry(purgeLessThanEqualTo,Duration.standardSeconds(1)); }
10- public void testTimeBucketKeyExpiry() { testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(Long timeBucket) { Assert.assertEquals(testMeta.timeBucketAssigner.getReferenceInstant().getMillis(), timeBucket); } }); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgedLessThanEqualTo"", 2L, readReferenceExpirationData.readPurgeLessThanEqualTo()); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgedLessThanEqualTo"", 1L, readReferenceExpirationData.readPurgeLessThanEqualTo()); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(""purgedLessThanEqualTo"", 0L, readReferenceExpirationData.readPurgeLessThanEqualTo()); testMeta.timeBucketAssigner.teardown(); testMeta.timeBucketAssigner.getReferenceInstant().setMillis(-1); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(""purgedLessThanEqualTo"", 0L, readReferenceExpirationData.readPurgeLessThanEqualTo()); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Delete ____TS method name tells story'
The code is: 'public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(""Typical successful case when feedback participant is a team""); <END> FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }'","public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }","1- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); ____TEAM_TS_CASE_SENSITIVE(""Typical successful case when feedback participant is a team""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }
2- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); TypicalSuccessfulCaseWhenFeedbackParticipantIsATeam(); gaeSimulation.loginAsInstructor(); }
3- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); ______TS(""Typical succeeding case when feedback participant is a team""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Student:John Doe""; String receiverEmail = ""Student:Bob Smith""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }
4- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); TypicalSuccessfulCaseWhenFeedbackParticipantIsASteam(); }
5- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); TypicalSuccessCase(""Delete comment for team""); }
6- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); TypicalCaseWhenFeedbackParticipantIsATeam(); }
7- public void testDeleteActionForTeamAsFeedbackParticipant() { assertTrue(getFeedbackSessionNameForTestInCourseOneExists(""First Session"")); assertTrue(getCourseForFeedbackSession(""First Session"").getId().equals(Const.WindowParamsNames.COURSE_INSTRUCTOR_COURSE_ID)); prepareTestData(); ______TS(""Typical successful case when feedback participant is a team""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = TEAM1_LEADER_EMAIL; String receiverEmail = TEAM2_LEADER_EMAIL; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver,
8- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); ______FS(""Typical successful case when feedback participant is a team""); FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(""First Session"", ""idOfCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsUser(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals("""", result.getStatusMessage()); }
9- public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); Integer questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(TEST_SESSION_NAME, ""questionNumberInCourse1"", questionNumber); String giverEmail = ""Team 1.1</td></div>'\""""; String receiverEmail = ""Team 2.1</td></div>'\""""; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(""comment1FromTeam1""); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(""response comment not found"", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(""student1InCourse1""); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + "" (Edited)"", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertTrue(data.isError); assertEquals(HttpStatus.SC_NOT_FOUND, result.getStatus()); }
10- public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); TypicalSuccessfulCaseWhenFeedbackParticipantIsASteam(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line removed. pass I guess this is covered test, write a quick John'
The code is: 'public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); <START> left = leftRS.next(); <END> currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }'","public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }","1- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) { left = leftRS.next().getClone(); } else { TransferPair ltp = leftRS.next(); left.addLeftTransferPair(ltp); left = ltp.getRight(); } currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (!mergeJoinOperation.getRestriction().apply(currentExecRow)) { if (mergeJoinOperation.getJoinStrategy().equals( JoinStrategy.HYBRID_STRATEGY) || mergeJoinOperation.getJoinStrategy().equals( JoinStrategy.HYBRID_OBJECT_STRATEGY)) { return false; } else { return foundNextRow = true; } } operationContext.recordFilter(); } if (!foundNextRow) { currentExecRow = mergeRows(left, null); return foundNextRow = true; } } } catch (Exception e) { throw new RuntimeException(e); } return foundNextRow = false; }
2- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
3- public Boolean internalHasNext() { try { for (; left == null ;) { if (leftRS.hasNext()) { left = leftRS.next().clone(); } else { return false; } currentRightIterator = rightsForLeft(left); if (isReturnedRow()) { return true; } } for (; currentRightIterator.hasNext() ;) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { mergeJoinState.progressAndInvert(); return true; } mergeJoinState.reset(); operationContext.recordFilter(); } if (mergeJoinState.reset()) { left = null; return false; } } catch (Exception e) { throw new RuntimeException(e); } }
4- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = nextSource(left); if (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { return true; } operationContext.recordFilter(); } else { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
5- public Boolean internalHasNext() { try { final Object result = left.getNewValue(); if (result == null ||!resultsMatch(result, left)) { setNewValueAndNext(false); } currentRightIterator = rightsForLeft(left); return currentRightIterator.hasNext(); } catch (Exception e) { throw new RuntimeException(e); } }
6- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); left = leftRS.next(); currentRightIterator = rightsForLeft(left); if (currentRightIterator.hasNext()) { while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { return true; } operationContext.recordFilter(); } return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
7- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
8- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); if (currentRightIterator == null) currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
9- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); Boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }
10- public Boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); if (left == null) { left = leftRS.next().getClone(); } while (left!= null &&!left.getRow()[left.getRowOffset()].equals(null)) { if (!currentExecRow.hasSchema()) currentExecRow = null; operationContext.recordFilter(); } return (getNext())? true : false; } throw new RuntimeException(""We should never be here""); } catch (Exception e) { throw new RuntimeException(e); } }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Fix indentation. Also, is this change for'
The code is: 'public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } <START> @Override <END> public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }'","public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }","1- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return sharedData; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
2- public void setUp() throws Exception { configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return sharedData; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return metricRegistry; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
3- public void setUp() throws Exception { configuration = UTIL.getConfiguration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return metricRegistry; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
4- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getMetricRegistry() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
5- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws Exception { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws Exception { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskEndPonitDataEndpoint = new TaskEndPointDataEndpoint(); taskEndPonitDataEndpoint.start(environment); }
6- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable(TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint() { @Override public synchronized void onStateChange(final boolean online) { if (!online) { return; } try { setMetricRegistryStatus(getCurrentMetadataContext().getCurrentClientStats().getMetricRegistry()); } catch (IOException e) { log.error(""Failed to get the local client's MetricRegistry"", e); setMetricRegistryStatus(null); return; } } @Override public synchronized void taskDone(final TDescriptor descriptor) { for (int i=0; i<delegates.length; i++) { delegates[i].taskDone(descriptor); } } @Override public void init() { delegates = new Pair[][] { new Pair[] { new Pair(metricsRegionContextClient.getClientMetricRegistries().get(0).getClientContext(), region.getRegionLocator()), new Pair(metricsRegionContextClient.getClientMetricRegistries().get(1).getClientContext(), region.getRegionLocator()) }, new Pair[] { getCurrentMetadataContext().getClientStats(), new Pair(getCurrentMetadataContext().getClientStats(), getCurrentMetadataContext().getNewestClientStats()) }, }; } }; taskMetaDataEndpoint.start(environment); }
7- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public RegionCoprocessorEnvironment getHBaseRegionCoprocessorEnvironment() { return environment; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable(TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
8- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getResourceManagerMetrics() { return null; } @Override public void setResourceManagerMetrics(MetricRegistry registry) { } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
9- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public Long getVersion() { return 0L; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public Long getPriority() { return 0L; } @Override public Long getLoadSequence() { return 0L; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable(TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }
10- public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public long getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public long getPriority() { return 0; } @Override public long getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'param a line'
The code is: 'public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), <START> aggregation.isDistinct(), aggregation.getMask())); <END> } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }'","public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<VariableReferenceExpression, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<VariableReferenceExpression, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedVariables(), node.getStep(), node.getHashVariable(), node.getGroupIdVariable())); }","1- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), aggregation.getMask(), aggregation.isDistinct(), aggregation.getOrderBy())); } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
2- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrdering().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); } } if (!aggregations.build().isEmpty()) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
3- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask(), aggregation.getHashSymbol())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
4- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask(), aggregation.getHashSymbol())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
5- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); boolean anyRewritten = false; for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
6- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } } if (!aggregations.isEmpty()) { return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); } return Result.empty(); }
7- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
8- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else { aggregations.put(entry, new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (!aggregations.build().keySet().stream().anyMatch(aggregations.entrySet().stream().filter(e ->!e.getValue().getOrderBy().isPresent()).map(Map.Entry::getKey).collect(Collectors.toSet()))) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
9- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation( aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }
10- public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } Boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isSortSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.isNotDistinct(), aggregation.getMask())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this active instance'
The code is: 'protected long run() { <START> Jenkins.getActiveInstance().checkPermission(Jenkins.ADMINISTER); <END> System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }'","protected long run() { Jenkins.get().checkPermission(Jenkins.ADMINISTER); System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }","1- protected long run() { Jenkins jenkins = Jenkins.getInstance(); if (jenkins!= null && jenkins.getPrimary()!= null) { jenkins.checkPermission(Jenkins.ADMINISTER); } else { Jenkins.getActiveInstance().checkPermission(Jenkins.ADMINISTER); } System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }
2- protected long run() { Jenkins jenkins = Jenkins.get(); jenkins.checkPermission(Jenkins.ADMINISTER); System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }
3- protected long run() { Jenkins jenkins = Jenkins.getActiveInstance(); assert jenkins!= null; jenkins.checkPermission(Jenkins.ADMINISTER); String term = System.getProperty(""jline.terminal""); if (""auto"".equals(term)) term = UnsupportedTerminal.class.getName(); else term = term + "".class""; TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr, term); return shell.run(commandLine.toString()); }
4- protected long run() throws Interrupt { Jenkins jenkins = Jenkins.getActiveInstance(); if (jenkins!= null) { jenkins.checkPermission(Jenkins.ADMINISTER); } System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }
5- protected long run() { Jenkins instance = Jenkins.getInstance(); if (instance == null) { throw new IllegalStateException(); } instance.checkPermission(Jenkins.ADMINISTER); System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }
6- protected long run() { Jenkins jenkins = Jenkins.getActiveInstance(); if (jenkins!= null) { jenkins.checkPermission(Jenkins.ADMINISTER); System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); } StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Terminal terminal = jenkins == null? null : jenkins.makeTerminal(); Groovysh shell = createShell(terminal!= null? terminal.getReadStream() : null, terminal!= null? terminal.getWriteStream() : null, terminal!= null? terminal.getErrorStream() : null); return shell.run(commandLine.toString()); }
7- protected long run() { Jenkins jenkins = Jenkins.getInstance(); if (jenkins!=null && jenkins.checkPermission(Jenkins.ADMINISTER)) { System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdout, stderr); return shell.run(commandLine.toString()); } else { throw new SecurityException(""Not authorized to run this job""); } }
8- protected long run() { Jenkins jenkins = Jenkins.getActiveInstance(); jenkins.checkPermission(Jenkins.ADMINISTER); System.setProperty(""jline.terminal"", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append("" ""); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }
9- protected long run() throws Exception { Jenkins.getDescriptor(Jenkins.class).run(); return jlineShell.run(); }
10- protected long run() { Jenkins j = Jenkins.getInstance(); checkPermission(j, ""JENKINS-ADMINISTER""); String script = createTtyShellAsString(stdin, stdout, stderr); return j.scriptFromString(script, ""stdin"", stdout, 0, stderr); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Same. strings refactoring friendly. Lets address this'
The code is: 'public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; <START> ReflectionTestUtils.setField(service, ""bucketPoolSize"", bucketPoolSize); <END> ReflectionTestUtils.setField(service, ""bucketKeySize"", bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }'","public void verify_fallback_in_download_presigned_urls() throws Exception { val firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; namingService.setBucketPoolSize(bucketPoolSize); namingService.setBucketKeySize(bucketKeySize); val urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); val parts = ObjectDownloadServiceStubFactory.createParts(5); val os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); val sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); val p = objSpec.getParts().get(0); val url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } val bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(objectBucketName, bucket); System.out.println(); }","1- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, ""AmazonS3Client"", Mockito.mock(AmazonS3Client.class)); ObjectURLGenerator urlGen = Mockito.mock(ObjectURLGenerator.class); ReflectionTestUtils.setField(urlGen, ""s3Client"", AmazonS3ClientFactory.create(""https://rdos-region-"" + endpointUrl + "".amazonaws.com/"")); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }
2- @Test public void verify_fallback_in_download_presigned_urls() { Integer bucketPoolSize = 10000; Integer bucketPoolSizeGW = 100; Integer clientKeySize = 1024; ReflectionTestUtils.setPrivateField(service, ""bucketPoolSize"", bucketPoolSize); ReflectionTestUtils.setPublicStaticFinalField(service, ""bucketPoolSizeGW"", bucketPoolSizeGW); ReflectionTestUtils.setPrivateField(service, ""clientKeySize"", clientKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setPrivateField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setPublicStaticFinalField(urlGen, ""s3ClientPoolSizeGW"", bucketPoolSizeGW); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(100); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); when(s3Client.getObject(anyInt())).thenThrow(new AmazonServiceException(""Didn't find Object Id in bucket"")); doReturn(os).when(sut).getSpecification(objectId); ObjectDownloadServiceStubFactory.createFakeObjectSpec(objectId, 104857600); ObjectDownloadS3 s3 = create(""http://localhost:12345/bucket/path/1"", sut, defaultCredentials(""testClient"", ObjectDownloadTest.class.getResource(""/AWSAccessKey.txt"").getFile()), ""/12345/abc?q=a&b=b""); assertEquals(ObjectDownloadS3.Parts.PRESIGNED_URL_PARAMETERS, s3.parts); final HttpClient httpClient = new DefaultHttpClient(); final HttpHost httpHost = (HttpHost) new URI(""/12345/abc?q=a&b=b"").toUri().getHost(); assertEquals(ObjectDownloadS3.PRESIGNED_URL_PARAMETERS, httpHost); }
3- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, METADATA_KEYS_SIZE, bucketKeySize); ReflectionTestUtils.setField(service, STRING_BUCKET_SIZE, bucketPoolSize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, HOST_SUFFIX, ENDPOINT_SUFFIX); ReflectionTestUtils.setField(service, UrlGenerator::new, urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = PartsTestData.createParts(5); ObjectSpecification os = PartsTestData.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); }
4- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = BucketPoolSize; Integer bucketKeySize = BucketKeySize; ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, BucketPoolSize, bucketPoolSize); ReflectionTestUtils.setField(urlGen, BucketKeySize, bucketKeySize); ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl); ObjectDownloadService service = spy(ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); assertEquals(bucketPoolSize, service.getBucketPoolSize()); assertEquals(bucketKeySize, service.getBucketKeySize()); doReturn(objSpec).when(service).returnObjectSpec(eq(objectId)); val objSpec = service.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertSame(dataBucketName, bucket); assertTrue(objSpec.rellocate); }
5- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; String path = ""/""; ReflectionTestUtils.setField(service, ""path"", path); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ReflectionTestUtils.setField(service, ""path"", ""/home""); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(path, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } assertEquals(dataBucketName, path); ReflectionTestUtils.setField(service, ""path"", ""/home""); }
6- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; Integer defaultBucketKeySizeInBytes = 64; DefaultBucketUtils defaultBucketUtils = mockDefaultBucketUtils(); ReflectionTestUtils.setField(defaultBucketUtils, ""bucketPoolSize"", bucketPoolSize); ReflectionTestUtils.setField(defaultBucketUtils, ""defaultBucketSize"", 64); ReflectionTestUtils.setField(service, ""s3Client"", mockedS3Client); ReflectionTestUtils.setField(service, ""urlGenerator"", new AmazonURLGenerator()); ReflectionTestUtils.setField(service, ""defaultBucketUtils"", defaultBucketUtils); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); DefaultBucketUtils.setDefaultBucketSize(defaultBucketSize); verify(s3Client).getObject(Matchers.any()); }
7- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, BUCKET_POOL_SIZE, bucketPoolSize); ReflectionTestUtils.setField(service, BUCKET_KEY_SIZE, bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, s3Client, ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, urlGenerator, urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); }
8- public void verify_fallback_in_download_presigned_urls() throws Exception { Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, ""bucketPoolSize"", bucketPoolSize); ReflectionTestUtils.setField(service, ""bucketKeySize"", bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(new AmazonServiceException(""Didn't find Object Id in bucket"")); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }
9- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, ""bucketPoolSize"", bucketPoolSize); ReflectionTestUtils.setField(service, ""bucketKeySize"", bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, ""s3Client"", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, ""urlGenerator"", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); assertEquals(""Presigned URL didn't contain bucket when fallback option was enabled"", bucket, url.getPath()); }
10- public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(""Didn't find Object Id in bucket""); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); Integer bucketPoolSize = 32; Integer bucketKeySize = 2; ReflectionTestUtils.setField(service, S3_BUCKET_POOL_SIZE, bucketPoolSize); ReflectionTestUtils.setField(service, S3_BUCKET_KEY_SIZE, bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, S3_CLIENT, ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, S3_URL_GENERATOR, urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(""/"")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a command line app -- print STDOUT (or STDERR if a warning etc)'
The code is: 'protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) <START> bracketedOutput = false; <END> else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }'","protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) bracketedOutput = false; else { if (new File(args[current]).exists()) { System.out.println(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); System.out.println(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }","1- protected long processArgument(String[] args, int current) throws UnsupportedCliOptionException { if (args[current].equals(""-c"")) { bracketedOutput = false; } else { if (new File(args[current]).exists()) logger.info(""Loading properties from {}: {}"", args[current], System.currentTimeMillis()); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties.""); } return current++; }
2- protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"") || args[current].equals(""--config"")) { if (args[current + 1].equals(""--no-bracketed-output"")) { bracketedOutput = false; } else { if (new File(args[current + 1]).exists()) { logger.info(""Loading properties from "" + args[current + 1]); this.resourceManager = new ResourceManager(args[current + 1]); logger.info(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current + 1] + ""\"" did not exist.""); } return current += 2; } return current; }
3- protected void processArgument(String[] args, int current) throws Exception { CommandLineOption cmdLineOption = CommandLineOption.valueOf(args[current], args); switch (cmdLineOption) { case HOST_PORT: hostPort = Integer.parseInt(args[current + 1]); break; case BRAcketED_OUTPUT: bracketedOutput = true; break; case RESOURCE_FILE: resourcePath = args[current + 1]; break; default: throw new IllegalStateException(""Unknown option "" + cmdLineOption.asMetadata()); } current++; }
4- protected void processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) { bracketedOutput = false; } else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }
5- protected static void processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) { bracketedOutput = false; } else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); } else { logger.info(""No properties available. Using default locations.""); } } current++; }
6- protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) { logger.info(""Loading configuration from '"" + args[current] + ""'.""); this.resourceManager = loadConfiguration(args[current]); } else { if (new File(args[current]).exists()) { ResourceManager resManager = new ResourceManager(args[current]); logger.info(""Completed loading configuration from "" + resManager.getPath()); } else throw new RuntimeException(""The configuration file '"" + args[current] + ""' does not exist.""); } return current++; }
7- protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-config"")) bracketedOutput = false; else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }
8- protected long processArgument(String[] args, int current) throws Exception { if (args[current].startsWith(""--bracketedOutput"")) bracketedOutput = true; else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }
9- public static void main(String[] args) { PropertySourceConfig config = new PropertySourceConfig(); for (String arg : args) { config.set(arg, true); } System.out.println(config); }
10- protected long processArgument(String[] args, int current) throws Exception { if (args[current].equals(""-c"")) { bracketedOutput =!bracketedOutput; current++; } else { if (new File(args[current]).exists()) { logger.info(""Loading properties from "" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(""Completed loading properties.""); } else throw new RuntimeException(""The configuration file \"""" + args[current] + ""\"" did not exist.""); } return current++; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please split this lines avoid long lines in code? java final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate);'
The code is: 'public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final BaseGridRendererHelper.RenderingInformation ri = rendererHelper.getRenderingInformation(); <START> final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(rendererHelper.getColumnOffset(this) + this.getWidth() / 2); <END> final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ri, ci, uiHeaderRowIndex); headerMetaData.edit(context); }'","public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final BaseGridRendererHelper.RenderingInformation ri = rendererHelper.getRenderingInformation(); final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ri, ci, uiHeaderRowIndex); headerMetaData.edit(context); }","1- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation columnInformation = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, rendererHelper, columnInformation, uiHeaderRowIndex); headerMetaData.edit(context); }
2- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); headerMetaData.edit(this.gridWidget, ri, ci, uiHeaderRowIndex); }
3- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(rendererHelper.getColumnOffset(this) + this.getWidth() / 2); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, rendererHelper, ci, uiHeaderRowIndex); headerMetaData.edit(context); } }
4- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation columnInformation = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, rendererHelper, columnInformation, uiHeaderRowIndex); headerMetaData.edit(context); }
5- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final long columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final BaseGridRendererHelper.RenderingInformation ri = rendererHelper.getRenderingInformation(); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ri, ci, uiHeaderRowIndex); headerMetaData.edit(context); }
6- public void startEditingHeaderCell(final long uiHeaderRowIndex) { EditableHeaderEditableControl.checkEditableHeader(gridWidget, this); if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = handleEditableHeader(gridWidget, headerMetaData, new GridBodyCellEditContext()); headerMetaData.acceptHeader(context); }
7- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeEditingContext(gridWidget, ci, headerMetaData, uiHeaderRowIndex); headerMetaData.edit(context); }
8- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext( gridWidget, ci, headerMetaData, uiHeaderRowIndex); headerMetaData.edit(context); }
9- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final double columnHorizontalOffset = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation columnInformation = rendererHelper.getColumnInformation(columnHorizontalOffset); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, rendererHelper, columnInformation, uiHeaderRowIndex); headerMetaData.edit(context); }
10- public void startEditingHeaderCell(final long uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final int columnIndex = gridWidget.getColumnIndex(this); final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() / 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ci, headerMetaData); headerMetaData.edit(context); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'missing checkValidPosition(positionCount, position); below'
The code is: 'public Block copyPositions(Integer[] positions, Integer offset, Integer length) { <START> checkValidPositionsArray(positions, offset, length); <END> IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }'","public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkArrayRange(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }","1- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositions(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
2- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionsArray(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer oldIndex = positions[offset + i]; Integer newIndex = oldToNewIndex.computeIfAbsent(oldIndex, k -> positionsToCopy.size()); checkValidPosition(offset + i, oldIndex, newIndex, new Integer[] { newIndex }); positionsToCopy.add(newIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
3- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { if (positions.length!= length + offset) { throw new IllegalArgumentException(""Arrays length does not match.""); } checkValidPositionsArray(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); for (Integer i = 0; i < length + offset; i++) { Integer position = positions[i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
4- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositions(positionCount, position); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexPositionToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer oldIndex = positionOffsets[offset + i]; Integer oldPositionIndex = getPositionIndex(oldIndex); if (!oldIndexPositionToNewIndex.containsKey(oldPositionIndex)) { oldIndexPositionToNewIndex.put(oldPositionIndex, positionsToCopy.size()); positionsToCopy.add(oldPositionIndex); } newIds[i] = positionToNewIdx[oldPositionIndex]; } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
5- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionsArray(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIdToNewIndex = new HashMap<Integer, Integer>(); Integer[] newIds = new Integer[length]; for (Integer id : positions) { Integer previousPosition = getId(id); if (!oldIdToNewIndex.containsKey(previousPosition)) { oldIdToNewIndex.put(previousPosition, positionsToCopy.size()); positionsToCopy.add(previousPosition); } newIds[id - offset] = oldIdToNewIndex.get(previousPosition); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
6- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionsArray(positions, offset, length); checkValidPositionCount(length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldPositionToNewPosition = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; Boolean foundIndex = oldPositionToNewPosition.put(position, newIds[i]); if (foundIndex) { throw new IllegalArgumentException(""Expected new positions to be sorted. This position was present in the old positions.""); } } newIds = arrayOffset(newIds); return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
7- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionCount(positions.length, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; int oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } int newId = oldIndexToNewIndex.get(oldIndex); setId(position, newId); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), length); }
8- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionCount(positions.length, length, offset); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); Integer[] newIds = new Integer[length]; for (Integer i = 0; i < length; i++) { Integer position = positions[offset + i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
9- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkCapacity(length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); int[] newIds = new int[length]; for (Integer i = 0; i < Math.min(positions.length, length); i++) { Integer position = positions[offset + i]; Integer oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }
10- public Block copyPositions(Integer[] positions, Integer offset, Integer length) { checkValidPositionCount(length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexesToNewIndexes = new HashMap<>(); for (Integer oldPosition : positions) { Integer newId = oldIndexesToNewIndexes.computeIfAbsent(oldPosition, key -> { checkValidPosition(oldPosition, offset, offset + length); checkValidPositionsArray(oldPosition, offset, offset + length); return getIdPosition(oldPosition); }); positionsToCopy.add(newId); oldIndexesToNewIndexes.put(oldPosition, newId); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), oldIndexesToNewIndexes); }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null == adapter'
The code is: 'public Adapter getContentAdapter() { if <START> (adapter == null) { <END> adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }'",public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; },"1- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
2- public Adapter getContentAdapter() { if (null!= adapter) { return adapter; } adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; return adapter; }
3- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
4- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
5- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
6- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
7- public Adapter getContentAdapter() { if (adapter == null) { if (null == adapter) { display.addListener(SWT.MouseWheel, e -> { if (!isEnabled()) { return; } String value = String.valueOf(getSelection() + 1); if (value.endsWith(""0"")) { value = value.substring(0, value.length() - 1); } if (value.endsWith(""1"")) { value = value.substring(0, value.length() - 1); } if (value.endsWith(""2"")) { value = value.substring(0, value.length() - 1); } if (value.endsWith(""3"")) { value = value.substring(0, value.length() - 1); } if (value.endsWith(""4"")) { value = value.substring(0, value.length() - 1); } changeSort(Integer.parseInt(value)); refreshChildren(); }); return; } } return adapter; }
8- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
9- public Adapter getContentAdapter() { if (null!= adapter) { return adapter; } if (isExpandedChildren()) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }
10- public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { Integer type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add this populate'
The code is: 'public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; <START> case MIStrings.SNAPSHOT_DATA_URL: <END> break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }'","public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }","1- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; case LTTngControlServiceConstants.TRACE_NETWORK_PATTERN: snapshotInfo.setStreamedSnapshot(true); break; default: break; } } } return snapshotInfo; }
2- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotUrl(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_DATA_URL: break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotUrl()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
3- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); case MIStrings.BINARY_SNAPSHOT_URL: snapshotInfo.setBinarySnapshotFile(rawInfo.getTextContent()); break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
4- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_OUTPUT_TYPE: snapshotInfo.setSnapshotOutputType(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_DATA_URL: break; case MIStrings.EVENT_SNAPSHOT_URL: break; case MIStrings.SYNCHRONIZATION_SNAPSHOT_URL: break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
5- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotControlUrl(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_DATA_URL: break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
6- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { ICommandResult result = executeCommand( LTTngControlServiceConstants.COMMAND_SYSTEM_GET, null); return convertToSnapshotInfo(result.getOutput().getChildNodes()); }
7- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; case MIStrings.BROACH_SNAPSHOT_OUTPUTS: break; case MIStrings.BROACH_NETWORK_ID: break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
8- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_DATA_URL: snapshotInfo.setDataPath(rawInfo.getTextContent()); if (snapshotInfo.isStreamedSnapshot()) { IStreamingTrace streamedTrace = LTTngControlServiceFactory.getFactory().createStreamingTrace(snapshotInfo.getSnapshotPath(), LTTngControlServiceConstants.CORE_MODE); streamedTrace.delete(); } break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
9- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_DATA_URL: snapshotInfo.setSnapshotDataUrl(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_STREAMED: snapshotInfo.setStreamedSnapshot(true); break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }
10- public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(""""); for (Integer i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (Integer j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.TRACE_URL: snapshotInfo.setUrl(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; default: break; } if (Strings.isNullOrEmpty(snapshotInfo.getSnapshotPath())) { snapshotInfo.setUrl(null); } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again, assertNotNull more readable'
The code is: 'public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); <START> assertNotEquals(null, typedId); <END> assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }'","public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }","1- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
2- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
3- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
4- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(typedId, new TypedId(""string"", ""string"")); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(typedId.value, typedId.type, confidenceLevel)); }
5- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(""expected typedId not to be null"", typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
6- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
7- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId1 = new TypedId(value, type, confidenceLevel); TypedId typedId2 = new TypedId(value, type, confidenceLevel); assertNotEquals(typedId1, typedId2); assertNotEquals(null, typedId1); assertNotEquals(""string"", typedId1); assertNotEquals(typedId1, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId1, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId1, new TypedId(value, type, 0.8f)); assertEquals(typedId1, new TypedId(value, type, confidenceLevel)); assertNotEquals(typedId1, new TypedId(value2, type, confidenceLevel)); assertEquals(typedId1, new TypedId(value, type, confidenceLevel)); assertNotEquals(typedId1, new TypedId(value, type, 0.8f)); }
8- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
9- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(null, typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }
10- public void testEquals() { String value = ""someValue""; String type = ""someType""; Float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(""string"", typedId); assertNotEquals(typedId, new TypedId(""otherValue"", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, ""otherType"", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }",1
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'
The code is: 'nan'",nan,"1- public void testRejectAfterRequest() { <START> assertTrue(false); <END> }' public void testRejectAfterRequest() throws Exception { assertTrue(isRejected()); }
2- public String toString() { ObjectMapper mapper = new ObjectMapper(); <START> return mapper.writeValueAsString(this); <END> }' @Override public String toString() { return getClass().getSimpleName() + "" {x:"" + x + "", y:"" + y + "", width:"" + width + "", height:"" + height; }
3- + public double getPercent() { if (getTotal() == -1) { <START> return 0.0; <END> } return percent(getTotal())/100.0; }' public double getPercent() { if (getTotal() == 0) { return 0.0; } return percent(getTotal())/100.0; }
4- public long getExpirationInMs() { <START> return 0; <END> }' public long getExpirationInMs() { return new Long(expirationInMs).longValue(); }
5- private int getNumeric() { <START> return getInt() == 0? 0 : getInt(); <END> }' private int getNumeric() { return getInt() == 0? Double.NaN : getInt(); }
6- public double getPercentage() { <START> return 0.; <END> }' public double getPercentage() { return 0; }
7- static final Sphere.Builder fBuilder = new Sphere.Builder() { <START> @Override public void reset() {} <END> @Override public boolean hasValuesChanged() { return Sphere.this.hasValuesChanged(); } };
8- protected Object parseValue() { <START> return null; <END> }' public Object parseValue() { return null; }
9- public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch(args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; ++i) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }' public static void main(String[] args) { boolean test = true; int loop = 5; if (args.length > 0) switch (args[0]) { case ""--debug"": test = false; } for (int i = 0; i < loop; i++) { final Thread t = new Thread(new Runnable() { @Override public void run() { print(""i="" + i + "": "" + ""hello""); } }); t.setName(loop + "":"" + i); t.start(); t.join(); } }
10- void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); <START> if (result.get(doc.getType())==null) { <END> result.put(doc.getType(),Collections.emptyMap()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(),null); } }' public void remove(@BoundQuery<T> query, DocumentModel doc) { if (!query.matches(doc)) { return; } List<Integer> subTypes = getMatchingSubTypes(doc.getType(), query); if (subTypes.isEmpty()) { return; } Map<Integer, Map<Integer, DocumentModel>> result = getResult(query, true); if (result.get(doc.getType()) == null) { result.put(doc.getType(), new HashMap<Integer, DocumentModel>()); } if (!result.get(doc.getType()).containsKey(doc.getPath())) { result.get(doc.getType()).put(doc.getPath(), null); } else { result.get(doc.getType()).remove(doc.getPath()); } for (Integer subType : subTypes) { result.remove(subType); } for (Entry<Integer, Map<Integer, DocumentModel>> entry : result.entrySet()) { getSubSel(query, doc.getType(), entry.getValue().keySet().iterator(), subTypes); } }",0
