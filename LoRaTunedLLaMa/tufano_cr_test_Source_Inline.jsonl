{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return NULL, throw UnsupportedOperatedException instead'\nThe code is: 'public Request iterate(final Request req, final Coordinates cords) { <START> return null; <END> \/\/ return NULL, throw UnsupportedOperatedException instead }'","output":"public Request iterate(final Request req, final Coordinates cords) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: unnecessary generic type declaration'\nThe code is: '<START> public static <T> void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { <END> \/\/ nit: unnecessary generic type declaration for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }'","output":"public static void handleBulkWriteError(List<BulkWriteError> errors,String op,GetCB cb) { for (BulkWriteError e : errors) { cb.getCtx(e.getIndex()).addError(getError(e,op)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'premature, if in usage validateLocksOnReads is false, flipping arguments sense'\nThe code is: 'private boolean isValidationNecessaryOnReads(TableReference tableRef) { <START> return isValidationNecessary(tableRef) && validateLocksOnReads; <END> \/\/ premature, if in usage validateLocksOnReads is false, flipping arguments sense }'","output":"private boolean isValidationNecessaryOnReads(TableReference tableRef) { return validateLocksOnReads && isValidationNecessary(tableRef); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I return true. fall return false, instead of creating a variable'\nThe code is: 'protected boolean isAnyAppConfiguredInSourceServerXml() { boolean bConfigured = false; Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(\"Application configuration is found in server.xml.\"); <START> bConfigured = true; <END> \/\/ I return true. fall return false, instead of creating a variable } return bConfigured; }'","output":"protected boolean isAnyAppConfiguredInSourceServerXml() { Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.size() > 0) { log.debug(\"Application configuration is found in server.xml.\"); return true; } else { return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.redisTemplate'\nThe code is: 'public void put(String key, String value) { Assert.notNull(key, \"'key' must not be null.\"); Assert.notNull(value, \"'value' must not be null.\"); <START> BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key); <END> \/\/ this.redisTemplate ops.set(value); }'","output":"public void put(String key, String value) { Assert.notNull(key, \"'key' must not be null.\"); Assert.notNull(value, \"'value' must not be null.\"); BoundValueOperations<String, String> ops = this.redisTemplate.boundValueOps(key); ops.set(value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I assume this meant removed'\nThe code is: 'public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(\"Launch batch job (makeUnique=false) twice\"); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\"); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(\"job launch --name \" + MY_JOB); <START> System.out.println(\"*************************\" + result.getException().getMessage()); <END> \/\/ I assume this meant removed assertThat( result.getException().getMessage(), containsString(\"A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters.\")); }'","output":"public void testLaunchJobTwiceWhereMakeUniqueIsFalse() { logger.info(\"Launch batch job (makeUnique=false) twice\"); executeJobCreate(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\"); checkForJobInList(MY_JOB, JOB_WITH_PARAMETERS_DESCRIPTOR + \" --makeUnique=false\", true); executeJobLaunch(MY_JOB); CommandResult result = executeCommandExpectingFailure(\"job launch --name \" + MY_JOB); assertThat( result.getException().getMessage(), containsString(\"A job instance already exists and is complete for parameters={}. If you want to run this job again, change the parameters.\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is a null check for passed in \"date\" required for safety'\nThe code is: 'public static Date parseDate(String date, String format) { <START> return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); <END> \/\/ Is a null check for passed in \"date\" required for safety }'","output":"public static Date parseDate(String date, String format) { if (date == null) { return null; } return parseDate(date, new SimpleDateFormat(format, Locale.getDefault())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'numberOfVotes null replace this Objects.equals(numberOfVotes, other.numberOfVotes)'\nThe code is: 'public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; <START> return type.equals(other.type) && value == other.value && numberOfVotes.equals(other.numberOfVotes); <END> \/\/ numberOfVotes null replace this Objects.equals(numberOfVotes, other.numberOfVotes) } return false; }'","output":"public boolean equals(Object that) { if (this == that) { return true; } if (that instanceof Rating) { Rating other = (Rating) that; return type.equals(other.type) && value == other.value && Objects.equals(numberOfVotes, other.numberOfVotes); } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a duplication me. this.json().getString(\"name\")'\nThe code is: 'public String name() { <START> return Json.createReader(new StringReader(this.obj)) <END> \/\/ a duplication me. this.json().getString(\"name\") .readObject() .getString(\"name\"); }'","output":"public String name() { return this.json().getString(\"name\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Serranya here. above'\nThe code is: 'public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(\"Stream returnsCorrectInput!\").asBytes(); MatcherAssert.assertThat( <START> \"Stream doesn't provide correct bytes\", <END> \/\/ @Serranya here. above new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }'","output":"public void returnsCorrectInputWithStream() throws Exception { final byte[] bytes = new Utf8String(\"Stream returnsCorrectInput!\").asBytes(); MatcherAssert.assertThat( \"Body content of Body.Stream doesn't provide the correct bytes\", new BytesOf( new Body.Stream(new InputOf(bytes).stream()) ).asBytes(), new IsEqual<>(bytes) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'SetSpecialDays tested E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE'\nThe code is: 'public void theSetSpecialDaysRequestIsReceived() throws Throwable { <START> PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_G_LABEL, this.deviceId.getDeviceIdG()); <END> \/\/ SetSpecialDays tested E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }'","output":"public void theSetSpecialDaysRequestIsReceived() throws Throwable { PROPERTIES_MAP.put(DEVICE_IDENTIFICATION_E_LABEL, this.deviceId.getDeviceIdE()); PROPERTIES_MAP.put(ORGANISATION_IDENTIFICATION_LABEL, this.organisationId.getOrganisationId()); this.RequestRunner(PROPERTIES_MAP, TEST_CASE_NAME_REQUEST, TEST_CASE_XML, TEST_SUITE_XML); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Put test in package (not directory) package private protected'\nThe code is: '<START> public static Map<String, String> getInputFiles(String descriptorAbsolutePath) { <END> \/\/ Put test in package (not directory) package private protected WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, \"Problem parsing WDL file: \" + ex.getMessage(), API_ERROR); } return wdlInputs; }'","output":"static Map<String, String> getInputFiles(String descriptorAbsolutePath) { WdlBridge wdlBridge = new WdlBridge(); Map<String, String> wdlInputs = null; try { wdlInputs = wdlBridge.getInputFiles(descriptorAbsolutePath); } catch (WdlParser.SyntaxError ex) { exceptionMessage(ex, \"Problem parsing WDL file: \" + ex.getMessage(), API_ERROR); } return wdlInputs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion Objects.requireNonNull(filter, \"filter null\");'\nThe code is: 'public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { <START> Objects.requireNonNull(filter, \"filter\"); <END> \/\/ suggestion Objects.requireNonNull(filter, \"filter null\"); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }'","output":"public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader) { Objects.requireNonNull(filter, \"filter cannot be null\"); return filter.accept(new RowGroupFilter(levels, blocks, reader)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove cast'\nThe code is: 'public void setLibraryAliasGenerator(NameGenerator<Library> generator) { <START> this.libraryAliasGenerator = (DefaultLibraryAliasGenerator) generator; <END> \/\/ Remove cast }'","output":"public void setLibraryAliasGenerator(NameGenerator<Library> generator) { this.libraryAliasGenerator = generator; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reason for this change? want people setFields change fields, good practice return unmodifableSet here'\nThe code is: 'public Set<Field> getFields() { <START> return fields.keySet(); <END> \/\/ reason for this change? want people setFields change fields, good practice return unmodifableSet here }'","output":"public Set<Field> getFields() { return Collections.unmodifiableSet(fields.keySet()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consider replacing 96-97 try block (see line 455)'\nThe code is: 'public static void copy(File source, File dest) throws IOException { <START> try (InputStream in = new FileInputStream(source)) { <END> \/\/ consider replacing 96-97 try block (see line 455) try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } } }'","output":"public static void copy(File source, File dest) throws IOException { try (InputStream in = new FileInputStream(source); OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) { transferData(in, out); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this dataset automatically executed'\nThe code is: 'public void runBeforeAllTests() { conceptService = Context.getConceptService(); <START> executeDataSet(STANDARD_TEST_DATASET_XML); <END> \/\/ this dataset automatically executed }'","output":"public void runBeforeAllTests() { conceptService = Context.getConceptService(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Need remove this leftover debug output'\nThe code is: 'public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); <START> System.out.println(headers.get(name)); <END> \/\/ Need remove this leftover debug output return headers.get(name); }'","output":"public List<String> getHeaders(String name) { MultivaluedMap<String, String> headers = requestContext.getMutableHeaders(); return headers.get(name); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> public ControllerFactory() { <END> \/\/ public }'","output":"private ControllerFactory() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: try avoid string concatenation in log. logger.info(\"Setting Quota mode {}\", mode.name());'\nThe code is: 'public void setQuotaMode(QuotaMode mode) { <START> logger.info(\"Setting Quota mode to \" + mode.name()); <END> \/\/ nit: try avoid string concatenation in log. logger.info(\"Setting Quota mode {}\", mode.name()); this.mode = mode; }'","output":"public void setQuotaMode(QuotaMode mode) { logger.info(\"Setting Quota mode to {}\", mode.name()); this.mode = mode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'match format, do \"Network parameters:\\n \" here'\nThe code is: 'private static void printNetworkParameters(NetworkParams networkParams) { <START> oshi.add(\"Network parameters:\" + networkParams.toString()); <END> \/\/ match format, do \"Network parameters:\\n \" here }'","output":"private static void printNetworkParameters(NetworkParams networkParams) { oshi.add(\"Network parameters:\\n\" + networkParams.toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I if people running locale GERMAN, CHINESE get localized error messages JDK? need check exception type, try change default locale restore test'\nThe code is: 'public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(\"P60000000000000D\"); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); <START> assertThat(e.getMessage(), is(\"Error during type conversion from type: java.time.Duration to the required type: \" + <END> \/\/ I if people running locale GERMAN, CHINESE get localized error messages JDK? need check exception type, try change default locale restore test \"long with value PT1440000000000000H due java.lang.ArithmeticException: long overflow\")); } }'","output":"public void testToMillisOverflow() throws Exception { Duration duration = Duration.parse(\"P60000000000000D\"); try { context.getTypeConverter().convertTo(long.class, duration); } catch (TypeConversionException e) { assertIsInstanceOf(ArithmeticException.class, e.getCause().getCause()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Check for null a defensive copy java this.signature = requireNonNull(signature, \"signature is null\").clone();'\nThe code is: 'public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, \"certificationRequestInfo is null\"); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, \"signatureAlgorithmIdentifier is null\"); <START> this.signature = signature; <END> \/\/ Check for null a defensive copy java this.signature = requireNonNull(signature, \"signature is null\").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }'","output":"public CertificationRequest(CertificationRequestInfo certificationRequestInfo, SignatureAlgorithmIdentifier signatureAlgorithmIdentifier, byte[] signature) { this.certificationRequestInfo = requireNonNull(certificationRequestInfo, \"certificationRequestInfo is null\"); this.signatureAlgorithmIdentifier = requireNonNull(signatureAlgorithmIdentifier, \"signatureAlgorithmIdentifier is null\"); this.signature = requireNonNull(signature, \"signature is null\").clone(); this.encoded = encodeSequence( certificationRequestInfo.getEncoded(), encodeSequence(signatureAlgorithmIdentifier.getEncoded()), encodeBitString(0, signature)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '!Strings.isNullOrEmpty(name)'\nThe code is: 'void setPluginName(String name) { <START> if (!name.isEmpty()) { <END> \/\/ !Strings.isNullOrEmpty(name) this.pluginName = name; } }'","output":"void setPluginName(String name) { if (!Strings.isNullOrEmpty(name)) { this.pluginName = name; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need do this reflective bullshit in a separate artifact'\nThe code is: 'public OracleReturning(RowMapper<ResultType> mapper) { this.mapper = mapper; try { <START> this.oraclePS = Class.forName(\"oracle.jdbc.OraclePreparedStatement\"); <END> \/\/ Do need do this reflective bullshit in a separate artifact this.registerReturnParameter = oraclePS.getMethod(\"registerReturnParameter\", new Class[]{int.class, int.class}); this.getReturnResultSet = oraclePS.getMethod(\"getReturnResultSet\"); } catch (Exception e) { throw new RuntimeException(e); } }'","output":"public OracleReturning(RowMapper<ResultType> mapper) { this.mapper = mapper; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws Exception is dropped rollbackLocks, this code : java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); }'\nThe code is: 'CompletableFuture<Void> getFailureOp(CommitData cd) { <START> return CompletableFuture.supplyAsync(() -> { <END> \/\/ throws Exception is dropped rollbackLocks, this code : java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); } try { rollbackLocks(cd); } catch (Exception e) { throw new CompletionException(e); } return null; }, env.getSharedResources().getSyncCommitExecutor()); }'","output":"CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'removed'\nThe code is: 'public void writeExternal(ObjectOutput out) throws IOException { URI uri = toURI(); try { <START> System.out.println(\"writing \" + uri.toASCIIString()); <END> \/\/ removed out.writeUTF(uri.toASCIIString()); } catch (Exception e) { if (e instanceof IOException) { throw (IOException) e; } throw new IOException(e); } }'","output":"public void writeExternal(ObjectOutput out) throws IOException { URI uri = toURI(); try { out.writeUTF(uri.toASCIIString()); } catch (Exception e) { if (e instanceof IOException) { throw (IOException) e; } throw new IOException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'MethodType.GENERATIVE.getCode()'\nThe code is: 'private boolean isGenerative(final String methodType) { <START> return methodType.equals(\"GEN\"); <END> \/\/ MethodType.GENERATIVE.getCode() }'","output":"private boolean isGenerative(final String methodType) { return methodType.equals(MethodType.GENERATIVE.getCode()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Long.BYTES Float.BYTES'\nThe code is: 'public int getMaxIntermediateSize() { <START> return Longs.BYTES + Floats.BYTES; <END> \/\/ Long.BYTES Float.BYTES }'","output":"public int getMaxIntermediateSize() { return Long.BYTES + Float.BYTES; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Consider System.currentTimeMillis instead, performance (not much, Date().getTime() I reckon), save GC execution, skipping creation of a new object, fills memory cleaned up. [StreamingServiceTransExecutor](<LINK_0>, more relevant here, this is called for row'\nThe code is: 'private void serviceCacheCleanup() { <START> long currentTime = new Date().getTime(); <END> \/\/ Consider System.currentTimeMillis instead, performance (not much, Date().getTime() I reckon), save GC execution, skipping creation of a new object, fills memory cleaned up. [StreamingServiceTransExecutor](<LINK_0>, more relevant here, this is called for row long updateTime = lastCacheCleanupMillis + ( DataServiceConstants.STREAMING_CACHE_CLEANUP_INTERVAL_SECONDS * 1000 ); if ( updateTime <= currentTime ) { serviceListeners.cleanUp(); lastCacheCleanupMillis = currentTime; } }'","output":"private void serviceCacheCleanup() { long currentTime = System.currentTimeMillis(); long updateTime = lastCacheCleanupMillis + ( DataServiceConstants.STREAMING_CACHE_CLEANUP_INTERVAL_SECONDS * 1000 ); if ( updateTime <= currentTime ) { serviceListeners.cleanUp(); lastCacheCleanupMillis = currentTime; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Removing datasource restoring snapshot is necessary IMO'\nThe code is: 'public static void afterClass() throws InterruptedException, TimeoutException, IOException, CommandFailedException { <START> client.apply(new RemoveDataSource(JDBC_STORE_DATASOURCE_NAME)); <END> \/\/ Removing datasource restoring snapshot is necessary IMO client.apply(snapshotBackup.restore()); administration.restartIfRequired(); }'","output":"public static void afterClass() throws InterruptedException, TimeoutException, IOException, CommandFailedException { client.apply(snapshotBackup.restore()); administration.restartIfRequired(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'put single statement --> final ContainerInfo containerInfo = containerStateManager.allocateContainer(pipelineManager, type, replicationFactor, owner);'\nThe code is: 'public ContainerInfo allocateContainer(final ReplicationType type, final ReplicationFactor replicationFactor, final String owner) throws IOException { lock.lock(); try { <START> final ContainerInfo containerInfo; <END> \/\/ put single statement --> final ContainerInfo containerInfo = containerStateManager.allocateContainer(pipelineManager, type, replicationFactor, owner); containerInfo = containerStateManager .allocateContainer(pipelineManager, type, replicationFactor, owner); addContainerToDB(containerInfo); return containerInfo; } finally { lock.unlock(); } }'","output":"public ContainerInfo allocateContainer(final ReplicationType type, final ReplicationFactor replicationFactor, final String owner) throws IOException { lock.lock(); try { final ContainerInfo containerInfo = containerStateManager.allocateContainer(pipelineManager, type, replicationFactor, owner); addContainerToDB(containerInfo); return containerInfo; } finally { lock.unlock(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'question: necessary'\nThe code is: 'public InputStream getEntryInputStream() { <START> if (data == null) { <END> \/\/ question: necessary throw new IllegalStateException(\"entry content can be accessed only once\"); } ByteBufInputStream res = new ByteBufInputStream(data); data = null; return res; }'","output":"public InputStream getEntryInputStream() { Preconditions.checkNotNull(data, \"entry content can be accessed only once\"); ByteBufInputStream res = new ByteBufInputStream(data); data = null; return res; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please, fail(). <LINK_0>'\nThe code is: 'public void testTxLocalNodeFailover(){ withAllIsolationsAndConcurrencies(new IgniteClosure<Object, Void>() { @Override public Void apply(Object o) { try { txLocalNodeFailover(); } <START> catch (Exception ignore) { <END> \/\/ Please, fail(). <LINK_0> ignore.printStackTrace(); assert false : \"Impossible situation\"; } return null; } }); }'","output":"public void testTxLocalNodeFailover() throws Exception { startGrid(getTestIgniteInstanceName(0)); runWithAllIsolations(new IgniteCallable<Void>() { @Override public Void call() throws Exception { txLocalNodeFailover(); return null; } }); stopAllGrids(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return _addedFiltersNoDuplicates.add(filterToAdd.withId(\"AvoidDuplicateFiltersThatOnlyDifferInTheirId\"));'\nThe code is: 'private boolean isNotDuplicateDocumentFilter(@NonNull final DocumentFilter filterToAdd) { <START> return _addedFiltersNoDuplicates.add(filterToAdd.withId(\"1\")); <END> \/\/ suggestion return _addedFiltersNoDuplicates.add(filterToAdd.withId(\"AvoidDuplicateFiltersThatOnlyDifferInTheirId\")); }'","output":"private boolean isNotDuplicateDocumentFilter(@NonNull final DocumentFilter filterToAdd) { return _addedFiltersNoDuplicates.add(filterToAdd.withId(\"AvoidDuplicateFiltersThatOnlyDifferInTheirId\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtils.isEmpty()'\nThe code is: 'public void run() { GerritTrigger trigger = getGerritTrigger(); if (trigger == null) { return; } <START> if (trigger.getTriggerConfigURL() == null || trigger.getTriggerConfigURL().isEmpty()) { <END> \/\/ StringUtils.isEmpty() return; } trigger.updateTriggerConfigURL(); }'","output":"public void run() { GerritTrigger trigger = getGerritTrigger(); if (trigger == null) { return; } if (StringUtils.isEmpty(trigger.getTriggerConfigURL())) { return; } trigger.updateTriggerConfigURL(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check this'\nThe code is: 'public static int abandonAudioFocusRequest( @NonNull AudioManager <START> audioManager, @NonNull <END> \/\/ check this AudioFocusRequestCompat focusRequest) { if (focusRequest == null) { throw new IllegalArgumentException(\"AudioFocusRequestCompat must not be null\"); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }'","output":"public static int abandonAudioFocusRequest( @NonNull AudioManager audioManager, @NonNull AudioFocusRequestCompat focusRequest) { if (audioManager == null) { throw new IllegalArgumentException(\"AudioManager must not be null\"); } if (focusRequest == null) { throw new IllegalArgumentException(\"AudioFocusRequestCompat must not be null\"); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { return audioManager.abandonAudioFocusRequest(focusRequest.getAudioFocusRequest()); } else { return audioManager.abandonAudioFocus(focusRequest.getOnAudioFocusChangeListener()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'some benefits of retained fragment in this case'\nThe code is: '@Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); <START> setRetainInstance(true); <END> \/\/ some benefits of retained fragment in this case mBlogId = getArguments().getLong(ARG_BLOG_ID); mPostId = getArguments().getLong(ARG_POST_ID); }'","output":"@Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mBlogId = getArguments().getLong(ARG_BLOG_ID); mPostId = getArguments().getLong(ARG_POST_ID); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I feel good this constructor. counter-intuitive fsContext argument here. is fsContext embededed fs object. Is a access it'\nThe code is: '<START> public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) { <END> \/\/ I feel good this constructor. counter-intuitive fsContext argument here. is fsContext embededed fs object. Is a access it super(fs); mFsContext = fsContext; mLocalCacheManager = new LocalCacheManager(mFsContext); }'","output":"public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) { super(fs); mFsContext = fsContext; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'submit'\nThe code is: 'protected void activate(BundleContext bundleContext) { XmlDocumentReader<List<?>> thingTypeReader = new ThingDescriptionReader(); thingTypeTracker = new XmlDocumentBundleTracker<List<?>>(bundleContext, XML_DIRECTORY, thingTypeReader, this, READY_MARKER, readyService); <START> trackerJob = scheduler.schedule(() -> { <END> \/\/ submit thingTypeTracker.open(); }, 0, TimeUnit.SECONDS); }'","output":"protected void activate(BundleContext bundleContext) { XmlDocumentReader<List<?>> thingTypeReader = new ThingDescriptionReader(); thingTypeTracker = new XmlDocumentBundleTracker<List<?>>(bundleContext, XML_DIRECTORY, thingTypeReader, this, READY_MARKER, readyService); trackerJob = scheduler.submit(() -> { thingTypeTracker.open(); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'removal of public breaks NameGenerator module - generally HeadlessEnvironment is for other use, IDE is in-use if lack module facade in workspace'\nThe code is: '<START> HeadlessEnvironment(Name... modules) { <END> \/\/ removal of public breaks NameGenerator module - generally HeadlessEnvironment is for other use, IDE is in-use if lack module facade in workspace super(modules); }'","output":"public HeadlessEnvironment(Name... modules) { super(modules); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this'\nThe code is: 'public void onClick(View view) { <START> Log.e(\"Click\", \"Button\"); <END> \/\/ remove this switch (view.getId()) { case R.id.take_photo_button: Log.e(\"Click\", \"Take Photo\"); onTakePhotoButtonPressed(view); break; case R.id.submit_field_report_button: onSubmitFieldReportButtonPressed(view); break; } }'","output":"public void onClick(View view) { switch (view.getId()) { case R.id.take_photo_button: onTakePhotoButtonPressed(view); break; case R.id.submit_field_report_button: onSubmitFieldReportButtonPressed(view); break; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"remove\" method is part of interface, client able invoke it, is need prepare a nice response for user. throw exception: throw new UnsupportedOperationException();'\nThe code is: 'protected Response performRemove(String id) { Fault fault = new Fault(); fault.setReason(\"Unsupported Operation\"); fault.setDetail(\"Remove is not supported\"); <START> throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(fault).build()); <END> \/\/ \"remove\" method is part of interface, client able invoke it, is need prepare a nice response for user. throw exception: throw new UnsupportedOperationException(); }'","output":"protected Response performRemove(String id) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'public void unsupportedDatabaseTypeIdentified() { <START> IllegalArgumentException thrown = Assertions.assertThrows(IllegalArgumentException.class, <END> \/\/ static import () -> new DatabaseInitializer(\"a2\", ds, environmentCreateOnStartup(\"true\"))); assertThat(thrown.getMessage(), CoreMatchers.containsString(\"No ddl script found\")); }'","output":"public void unsupportedDatabaseTypeIdentified() { IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> new DatabaseInitializer(\"a2\", ds, environmentCreateOnStartup(\"true\"))); assertThat(thrown.getMessage(), containsString(\"No ddl script found\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'mExecutor.shutdown()'\nThe code is: 'private void shutdownVpnRunner() { mActiveNetwork = null; mIsRunning = false; resetIkeState(); final ConnectivityManager cm = ConnectivityManager.from(mContext); cm.unregisterNetworkCallback(mNetworkCallback); <START> } <END> \/\/ mExecutor.shutdown()'","output":"private void shutdownVpnRunner() { mActiveNetwork = null; mIsRunning = false; resetIkeState(); final ConnectivityManager cm = ConnectivityManager.from(mContext); cm.unregisterNetworkCallback(mNetworkCallback); mExecutor.shutdown(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else is redundant'\nThe code is: 'public <T extends IRemoteConnection.Service> T getService(IRemoteConnection connection, Class<T> service) { if (IRemoteCommandShellService.class.equals(service)) { return (T) new JSchCommandShellService(connection); } else { <START> return null; <END> \/\/ else is redundant } }'","output":"public <T extends IRemoteConnection.Service> T getService(IRemoteConnection connection, Class<T> service) { if (IRemoteCommandShellService.class.equals(service)) { return (T) new JSchCommandShellService(connection); } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wrong indentation. 4 spaces'\nThe code is: 'public double get(int i, int j) { <START> ensureIndexesAreInBounds(i, j); <END> \/\/ wrong indentation. 4 spaces return getOrElse(i, j, 0.0); }'","output":"public double get(int i, int j) { return getOrElse(i, j, 0.0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This conditional is necessary, a performance point of view. meaning clearer put() call conditional'\nThe code is: 'private void addPatternToIndex(TripPattern tripPattern) { for (Stop stop: tripPattern.getStops()) { <START> if (!patternsForStop.containsEntry(stop, tripPattern)) { <END> \/\/ This conditional is necessary, a performance point of view. meaning clearer put() call conditional patternsForStop.put(stop, tripPattern); } } }'","output":"private void addPatternToIndex(TripPattern tripPattern) { for (Stop stop: tripPattern.getStops()) { patternsForStop.put(stop, tripPattern); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is point of putting application mode in session? read information simply read configuration'\nThe code is: 'protected void executeCommand() { setActionReturnValue(getCurrentUser()); getReturnValue().setLoginResult(LoginResult.Autheticated); getReturnValue().setSessionId(engineSessionId); updateUserData(); ApplicationMode appMode = ApplicationMode.from(Config.<Integer> getValue(ConfigValues.ApplicationMode)); <START> SessionDataContainer.getInstance().setData(\"app_mode\", appMode); <END> \/\/ is point of putting application mode in session? read information simply read configuration setSucceeded(true); }'","output":"protected void executeCommand() { setActionReturnValue(getCurrentUser()); getReturnValue().setLoginResult(LoginResult.Autheticated); getReturnValue().setSessionId(engineSessionId); updateUserData(); setSucceeded(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want allow <null> values, primitive boolean instead of java.lang.Boolean object'\nThe code is: '<START> protected Boolean getAutoCorrectFontMetrics() { <END> \/\/ want allow <null> values, primitive boolean instead of java.lang.Boolean object return false; }'","output":"protected boolean getAutoCorrectFontMetrics() { return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion List<Action> actions = new Vector<>(getPersistedActions()); for clarity'\nThe code is: 'public List<Action> getActions() { <START> List<Action> actions = new Vector<>(super.getActions()); <END> \/\/ suggestion List<Action> actions = new Vector<>(getPersistedActions()); for clarity actions.addAll(transientActions); return Collections.unmodifiableList(actions); }'","output":"public List<Action> getActions() { List<Action> actions = new Vector<>(getPersistedActions()); actions.addAll(transientActions); return Collections.unmodifiableList(actions); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Interesting: is a reason wrote this opposed nanos.get();? memory semantics (this a volatile *write* well), I understand need'\nThe code is: 'public long read() { long value = nanos.getAndAdd(0); <START> return value; <END> \/\/ Interesting: is a reason wrote this opposed nanos.get();? memory semantics (this a volatile *write* well), I understand need }'","output":"public long read() { return nanos.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a field create time'\nThe code is: 'public VertexQuery queryVertex(Graph graph, Vertex vertex, String queryString, Authorizations authorizations) { return new ElasticSearchParentChildVertexQuery( getClient(), getConfig().getIndicesToQuery(), graph, vertex, queryString, getAllPropertyDefinitions(), getConfig().getScoringStrategy(), <START> getConfig().getNameSubstitutionStrategy(), <END> \/\/ this a field create time authorizations); }'","output":"public VertexQuery queryVertex(Graph graph, Vertex vertex, String queryString, Authorizations authorizations) { return new ElasticSearchParentChildVertexQuery( getClient(), getConfig().getIndicesToQuery(), graph, vertex, queryString, getAllPropertyDefinitions(), getConfig().getScoringStrategy(), this.nameSubstitutionStrategy, authorizations); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I changes in hot-fix branch. provide context changing this exception throwable'\nThe code is: 'private Runnable getScheduleableAction(String actionName, Runnable runnable) { return () -> { try { runnable.run(); if (Thread.currentThread().isInterrupted()) { LOG.warn(\"Action: {} is interrupted.\", actionName); doCleanUpOnTaskException(new InterruptedException()); } else { LOG.debug(\"Action: {} completed successfully.\", actionName); } <START> } catch (Exception exception) { <END> \/\/ I changes in hot-fix branch. provide context changing this exception throwable LOG.error(\"Execution of action: {} failed.\", actionName, exception); doCleanUpOnTaskException(exception); } }; }'","output":"private Runnable getScheduleableAction(String actionName, Runnable runnable) { return () -> { try { runnable.run(); if (Thread.currentThread().isInterrupted()) { LOG.warn(\"Action: {} is interrupted.\", actionName); doCleanUpOnTaskException(new InterruptedException()); } else { LOG.debug(\"Action: {} completed successfully.\", actionName); } } catch (Throwable throwable) { LOG.error(\"Execution of action: {} failed.\", actionName, throwable); doCleanUpOnTaskException(throwable); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This if necessary. totalSessionsCompleted is prevent new sessions maxSessionsAllowed is reached in getNewSession'\nThe code is: 'public void afterSession(TestSession session) { LOGGER.entering(); totalSessionsCompleted++; <START> if (totalSessionsCompleted <= maxSessionsAllowed) { <END> \/\/ This if necessary. totalSessionsCompleted is prevent new sessions maxSessionsAllowed is reached in getNewSession proxyLogger.fine(\"Completed session #\" + totalSessionsCompleted + \" (\" + session.toString() + \")\"); } proxyLogger.fine(\"Total number of slots used: \" + getTotalUsed() + \" on node: \" + getId()); LOGGER.exiting(); }'","output":"public void afterSession(TestSession session) { LOGGER.entering(); totalSessionsCompleted++; proxyLogger.fine(\"Completed session #\" + totalSessionsCompleted + \" (\" + session.toString() + \")\"); proxyLogger.fine(\"Total number of slots used: \" + getTotalUsed() + \" on node: \" + getId()); LOGGER.exiting(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getUsage(...) expects a localization key'\nThe code is: 'public String getUsage(ICommandSender commandSender) { <START> return new TextComponentTranslation(\"commands.bloodmagic.orb.usage\").getFormattedText(); <END> \/\/ getUsage(...) expects a localization key }'","output":"public String getUsage(ICommandSender commandSender) { return \"commands.bloodmagic.orb.usage\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'withMillisOfSecond(0) done here'\nThe code is: 'private DateTime lease() { <START> DateTime lease = new DateTime(); <END> \/\/ withMillisOfSecond(0) done here setLease(lease); latestOwnedLease = lease; return lease; }'","output":"private DateTime lease() { DateTime lease = new DateTime().withMillisOfSecond(0); setLease(lease); latestOwnedLease = lease; return lease; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'WikipediaApp.getInstance() instead'\nThe code is: 'private WikipediaApp getApplication() { <START> return (WikipediaApp) getPageActivity().getApplication(); <END> \/\/ WikipediaApp.getInstance() instead }'","output":"private WikipediaApp getApplication() { return WikipediaApp.getInstance(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please stick java convention for naming variables - letter case. this is another case local variable is needed return directly'\nThe code is: 'private static IConfiguration helper_getActiveConfiguration(IProject project) { IManagedBuildInfo buildInfo = ManagedBuildManager.getBuildInfo(project); <START> IConfiguration ActiveConf = buildInfo.getDefaultConfiguration(); <END> \/\/ Please stick java convention for naming variables - letter case. this is another case local variable is needed return directly return ActiveConf; }'","output":"private static IConfiguration helper_getActiveConfiguration(IProject project) { IManagedBuildInfo buildInfo = ManagedBuildManager.getBuildInfo(project); return buildInfo.getDefaultConfiguration(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IOUtils.copy in <LINK_0> I forgot I introduced this method'\nThe code is: 'public static void copyFileFromAssets(String fileSourcePath, String fileDestPath) throws IOException { AssetManager assetManager = InstrumentationRegistry.getInstrumentation().getContext().getAssets(); try (InputStream input = assetManager.open(fileSourcePath); OutputStream output = new FileOutputStream(fileDestPath)) { <START> byte[] buffer = new byte[1024]; <END> \/\/ IOUtils.copy in <LINK_0> I forgot I introduced this method int length; while ((length = input.read(buffer)) != -1) { output.write(buffer, 0, length); } } }'","output":"public static void copyFileFromAssets(String fileSourcePath, String fileDestPath) throws IOException { AssetManager assetManager = InstrumentationRegistry.getInstrumentation().getContext().getAssets(); try (InputStream input = assetManager.open(fileSourcePath); OutputStream output = new FileOutputStream(fileDestPath)) { IOUtils.copy(input, output); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a log statement slipped through'\nThe code is: 'public boolean add(DocumentWriteOperation documentWriteOperation) { <START> System.out.println(operations); <END> \/\/ a log statement slipped through return operations.add(documentWriteOperation); }'","output":"public boolean add(DocumentWriteOperation documentWriteOperation) { return operations.add(documentWriteOperation); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'needed'\nThe code is: 'public void testEncryption() throws Throwable { <START> super.testEncryption(); <END> \/\/ needed }'","output":"public void testEncryption() throws Throwable { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for consistency reason prev line please \"validateVm\" (small \"m\")'\nThe code is: 'private void onSaveVm() { UnitVmModel model = (UnitVmModel) getWindow(); String name = model.getName().getEntity(); setcurrentVm(new VM()); <START> validateVM(model, name); <END> \/\/ for consistency reason prev line please \"validateVm\" (small \"m\") }'","output":"private void onSaveVm() { UnitVmModel model = (UnitVmModel) getWindow(); String name = model.getName().getEntity(); setcurrentVm(new VM()); validateVm(model, name); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer this happen in serverAdded event listener'\nThe code is: '@Override protected void onEntityAdded(Entity member) { try { ((MongoDBReplicaSetImpl) entity).serverAdded((MongoDBServer) member); } catch (Exception e) { <START> ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator((EntityLocal)member, \"Failed to update replicaset\", e); <END> \/\/ prefer this happen in serverAdded event listener } }'","output":"@Override protected void onEntityAdded(Entity member) { ((MongoDBReplicaSetImpl) entity).serverAdded((MongoDBServer) member); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ah yes, sure. \"protected\" maybe. public constructor DEFAULT_INSTANCE constant stumble'\nThe code is: '<START> public BaseDialectNamingAdaptor() { <END> \/\/ Ah yes, sure. \"protected\" maybe. public constructor DEFAULT_INSTANCE constant stumble }'","output":"protected BaseDialectNamingAdaptor() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'test class in package'\nThe code is: '<START> public MockAssignmentMetadataStore() { <END> \/\/ test class in package super(Mockito.mock(BucketDataAccessor.class), \"\"); }'","output":"MockAssignmentMetadataStore() { super(Mockito.mock(BucketDataAccessor.class), \"\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'start client grid startClientGrid() called'\nThe code is: '@Override protected void beforeTestsStarted() throws Exception { startGridsMultiThreaded(3); <START> startGrid(); <END> \/\/ start client grid startClientGrid() called }'","output":"@Override protected void beforeTestsStarted() throws Exception { startGridsMultiThreaded(3); startClientGrid(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'happen #clearTestUsers threw exception? LDAP port open? #stopLdapService need a finally block'\nThe code is: 'public void tearDown() throws UserStoreException { clearTestUsers(); <START> testDirectoryServer.stopLdapService(); <END> \/\/ happen #clearTestUsers threw exception? LDAP port open? #stopLdapService need a finally block }'","output":"public void tearDown() throws UserStoreException { try { clearTestUsers(); } finally { testDirectoryServer.stopLdapService(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@erdemedeiros remove system outs'\nThe code is: 'public void run(String... strings) throws Exception { <START> System.out.println(\">>> Starting Audit App... \"); <END> \/\/ @erdemedeiros remove system outs }'","output":"public void run(String... strings) throws Exception { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertEquals instead'\nThe code is: 'public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertTrue(rankDetails.getMinOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <START> assertTrue(rankDetails.getMaxOptionsToBeRanked() == FeedbackRankQuestionDetails.NO_VALUE); <END> \/\/ assertEquals instead assertFalse(rankDetails.areDuplicatesAllowed()); }'","output":"public void testConstructor_defaultConstructor_fieldsShouldHaveCorrectDefaultValues() { FeedbackRankOptionsQuestionDetails rankDetails = new FeedbackRankOptionsQuestionDetails(); assertEquals(FeedbackQuestionType.RANK_OPTIONS, rankDetails.getQuestionType()); assertEquals(rankDetails.getMinOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertEquals(rankDetails.getMaxOptionsToBeRanked(), FeedbackRankQuestionDetails.NO_VALUE); assertFalse(rankDetails.areDuplicatesAllowed()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'streamEstimator null right'\nThe code is: 'public void cleanup() { <START> if(this.streamEstimator != null) { <END> \/\/ streamEstimator null right this.streamEstimator.reset(); } }'","output":"public void cleanup() { this.streamEstimator.reset(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IfExists => ifExists'\nThe code is: 'public String asSummaryString() { Map<String, Object> params = new LinkedHashMap<>(); params.put(\"identifier\", viewIdentifier); <START> params.put(\"IfExists\", ifExists); <END> \/\/ IfExists => ifExists params.put(\"isTemporary\", isTemporary); return OperationUtils.formatWithChildren( \"DROP VIEW\", params, Collections.emptyList(), Operation::asSummaryString); }'","output":"public String asSummaryString() { Map<String, Object> params = new LinkedHashMap<>(); params.put(\"identifier\", viewIdentifier); params.put(\"ifExists\", ifExists); params.put(\"isTemporary\", isTemporary); return OperationUtils.formatWithChildren( \"DROP VIEW\", params, Collections.emptyList(), Operation::asSummaryString); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I try-with-resources here, fix Sonar complaining it. I smth like: java try (Repository repo = EGitUtils.getRepository(project)) { if (repo == null) { return null; } return EGitUtils.getCurrentBranch(repo); }'\nThe code is: 'public static String getCurrentBranch(IProject project) throws CoreException { if (project == null) { return null; } <START> Repository repo = EGitUtils.getRepository(project); <END> \/\/ I try-with-resources here, fix Sonar complaining it. I smth like: java try (Repository repo = EGitUtils.getRepository(project)) { if (repo == null) { return null; } return EGitUtils.getCurrentBranch(repo); } if (repo == null) { return null; } String currentBranch = EGitUtils.getCurrentBranch(repo); repo.close(); return currentBranch; }'","output":"public static String getCurrentBranch(IProject project) throws CoreException { if (project == null) { return null; } try (Repository repo = EGitUtils.getRepository(project)) { if (repo == null) { return null; } return EGitUtils.getCurrentBranch(repo); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'truncation handle is HSID, TxnEgo.txnIdToString() instead'\nThe code is: 'public String toString() { return super.toString() + \" TruncationHandleMessage truncation handle id: \" <START> + CoreUtils.hsIdToString(m_truncationHandle); <END> \/\/ truncation handle is HSID, TxnEgo.txnIdToString() instead }'","output":"public String toString() { return super.toString() + \" TruncationHandleMessage truncation handle id: \" + TxnEgo.txnIdToString(m_truncationHandle); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'instanceof Dataset is redundant -- a single instanceof FilesystemDataset check'\nThe code is: 'public ConfigBuilder readFrom(View<?> view) { <START> if (view instanceof Dataset && view instanceof FileSystemDataset) { <END> \/\/ instanceof Dataset is redundant -- a single instanceof FilesystemDataset check FileSystemDataset dataset = (FileSystemDataset) view; conf.set(KITE_PARTITION_DIR, String.valueOf(dataset.getDescriptor().getLocation())); } withType(view.getType()); return readFrom(view.getUri()); }'","output":"public ConfigBuilder readFrom(View<?> view) { if (view instanceof FileSystemDataset) { FileSystemDataset dataset = (FileSystemDataset) view; conf.set(KITE_PARTITION_DIR, String.valueOf(dataset.getDescriptor().getLocation())); } withType(view.getType()); return readFrom(view.getUri()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Making methods public for test purposes is a good idea, esp. for AzureBlobFileSystem class. Find alternative'\nThe code is: '<START> public AzureBlobFileSystemStore getAbfsStore() { <END> \/\/ Making methods public for test purposes is a good idea, esp. for AzureBlobFileSystem class. Find alternative return abfsStore; }'","output":"AzureBlobFileSystemStore getAbfsStore() { return abfsStore; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'test constructor need public'\nThe code is: '<START> public CosmosDataAccessor(AsyncDocumentClient asyncDocumentClient, String cosmosCollectionLink, <END> \/\/ test constructor need public AzureMetrics azureMetrics) { this.asyncDocumentClient = asyncDocumentClient; this.cosmosCollectionLink = cosmosCollectionLink; this.azureMetrics = azureMetrics; }'","output":"CosmosDataAccessor(AsyncDocumentClient asyncDocumentClient, String cosmosCollectionLink, AzureMetrics azureMetrics) { this.asyncDocumentClient = asyncDocumentClient; this.cosmosCollectionLink = cosmosCollectionLink; this.azureMetrics = azureMetrics; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename sash'\nThe code is: 'public void setToolTipText(String string) { super.setToolTipText(string); for (Sash <START> sashe : <END> \/\/ rename sash sashes) { sashe.setToolTipText(string); } }'","output":"public void setToolTipText(String string) { super.setToolTipText(string); for (Sash sash : sashes) { sash.setToolTipText(string); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'private static boolean isApiKey(String value) { <START> if (Strings.isNullOrEmpty(value)) { <END> \/\/ static import return false; } try { UUID.fromString(value); } catch (IllegalArgumentException e) { return false; } return true; }'","output":"private static boolean isApiKey(String value) { if (isNullOrEmpty(value)) { return false; } try { UUID.fromString(value); } catch (IllegalArgumentException e) { return false; } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"else\" unnecessary'\nThe code is: 'protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException(\"BlobStorageService cannot be null\"); <START> } else { <END> \/\/ \"else\" unnecessary this.blobStorageService = blobStorageService; logger.trace(\"BlobStorage service set to {}\", blobStorageService.getClass()); } }'","output":"protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException(\"BlobStorageService cannot be null\"); } this.blobStorageService = blobStorageService; logger.trace(\"BlobStorage service set to {}\", blobStorageService.getClass()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'checkit'\nThe code is: 'public MergingEquivalentsResolverBackedContainerSummaryResolver(MergingEquivalentsResolver<Content> contentResolver) { <START> this.contentResolver = contentResolver; <END> \/\/ checkit }'","output":"public MergingEquivalentsResolverBackedContainerSummaryResolver(MergingEquivalentsResolver<Content> contentResolver) { this.contentResolver = checkNotNull(contentResolver); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws Exception reduced throws IOException'\nThe code is: '<START> private void writeUserMapToDisk(String prefix, byte[] userMapBytes) throws Exception <END> \/\/ throws Exception reduced throws IOException { File cacheDir = new File(commonCacheConfig.getCacheDirectory()); cacheDir.mkdirs(); File userMapFile = new File(commonCacheConfig.getCacheDirectory(), getUserMapFilename(prefix)); Files.write(userMapBytes, userMapFile); }'","output":"private void writeUserMapToDisk(String prefix, byte[] userMapBytes) throws IOException { File cacheDir = new File(commonCacheConfig.getCacheDirectory()); cacheDir.mkdirs(); File userMapFile = new File(commonCacheConfig.getCacheDirectory(), getUserMapFilename(prefix)); Files.write(userMapBytes, userMapFile); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I a SWT.Selection event I click, if a non-empty selection before, clicking clears selection'\nThe code is: 'private void notifyClick(final Point p) { notify(SWT.MouseEnter); notify(SWT.Activate); notify(SWT.FocusIn); <START> notify(SWT.Selection); <END> \/\/ I a SWT.Selection event I click, if a non-empty selection before, clicking clears selection notify(SWT.MouseDown, createMouseEvent(p.x, p.y, 1, SWT.NONE, 1)); notify(SWT.MouseUp, createMouseEvent(p.x, p.y, 1, SWT.BUTTON1, 1)); }'","output":"private void notifyClick(final Point p) { notify(SWT.MouseEnter); notify(SWT.Activate); notify(SWT.FocusIn); notify(SWT.MouseDown, createMouseEvent(p.x, p.y, 1, SWT.NONE, 1)); notify(SWT.MouseUp, createMouseEvent(p.x, p.y, 1, SWT.BUTTON1, 1)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this necessary'\nThe code is: 'public void end() throws Exception { <START> super.init(); <END> \/\/ Is this necessary super.cleanup(); }'","output":"public void end() throws Exception { super.cleanup(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please change static. is a bad design decision. Static classes methods complicate tests'\nThe code is: '<START> public static final void setUp(final Map<String, String>... propertyMaps) { <END> \/\/ Please change static. is a bad design decision. Static classes methods complicate tests Properties properties = new Properties(); for (Map<String, String> map: propertyMaps) { for (Map.Entry<String, String> entry : map.entrySet()) { properties.setProperty(entry.getKey(), entry.getValue()); } } ConfigurationHolder.initFromProperties(properties); }'","output":"public final void setUp(final Map<String, String>... propertyMaps) { Properties properties = new Properties(); for (Map<String, String> map: propertyMaps) { for (Map.Entry<String, String> entry : map.entrySet()) { properties.setProperty(entry.getKey(), entry.getValue()); } } ConfigurationHolder.initFromProperties(properties); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw this error, handled test runtime'\nThe code is: 'public void testSuccessfulStartTransport() { try { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(\"dummyTransport\"); transportManager.registerTransport(carbonTransport); transportManager.startTransport(\"dummyTransport\"); <START> } catch (IllegalArgumentException e) { <END> \/\/ throw this error, handled test runtime Assert.assertTrue(false); } Assert.assertTrue(true); }'","output":"public void testSuccessfulStartTransport() { CustomCarbonTransport carbonTransport = new CustomCarbonTransport(\"dummyTransport\"); transportManager.registerTransport(carbonTransport); transportManager.startTransport(\"dummyTransport\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor - this simplified java return new Stream.Cons<>(head, tailSupplier);'\nThe code is: 'static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, \"tailSupplier is null\"); <START> return new Stream.Cons<>(head, () -> tailSupplier.get()); <END> \/\/ minor - this simplified java return new Stream.Cons<>(head, tailSupplier); }'","output":"static <T> Stream<T> gen(T head, Supplier<Stream<T>> tailSupplier) { Objects.requireNonNull(tailSupplier, \"tailSupplier is null\"); return new Stream.Cons<>(head, tailSupplier); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'double ;'\nThe code is: 'public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException(\"boo\"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated();; <END> \/\/ double ; ts.assertError(TestException.class); ts.assertErrorMessage(\"boo\"); }'","output":"public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException(\"boo\"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); ts.assertTerminated(); ts.assertError(TestException.class); ts.assertErrorMessage(\"boo\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I understand this check is here. maybeMove is check of checking rights'\nThe code is: 'protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { <END> \/\/ I understand this check is here. maybeMove is check of checking rights maybeMove(oldChildReference, newChildReference); } } }); }'","output":"protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); maybeMove(oldChildReference, newChildReference); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename contribution'\nThe code is: 'public void init(IActionBars bars, IWorkbenchPage page) { for (Object <START> element : <END> \/\/ rename contribution cache) { ((EditorContribution) element).contribute(bars.getMenuManager(), false, bars.getToolBarManager(), true); } }'","output":"public void init(IActionBars bars, IWorkbenchPage page) { for (Object contribution : cache) { ((EditorContribution) contribution).contribute(bars.getMenuManager(), false, bars.getToolBarManager(), true); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reason include unused constructor'\nThe code is: 'public ServerPermission(String name, String actions) { super(name, actions); <START> } <END> \/\/ reason include unused constructor'","output":"public ServerPermission(String name, String actions) { super(validatePermissionName(name), validatePermissionActions(actions)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Boolean instead of boolean'\nThe code is: '<START> public Boolean getSabbatical() <END> \/\/ Boolean instead of boolean { return _sabbatical; }'","output":"public boolean getSabbatical() { return _sabbatical; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do set false? set true'\nThe code is: 'public BugzillaRestTaskEditorPage(TaskEditor editor, String connectorKind) { super(editor, connectorKind); <START> setNeedsPrivateSection(false); <END> \/\/ do set false? set true setNeedsSubmitButton(false); }'","output":"public BugzillaRestTaskEditorPage(TaskEditor editor, String connectorKind) { super(editor, connectorKind); setNeedsPrivateSection(true); setNeedsSubmitButton(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need this. buildUserAccount() a null check'\nThe code is: 'public UserAccount getCurrentUser() { final Account account = getCurrentAccount(); <START> return account == null ? null : buildUserAccount(account); <END> \/\/ need this. buildUserAccount() a null check }'","output":"public UserAccount getCurrentUser() { return buildUserAccount(getCurrentAccount()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ITEMS -> items'\nThe code is: 'public void init() { <START> ITEMS = new ArrayList<>(Arrays.asList(\"first\", \"middle\", \"last\")); <END> \/\/ ITEMS -> items dataProvider = DataProvider.ofCollection(ITEMS); dataController = new DataControllerStub(); dataView = new ListDataViewImpl(dataController); }'","output":"public void init() { items = new ArrayList<>(Arrays.asList(\"first\", \"middle\", \"last\")); dataProvider = DataProvider.ofCollection(items); dataController = new DataControllerStub(); dataView = new ListDataViewImpl(dataController); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is double wait needed'\nThe code is: 'public void expandPanels() { if (isElementPresent(\"collapse-panels-button\")) { clickCollapseExpandButtonAndWaitForPanelsToExpand(); <START> waitForPanelsToExpand(); <END> \/\/ Is double wait needed } }'","output":"public void expandPanels() { if (isElementPresent(\"collapse-panels-button\")) { clickCollapseExpandButtonAndWaitForPanelsToExpand(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Method deprecated. clientBuilder.version() instead'\nThe code is: 'private RemoteCacheManager createExecClient() { org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = super.createHotRodClientConfigurationBuilder(servers.get(0).getPort()); clientBuilder.marshaller(new UTF8StringMarshaller()); <START> clientBuilder.protocolVersion(getProtocolVersion()); <END> \/\/ Method deprecated. clientBuilder.version() instead return new InternalRemoteCacheManager(clientBuilder.build()); }'","output":"private RemoteCacheManager createExecClient() { org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = super.createHotRodClientConfigurationBuilder(servers.get(0).getPort()); clientBuilder.marshaller(new UTF8StringMarshaller()); clientBuilder.version(getProtocolVersion()); return new InternalRemoteCacheManager(clientBuilder.build()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Some of codec constructors public some package-protected. access, is some specific reason for'\nThe code is: '<START> GammaIntegerCodec(final BitInputStream coreBlockInputStream, <END> \/\/ Some of codec constructors public some package-protected. access, is some specific reason for final BitOutputStream coreBlockOutputStream, final int offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }'","output":"public GammaIntegerCodec(final BitInputStream coreBlockInputStream, final BitOutputStream coreBlockOutputStream, final int offset) { super(coreBlockInputStream, coreBlockOutputStream); this.offset = offset; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this present - super() base class is Object a special constructor call'\nThe code is: 'public EventWithLocalDate() { <START> super(); <END> \/\/ this present - super() base class is Object a special constructor call }'","output":"public EventWithLocalDate() {}"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Single statements need a transaction'\nThe code is: 'public void setLastCancelAllTimeMillis(final long timeMillis) { <START> mWorkDatabase.beginTransaction(); <END> \/\/ Single statements need a transaction try { Preference preference = new Preference(KEY_LAST_CANCEL_ALL_TIME_MS, timeMillis); mWorkDatabase.preferenceDao().insertPreference(preference); mWorkDatabase.setTransactionSuccessful(); } finally { mWorkDatabase.endTransaction(); } }'","output":"public void setLastCancelAllTimeMillis(final long timeMillis) { Preference preference = new Preference(KEY_LAST_CANCEL_ALL_TIME_MS, timeMillis); mWorkDatabase.preferenceDao().insertPreference(preference); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Worth try resources: java try (final InputStream inputStream = ioService.newInputStream(path, StandardOpenOption.READ)) { final String drl = DecisionTableFactory.loadFromInputStream(inputStream, null); return fillDrlIndexBuilder(path, drl); }'\nThe code is: 'public IndexBuilder fillIndexBuilder(final Path path) throws Exception { InputStream inputStream = null; try { inputStream = ioService.newInputStream(path, StandardOpenOption.READ); <START> final String drl = DecisionTableFactory.loadFromInputStream(inputStream, <END> \/\/ Worth try resources: java try (final InputStream inputStream = ioService.newInputStream(path, StandardOpenOption.READ)) { final String drl = DecisionTableFactory.loadFromInputStream(inputStream, null); return fillDrlIndexBuilder(path, drl); } null); return fillDrlIndexBuilder(path, drl); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { } } } }'","output":"public IndexBuilder fillIndexBuilder(final Path path) throws Exception { try (final InputStream inputStream = ioService.newInputStream(path, StandardOpenOption.READ)) { final String drl = DecisionTableFactory.loadFromInputStream(inputStream, null); return fillDrlIndexBuilder(path, drl); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This exposes mutable internal state. A copy is needed'\nThe code is: 'Map<String, String> getCanonicalHeaders() { <START> return canonicalHeaders; <END> \/\/ This exposes mutable internal state. A copy is needed }'","output":"Map<String, String> getCanonicalHeaders() { return new HashMap<>(canonicalHeaders); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'description setter handle null-checking logic do here'\nThe code is: 'private Action toAction() { try { <START> return new ActionImpl(getId(), title, description != null ? description : \"\", new URL(url)); <END> \/\/ description setter handle null-checking logic do here } catch (MalformedURLException e) { LOGGER.debug(\"Unable to parse the action url: url={}\", url, e); return null; } }'","output":"private Action toAction() { try { return new ActionImpl(getId(), title, description, new URL(url)); } catch (MalformedURLException e) { LOGGER.debug(\"Unable to parse the action url: url={}\", url, e); return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please provide more meaningful field names. consider prefixing field names f parameter fields p'\nThe code is: 'public TableViewerColumn getTableViewerColumn() { <START> return tlc; <END> \/\/ Please provide more meaningful field names. consider prefixing field names f parameter fields p }'","output":"public TableViewerColumn getTableViewerColumn() { return tableViewerColumn; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I guess path \"JERSEY-2643\" instead of \"test3\"'\nThe code is: 'public void JERSEY_2643() { <START> String result = target(\"test3\").request().get(String.class); <END> \/\/ I guess path \"JERSEY-2643\" instead of \"test3\" assertEquals(\"test ok\", result); }'","output":"public void JERSEY_2643() { String result = target(\"JERSEY-2643\").request().get(String.class); assertEquals(\"test ok\", result); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need store return - write as: java Assertions.assertDoesNotThrow(() -> { DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); });'\nThe code is: 'public void testToStreamRecordV2WhenOldImageIsNull() { com.amazonaws.services.lambda.runtime.events.models.dynamodb.StreamRecord streamRecord = streamRecord_event.clone(); streamRecord.setOldImage(null); Assertions.assertDoesNotThrow(() -> { <START> StreamRecord convertedStreamRecord = DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); <END> \/\/ need store return - write as: java Assertions.assertDoesNotThrow(() -> { DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); }); }); }'","output":"public void testToStreamRecordV2WhenOldImageIsNull() { com.amazonaws.services.lambda.runtime.events.models.dynamodb.StreamRecord streamRecord = streamRecord_event.clone(); streamRecord.setOldImage(null); Assertions.assertDoesNotThrow(() -> { DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getFreshTimestamps(numTimestamps)'\nThe code is: 'public void freshTimestampsDelegatesToTimestampService() { int numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); <START> when(timestampService.getFreshTimestamps(10)).thenReturn(range); <END> \/\/ getFreshTimestamps(numTimestamps) assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }'","output":"public void freshTimestampsDelegatesToTimestampService() { int numTimestamps = 10; TimestampRange range = TimestampRange.createInclusiveRange(21L, 30L); when(timestampService.getFreshTimestamps(numTimestamps)).thenReturn(range); assertEquals(range, timelock.getFreshTimestamps(numTimestamps)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This methods protected public accessed subclasses'\nThe code is: '<START> public void setText(String input, WebElement element) { <END> \/\/ This methods protected public accessed subclasses element.click(); element.clear(); element.sendKeys(input); element.sendKeys(Keys.ESCAPE); }'","output":"protected void setText(String input, WebElement element) { element.click(); element.clear(); element.sendKeys(input); element.sendKeys(Keys.ESCAPE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This set patientProgram creating another instance'\nThe code is: 'public void setPatientProgram(PatientProgram patientProgram) { <START> setOwner(new PatientProgram(patientProgram)); <END> \/\/ This set patientProgram creating another instance }'","output":"public void setPatientProgram(PatientProgram patientProgram) { setOwner(patientProgram); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, usage of this output'\nThe code is: 'public void afterSuite() throws IOException { <START> System.out.println(\"afterSuite \" + getClass().getName()); <END> \/\/ here, usage of this output _lock.close(); super.afterSuite(); }'","output":"public void afterSuite() throws IOException { _lock.close(); super.afterSuite(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This public remove. Travis report'\nThe code is: '<START> public MicroGauge(Gauge gauge) { <END> \/\/ This public remove. Travis report this.gauge = gauge; }'","output":"MicroGauge(Gauge gauge) { this.gauge = gauge; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(glowing methods) added day 1 of 1.9 builds, check is required here'\nThe code is: 'public void setGlowing(Boolean glow) { <START> if(ReflectionUtils.hasMethod(e.getClass(), \"setGlowing\", null)) { END> e.setGlowing(glow); } }'","output":"public void setGlowing(Boolean glow) { e.setGlowing(glow); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'evidence this non-null (though might've original intent)'\nThe code is: '<START> public @NotNull Connection.Direction getPreferredDirection() { <END> \/\/ evidence this non-null (though might've original intent) return preferredDirection; }'","output":"public Connection.Direction getPreferredDirection() { return preferredDirection; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: parameterized logging'\nThe code is: 'public void consolidate() throws IOException { if (getSnapshotFormat(desc) == SnapshotManifestV1.DESCRIPTOR_VERSION) { LOG.info(\"Using old Snapshot Format\"); FSTableDescriptors.createTableDescriptorForTableDirectory(workingDirFs, workingDir, htd, false); } else { <START> LOG.debug(\"Convert to Single Snapshot Manifest for \" + this.desc.getName()); <END> \/\/ nit: parameterized logging convertToV2SingleManifest(); } }'","output":"public void consolidate() throws IOException { if (getSnapshotFormat(desc) == SnapshotManifestV1.DESCRIPTOR_VERSION) { LOG.info(\"Using old Snapshot Format\"); FSTableDescriptors.createTableDescriptorForTableDirectory(workingDirFs, workingDir, htd, false); } else { LOG.debug(\"Convert to Single Snapshot Manifest for {}\", this.desc.getName()); convertToV2SingleManifest(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Move this validation PluginProfileService'\nThe code is: 'public void update(Username currentUser, String md5, SecurityAuthConfig newSecurityAuthConfig, LocalizedOperationResult result) { SecurityAuthConfigUpdateCommand command = new SecurityAuthConfigUpdateCommand(goConfigService, newSecurityAuthConfig, authorizationExtension, currentUser, result, hashingService, md5); <START> validatePluginProperties(command, newSecurityAuthConfig); <END> \/\/ Move this validation PluginProfileService update(currentUser, newSecurityAuthConfig, result, command); }'","output":"public void update(Username currentUser, String md5, SecurityAuthConfig newSecurityAuthConfig, LocalizedOperationResult result) { SecurityAuthConfigUpdateCommand command = new SecurityAuthConfigUpdateCommand(goConfigService, newSecurityAuthConfig, authorizationExtension, currentUser, result, hashingService, md5); update(currentUser, newSecurityAuthConfig, result, command); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this line, this is done in transactionalFeature.nextTransaction()'\nThe code is: 'protected void waitForAsyncCompletion() { <START> nextTransaction(); <END> \/\/ remove this line, this is done in transactionalFeature.nextTransaction() transactionalFeature.nextTransaction(); eventService.waitForAsyncCompletion(); }'","output":"protected void waitForAsyncCompletion() { transactionalFeature.nextTransaction(); eventService.waitForAsyncCompletion(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nicely done! consideration: ioobException contains information wrong (i.e. actual index size of list) catching throwing a new lose this information. please change stacktrace message of original exception passed on: } catch (IndexOutOfBoundsException ioobException) { comparingSet.remove(element); throw ioobException;'\nThe code is: 'public void add(int index, T element) { if (comparingSet.add(element)) { try { super.add(index, element); } catch (IndexOutOfBoundsException ioobException) { comparingSet.remove(element); <START> throw new IndexOutOfBoundsException(); <END> \/\/ nicely done! consideration: ioobException contains information wrong (i.e. actual index size of list) catching throwing a new lose this information. please change stacktrace message of original exception passed on: } catch (IndexOutOfBoundsException ioobException) { comparingSet.remove(element); throw ioobException; } } }'","output":"public void add(int index, T element) { if (comparingSet.add(element)) { try { super.add(index, element); } catch (IndexOutOfBoundsException ioobException) { comparingSet.remove(element); throw ioobException; } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I wouldnt regex matcher this in this way. if a label contains a special char... matched properly'\nThe code is: 'public LabeledText(ReferencedComposite referencedComposite, String label) { <START> super(referencedComposite, 0, new WithLabelMatcher(new RegexMatcher(label + \"\\\\s*\\\\**\"))); <END> \/\/ I wouldnt regex matcher this in this way. if a label contains a special char... matched properly }'","output":"public LabeledText(ReferencedComposite referencedComposite, String label) { super(referencedComposite, 0, new WithLabelMatcher(label)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'SinkSemantic KafkaSinkSemantic? confusing works for source'\nThe code is: '<START> public static KafkaSemantic getSinkSemantic(String semantic){ <END> \/\/ SinkSemantic KafkaSinkSemantic? confusing works for source switch (semantic){ case SINK_SEMANTIC_VALUE_EXACTLY_ONCE: return EXACTLY_ONCE; case SINK_SEMANTIC_VALUE_AT_LEAST_ONCE: return AT_LEAST_ONCE; case SINK_SEMANTIC_VALUE_NONE: return NONE; default: throw new TableException(\"Validator should have checked that\"); } }'","output":"public static KafkaSinkSemantic getSinkSemantic(String semantic){ switch (semantic){ case SINK_SEMANTIC_VALUE_EXACTLY_ONCE: return EXACTLY_ONCE; case SINK_SEMANTIC_VALUE_AT_LEAST_ONCE: return AT_LEAST_ONCE; case SINK_SEMANTIC_VALUE_NONE: return NONE; default: throw new TableException(\"Validator should have checked that\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'byteContainments? Especially \"s\" is missing'\nThe code is: 'public void scanFile(JavaFileScannerContext context) { this.context = context; scan(context.getTree()); shifts.clear(); <START> byteSecuring.clear(); <END> \/\/ byteContainments? Especially \"s\" is missing }'","output":"public void scanFile(JavaFileScannerContext context) { this.context = context; scan(context.getTree()); shifts.clear(); byteContainments.clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove \"public\" (our mistake, other constructors in this class package-private, too)'\nThe code is: '<START> public IosRSAKey() { <END> \/\/ Please remove \"public\" (our mistake, other constructors in this class package-private, too) }'","output":"private IosRSAKey() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace method call of(partialFunction) providing a type hint <R>: java return () -> Try.<R> of(partialFunction::apply).getOption();'\nThe code is: 'static <R> Function0<Option<R>> lift(CheckedFunction0<? extends R> partialFunction) { <START> return () -> Try.of(of(partialFunction)::apply).getOption(); <END> \/\/ replace method call of(partialFunction) providing a type hint <R>: java return () -> Try.<R> of(partialFunction::apply).getOption(); }'","output":"static <R> Function0<Option<R>> lift(CheckedFunction0<? extends R> partialFunction) { return () -> Try.<R>of(partialFunction::apply).getOption(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename'\nThe code is: 'private final void fireCommandChanged(final CommandEvent commandEvent) { if (commandEvent == null) { throw new NullPointerException(\"Cannot fire a null event\"); } final Object[] listeners = getListeners(); for (Object <START> listener2 : <END> \/\/ rename listeners) { final ICommandListener listener = (ICommandListener) listener2; SafeRunner.run(new ISafeRunnable() { @Override public void handleException(Throwable exception) { } @Override public void run() throws Exception { listener.commandChanged(commandEvent); } }); } }'","output":"private final void fireCommandChanged(final CommandEvent commandEvent) { if (commandEvent == null) { throw new NullPointerException(\"Cannot fire a null event\"); } final Object[] listeners = getListeners(); for (Object listener : listeners) { final ICommandListener commandListener = (ICommandListener) listener; SafeRunner.run(new ISafeRunnable() { @Override public void handleException(Throwable exception) { } @Override public void run() throws Exception { commandListener.commandChanged(commandEvent); } }); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add ioe exception'\nThe code is: 'public static byte[] serializeAuthenticatorUserMap( ObjectMapper objectMapper, Map<String, BasicAuthenticatorUser> userMap ) { try { return objectMapper.writeValueAsBytes(userMap); } catch (IOException ioe) { <START> throw new ISE(\"WTF? Couldn't serialize userMap!\"); <END> \/\/ Please add ioe exception } }'","output":"public static byte[] serializeAuthenticatorUserMap( ObjectMapper objectMapper, Map<String, BasicAuthenticatorUser> userMap ) { try { return objectMapper.writeValueAsBytes(userMap); } catch (IOException ioe) { throw new ISE(ioe, \"WTF? Couldn't serialize userMap!\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is anywhere. if do need public'\nThe code is: '<START> public static void changeOutcomeSettings(OutcomeSettings settings){ <END> \/\/ this is anywhere. if do need public outcomeSettings = settings; outcomeEventsController.setOutcomeSettings(settings); }'","output":"static void changeOutcomeSettings(OutcomeSettings settings) { outcomeSettings = settings; outcomeEventsController.setOutcomeSettings(settings); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Static string constants'\nThe code is: 'private JClassType getPreBootstrapper() throws UnableToCompleteException { <START> String typeName = lookupTypeNameByProperty(\"gwtp.prebootstrapper\"); <END> \/\/ Static string constants if (typeName == null) { return null; } return findAndVerifyType(typeName, PreBootstrapper.class); }'","output":"private JClassType getPreBootstrapper() throws UnableToCompleteException { String typeName = lookupTypeNameByProperty(PROPERTY_NAME_PREBOOTSTRAPPER); if (typeName == null) { return null; } return findAndVerifyType(typeName, PreBootstrapper.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Another space add'\nThe code is: 'public TextArgs add(Object... args) { if (positionedArgsBuilder == null) { throw new IllegalArgumentException(\"Positioned arguments were already accessed, to add\" + <START> \"more arguments use TextArgs.copy()\"); <END> \/\/ Another space add } positionedArgsBuilder.add(args); return this; }'","output":"public TextArgs add(Object... args) { return new TextArgs( ImmutableList.builder().addAll(positionedArgs).add(args).build(), namedArgs ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collectors.toSet()'\nThe code is: 'private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) { ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters(); params.setStorageDomainId(storageDomainId); Set<String> lunIds = <START> newLuns.stream().map(LogicalUnit::getId).collect(toCollection(HashSet::new)); <END> \/\/ Collectors.toSet() params.setLunIds(lunIds); params.setForce(force); return params; }'","output":"private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) { ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters(); params.setStorageDomainId(storageDomainId); Set<String> lunIds = newLuns.stream().map(LogicalUnit::getId).collect(Collectors.toSet()); params.setLunIds(lunIds); params.setForce(force); return params; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '!isEmpty CL'\nThe code is: 'public void enableDefault() { if (getDefaultApi() == null) { return; } List<? extends CloudTestingType> appSupportedDomain = getAppSupportedDomain(); if (appSupportedDomain.contains(defaultApi)) { enable(defaultApi); } else if <START> (appSupportedDomain.size() > 0) { <END> \/\/ !isEmpty CL enable(appSupportedDomain.get(0)); } }'","output":"public void enableDefault() { if (getDefaultApi() == null) { return; } List<? extends CloudTestingType> appSupportedDomain = getAppSupportedDomain(); if (appSupportedDomain.contains(defaultApi)) { enable(defaultApi); } else if (!appSupportedDomain.isEmpty()) { enable(appSupportedDomain.get(0)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion LOG.warn(\"could remove referencePoint, referencePoint is registered ID: \" + id);'\nThe code is: 'public synchronized void removeReferencePoint(String id) { IReferencePoint referencePoint = idToReferencePointMapping.get(id); if (referencePoint == null) { <START> LOG.warn(\"could not remove referencePoint, no referencePoint is registerid with ID: \" + id); <END> \/\/ suggestion LOG.warn(\"could remove referencePoint, referencePoint is registered ID: \" + id); return; } if (partiallySharedReferencePoints.contains(referencePoint)) partiallySharedReferencePoints.remove(referencePoint); else completelySharedReferencePoints.remove(referencePoint); idToReferencePointMapping.remove(id); referencePointToIDMapping.remove(referencePoint); partiallySharedResourceMapping.remove(referencePoint); LOG.debug(\"removed referencePoint \" + referencePoint + \" with ID \" + id); }'","output":"public synchronized void removeReferencePoint(String id) { IReferencePoint referencePoint = idToReferencePointMapping.get(id); if (referencePoint == null) { LOG.warn(\"could not remove referencePoint, no referencePoint is registered with ID: \" + id); return; } if (partiallySharedReferencePoints.contains(referencePoint)) partiallySharedReferencePoints.remove(referencePoint); else completelySharedReferencePoints.remove(referencePoint); idToReferencePointMapping.remove(id); referencePointToIDMapping.remove(referencePoint); partiallySharedResourceMapping.remove(referencePoint); LOG.debug(\"removed referencePoint \" + referencePoint + \" with ID \" + id); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'RulesDao.getRules() returns a list'\nThe code is: 'public RestListWrapper<Rule> getRules() { return new RestListWrapper<>( <START> RulesDao.getRules().stream().collect(Collectors.toList()), <END> \/\/ RulesDao.getRules() returns a list Rule.class, this, \"id\", null); }'","output":"public RestListWrapper<Rule> getRules() { return new RestListWrapper<>(RulesDao.getRules(), Rule.class, this, \"id\", null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need IOException'\nThe code is: '<START> public void testSerde() throws JsonParseException, JsonMappingException, JsonProcessingException, IOException <END> \/\/ need IOException { ObjectMapper mapper = new DefaultObjectMapper(); SketchEstimateWithErrorBounds est = new SketchEstimateWithErrorBounds(100.0,101.5,98.5,2); Assert.assertEquals(est, mapper.readValue( mapper.writeValueAsString(est), SketchEstimateWithErrorBounds.class)); }'","output":"public void testSerde() throws IOException { ObjectMapper mapper = new DefaultObjectMapper(); SketchEstimateWithErrorBounds est = new SketchEstimateWithErrorBounds(100.0,101.5,98.5,2); Assert.assertEquals(est, mapper.readValue( mapper.writeValueAsString(est), SketchEstimateWithErrorBounds.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'cleanup bundle is destroyed a shutdown hook'\nThe code is: 'public DhcpdImpl() { <START> Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() { <END> \/\/ cleanup bundle is destroyed a shutdown hook @Override public void run() { DhcpdImpl.this.shutdown = true; DhcpdImpl.this.port67Listener.stop(); DhcpdImpl.this.port68Listener.stop(); LOG.debug(\"Dhcpd terminated successfully.\"); } })); }'","output":"public DhcpdImpl() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'protected most'\nThe code is: '<START> public SearchFormsLoader generateLoader( <END> \/\/ protected most CatalogFramework catalogFramework, EndpointUtil endpointUtil, String formsDir, String formsFile, String resultsFile) { return new SearchFormsLoader(catalogFramework, endpointUtil, formsDir, formsFile, resultsFile); }'","output":"protected SearchFormsLoader generateLoader( CatalogFramework catalogFramework, EndpointUtil endpointUtil, String formsDir, String formsFile, String resultsFile) { return new SearchFormsLoader(catalogFramework, endpointUtil, formsDir, formsFile, resultsFile); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove merging'\nThe code is: 'private void assertQuery(String query, byte[] checksum) { byte[] expected = (byte[]) computeActual(query).getOnlyValue(); for (int i = 0; i < expected.length; i++) { System.err.print(expected[i] + \", \"); <START> } <END> \/\/ Remove merging assertEquals(computeActual(query).getOnlyValue(), checksum); }'","output":"private void assertQuery(String query, byte[] checksum) { assertEquals(computeActual(query).getOnlyValue(), checksum); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again, insufficient. FileWriter is AutoCloseable'\nThe code is: 'private static void writeDataToFile(String data, String filePath) throws IOException { File f = new File(filePath); if (!f.exists()) { try { f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } FileWriter fstream = new FileWriter(filePath); <START> try (BufferedWriter out = new BufferedWriter(fstream)) { <END> \/\/ Again, insufficient. FileWriter is AutoCloseable out.write(data); } }'","output":"private static void writeDataToFile(String data, String filePath) throws IOException { File f = new File(filePath); if (!f.exists()) { try { f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } try (BufferedWriter out = new BufferedWriter(new FileWriter(filePath))) { out.write(data); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return \"kudu\"'\nThe code is: 'public String getName() { <START> return name; <END> \/\/ return \"kudu\" }'","output":"public String getName() { return \"kudu\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this'\nThe code is: 'default Tuple2<Seq<K>, Seq<V>> unzip() { <START> return this.unzip(Function.identity()); <END> \/\/ remove this }'","output":"default Tuple2<Seq<K>, Seq<V>> unzip() { return unzip(Function.identity()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Double ||'\nThe code is: 'protected SChannelOutput(final SynchronousQueue<Object> cell, final SChannel channel) { this.cell = cell; this.channel = channel; <START> if (VmSettings.ACTOR_TRACING | VmSettings.REPLAY) { <END> \/\/ Double || numWrites = new AtomicInteger(0); } else { numWrites = null; } }'","output":"protected SChannelOutput(final SynchronousQueue<Object> cell, final SChannel channel) { this.cell = cell; this.channel = channel; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static imports'\nThe code is: 'public CifsWinRmConnection(String type, ConnectionOptions options, AddressPortMapper mapper) { super(type, options, mapper, true); <START> ConnectionValidator.assertIsWindowsHost(os, CIFS_PROTOCOL, cifsConnectionType); <END> \/\/ static imports ConnectionValidator.assertNotOldStyleWindowsDomain(username, CIFS_PROTOCOL, cifsConnectionType); }'","output":"public CifsWinRmConnection(String type, ConnectionOptions options, AddressPortMapper mapper) { super(type, options, mapper); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'discussed in main issue, this in check for entire method. this moved isCheckedMethod method'\nThe code is: 'private void visitParameterDef(DetailAST parameterDef) { final DetailAST grandParentAST = parameterDef.getParent().getParent(); if (grandParentAST.getType() == TokenTypes.METHOD_DEF && isCheckedMethod(grandParentAST) && isVerifiable(grandParentAST) <START> && !AnnotationUtil.containsAnnotation(grandParentAST, \"Override\")) { <END> \/\/ discussed in main issue, this in check for entire method. this moved isCheckedMethod method checkClassName(parameterDef); } }'","output":"private void visitParameterDef(DetailAST parameterDef) { final DetailAST grandParentAST = parameterDef.getParent().getParent(); if (grandParentAST.getType() == TokenTypes.METHOD_DEF && isCheckedMethod(grandParentAST)) { checkClassName(parameterDef); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I need this check this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) needed, if getParameters().getGeoRepSessionId() simply get result'\nThe code is: 'private GlusterGeoRepSession getGeoRepSession() { if (getParameters().getGeoRepSessionId() != null) { return geoRepDao.getById(getParameters().getGeoRepSessionId()); } <START> return null; <END> \/\/ I need this check this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) needed, if getParameters().getGeoRepSessionId() simply get result }'","output":"private GlusterGeoRepSession getGeoRepSession() { return geoRepDao.getById(getParameters().getGeoRepSessionId()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![MAJOR](<LINK_1> 'Severity: MAJOR') \"getPluginKeyAndResourcePath\" a \"static\" method. [![rule](<LINK_2>](<LINK_0>'\nThe code is: '<START> private String getPluginKeyAndResourcePath(HttpServletRequest request) { <END> \/\/ ![MAJOR](<LINK_1> 'Severity: MAJOR') \"getPluginKeyAndResourcePath\" a \"static\" method. [![rule](<LINK_2>](<LINK_0> return StringUtils.substringAfter(request.getRequestURI(), request.getContextPath() + request.getServletPath() + \"\/\"); }'","output":"private static String getPluginKeyAndResourcePath(HttpServletRequest request) { return StringUtils.substringAfter(request.getRequestURI(), request.getContextPath() + request.getServletPath() + \"\/\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is true instead of false'\nThe code is: 'public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand command) throws Throwable { if (this.statisticsEnabled) prepares.incrementAndGet(); Object result = invokeNextInterceptorAndVerifyTransaction(ctx, command); if (!ctx.isOriginLocal()) { if (command.isOnePhaseCommit()) { <START> txTable.remoteTransactionCommitted(command.getGlobalTransaction(), false); <END> \/\/ I is true instead of false } else { txTable.remoteTransactionPrepared(command.getGlobalTransaction()); } } return result; }'","output":"public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand command) throws Throwable { if (this.statisticsEnabled) prepares.incrementAndGet(); Object result = invokeNextInterceptorAndVerifyTransaction(ctx, command); if (!ctx.isOriginLocal()) { if (command.isOnePhaseCommit()) { txTable.remoteTransactionCommitted(command.getGlobalTransaction(), true); } else { txTable.remoteTransactionPrepared(command.getGlobalTransaction()); } } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logging removed \/ disabled merging'\nThe code is: 'private void log(final String message) { <START> System.out.println(message); <END> \/\/ logging removed \/ disabled merging }'","output":"private void log(final String message) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer handled (the snapshot type) in a separate change'\nThe code is: 'public CreateAllSnapshotsFromVmParameters() { needsLocking = true; <START> snapshotType = SnapshotType.REGULAR; <END> \/\/ prefer handled (the snapshot type) in a separate change saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); }'","output":"public CreateAllSnapshotsFromVmParameters() { needsLocking = true; saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This dropped'\nThe code is: 'public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(\"credentialType\", credentialType); SupportLevel supportLevel = stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); <START> if (supportLevel == null) { <END> \/\/ This dropped throw log.unableToDetermineSupportLevel(); } return supportLevel; }'","output":"public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName) throws RealmUnavailableException { Assert.checkNotNullParam(\"credentialType\", credentialType); return stateRef.get().getCredentialAcquireSupport(credentialType, algorithmName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ImmutableList.copyOf'\nThe code is: 'public DelegatingSystemTablesProvider(SystemTablesProvider... delegates) { <START> this(Arrays.asList(delegates)); <END> \/\/ ImmutableList.copyOf }'","output":"public DelegatingSystemTablesProvider(SystemTablesProvider... delegates) { this(ImmutableList.copyOf(delegates)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unsafe addition, integer overflow. long instead of integer'\nThe code is: 'public static int ownedQuantity(ArrayList<Order> position, String symbol) { int ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { <START> ownedQuantity += stock.getSize(); <END> \/\/ unsafe addition, integer overflow. long instead of integer } } return ownedQuantity; }'","output":"public static int ownedQuantity(ArrayList<Order> position, String symbol) { long ownedQuantity = 0; for (Order stock : position) { if (stock.getStockSymbol().equals(symbol)) { ownedQuantity += stock.getSize(); } } return ownedQuantity; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'break for loop if annotation is'\nThe code is: 'public static OlapAnnotation getOlapAnnotationByName( final String name, List<OlapAnnotation> annotations) { OlapAnnotation foundAnnotation = null; for( OlapAnnotation annotation : annotations ) { if ( name.equals( annotation.getName() ) ) { <START> foundAnnotation = annotation; <END> \/\/ break for loop if annotation is } } return foundAnnotation; }'","output":"public static OlapAnnotation getOlapAnnotationByName( final String name, List<OlapAnnotation> annotations) { OlapAnnotation foundAnnotation = null; for( OlapAnnotation annotation : annotations ) { if ( name.equals( annotation.getName() ) ) { foundAnnotation = annotation; break; } } return foundAnnotation; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please separate lines readable. boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration.isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; }'\nThe code is: 'private String getCurrentValueFromViewer(MergeViewerSide side) { <START> final boolean isLeft = (MergeViewerSide.LEFT == side) != getCompareConfiguration().isMirrored(); <END> \/\/ Please separate lines readable. boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration.isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }'","output":"private String getCurrentValueFromViewer(MergeViewerSide side) { boolean isLeft = MergeViewerSide.LEFT == side; if (getCompareConfiguration().isMirrored()) { isLeft = MergeViewerSide.RIGHT == side; } final GetContentRunnable runnable = new GetContentRunnable(isLeft); Display.getDefault().syncExec(runnable); return (String)runnable.getResult(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: put args a separate line'\nThe code is: '<START> private String storeSensorPrefix(final String threadId, final String taskId, final String storeName) { <END> \/\/ nit: put args a separate line return taskSensorPrefix(threadId, taskId) + SENSOR_PREFIX_DELIMITER + \"store\" + SENSOR_PREFIX_DELIMITER + storeName; }'","output":"private String storeSensorPrefix(final String threadId, final String taskId, final String storeName) { return taskSensorPrefix(threadId, taskId) + SENSOR_PREFIX_DELIMITER + SENSOR_STORE_LABEL + SENSOR_PREFIX_DELIMITER + storeName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is clear enough additional id variable for'\nThe code is: 'public WebElement getEditInstructorLink(int instrNum) { String id = \"instrEditLink\" + instrNum; <START> return browser.driver.findElement(By.id(id)); <END> \/\/ I is clear enough additional id variable for }'","output":"public WebElement getEditInstructorLink(int instrNum) { return browser.driver.findElement(By.id(\"instrEditLink\" + instrNum)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'private'\nThe code is: '<START> void printUsage() { <END> \/\/ private final String usage = \"java -jar VarSim.jar <tool> <tool_args>... \\n\" + \" --= Simulation =-- \\n\" + \" randvcf2vcf -- Randomly samples variants from a VCF file\\n\" + \" randdgv2vcf -- Randomly samples variants from a DGV database file\\n\" + \" --= Validation =-- \\n\" + \" vcfcompare -- Generate JSON describing vcf accuracy relative to truth \\n\" + \" samcompare -- Generate JSON describing alignment accuracy relative to truth \\n\" + \" vcfstats -- Generate stats on size range and variant types in a VCF\\n\" + \" --= Internal =-- \\n\" + \" vcf2diploid -- Enhanced version of vcf2diploid from alleleseq \\n\" + \" fastq_liftover -- Lifts over simulated FASTQ files to reference coordinates \\n\" + \"\\n\"; System.err.println(VarSim.class.getSimpleName() + \" \" + VERSION); System.err.println(usage); }'","output":"private void printUsage() { final String usage = \"java -jar VarSim.jar <tool> <tool_args>... \\n\" + \" --= Simulation =-- \\n\" + \" randvcf2vcf -- Randomly samples variants from a VCF file\\n\" + \" randdgv2vcf -- Randomly samples variants from a DGV database file\\n\" + \" --= Validation =-- \\n\" + \" vcfcompare -- Generate JSON describing vcf accuracy relative to truth \\n\" + \" samcompare -- Generate JSON describing alignment accuracy relative to truth \\n\" + \" vcfstats -- Generate stats on size range and variant types in a VCF\\n\" + \" --= Internal =-- \\n\" + \" vcf2diploid -- Enhanced version of vcf2diploid from alleleseq \\n\" + \" fastq_liftover -- Lifts over simulated FASTQ files to reference coordinates \\n\" + \"\\n\"; System.err.println(VarSim.class.getSimpleName() + \" \" + VERSION); System.err.println(usage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Defensive copy instead'\nThe code is: 'AbstractChangeNotes(GitRepositoryManager repoManager, Change change) { this.repoManager = repoManager; <START> this.change = change; <END> \/\/ Defensive copy instead }'","output":"AbstractChangeNotes(GitRepositoryManager repoManager, Change change) { this.repoManager = repoManager; this.change = new Change(change); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"or properties\". Well. a of these'\nThe code is: 'public String send(Map<Header, Object> headers, Map<String, String> properties, ForkliftMessage message) throws ProducerException { <START> throw new UnsupportedOperationException(\"Kafka Producer does not support headers or properties\"); <END> \/\/ \"or properties\". Well. a of these }'","output":"public String send(Map<Header, Object> headers, Map<String, String> properties, ForkliftMessage message) throws ProducerException { throw new UnsupportedOperationException(\"Kafka Producer does not support headers\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Put close() a finally block attempt is close session, commit failure. If closing session fails, do -- log move on'\nThe code is: 'public void sendEvents() { log.debug(\"Committing ActiveMQ transaction\"); try { ClientSession session = this.getClientSession(); session.commit(); <START> session.close(); <END> \/\/ Put close() a finally block attempt is close session, commit failure. If closing session fails, do -- log move on } catch (Exception e) { log.error(\"Error committing ActiveMQ transaction\", e); } }'","output":"public void sendEvents() { log.debug(\"Committing ActiveMQ transaction\"); try (ClientSession session = this.getClientSession()) { session.commit(); } catch (Exception e) { log.error(\"Error committing ActiveMQ transaction\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> PRED_change_owner_1(Term a1, Operation n) { <END> \/\/ public arg1 = a1; cont = n; }'","output":"public PRED_change_owner_1(Term a1, Operation n) { arg1 = a1; cont = n; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please do System.out.println, log'\nThe code is: 'public void process(final ElasticJob elasticJob, final JobConfiguration jobConfig, final JobFacade jobFacade, final ShardingContext shardingContext) { <START> System.out.println(jobConfig.getProps().getProperty(PrintJobProperties.CONTENT_KEY)); <END> \/\/ Please do System.out.println, log }'","output":"public void process(final ElasticJob elasticJob, final JobConfiguration jobConfig, final JobFacade jobFacade, final ShardingContext shardingContext) { log.info(jobConfig.getProps().getProperty(PrintJobProperties.CONTENT_KEY)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this throw exception'\nThe code is: 'public AnnotationDeclaration asAnnotationDeclaration() { <START> return (AnnotationDeclaration) this; <END> \/\/ this throw exception }'","output":"public AnnotationDeclaration asAnnotationDeclaration() { throw new IllegalStateException(f(\"%s is not an AnnotationDeclaration\", this)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'synchronized'\nThe code is: '<START> void setMetric(Object metric) { <END> \/\/ synchronized this.metric = metric; }'","output":"synchronized void setMetric(Object metric) { this.metric = metric; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This right. I assumed this stream(), streamByPage()'\nThe code is: 'public void listSettingsWithPagination() { final int numberExpected = 50; for (int value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + \"-\" + value).value(\"myValue\").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + \"-*\").labels(labelPrefix); <START> assertEquals(numberExpected, client.listSettings(filter).streamByPage().count()); <END> \/\/ This right. I assumed this stream(), streamByPage() }'","output":"public void listSettingsWithPagination() { final int numberExpected = 50; for (int value = 0; value < numberExpected; value++) { client.setSetting(new ConfigurationSetting().key(keyPrefix + \"-\" + value).value(\"myValue\").label(labelPrefix)); } SettingSelector filter = new SettingSelector().keys(keyPrefix + \"-*\").labels(labelPrefix); assertEquals(numberExpected, client.listSettings(filter).stream().count()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'trim this? suggestion this.dlqTopicName = connConfig.dlqTopicName().trim();'\nThe code is: 'DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; <START> this.dlqTopicName = connConfig.dlqTopicName(); <END> \/\/ trim this? suggestion this.dlqTopicName = connConfig.dlqTopicName().trim(); }'","output":"DeadLetterQueueReporter(KafkaProducer<byte[], byte[]> kafkaProducer, SinkConnectorConfig connConfig, ConnectorTaskId id, ErrorHandlingMetrics errorHandlingMetrics) { Objects.requireNonNull(kafkaProducer); Objects.requireNonNull(connConfig); Objects.requireNonNull(id); Objects.requireNonNull(errorHandlingMetrics); this.kafkaProducer = kafkaProducer; this.connConfig = connConfig; this.connectorTaskId = id; this.errorHandlingMetrics = errorHandlingMetrics; this.dlqTopicName = connConfig.dlqTopicName().trim(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool());'\nThe code is: 'protected void updateWipeAfterDeleteChangeability() { if (isVmAttachedToPool()) { getIsWipeAfterDelete().setIsChangeable(false); } else { <START> getIsWipeAfterDelete().setIsChangeable(true); <END> \/\/ getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool()); } }'","output":"protected void updateWipeAfterDeleteChangeability() { getIsWipeAfterDelete().setIsChangeable(!isVmAttachedToPool()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'traceEvents.containsValue(field)'\nThe code is: 'private boolean checkFieldPresent(@NonNull String field) { final Multimap<@NonNull String, @NonNull String> traceEvents = TmfEventTypeCollectionHelper.getEventFieldNames((getContainedEventTypes())); Optional<@NonNull String> event = traceEvents.values().stream() .filter(fieldName -> fieldName.equals(field)) .findAny(); return <START> event.isPresent(); <END> \/\/ traceEvents.containsValue(field) }'","output":"private boolean checkFieldPresent(@NonNull String field) { final Multimap<@NonNull String, @NonNull String> traceEvents = TmfEventTypeCollectionHelper.getEventFieldNames((getContainedEventTypes())); return traceEvents.containsValue(field); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Fragment obtain host calling FragmentUtil.getCallback(). I if Activity is ratained in a Fragment instance, a memory leak'\nThe code is: '@Override protected DescriptionEditSuccessFragment createFragment() { DescriptionEditSuccessFragment fragment = DescriptionEditSuccessFragment.newInstance(); <START> fragment.setCallback(this); <END> \/\/ Fragment obtain host calling FragmentUtil.getCallback(). I if Activity is ratained in a Fragment instance, a memory leak return fragment; }'","output":"@Override protected DescriptionEditSuccessFragment createFragment() { return DescriptionEditSuccessFragment.newInstance(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ah, thanks for pointing out - I missed that. is calls xaResource() method? in spring config boot? need recovery helper is installed boot? Is a reason do in xaResourceRecovery() method immediately below? preference some force DummyXAResourceRecovery set RecoveryManagerService boot? For example call a setter RecoveryManagerService spring wiring passes DummyXAResourceRecovery in pass RecoveryManagerService DummyXAResourceRecovery call add it? This is if possible'\nThe code is: 'public DummyXAResource xaResource() { rms.addXAResourceRecovery(xaResourceRecovery()); <START> return new DummyXAResource(); <END> \/\/ Ah, thanks for pointing out - I missed that. is calls xaResource() method? in spring config boot? need recovery helper is installed boot? Is a reason do in xaResourceRecovery() method immediately below? preference some force DummyXAResourceRecovery set RecoveryManagerService boot? For example call a setter RecoveryManagerService spring wiring passes DummyXAResourceRecovery in pass RecoveryManagerService DummyXAResourceRecovery call add it? This is if possible }'","output":"public DummyXAResource xaResource() { return new DummyXAResource(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove useless assert'\nThe code is: 'public void testEGetNullEObjectNullFeature() { <START> assertEquals(null, eObjectServices.eGet(null, null)); <END> \/\/ Remove useless assert }'","output":"public void testEGetNullEObjectNullFeature() { eObjectServices.eGet(null, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Mind changing type of this Map<String, Object>'\nThe code is: '<START> private static Object wrapHash(String key, Multihash h) { <END> \/\/ Mind changing type of this Map<String, Object> Map<String, Object> json = new TreeMap<>(); json.put(key, h.toString()); return json; }'","output":"private static Map<String, Object> wrapHash(String key, Multihash h) { Map<String, Object> json = new TreeMap<>(); json.put(key, h.toString()); return json; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'crash if bad format string'\nThe code is: 'public VSizeIndexedWriter( IOPeon ioPeon, String filenameBase, int maxId ) { this.ioPeon = ioPeon; <START> this.metaFileName = StringUtils.safeFormat(\"%s.meta\", filenameBase); <END> \/\/ crash if bad format string this.headerFileName = StringUtils.safeFormat(\"%s.header\", filenameBase); this.valuesFileName = StringUtils.safeFormat(\"%s.values\", filenameBase); this.maxId = maxId; }'","output":"public VSizeIndexedWriter( IOPeon ioPeon, String filenameBase, int maxId ) { this.ioPeon = ioPeon; this.metaFileName = StringUtils.format(\"%s.meta\", filenameBase); this.headerFileName = StringUtils.format(\"%s.header\", filenameBase); this.valuesFileName = StringUtils.format(\"%s.values\", filenameBase); this.maxId = maxId; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'duplicate tokens, re-call getRequiredTokens'\nThe code is: 'public int[] getAcceptableTokens() { return new int[] { TokenTypes.LAMBDA, <START> }; <END> \/\/ duplicate tokens, re-call getRequiredTokens }'","output":"public int[] getAcceptableTokens() { return getRequiredTokens(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this is error: return instance of ExceptionLogHandler, of WarningErrorHandler'\nThe code is: 'public static <RT> ErrorHandler<RT> get(Logger logger) { <START> return new WarningErrorHandler<RT>(logger); <END> \/\/ I this is error: return instance of ExceptionLogHandler, of WarningErrorHandler }'","output":"public static <RT> ErrorHandler<RT> get(Logger logger) { return new ExceptionLogHandler<RT>(logger); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is a convention ++'\nThe code is: 'public void onBecomeStandbyFromLeader(Message message, NotificationContext context) { <START> logger.info(\"++Becoming STANDBY from LEADER\"); <END> \/\/ Is a convention ++ }'","output":"public void onBecomeStandbyFromLeader(Message message, NotificationContext context) { logger.info(\"Becoming STANDBY from LEADER\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return mapper.orElseGet(ObjectMapper::new).convertValue(attributes, ValueAttributesInfo.class);'\nThe code is: 'public static ValueAttributesInfo fromMap(Map<String, String> attributes, Optional<ObjectMapper> mapper) { <START> return mapper.orElseGet(() -> new ObjectMapper()).convertValue(attributes, ValueAttributesInfo.class); <END> \/\/ suggestion return mapper.orElseGet(ObjectMapper::new).convertValue(attributes, ValueAttributesInfo.class); }'","output":"public static ValueAttributesInfo fromMap(Map<String, String> attributes, Optional<ObjectMapper> mapper) { return mapper.orElseGet(ObjectMapper::new).convertValue(attributes, ValueAttributesInfo.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return StringUtils.defaultString(string);'\nThe code is: 'public static String asEqualsPattern(String string) { <START> return StringUtils.isNotEmpty(string) ? String.format(\"%s\", string) : \"\"; <END> \/\/ return StringUtils.defaultString(string); }'","output":"public static String asEqualsPattern(String string) { return StringUtils.defaultString(string); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'put Objects.requireNonNull(...) beginning of method? This easier read'\nThe code is: 'public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { <START> return new OnmsTopologyVertex(Objects.requireNonNull(id, \"id is null, cannot create vertex\"), label, address, <END> \/\/ put Objects.requireNonNull(...) beginning of method? This easier read iconKey); }'","output":"public static OnmsTopologyVertex create(String id, String label, String address, String iconKey) { Objects.requireNonNull(id, \"id is null, cannot create vertex\"); return new OnmsTopologyVertex(id, label, address, iconKey); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'listener'\nThe code is: 'private void firePropertyChange(final PropertyChangeEvent event) { Object[] allListeners = listeners.getListeners(); for <START> (Object allListener : <END> \/\/ listener allListeners) { final IPropertyChangeListener listener = (IPropertyChangeListener) allListener; SafeRunner.run(new ISafeRunnable() { @Override public void run() throws Exception { listener.propertyChange(event); } @Override public void handleException(Throwable exception) { } }); } }'","output":"private void firePropertyChange(final PropertyChangeEvent event) { Object[] allListeners = listeners.getListeners(); for (Object l : allListeners) { final IPropertyChangeListener listener = (IPropertyChangeListener)l; SafeRunner.run(new ISafeRunnable() { @Override public void run() throws Exception { listener.propertyChange(event); } @Override public void handleException(Throwable exception) { } }); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this problems actual consumers? If a user decides build a listener implements IClassListener provides implementation for onAfterClass() exceptions for onBeforeClass. IMO throwing exceptions in default methods. please this removed in this listener interface'\nThe code is: 'default void onBeforeClass(ITestClass testClass) { <START> throw new UnsupportedOperationException(\"Method is not implemented\"); <END> \/\/ this problems actual consumers? If a user decides build a listener implements IClassListener provides implementation for onAfterClass() exceptions for onBeforeClass. IMO throwing exceptions in default methods. please this removed in this listener interface }'","output":"default void onBeforeClass(ITestClass testClass) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change BROWSER'\nThe code is: 'public void setEnvironment(String value) { switch (value) { <START> case \"LEGACY\": <END> \/\/ change BROWSER this.environment = CompilerOptions.Environment.BROWSER; break; case \"CUSTOM\": this.environment = CompilerOptions.Environment.CUSTOM; break; default: throw new BuildException( \"Unrecognized 'environment' option value (\" + value + \")\"); } }'","output":"public void setEnvironment(String value) { switch (value) { case \"BROWSER\": this.environment = CompilerOptions.Environment.BROWSER; break; case \"CUSTOM\": this.environment = CompilerOptions.Environment.CUSTOM; break; default: throw new BuildException( \"Unrecognized 'environment' option value (\" + value + \")\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'entry'\nThe code is: 'private LogEntry getLogEntryByRevision(ILogEntry[] entries, String revision) { for (ILogEntry <START> entrie : <END> \/\/ entry entries) { if (entrie.getRevision().equals(revision) && entrie instanceof LogEntry) { return (LogEntry) entrie; } } return null; }'","output":"private LogEntry getLogEntryByRevision(ILogEntry[] entries, String revision) { for (ILogEntry entry : entries) { if (entry.getRevision().equals(revision) && entry instanceof LogEntry) { return (LogEntry) entry; } } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Default false'\nThe code is: 'public boolean isDeferJavaScriptLoading() { ConfigurationService cs = Framework.getService(ConfigurationService.class); <START> return cs.getBoolean(DEFER_JS_PROP, true); <END> \/\/ Default false }'","output":"public boolean isDeferJavaScriptLoading() { ConfigurationService cs = Framework.getService(ConfigurationService.class); return cs.isBooleanTrue(DEFER_JS_PROP); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, dropTable: return new MetaDataMutationResult(MutationCode.TABLE_ALREADY_EXISTS, 0, null);'\nThe code is: 'public MetaDataMutationResult dropIndex(List<Mutation> tableMetadata, String tableName) throws SQLException { <START> throw new UnsupportedOperationException(); <END> \/\/ here, dropTable: return new MetaDataMutationResult(MutationCode.TABLE_ALREADY_EXISTS, 0, null); }'","output":"public MetaDataMutationResult dropIndex(List<Mutation> tableMetadata, String tableName) throws SQLException { return new MetaDataMutationResult(MutationCode.TABLE_ALREADY_EXISTS, 0, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I \"force\" variable passed vdsServer method is, instead of converting string'\nThe code is: 'public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) { try { <START> return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force.toString())); <END> \/\/ I \"force\" variable passed vdsServer method is, instead of converting string } catch (UndeclaredThrowableException ute) { throw new XmlRpcRunTimeException(ute); } }'","output":"public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) { try { return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeStart(volumeName, force)); } catch (UndeclaredThrowableException ute) { throw new XmlRpcRunTimeException(ute); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this return type changed avoid list cast'\nThe code is: '<START> public @ResponseBody List<Member> getPlayersForTeam( <END> \/\/ this return type changed avoid list cast HttpSession session, @PathVariable int id) { if (session.getAttribute(\"member\") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return (List<Member>) team.getPlayers(); }'","output":"public @ResponseBody Set<Member> getPlayersForTeam( HttpSession session, @PathVariable int id) { if (session.getAttribute(\"member\") == null) { return null; } TeamDao teamDao = new TeamDao(); Team team = teamDao.getTeamById(id, false, true, false); return team.getPlayers(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'create filter re-use one. Accept is called for file, this unnecessary slowdown recreate instance over. Please remove getXpathFilter move code finishLocalSetup assign a field'\nThe code is: 'public boolean accept(TreeWalkerAuditEvent treeWalkerAuditEvent) { <START> final XpathFilter xpathFilter = getXpathFilter(); <END> \/\/ create filter re-use one. Accept is called for file, this unnecessary slowdown recreate instance over. Please remove getXpathFilter move code finishLocalSetup assign a field return xpathFilter.accept(treeWalkerAuditEvent); }'","output":"public boolean accept(TreeWalkerAuditEvent treeWalkerAuditEvent) { return xpathFilter.accept(treeWalkerAuditEvent); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Argument name'\nThe code is: 'public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { <START> ArgChecker.notNull(index, \"currency\"); <END> \/\/ Argument name ArgChecker.notNull(forwardCurve, \"forwardCurve\"); ArgChecker.notNull(timeSeries, \"timeSeries\"); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }'","output":"public ImmutableRatesProviderBuilder overnightIndexCurve( OvernightIndex index, Curve forwardCurve, LocalDateDoubleTimeSeries timeSeries) { ArgChecker.notNull(index, \"index\"); ArgChecker.notNull(forwardCurve, \"forwardCurve\"); ArgChecker.notNull(timeSeries, \"timeSeries\"); this.indexCurves.put(index, forwardCurve); this.timeSeries.put(index, timeSeries); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nice a static import, for consistency'\nThe code is: 'public void addLineItem() { <START> ProductFixtures.withTaxedProduct(client(), product -> { <END> \/\/ nice a static import, for consistency final LineItemDraft lineItemDraft = LineItemDraft.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(lineItemDraft); testOrderEditStagedUpdateAction(addLineItem); }); }'","output":"public void addLineItem() { withTaxedProduct(client(), product -> { final LineItemDraft lineItemDraft = LineItemDraft.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(lineItemDraft); testOrderEditStagedUpdateAction(addLineItem); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add a java Objects.requireNonNull(computation, \"computation is null\");'\nThe code is: '<START> static <T> Future<T> ofSupplier(ExecutorService executorService, Supplier<? extends T> computation) { <END> \/\/ Please add a java Objects.requireNonNull(computation, \"computation is null\"); return of(executorService, computation::get); }'","output":"static <T> Future<T> ofSupplier(ExecutorService executorService, Supplier<? extends T> computation) { Objects.requireNonNull(computation, \"computation is null\"); return of(executorService, computation::get); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant semicolon'\nThe code is: 'public LoginPasswordAuthentication(final String login, final String password) { <START> this.login = notEmpty(login, \"login\");; <END> \/\/ redundant semicolon this.password = notEmpty(password, \"password\");; }'","output":"public LoginPasswordAuthentication(final String login, final String password) { this.login = notEmpty(login, \"login\"); this.password = notEmpty(password, \"password\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close(); );'\nThe code is: 'public void destroy() { <START> this.connectionFactoryMap.forEach((ldap, connectionFactory) -> { connectionFactory.close(); }); <END> \/\/ suggestion this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close(); ); }'","output":"public void destroy() { this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'more obvious while reading code if was: suggestion return executeLedgerOnlyStrategy();'\nThe code is: 'protected RefundsResponse executeFutureBehaviourStrategy() { <START> return getPaymentRefundsService.getLedgerTransactionTransactions(account, paymentId); <END> \/\/ more obvious while reading code if was: suggestion return executeLedgerOnlyStrategy(); }'","output":"protected RefundsResponse executeFutureBehaviourStrategy() { return executeLedgerOnlyStrategy(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace this(true, true, true);'\nThe code is: 'public RemoteOutcomeParams() { <START> new RemoteOutcomeParams(true, true, true); <END> \/\/ replace this(true, true, true); }'","output":"public RemoteOutcomeParams() { this(true, true, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'implementing hashCode abstract level is specific here'\nThe code is: '<START> public int hashCode() <END> \/\/ implementing hashCode abstract level is specific here { return abstractBlockHashCode(); }'","output":"public int hashCode() { return super.hashCode(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this isnt needed delegated method added messageChanged() already, for a number of methods'\nThe code is: 'public org.apache.activemq.artemis.api.core.Message putByteProperty(SimpleString key, byte value) { org.apache.activemq.artemis.api.core.Message message = putByteProperty(key.toString(), value); <START> messageChanged(); <END> \/\/ this isnt needed delegated method added messageChanged() already, for a number of methods return message; }'","output":"public org.apache.activemq.artemis.api.core.Message putByteProperty(SimpleString key, byte value) { return putByteProperty(key.toString(), value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'METADATA_VIEW_ICON'\nThe code is: 'public IImage getIcon() { return ECoreImage.METADATA_TABLE_ICON; <START> } <END> \/\/ METADATA_VIEW_ICON'","output":"public IImage getIcon() { return ECoreImage.METADATA_VIEW_ICON; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Visibility missing. Synchronized static'\nThe code is: '<START> static synchronized void addToList(TerminalInfoView view) { <END> \/\/ Visibility missing. Synchronized static views.add(view); }'","output":"private static synchronized void addToList(TerminalInfoView view) { views.add(view); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getUrl method nicer if parameter consist variable e.g. getUrl(URLsContent.filePage + fileName);'\nThe code is: 'public void openFilePage(String fileName) { <START> getUrl(Global.DOMAIN + URLsContent.wikiDir + URLsContent.fileNS + fileName); <END> \/\/ getUrl method nicer if parameter consist variable e.g. getUrl(URLsContent.filePage + fileName); waitForElementByElement(tabList.get(0)); PageObjectLogging.log(\"Open file page\", \"file page opened\", true); }'","output":"public void openFilePage(String fileName) { getUrl(URLsContent.filePage + fileName); waitForElementByElement(tabList.get(0)); PageObjectLogging.log(\"Open file page\", \"file page opened\", true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'config is initialized in BaseTestCase.java'\nThe code is: 'protected void inject(Injector injector) throws Exception { super.inject(injector); environment = injector.getInstance(IEdxEnvironment.class); <START> config = injector.getInstance(Config.class); <END> \/\/ config is initialized in BaseTestCase.java }'","output":"protected void inject(Injector injector) throws Exception { super.inject(injector); environment = injector.getInstance(IEdxEnvironment.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logging right. log this in else part remove return'\nThe code is: 'public void registerType(HierarchicalTypeDefinition<?> typeDef) throws Exception { if (metadataService.getTypeNamesList().contains(typeDef.typeName)) { log.info(\"Given type: [{}] is already registered.\", typeDef.typeName); <START> return; <END> \/\/ logging right. log this in else part remove return } final String typeDefJson = TypesSerialization.toJson(typeDef, false); final JSONObject type = metadataService.createType(typeDefJson); log.info(\"####### registered type [{}] \", type); final List<String> typeNamesList = metadataService.getTypeNamesList(); log.debug(\"####### registered typeNames [{}] \", typeNamesList); }'","output":"public void registerType(HierarchicalTypeDefinition<?> typeDef) throws Exception { if (metadataService.getTypeNamesList().contains(typeDef.typeName)) { LOG.info(\"Given type: [{}] is already registered.\", typeDef.typeName); } else { final String typeDefJson = TypesSerialization.toJson(typeDef, false); final JSONObject type = metadataService.createType(typeDefJson); LOG.info(\"####### registered type [{}] \", type); final List<String> typeNamesList = metadataService.getTypeNamesList(); LOG.debug(\"####### registered typeNames [{}] \", typeNamesList); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'meant private Closeables() right? is need instantiate this class. TBH, I get rid of this constructor, class default access all..'\nThe code is: '<START> Closeables() { <END> \/\/ meant private Closeables() right? is need instantiate this class. TBH, I get rid of this constructor, class default access all.. }'","output":"private Closeables() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please change this a bit? Stopping timer is important closing resource, if stopping timer throws kind of exception stop resource. do more like. try { super.close(); } finally { getMeasured().close(); } This guarantee close resource always, if exception is thrown in cases resource exception takes precedent in newer versions of java other exception show a Suppressed exception'\nThe code is: 'public void close() throws Exception { <START> super.close(); <END> \/\/ please change this a bit? Stopping timer is important closing resource, if stopping timer throws kind of exception stop resource. do more like. try { super.close(); } finally { getMeasured().close(); } This guarantee close resource always, if exception is thrown in cases resource exception takes precedent in newer versions of java other exception show a Suppressed exception getMeasured().close(); }'","output":"public void close() throws Exception { try { super.close(); } finally { getMeasured().close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exchangePoint'\nThe code is: 'public boolean exchangeableCoupon(long couponId, String loginName){ <START> long exchange_point = couponExchangeMapper.findByCouponId(couponId).getExchangePoint(); <END> \/\/ exchangePoint long availablePoint = accountMapper.findUsersAccountAvailablePoint(loginName); CouponModel couponModel = couponMapper.lockById(couponId); return availablePoint >= exchange_point && couponModel.getIssuedCount() <= couponModel.getTotalCount(); }'","output":"public boolean exchangeableCoupon(long couponId, String loginName){ long exchangePoint = couponExchangeMapper.findByCouponId(couponId).getExchangePoint(); long availablePoint = accountMapper.findUsersAccountAvailablePoint(loginName); CouponModel couponModel = couponMapper.lockById(couponId); return availablePoint >= exchangePoint && couponModel.getIssuedCount() <= couponModel.getTotalCount(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this defensively copy, instead offer add remove interface'\nThe code is: 'public void setProviders( Map<String, Map.Entry<String, BlobStore>> providers) { <START> this.providers = providers; <END> \/\/ this defensively copy, instead offer add remove interface }'","output":"public void setProviders( Map<String, Map.Entry<String, BlobStore>> providers) { this.providers = ImmutableMap.copyOf(providers); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call update update apply change if is ignore'\nThe code is: 'public static synchronized void setupRetentionPolicyMgr(int numThreads) { if (s_retentionPolicyMgr == null) { s_retentionPolicyMgr = new RetentionPolicyMgr(numThreads); } else if (s_retentionPolicyMgr.getRetentionThreadPoolSize() != numThreads) { <START> s_retentionPolicyMgr.updateThreadPoolSize(numThreads); <END> \/\/ call update update apply change if is ignore } }'","output":"public static synchronized void setupRetentionPolicyMgr(int numThreads) { if (s_retentionPolicyMgr == null) { s_retentionPolicyMgr = new RetentionPolicyMgr(numThreads); } else { s_retentionPolicyMgr.updateThreadPoolSize(numThreads); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename 'selectionChangedListener''\nThe code is: 'public void selectionChanged(final SelectionChangedEvent event) { Object[] listeners = getListeners(); for (Object listener : listeners) { final ISelectionChangedListener <START> l = <END> \/\/ rename 'selectionChangedListener' (ISelectionChangedListener) listener; SafeRunner.run(new SafeRunnable() { @Override public void run() { l.selectionChanged(event); } }); } }'","output":"public void selectionChanged(final SelectionChangedEvent event) { for (Object listener : getListeners()) { final ISelectionChangedListener selectionChangedListener = (ISelectionChangedListener) listener; SafeRunner.run(new SafeRunnable() { @Override public void run() { selectionChangedListener.selectionChanged(event); } }); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'clicked button in command before, it'\nThe code is: 'public void clickOnIncrementMemoryButton(String machineName) { seleniumWebDriverHelper.waitAndClick(By.xpath(format(INCREMENT_MEMORY_BUTTON, machineName))); <START> WaitUtils.sleepQuietly(1); <END> \/\/ clicked button in command before, it }'","output":"public void clickOnIncrementMemoryButton(String machineName) { seleniumWebDriverHelper.waitAndClick(By.xpath(format(INCREMENT_MEMORY_BUTTON, machineName))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Redundant modifier. Travis report for class private'\nThe code is: '<START> public IntegrationGraphCorsConfigurer(String path, String[] allowedOrigins) { <END> \/\/ Redundant modifier. Travis report for class private this.path = path; this.allowedOrigins = allowedOrigins; }'","output":"private IntegrationGraphCorsConfigurer(String path, String[] allowedOrigins) { this.path = path; this.allowedOrigins = allowedOrigins; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for debugging. debug logs instead'\nThe code is: 'public void channelRegistered(ChannelHandlerContext ctx) throws Exception { super.channelRegistered(ctx); LOG.info(\"channelRegistered {}\", ctx); <START> } <END> \/\/ for debugging. debug logs instead'","output":"public void channelRegistered(ChannelHandlerContext ctx) throws Exception { super.channelRegistered(ctx); LOG.debug(\"channelRegistered {}\", ctx); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is 3.3 feature, 3.2'\nThe code is: 'private void addWatchdogActions(VersionCaps version, WatchdogAction[] values) { <START> if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) { <END> \/\/ this is 3.3 feature, 3.2 version.setWatchdogActions(new WatchdogActions()); for (WatchdogAction watchdogAction : values) { version.getWatchdogActions().getWatchdogActions().add(watchdogAction.value()); } } }'","output":"private void addWatchdogActions(VersionCaps version, WatchdogAction[] values) { if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) { version.setWatchdogActions(new WatchdogActions()); for (WatchdogAction watchdogAction : values) { version.getWatchdogActions().getWatchdogActions().add(watchdogAction.value()); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'synchronized is unnecessary Context is (must be) instanciated for thread. purpose of Context class is making invokeTemplate single-threaded'\nThe code is: 'private Invocable lazyGetTemplateInvocable() { if (templateInvocable == null) { <START> synchronized(this) { <END> \/\/ synchronized is unnecessary Context is (must be) instanciated for thread. purpose of Context class is making invokeTemplate single-threaded templateInvocable = newTemplateInvocable(params); } } return templateInvocable; }'","output":"private Invocable lazyGetTemplateInvocable() { if (templateInvocable == null) { templateInvocable = newTemplateInvocable(params); } return templateInvocable; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java for (ISessionEventListener target : v) { ... }'\nThe code is: 'public void fireEvent(ExecEvent eo) { List<ISessionEventListener> v; synchronized (this) { if (_listeners.size() == 0) { return; } v = new ArrayList<>(_listeners); } for (Object aV : v) { <START> ISessionEventListener target = (ISessionEventListener) aV; <END> \/\/ java for (ISessionEventListener target : v) { ... } try { target.sessionUpdate(eo); } catch (Exception ex) { LOG.log(Level.SEVERE, \"Couldn't invoke method sessionUpdate() on \" + target, ex); } } }'","output":"public void fireEvent(ExecEvent eo) { List<ISessionEventListener> v; synchronized (this) { if (_listeners.size() == 0) { return; } v = new ArrayList<>(_listeners); } for (ISessionEventListener target : v) { try { target.sessionUpdate(eo); } catch (Exception ex) { LOG.log(Level.SEVERE, \"Couldn't invoke method sessionUpdate() on \" + target, ex); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove unused 'e's'\nThe code is: 'public void testExcludeTable() throws Exception { <START> MaxwellAbstractRowsEvent e; <END> \/\/ remove unused 'e's List<RowMap> list; MaxwellFilter filter = new MaxwellFilter(); filter.excludeTable(\"minimal\"); list = getRowsForSQL(filter, insertSQL, createDBs); assertThat(list.size(), is(1)); assertThat(list.get(0).getTable(), is(\"bars\")); }'","output":"public void testExcludeTable() throws Exception { List<RowMap> list; MaxwellFilter filter = new MaxwellFilter(); filter.excludeTable(\"minimal\"); list = getRowsForSQL(filter, insertSQL, createDBs); assertThat(list.size(), is(1)); assertThat(list.get(0).getTable(), is(\"bars\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(args[0], args)'\nThe code is: 'public static void execShell(String command) { String[] args = { \"\/system\/bin\/sh\", \"-c\", command }; try { <START> Libcore.os.execv(\"\/system\/bin\/sh\", args); <END> \/\/ (args[0], args) } catch (ErrnoException e) { throw new RuntimeException(e); } }'","output":"public static void execShell(String command) { String[] args = { \"\/system\/bin\/sh\", \"-c\", command }; try { Libcore.os.execv(args[0], args); } catch (ErrnoException e) { throw new RuntimeException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove rounding... 3rd strike ;)'\nThe code is: 'public long getBucketStartTime(int index) { <START> return fFirstBucketTime + (long) (index * fBucketDuration + .5); <END> \/\/ Remove rounding... 3rd strike ;) }'","output":"public long getBucketStartTime(int index) { return fFirstBucketTime + (long) (index * fBucketDuration); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'correct get type object is EntityDictionary.getType. works DynamicType'\nThe code is: 'public void updateToManyRelation(DataStoreTransaction relationTx, Object entity, String relationName, Set<Object> newRelationships, Set<Object> deletedRelationships, RequestScope scope) { relationTx = getRelationTransaction(entity, relationName); <START> DataStoreTransaction entityTransaction = getTransaction(getType(entity.getClass())); <END> \/\/ correct get type object is EntityDictionary.getType. works DynamicType entityTransaction.updateToManyRelation(relationTx, entity, relationName, newRelationships, deletedRelationships, scope); }'","output":"public void updateToManyRelation(DataStoreTransaction relationTx, Object entity, String relationName, Set<Object> newRelationships, Set<Object> deletedRelationships, RequestScope scope) { relationTx = getRelationTransaction(entity, relationName); DataStoreTransaction entityTransaction = getTransaction(EntityDictionary.getType(entity)); entityTransaction.updateToManyRelation(relationTx, entity, relationName, newRelationships, deletedRelationships, scope); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'jsonOne. This is assuming numeral part of variable name is expected number of fields in serialized version. If case, elaborate naming convention'\nThe code is: 'public void testGoogleAnalyticsTrackingSettingSerialization() throws Exception { GoogleAnalyticsSetting setting = new GoogleAnalyticsSetting(); setting.setEnable(false); <START> String jsonTwo = mapper.writeValueAsString(setting); <END> \/\/ jsonOne. This is assuming numeral part of variable name is expected number of fields in serialized version. If case, elaborate naming convention System.out.println(jsonTwo); Assert.assertEquals(jsonTwo, \"{\\\"enable\\\":false}\"); }'","output":"public void testGoogleAnalyticsTrackingSettingSerialization() throws Exception { GoogleAnalyticsSetting setting = new GoogleAnalyticsSetting(); setting.setEnable(false); String json = mapper.writeValueAsString(setting); System.out.println(json); Assert.assertEquals(json, \"{\\\"enable\\\":false}\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Return FORBIDDEN too. need play nice if user rights call this'\nThe code is: 'public List<NuxeoOAuth2Token> getTokens(@Context HttpServletRequest request) throws IOException, RestOperationException { if (!((NuxeoPrincipal)getContext().getCoreSession().getPrincipal()).isAdministrator()) { <START> return Collections.emptyList(); <END> \/\/ Return FORBIDDEN too. need play nice if user rights call this } return getTokens(); }'","output":"public List<NuxeoOAuth2Token> getTokens(@Context HttpServletRequest request) throws IOException, RestOperationException { checkPermission(); return getTokens(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please, text \"Project name\" (Name fixed sending this pool request) thank you'\nThe code is: 'public AttributeDefinition getAttributeDefinition() { AttributeDefinition attr = new AttributeDefinition(); attr.setNamespace(AttributesManager.NS_GROUP_RESOURCE_ATTR_DEF); attr.setFriendlyName(\"projectName\"); <START> attr.setDisplayName(\"projectName\"); <END> \/\/ Please, text \"Project name\" (Name fixed sending this pool request) thank you attr.setType(String.class.getName()); attr.setDescription(\"Name of project, directory where the project exists.\"); return attr; }'","output":"public AttributeDefinition getAttributeDefinition() { AttributeDefinition attr = new AttributeDefinition(); attr.setNamespace(AttributesManager.NS_GROUP_RESOURCE_ATTR_DEF); attr.setFriendlyName(\"projectName\"); attr.setDisplayName(\"Project name\"); attr.setType(String.class.getName()); attr.setDescription(\"Name of project, directory where the project exists.\"); return attr; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null check unnecessary'\nThe code is: 'public QueryResponse getChromosomes(@RequestParam(name = \"species\") String species, HttpServletResponse response) throws IllegalOpenCGACredentialsException, IOException { <START> if (species == null || species.isEmpty()) { <END> \/\/ null check unnecessary response.setStatus(HttpServletResponse.SC_BAD_REQUEST); return setQueryResponse(\"Please specify a species\"); } MultiMongoDbFactory.setDatabaseNameForCurrentThread(DBAdaptorConnector.getDBName(species)); List<String> chromosomeList = variantEntityRepository.findDistinctChromosomes(); QueryResult<String> queryResult = Utils.buildQueryResult(chromosomeList); return setQueryResponse(queryResult); }'","output":"public QueryResponse getChromosomes(@RequestParam(name = \"species\") String species, HttpServletResponse response) throws IllegalOpenCGACredentialsException, IOException { if (species.isEmpty()) { response.setStatus(HttpServletResponse.SC_BAD_REQUEST); return setQueryResponse(\"Please specify a species\"); } MultiMongoDbFactory.setDatabaseNameForCurrentThread(DBAdaptorConnector.getDBName(species)); List<String> chromosomeList = variantEntityRepository.findDistinctChromosomes(); QueryResult<String> queryResult = Utils.buildQueryResult(chromosomeList); return setQueryResponse(queryResult); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'intend leave printStackTrace() here'\nThe code is: 'private void checkForIllegalStreamName(String streamName, String streamDef) { try { StreamNode sn = parse(streamName, streamDef); fail(\"expected to fail but parsed \" + sn.stringify()); } catch (StreamDefinitionException e) { assertEquals(XDDSLMessages.ILLEGAL_STREAM_NAME, e.getMessageCode()); assertEquals(0, e.getPosition()); <START> e.printStackTrace(); <END> \/\/ intend leave printStackTrace() here assertEquals(streamName, e.getInserts()[0]); } }'","output":"private void checkForIllegalStreamName(String streamName, String streamDef) { try { StreamNode sn = parse(streamName, streamDef); fail(\"expected to fail but parsed \" + sn.stringify()); } catch (StreamDefinitionException e) { assertEquals(XDDSLMessages.ILLEGAL_STREAM_NAME, e.getMessageCode()); assertEquals(0, e.getPosition()); assertEquals(streamName, e.getInserts()[0]); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this is here. consider changing private'\nThe code is: '<START> protected void <END> \/\/ I this is here. consider changing private endRemoveEntity() { setCommandShouldBeLogged(false); setSucceeded(true); }'","output":"private void endRemoveEntity() { setCommandShouldBeLogged(false); setSucceeded(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit. this string literal a top-level constant'\nThe code is: 'EmailSender(final Mailer mailer, final Config config, final ObjectMapper mapper) { _fromAddress = config.getString(\"fromAddress\"); _mailer = mailer; try { <START> _allowedRecipients = mapper.readValue(ConfigurationHelper.toJson(config, \"allowedRecipients\"), ALLOWED_RECIPIENTS_TYPE); <END> \/\/ nit. this string literal a top-level constant } catch (final IOException e) { throw new IllegalArgumentException(e); } }'","output":"EmailSender(final Mailer mailer, final Config config, final ObjectMapper mapper) { _fromAddress = config.getString(\"fromAddress\"); _mailer = mailer; try { _allowedRecipients = mapper.readValue(ConfigurationHelper.toJson(config, ALLOWED_RECIPIENTS_KEY), ALLOWED_RECIPIENTS_TYPE); } catch (final IOException e) { throw new IllegalArgumentException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else is necessary (the if returns)'\nThe code is: 'public void setName(String name) { if (name == null) { super.setName(name); return; <START> } else if (name.startsWith(this.getContextIndex() + \":\")) { <END> \/\/ else is necessary (the if returns) name = name.substring(name.indexOf(\":\")+1); } super.setName(getPanelName(this.getContextIndex(), name)); }'","output":"public void setName(String name) { if (name == null) { super.setName(name); return; } if (name.startsWith(this.getContextIndex() + \":\")) { name = name.substring(name.indexOf(\":\")+1); } super.setName(getPanelName(this.getContextIndex(), name)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Rename -> CosmosDbFactory CosmosFactory'\nThe code is: 'public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { <START> Assert.notNull(cosmosFactory, \"CosmosDbFactory must not be null!\"); <END> \/\/ Rename -> CosmosDbFactory CosmosFactory Assert.notNull(cosmosConfig, \"CosmosConfig must not be null!\"); Assert.notNull(mappingCosmosConverter, \"MappingCosmosConverter must not be null!\"); this.cosmosFactory = cosmosFactory; this.cosmosConfig = cosmosConfig; this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosClient(); }'","output":"public ReactiveCosmosTemplate(CosmosFactory cosmosFactory, CosmosConfig cosmosConfig, MappingCosmosConverter mappingCosmosConverter) { Assert.notNull(cosmosFactory, \"CosmosFactory must not be null!\"); Assert.notNull(cosmosConfig, \"CosmosConfig must not be null!\"); Assert.notNull(mappingCosmosConverter, \"MappingCosmosConverter must not be null!\"); this.mappingCosmosConverter = mappingCosmosConverter; this.cosmosAsyncClient = cosmosFactory.getCosmosAsyncClient(); this.databaseName = cosmosFactory.getDatabaseName(); this.responseDiagnosticsProcessor = cosmosConfig.getResponseDiagnosticsProcessor(); this.queryMetricsEnabled = cosmosConfig.isQueryMetricsEnabled(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'line need throw IOException'\nThe code is: 'protected static Blob readStringBlob(String ctype, String fileName, String content) throws IOException { Blob blob = new StringBlob(fileName, content, ctype); <START> return blob; <END> \/\/ line need throw IOException }'","output":"protected static Blob readStringBlob(String ctype, String fileName, String content) { return new StringBlob(fileName, content, ctype); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I advantage of requireNonNull()'\nThe code is: 'public Response awaitResponse() throws Exception { <START> return Objects.requireNonNull(remoteFuture).get(); <END> \/\/ I advantage of requireNonNull() }'","output":"public Response awaitResponse() throws Exception { return remoteFuture.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Checks -> Check'\nThe code is: 'public void setupChild(Configuration childConf) throws CheckstyleException { final String name = childConf.getName(); final Object module = moduleFactory.createModule(name); if (!(module instanceof AbstractCheck)) { throw new CheckstyleException( \"TreeWalker is not allowed as a parent of \" + name + \" Please review 'Parent Module' section for this Check in web\" <START> + \" documentation if Checks is standard.\"); <END> \/\/ Checks -> Check } final AbstractCheck check = (AbstractCheck) module; check.contextualize(childContext); check.configure(childConf); check.init(); registerCheck(check); }'","output":"public void setupChild(Configuration childConf) throws CheckstyleException { final String name = childConf.getName(); final Object module = moduleFactory.createModule(name); if (!(module instanceof AbstractCheck)) { throw new CheckstyleException( \"TreeWalker is not allowed as a parent of \" + name + \" Please review 'Parent Module' section for this Check in web\" + \" documentation if Check is standard.\"); } final AbstractCheck check = (AbstractCheck) module; check.contextualize(childContext); check.configure(childConf); check.init(); registerCheck(check); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I \"valid times\" changed \"setup time\" \"setup\"'\nThe code is: 'protected final void setDatabaseUrl(final List<ServerAddress> databaseUrl) { if (!setup) { <START> throw new IllegalStateException(\"Can only set this variable during valid times\"); <END> \/\/ I \"valid times\" changed \"setup time\" \"setup\" } this.databaseUrl = databaseUrl; }'","output":"protected final void setDatabaseUrl(final List<ServerAddress> databaseUrl) { if (!setup) { throw new IllegalStateException(\"Can only set this variable during setup\"); } this.databaseUrl = databaseUrl; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'update this GDB_7_12_VERSION'\nThe code is: '<START> protected String getMinGDBVersionSupported() { return GdbDebugServicesFactory.GDB_7_7_VERSION; } <END> \/\/ update this GDB_7_12_VERSION'","output":"protected String getMinGDBVersionSupported() { return GdbDebugServicesFactory.GDB_7_12_VERSION; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is unnecessary'\nThe code is: 'public BenchmarkSuiteConfig setSuite(String suite) { <START> if (suite != null) { this.suite = suite; } <END> \/\/ This is unnecessary return this; }'","output":"public BenchmarkSuiteConfig setSuite(String suite) { this.suite = suite; return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'BTW, I agree @coverbeck this, parallelStream is more complex needed here. a normal stream templating this V2 version, thanks'\nThe code is: 'public List<ToolVersionV1> getVersionsV1() { List<ToolVersion> toolVersions = this.tool.getVersions(); <START> return toolVersions.parallelStream().map(toolVersion -> new ToolVersionV1(toolVersion)).collect(Collectors.toList()); <END> \/\/ BTW, I agree @coverbeck this, parallelStream is more complex needed here. a normal stream templating this V2 version, thanks }'","output":"public List<ToolVersionV1> getVersionsV1() { List<ToolVersion> toolVersions = this.tool.getVersions(); return toolVersions.stream().map(toolVersion -> new ToolVersionV1(toolVersion)).collect(Collectors.toList()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Maybe, a solution wrt visibility move LanguageMetricsProvider out of ApexHandler, this package. ApexMetrics change for 7.0 (apart this method), while LanguageMetricsProvider is experimental remove new API freely in 7.0'\nThe code is: '<START> public static void reset() { <END> \/\/ Maybe, a solution wrt visibility move LanguageMetricsProvider out of ApexHandler, this package. ApexMetrics change for 7.0 (apart this method), while LanguageMetricsProvider is experimental remove new API freely in 7.0 FACADE.reset(); }'","output":"static void reset() { FACADE.reset(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'isEmpty() please'\nThe code is: 'public List<FlowLog> getFlowLogsByFlowIdsCreatedDesc(Set<String> flowIds) { LOGGER.info(\"Getting flow logs by these flow ids: {}\", Joiner.on(\",\").join(flowIds)); <START> if (flowIds.size() > 0) { <END> \/\/ isEmpty() please return flowLogRepository.findAllByFlowIdsCreatedDesc(flowIds); } else { return Collections.emptyList(); } }'","output":"public List<FlowLog> getFlowLogsByFlowIdsCreatedDesc(Set<String> flowIds) { LOGGER.info(\"Getting flow logs by these flow ids: {}\", Joiner.on(\",\").join(flowIds)); if (!flowIds.isEmpty()) { return flowLogRepository.findAllByFlowIdsCreatedDesc(flowIds); } else { return Collections.emptyList(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'sense assertEquals below, actual in failing case'\nThe code is: 'public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); <START> assertTrue(tbm.getSize() == 0); <END> \/\/ sense assertEquals below, actual in failing case MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertTrue(tbm.getSize() == 1); }'","output":"public void testDynamicItem_AddOne() { contextRule.createAndRunWorkbench(window); ToolBarManager tbm = getManager(toolBar); assertEquals(tbm.getSize(), 0); MToolItem toolItem1 = ems.createModelElement(MDirectToolItem.class); toolBar.getChildren().add(toolItem1); assertEquals(tbm.getSize(), 1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return ReadOnlyArray ReadOnlyArrayInterface. IIRC, ReadOnlyArrayInterface is internal for Java'\nThe code is: '<START> public ReadOnlyArrayInterface getArray(int index) { <END> \/\/ return ReadOnlyArray ReadOnlyArrayInterface. IIRC, ReadOnlyArrayInterface is internal for Java return (ReadOnlyArrayInterface) fleeceValueToObject(index); }'","output":"public ReadOnlyArray getArray(int index) { return (ReadOnlyArray) fleeceValueToObject(index); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Java if (lookupBoundClass(entityClass) == null) { bindEntity(entityClass); } simpler more straight forward'\nThe code is: 'private void bindIfUnbound(Class<?> entityClass) { if (lookupBoundClass(entityClass) != null) { return; } <START> bindEntity(entityClass); <END> \/\/ Java if (lookupBoundClass(entityClass) == null) { bindEntity(entityClass); } simpler more straight forward }'","output":"private void bindIfUnbound(Class<?> entityClass) { if (lookupBoundClass(entityClass) == null) { bindEntity(entityClass); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reuse existing constructors? public PermissionsOperationsParameters(Permission permission, Guid targetId) { this(permission); this.targetId = targetId; }'\nThe code is: 'public PermissionsOperationsParameters(Permission permission, Guid targetId) { <START> this.permission = permission; <END> \/\/ reuse existing constructors? public PermissionsOperationsParameters(Permission permission, Guid targetId) { this(permission); this.targetId = targetId; } this.targetId = targetId; }'","output":"public PermissionsOperationsParameters(Permission permission, Guid targetId) { this(permission); this.targetId = targetId; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Revert WARN'\nThe code is: 'public void receiveCommand(String itemName, Command command) { logger.trace(\"receiveCommand({},{}) called.\", itemName, command.toString()); if (this.eventPublisher == null) { <START> logger.error(\"receiveCommand(): eventPublisher is NULL. Should NEVER occur.\"); <END> \/\/ Revert WARN return; } super.receiveCommand(itemName, command); }'","output":"public void receiveCommand(String itemName, Command command) { logger.trace(\"receiveCommand({},{}) called.\", itemName, command.toString()); if (this.eventPublisher == null) { logger.warn(\"receiveCommand(): eventPublisher is NULL. Should NEVER occur.\"); return; } super.receiveCommand(itemName, command); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo above, be: return this.rpmRevision;'\nThe code is: 'public String getRpmRevision() { <START> return this.rpmRevison; <END> \/\/ typo above, be: return this.rpmRevision; }'","output":"public String getRpmRevision() { return this.rpmRevision; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This public'\nThe code is: '<START> public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { <END> \/\/ This public return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); }'","output":"CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if lamda expressions diamond operators available)'\nThe code is: 'public List<ERepositoryObjectType> getTypes() { <START> List<ERepositoryObjectType> toReturn = new ArrayList<ERepositoryObjectType>(); <END> \/\/ if lamda expressions diamond operators available) toReturn.add(ERepositoryObjectType.PROCESS); return toReturn; }'","output":"public List<ERepositoryObjectType> getTypes() { List<ERepositoryObjectType> toReturn = new ArrayList<>(); toReturn.add(ERepositoryObjectType.PROCESS); return toReturn; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'groupIdExisting -> existingGroupId'\nThe code is: 'private boolean groupAndValueMatches(long groupId, Block block, int position, int nodePointer, int valuePosition) { <START> long groupIdExisting = groupIds.get(nodePointer); <END> \/\/ groupIdExisting -> existingGroupId return groupIdExisting == groupId && type.equalTo(block, position, values, valuePosition); }'","output":"private boolean groupAndValueMatches(long groupId, Block block, int position, int nodePointer, int valuePosition) { long existingGroupId = groupIds.get(nodePointer); return existingGroupId == groupId && type.equalTo(block, position, values, valuePosition); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this before, do reasons iterator instead of for-loop'\nThe code is: 'public List<StudentAttributes> getAllCourseStudents() { List<StudentAttributes> list = new LinkedList<StudentAttributes>(); List<CourseStudent> entities = getCourseStudentEntities(); Iterator<CourseStudent> it = entities.iterator(); <START> while (it.hasNext()) { <END> \/\/ this before, do reasons iterator instead of for-loop CourseStudent student = it.next(); if (!JDOHelper.isDeleted(student)) { list.add(new StudentAttributes(student)); } } return list; }'","output":"public List<StudentAttributes> getAllCourseStudents() { List<StudentAttributes> list = new LinkedList<StudentAttributes>(); List<CourseStudent> entities = getCourseStudentEntities(); for (CourseStudent student : entities) { if (!JDOHelper.isDeleted(student)) { list.add(new StudentAttributes(student)); } } return list; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'session unavailable a demo user? if a SessionUnavailableException is thrown'\nThe code is: 'public static boolean isDemoUser() { try { User u = CommCareApplication._().getSession().getLoggedInUser(); return (User.TYPE_DEMO.equals(u.getUserType())); } catch (SessionUnavailableException e) { <START> return true; <END> \/\/ session unavailable a demo user? if a SessionUnavailableException is thrown } }'","output":"public static boolean isDemoUser() { try { User u = CommCareApplication._().getSession().getLoggedInUser(); return (User.TYPE_DEMO.equals(u.getUserType())); } catch (SessionUnavailableException e) { return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'SQL.sanitizeCondition also'\nThe code is: 'public void testInvalidCondition() throws Exception { final String query = \"and if(length(user())>0,sleep(10),2)\"; <START> final String s = SQLUtil.sanitizeParameter( query ); <END> \/\/ SQL.sanitizeCondition also assertNotNull(s); assertEquals(StringPool.BLANK, s); }'","output":"public void testInvalidCondition() throws Exception { final String query = \"and if(length(user())>0,sleep(10),2)\"; final String s = SQLUtil.sanitizeCondition( query ); assertNotNull(s); assertEquals(StringPool.BLANK, s); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Hmm... getActiveInstance() is deprecated in modern versions of Jenkins (as is getInstance()) - Jenkins.get() is favored days (ever Jenkins version 2.98). update this code already-outdated call, a idea bump minimum version of Jenkins required 2.98 (we require Java 8, _actually_ Jenkins 1.642.3 anymore) call Jenkins.get() instead. @olivergondza WDYT'\nThe code is: 'public FormValidation doCheckEndPointUrl(@QueryParameter String value) { <START> Jenkins.getActiveInstance().checkPermission(Jenkins.ADMINISTER); <END> \/\/ Hmm... getActiveInstance() is deprecated in modern versions of Jenkins (as is getInstance()) - Jenkins.get() is favored days (ever Jenkins version 2.98). update this code already-outdated call, a idea bump minimum version of Jenkins required 2.98 (we require Java 8, _actually_ Jenkins 1.642.3 anymore) call Jenkins.get() instead. @olivergondza WDYT if (Util.fixEmpty(value) == null) return FormValidation.validateRequired(value); try { new URL(value); } catch (MalformedURLException ex) { return FormValidation.error(ex, \"The endpoint must be URL\"); } return FormValidation.ok(); }'","output":"public FormValidation doCheckEndPointUrl(@QueryParameter String value) { Jenkins.get().checkPermission(Jenkins.ADMINISTER); if (Util.fixEmpty(value) == null) return FormValidation.validateRequired(value); try { new URL(value); } catch (MalformedURLException ex) { return FormValidation.error(ex, \"The endpoint must be URL\"); } return FormValidation.ok(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Default access is good enough is consistent PartialDefaultRecord'\nThe code is: '<START> protected DefaultRecord(int sizeInBytes, <END> \/\/ Default access is good enough is consistent PartialDefaultRecord byte attributes, long offset, long timestamp, int sequence, ByteBuffer key, ByteBuffer value, Header[] headers) { this.sizeInBytes = sizeInBytes; this.attributes = attributes; this.offset = offset; this.timestamp = timestamp; this.sequence = sequence; this.key = key; this.value = value; this.headers = headers; }'","output":"DefaultRecord(int sizeInBytes, byte attributes, long offset, long timestamp, int sequence, ByteBuffer key, ByteBuffer value, Header[] headers) { this.sizeInBytes = sizeInBytes; this.attributes = attributes; this.offset = offset; this.timestamp = timestamp; this.sequence = sequence; this.key = key; this.value = value; this.headers = headers; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Adding this a field is good manner'\nThe code is: 'public EndNode onboardEndnodeWithGateway( @NonNull PendingEndNode pendingEndNode, @NonNull String endnodePassword, @Nullable OnboardEndnodeWithGatewayOptions options) throws ThingIFException { <START> return thingIfApi.onboardEndnodeWithGateway(pendingEndNode, endnodePassword, options); <END> \/\/ Adding this a field is good manner }'","output":"public EndNode onboardEndnodeWithGateway( @NonNull PendingEndNode pendingEndNode, @NonNull String endnodePassword, @Nullable OnboardEndnodeWithGatewayOptions options) throws ThingIFException { return this.thingIfApi.onboardEndnodeWithGateway(pendingEndNode, endnodePassword, options); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simply call? return build(Stage.PRODUCTION);'\nThe code is: 'public GuiceBundle<T> build() { <START> return new GuiceBundle<T>(Stage.PRODUCTION, autoConfig, modules, configurationClass); <END> \/\/ simply call? return build(Stage.PRODUCTION); }'","output":"public GuiceBundle<T> build() { return build(Stage.PRODUCTION); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);'\nThe code is: 'public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateTimerEvent emptyTopEvent = getCatchingIntermediateNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_NO_OUTGOING_EDGE); assertGeneralSet(emptyTopEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, \"\"); <END> \/\/ suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE); }'","output":"public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateTimerEvent emptyTopEvent = getCatchingIntermediateNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_NO_OUTGOING_EDGE); assertGeneralSet(emptyTopEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method unchanged is modify interface Catalog. Instead add null checks this method is used'\nThe code is: 'public ValidationLayer getValidationLayer() throws CatalogException { if(valLayer != null) { return valLayer; } else { <START> throw new CatalogException(\"validation layer is not initialized\"); <END> \/\/ this method unchanged is modify interface Catalog. Instead add null checks this method is used } }'","output":"public ValidationLayer getValidationLayer() { return valLayer; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catching InterrptedException, reset state via: java Thread.currentThread().interrupt();'\nThe code is: 'public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) { try { sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { <START> log.warn(\"Error occurred while sleeping\", e); <END> \/\/ catching InterrptedException, reset state via: java Thread.currentThread().interrupt(); } return true; }'","output":"public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) { try { sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { log.warn(\"Error occurred while sleeping\", e); Thread.currentThread().interrupt(); } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'literalEncoder.toExpression() returns Expression if is instanceof Expression, a NullLiteral if equals null. I get rid of if statements return literalEncoder.toExpression(value,BOOLEAN). add a visitNullLiteral FilterExpressionStatsCalculatingVisitor'\nThe code is: 'private Expression simplifyExpression(Session session, Expression predicate, TypeProvider types) { Map<NodeRef<Expression>, Type> expressionTypes = getExpressionTypes(session, predicate, types); ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(predicate, metadata, session, expressionTypes); Object value = interpreter.optimize(NoOpSymbolResolver.INSTANCE); <START> if (value instanceof Expression) { <END> \/\/ literalEncoder.toExpression() returns Expression if is instanceof Expression, a NullLiteral if equals null. I get rid of if statements return literalEncoder.toExpression(value,BOOLEAN). add a visitNullLiteral FilterExpressionStatsCalculatingVisitor return (Expression) value; } if (value == null) { value = false; } return literalEncoder.toExpression(value, BOOLEAN); }'","output":"private Expression simplifyExpression(Session session, Expression predicate, TypeProvider types) { Map<NodeRef<Expression>, Type> expressionTypes = getExpressionTypes(session, predicate, types); ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(predicate, metadata, session, expressionTypes); Object value = interpreter.optimize(NoOpSymbolResolver.INSTANCE); if (value == null) { value = false; } return literalEncoder.toExpression(value, BOOLEAN); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'again. please throw original exception'\nThe code is: 'public T remove(int index) { try { T removedObject = super.remove(index); comparingSet.remove(removedObject); return removedObject; <START> } catch (IndexOutOfBoundsException ioobException) { <END> \/\/ again. please throw original exception throw new IndexOutOfBoundsException(); } }'","output":"public T remove(int index) { try { T removedObject = super.remove(index); comparingSet.remove(removedObject); return removedObject; } catch (IndexOutOfBoundsException ioobException) { throw ioobException; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this mapping happen public enum mapping backend enum string'\nThe code is: '<START> public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType hookContentType, <END> \/\/ this mapping happen public enum mapping backend enum string String template) { switch (hookContentType) { case BINARY: return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.BINARY.toString(); case TEXT: return org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType.TEXT.toString(); default: return null; } }'","output":"public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterHookContentType hookContentType, String template) { switch (hookContentType) { case BINARY: return HookContentType.BINARY.toString(); case TEXT: return HookContentType.TEXT.toString(); default: return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add \"this\" qualifier'\nThe code is: 'public List<DataSample> getData() { <START> return data; <END> \/\/ Add \"this\" qualifier }'","output":"public List<DataSample> getData() { return this.data; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I log warn.. need for special logger'\nThe code is: 'private boolean flowControl(int size) { boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { <START> ActiveMQServerLogger.LOGGER.failedToStopReplicationServer(e); <END> \/\/ I log warn.. need for special logger } } return flowWorked; }'","output":"private boolean flowControl(int size) { boolean flowWorked = replicatingChannel.getConnection().blockUntilWritable(size, timeout); if (!flowWorked) { try { ActiveMQServerLogger.LOGGER.slowReplicationResponse(); stop(); } catch (Exception e) { logger.warn(e.getMessage(), e); } } return flowWorked; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertKeyPair(file, null);'\nThe code is: 'public void loadKeyOpenSSH() throws IOException, GeneralSecurityException { File file = new File(this.getClass().getResource(\"openssh\").getFile()); <START> assertkeyPair(file, null); <END> \/\/ suggestion assertKeyPair(file, null); }'","output":"public void loadKeyOpenSSH() throws IOException, GeneralSecurityException { File file = new File(this.getClass().getResource(\"openssh\").getFile()); assertKeyPairNotNull(file, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this protected? override if is public'\nThe code is: '<START> protected boolean hasChanges() { <END> \/\/ this protected? override if is public return hasChanges; }'","output":"public boolean hasChanges() { return hasChanges; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Override this line'\nThe code is: '<START> public long length() { <END> \/\/ @Override this line return length; }'","output":"@Override public long length() { return length; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'In this case isShortwill a default of false - I assume is OK? a common pattern for multiple constructors is call \"full\" passing in defaults for missing values: PostMessageField(String title, String value) { self(title, value, false) }'\nThe code is: 'public PostMessageField(String title, String value) { this.title = title; <START> this.value = value; <END> \/\/ In this case isShortwill a default of false - I assume is OK? a common pattern for multiple constructors is call \"full\" passing in defaults for missing values: PostMessageField(String title, String value) { self(title, value, false) } }'","output":"public PostMessageField(String title, String value) { this(title, value, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'pass thiz type Object instead of thiz.toString() here, JBoss logger call toString() automatically, if for some reason thiz is null, throw NPE this code'\nThe code is: 'public Object get(Object thiz) { try { return getter.invoke( thiz ); } catch (Error e) { throw e; } catch (Throwable e) { if ( e instanceof InterruptedException ) { Thread.currentThread().interrupt(); } <START> throw log.errorInvokingMember( member.getName(), thiz.toString(), e ); <END> \/\/ pass thiz type Object instead of thiz.toString() here, JBoss logger call toString() automatically, if for some reason thiz is null, throw NPE this code } }'","output":"public Object get(Object thiz) { try { return getter.invoke( thiz ); } catch (Error e) { throw e; } catch (Throwable e) { if ( e instanceof InterruptedException ) { Thread.currentThread().interrupt(); } throw log.errorInvokingMember( member, thiz, e ); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'stick existing coding style omit Assert. prefix here'\nThe code is: 'public void htmlFlag(){ String results = (String) Eclim.execute(new String[]{ \"java_element_doc\", \"-p\", Jdt.TEST_PROJECT, \"-f\", TEST_FILE, \"-o\", \"255\", \"-l\", \"11\", \"-e\", \"utf-8\", \"-h\", \"true\" }); <START> Assert.assertTrue(\"HTML Format expected\", results.startsWith(\"<html><head>\")); <END> \/\/ stick existing coding style omit Assert. prefix here }'","output":"public void htmlFlag(){ String results = (String) Eclim.execute(new String[]{ \"java_element_doc\", \"-p\", Jdt.TEST_PROJECT, \"-f\", TEST_FILE, \"-o\", \"255\", \"-l\", \"11\", \"-e\", \"utf-8\", \"-h\", \"true\" }); assertTrue(\"HTML Format expected\", results.startsWith(\"<html><head>\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I print content of 'input' pass 'e' (exception) a argument of RuntimeExeption c'tor call'\nThe code is: 'public static String mapToJsonUnchecked(Map<String, Object> input) { try { return mapToJson(input); } catch (IOException e) { throw new RuntimeException(String.format(\"Object \\\"%s\\\" cannot be serialized to JSON.\", <START> e)); <END> \/\/ I print content of 'input' pass 'e' (exception) a argument of RuntimeExeption c'tor call } }'","output":"public static String mapToJsonUnchecked(Map<String, Object> input) { try { return mapToJson(input); } catch (IOException e) { throw new RuntimeException(String.format(\"Object \\\"%s\\\" cannot be serialized to JSON.\", input), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Breaks encapsulation. Consider return Collections.unmodifiableSet(myAppliesToProfiles). for other collection accessors'\nThe code is: 'public Set<String> getAppliesToProfiles() { <START> return myAppliesToProfiles; <END> \/\/ Breaks encapsulation. Consider return Collections.unmodifiableSet(myAppliesToProfiles). for other collection accessors }'","output":"public Set<String> getAppliesToProfiles() { return Collections.unmodifiableSet(myAppliesToProfiles); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a try resources'\nThe code is: 'private void createSmallBam(final File outputFile) { final SAMFileWriterFactory factory = new SAMFileWriterFactory(); factory.setCreateIndex(true); factory.setCreateMd5File(true); final SAMFileHeader header = new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.coordinate); header.addSequence(new SAMSequenceRecord(\"chr1\", 123)); final SAMFileWriter writer = factory.makeBAMWriter(header, false, outputFile); fillSmallBam(writer); <START> writer.close(); <END> \/\/ this a try resources }'","output":"private void createSmallBam(final File outputFile) { final SAMFileWriterFactory factory = new SAMFileWriterFactory(); factory.setCreateIndex(true); factory.setCreateMd5File(true); final SAMFileHeader header = new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.coordinate); header.addSequence(new SAMSequenceRecord(\"chr1\", 123)); try (final SAMFileWriter writer = factory.makeBAMWriter(header, false, outputFile)) { fillSmallBam(writer); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Revert this'\nThe code is: 'public ExtendedUser(final ByteBuf buffer) throws InvalidPacketException { this.src_charset = new Charset(buffer); <START> this.src_user = new Opaque(buffer, Optional.empty(), buffer1 -> Opaque.parseBytes(buffer1)); <END> \/\/ Revert this this.dst_charset = new Charset(buffer); this.dst_user = new Opaque(buffer, Optional.empty(), buffer1 -> Opaque.parseBytes(buffer1)); }'","output":"public ExtendedUser(final ByteBuf buffer) throws InvalidPacketException { this.src_charset = new Charset(buffer); this.src_user = new Opaque(buffer, Optional.empty(), Opaque::parseBytes); this.dst_charset = new Charset(buffer); this.dst_user = new Opaque(buffer, Optional.empty(), Opaque::parseBytes); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: this is necessary, false is default'\nThe code is: 'public SourceOperatorStreamTask(Environment env) throws Exception { super(env); <START> this.isExternallyInducedSource = false; <END> \/\/ nit: this is necessary, false is default }'","output":"public SourceOperatorStreamTask(Environment env) throws Exception { super(env); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'avoid this null check initialization in field declaration. Besides LGTM'\nThe code is: 'public HermesClient build() { if (retryCondition == null) { <START> retryCondition = new HermesClientBasicRetryCondition(); <END> \/\/ avoid this null check initialization in field declaration. Besides LGTM } return new HermesClient(sender, uri, retries, retryCondition); }'","output":"public HermesClient build() { return new HermesClient(sender, uri, retries, retryCondition); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Need do a stricter check that. if is a layer store named \"script\" for some reason? a GET for layer this converter'\nThe code is: 'public void encodeLink(String link, HierarchicalStreamWriter writer) { String path = request.getRequestURI(); <START> if (path.contains(\"script\")) { <END> \/\/ Need do a stricter check that. if is a layer store named \"script\" for some reason? a GET for layer this converter try { link = URLDecoder.decode(link, \"UTF-8\"); encodeAlternateAtomLinkNoExt(link, writer); writer.addAttribute(\"type\", getMediaType()); writer.endNode(); } catch (UnsupportedEncodingException e) { } } else { encodeAlternateAtomLink(link, writer); } }'","output":"public void encodeLink(String link, HierarchicalStreamWriter writer) { if (checkPath(request)) { try { link = URLDecoder.decode(link, \"UTF-8\"); encodeAlternateAtomLinkNoExt(link, writer); writer.addAttribute(\"type\", getMediaType()); writer.endNode(); } catch (UnsupportedEncodingException e) { } } else { encodeAlternateAtomLink(link, writer); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'code in this method thing, link element. considered extracting call: getLinkRedirectTitle(externalLinks.get(index)) getLinkRedirectTitle(internalLinks.get(index))'\nThe code is: '<START> public String getInternalLinkRedirectTitleWithIndex(int index) { <END> \/\/ code in this method thing, link element. considered extracting call: getLinkRedirectTitle(externalLinks.get(index)) getLinkRedirectTitle(internalLinks.get(index)) wait.forElementVisible(internalLink.get(index)); scrollToElement(internalLink.get(index)); return internalLink.get(index).getAttribute(\"href\"); }'","output":"public String getInternalLinkRedirectTitleWithIndex(int index) { return getLinkRedirectTitle(internalLinks.get(index)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Code style: curly brackets, space if'\nThe code is: 'private void decodeRowType4() throws IOException { <START> if(optionByteAligned) resetBuffer(); <END> \/\/ Code style: curly brackets, space if eof: while (true) { Node n = eolOnlyTree.root; while (true) { n = n.walk(readBit()); if (n == null) { continue eof; } if (n.isLeaf) { break eof; } } } if (!optionG32D || readBit()) { decode1D(); } else { decode2D(); } }'","output":"private void decodeRowType4() throws IOException { if (optionByteAligned) { resetBuffer(); } eof: while (true) { Node n = eolOnlyTree.root; while (true) { n = n.walk(readBit()); if (n == null) { continue eof; } if (n.isLeaf) { break eof; } } } if (!optionG32D || readBit()) { decode1D(); } else { decode2D(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This needs changed TestUtills.runRepairability(\"JKali\", \"\/repairability_test_files\/JKali\/\"); argument is name of tool'\nThe code is: 'public void JKaliTest() throws Exception { <START> FinalResult result = TestUtills.runRepairability(\"JKaliTest\", \"\/repairability_test_files\/JKali\/\"); <END> \/\/ This needs changed TestUtills.runRepairability(\"JKali\", \"\/repairability_test_files\/JKali\/\"); argument is name of tool TestUtills.numberOfInstances(result, 5, 5); }'","output":"public void JKaliTest() throws Exception { FinalResult result = TestUtills.runRepairability(\"JKali\", \"\/repairability_test_files\/JKali\/\"); TestUtills.numberOfInstances(result, 5, 5); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I would've OK a 0 here, == matters -- problem'\nThe code is: 'private static boolean equals(float a, float b) { <START> return Float.compare(a, b) == COMPARE_EQUALS; <END> \/\/ I would've OK a 0 here, == matters -- problem }'","output":"private static boolean equals(float a, float b) { return Float.compare(a, b) == 0; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change to: return mode;'\nThe code is: 'public String getMode() { <START> return mode.toString(); <END> \/\/ Change to: return mode; }'","output":"public String getMode() { return mode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Likewise.'\nThe code is: 'public void handleUnimprovedHoursSpentInputChange( ChangeEvent event ) { try { Long value = unimprovedHoursSpentInput.getValue().isEmpty() ? null : Long.parseLong( unimprovedHoursSpentInput.getValue() ); presenter.onUnimprovedHoursSpentChange( value ); } catch ( NumberFormatException e ) { <START> <END> \/\/ Likewise. } }'","output":"public void handleUnimprovedHoursSpentInputChange( ChangeEvent event ) { boolean isNumeric = unimprovedHoursSpentInput.getValue().matches( \"\\\\d+\" ); if (isNumeric) { presenter.onUnimprovedHoursSpentChange( Long.parseLong( unimprovedHoursSpentInput.getValue() ) ); } else { presenter.onUnimprovedHoursSpentChange( 0l ); unimprovedHoursSpentInput.setValue( \"0\" ); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Minor: locateMemberTests renamed locateTestsArtifact, downloadMemberTests renamed, too'\nThe code is: '<START> private static File locateTestsArtifact(String version, File target, boolean enterprise) { <END> \/\/ Minor: locateMemberTests renamed locateTestsArtifact, downloadMemberTests renamed, too File artifact = new File(LOCAL_M2_REPOSITORY_PREFIX + constructPathForTests(version, enterprise)); if (artifact.exists()) { return artifact; } else { return downloadMemberTests(version, target, enterprise); } }'","output":"private static File locateTestsArtifact(String version, File target, boolean enterprise) { File artifact = new File(LOCAL_M2_REPOSITORY_PREFIX + constructPathForTests(version, enterprise)); if (artifact.exists()) { return artifact; } else { return downloadTestsArtifact(version, target, enterprise); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'making method implementation be: return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE);'\nThe code is: 'private boolean isDraft(final ReceiveCommand cmd) { <START> String refName = cmd.getRefName(); <END> \/\/ making method implementation be: return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE); if (refName.startsWith(NEW_DRAFT_CHANGE)) { return true; } return false; }'","output":"private boolean isDraft(final ReceiveCommand cmd) { return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IllegalArgumentException'\nThe code is: 'public String getServerSpecificRoot(String hostId) { if (!m_hostRoots.containsKey(hostId)) { <START> throw new RuntimeException(\"getServerSpecificRoot possibly called before cluster has started.\"); <END> \/\/ IllegalArgumentException } return m_hostRoots.get(hostId) + \"\/voltdbroot\"; }'","output":"public String getServerSpecificRoot(String hostId) { if (!m_hostRoots.containsKey(hostId)) { throw new IllegalArgumentException(\"getServerSpecificRoot possibly called before cluster has started.\"); } return m_hostRoots.get(hostId) + \"\/voltdbroot\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove this committing'\nThe code is: 'private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); <START> Assert.assertTrue(\"test\", false); <END> \/\/ Please remove this committing }'","output":"private void compare(ByteString a, ByteString b) { Assert.assertTrue(underTest.compare(a, b) < 0); Assert.assertTrue(underTest.compare(b, a) > 0); Assert.assertTrue(underTest.compare(b, b) == 0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this. is needed. targetDomainName field volatile checked modified invalidated threads'\nThe code is: 'public void invalidate() { <START> this.targetDomainName = null; <END> \/\/ this. is needed. targetDomainName field volatile checked modified invalidated threads }'","output":"public void invalidate() { targetDomainName = null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'computeIfAbsent() work for here'\nThe code is: 'protected String getQuery(Query queryName, Supplier<String> queryProvider) { <START> String query = this.queryCache.get(queryName); <END> \/\/ computeIfAbsent() work for here if (query == null) { query = StringUtils.replace(queryProvider.get(), \"%PREFIX%\", this.tablePrefix); this.queryCache.put(queryName, query); } return query; }'","output":"protected String getQuery(Query queryName, Supplier<String> queryProvider) { return this.queryCache.computeIfAbsent(queryName, k -> StringUtils.replace(queryProvider.get(), \"%PREFIX%\", this.tablePrefix)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@t-izbassar I clear, default matcher in Hamcrest library is Matchers.equalTo(), a user of HmRqTextBody expect body is equal constructor parameter string'\nThe code is: 'public HmRqTextBody(final String expected) { <START> this(Matchers.containsString(expected)); <END> \/\/ @t-izbassar I clear, default matcher in Hamcrest library is Matchers.equalTo(), a user of HmRqTextBody expect body is equal constructor parameter string }'","output":"public HmRqTextBody(final String expected) { this(Matchers.equalTo(expected)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add more descriptive name instead of element? templateName, templateElement template'\nThe code is: 'public VisualEditorPageObject selectInfoboxTemplate(int i) { WebElement element = infoboxTemplatesList.get(i); wait.forElementClickable(element); <START> element.click(); <END> \/\/ add more descriptive name instead of element? templateName, templateElement template return this; }'","output":"public VisualEditorPageObject selectInfoboxTemplate(int i) { WebElement template = infoboxTemplatesList.get(i); wait.forElementClickable(template); template.click(); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new HashMap<>();'\nThe code is: 'public GCSAvroOutputFormatProvider(GCSAvroSinkConfig config, BatchSinkContext context) { <START> conf = Maps.newHashMap(); <END> \/\/ new HashMap<>(); conf.put(JobContext.OUTPUT_KEY_CLASS, AvroKey.class.getName()); conf.put(\"avro.schema.output.key\", config.schema); conf.put(FileOutputFormat.OUTDIR, String.format(\"gs:\/\/%s\/%s\", config.bucketKey, config.path)); }'","output":"public GCSAvroOutputFormatProvider(GCSAvroSinkConfig config, BatchSinkContext context) { conf = new HashMap<>(); conf.put(JobContext.OUTPUT_KEY_CLASS, AvroKey.class.getName()); conf.put(\"avro.schema.output.key\", config.schema); conf.put(FileOutputFormat.OUTDIR, String.format(\"gs:\/\/%s\/%s\", config.bucketKey, config.path)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove useless super()'\nThe code is: 'public UniqueConstraintDetails(Label label, String property) { <START> super(); <END> \/\/ remove useless super() this.label = label; this.property = property; }'","output":"public UniqueConstraintDetails(Label label, String property) { this.label = label; this.property = property; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I find strange websocket is a member of connectionAttemptState, simply a member of XmppWebsocketTransportModule instead'\nThe code is: 'protected void disconnect() { <START> connectionAttemptState.websocket.disconnect(1000, \"Websocket closed normally\"); <END> \/\/ I find strange websocket is a member of connectionAttemptState, simply a member of XmppWebsocketTransportModule instead }'","output":"protected void disconnect() { websocket.disconnect(1000, \"Websocket closed normally\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline key IMO'\nThe code is: 'public Map.Entry<K, Collection<V>> next() { final Map.Entry<K, Collection<V>> entry = super.next(); final K key = entry.getKey(); final Collection<V> value = entry.getValue(); <START> return new UnmodifiableMapEntry<>(key, value); <END> \/\/ inline key IMO }'","output":"public Map.Entry<K, Collection<V>> next() { final Map.Entry<K, Collection<V>> entry = super.next(); return new UnmodifiableMapEntry<>(entry.getKey(), entry.getValue()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'instance of ServoControl Servo.. :)'\nThe code is: 'public void onJointAngles(Map<String, Double> angleMap) { for (String name : angleMap.keySet()) { ServiceInterface si = Runtime.getService(name); <START> if (si instanceof Servo) { <END> \/\/ instance of ServoControl Servo.. :) ((Servo) si).moveTo(angleMap.get(name)); } } }'","output":"public void onJointAngles(Map<String, Double> angleMap) { for (String name : angleMap.keySet()) { ServiceInterface si = Runtime.getService(name); if (si instanceof ServoControl) { ((ServoControl) si).moveTo(angleMap.get(name)); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'provide a default, in case of this header is missing. I guess do like: java String charset = Objects.firstNonNull(request.getHeader(\"Accept-Charset\"), \"UTF-8\"); return charset.split(\",\")[0];'\nThe code is: 'private String getRequestCharset() { String charset = request.getHeader(\"Accept-Charset\"); if(charset != null) { charset = charset.split(\",\")[0]; } <START> return charset; <END> \/\/ provide a default, in case of this header is missing. I guess do like: java String charset = Objects.firstNonNull(request.getHeader(\"Accept-Charset\"), \"UTF-8\"); return charset.split(\",\")[0]; }'","output":"private String getRequestCharset() { String charset = Objects.firstNonNull(request.getHeader(\"Accept-Charset\"), \"UTF-8\"); return charset.split(\",\")[0]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Put setters end of file'\nThe code is: '<START> void setStudyDataManager(final StudyDataManager studyDataManager) { <END> \/\/ Put setters end of file this.studyDataManager = studyDataManager; }'","output":"public void setStudyDataManager(final StudyDataManager studyDataManager) { this.studyDataManager = studyDataManager; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'While it, remove redundant this. well'\nThe code is: 'public void clickDisplayedToStudentCheckBox(int instrNum) { <START> this.getDisplayedToStudentCheckBox(instrNum).click(); <END> \/\/ While it, remove redundant this. well }'","output":"public void clickDisplayedToStudentCheckBox(int instrNum) { getDisplayedToStudentCheckBox(instrNum).click(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'subtask != task lines be: SubMonitor.convert(monitor, \/title\/, 1); (other cases of marked ditto2)'\nThe code is: 'public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); int totalSelected = selection.length; if (totalSelected > 0) { if (monitor == null) { monitor = new NullProgressMonitor(); } SubMonitor submonitor = SubMonitor.convert(monitor, 1); <START> submonitor.subTask(CUIPlugin.getResourceString(KEY_TITLE)); <END> \/\/ subtask != task lines be: SubMonitor.convert(monitor, \/title\/, 1); (other cases of marked ditto2) convertProjects(selection, submonitor.split(1), projectID); } }'","output":"public void doRun(IProgressMonitor monitor, String projectID) throws CoreException { Object[] selection = getCheckedElements(); int totalSelected = selection.length; if (totalSelected > 0) { SubMonitor submonitor = SubMonitor.convert(monitor, CUIPlugin.getResourceString(KEY_TITLE), 1); convertProjects(selection, submonitor.split(1), projectID); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a singleton instance of DefaultVariableNameFunction'\nThe code is: 'public EntityType(Type type) { <START> this(type, new LinkedHashSet<Supertype>(), new DefaultVariableNameFunction()); <END> \/\/ a singleton instance of DefaultVariableNameFunction }'","output":"public EntityType(Type type) { this(type, new LinkedHashSet<Supertype>(), DefaultVariableNameFunction.INSTANCE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'u extract a final constant a readable name out of \"<[ ]*%s[ ]*>\"'\nThe code is: 'public String getOpenTagPattern() { <START> return String.format(\"<[ ]*%s[ ]*>\", this.xmlName); <END> \/\/ u extract a final constant a readable name out of \"<[ ]*%s[ ]*>\" }'","output":"public String getOpenTagPattern() { return String.format(OPEN_TAG_PATTERN, this.xmlName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add @Inject annotation remove public modifier constructor package private ([background](<LINK_0>'\nThe code is: '<START> public OperatingSystemToOperatingSystem(final OperatingSystemToOsFamily operatingSystemToOsFamily) { <END> \/\/ Add @Inject annotation remove public modifier constructor package private ([background](<LINK_0> this.operatingSystemToOsFamily = operatingSystemToOsFamily; }'","output":"OperatingSystemToOperatingSystem(final OperatingSystemToOsFamily operatingSystemToOsFamily) { this.operatingSystemToOsFamily = operatingSystemToOsFamily; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'hide this expose factory method'\nThe code is: '<START> public LBClient(ILoadBalancer lb, IClientConfig clientConfig) { <END> \/\/ hide this expose factory method super(lb, clientConfig); this.setRetryHandler(RetryHandler.DEFAULT); this.clientConfig = clientConfig; connectTimeout = clientConfig.get(CommonClientConfigKey.ConnectTimeout); readTimeout = clientConfig.get(CommonClientConfigKey.ReadTimeout); }'","output":"LBClient(ILoadBalancer lb, IClientConfig clientConfig) { super(lb, clientConfig); this.setRetryHandler(RetryHandler.DEFAULT); this.clientConfig = clientConfig; connectTimeout = clientConfig.get(CommonClientConfigKey.ConnectTimeout); readTimeout = clientConfig.get(CommonClientConfigKey.ReadTimeout); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Empty list instead of null'\nThe code is: 'public List<Element> previousElementSiblings() { if (parentNode == null) { return null; } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } <START> return null; <END> \/\/ Empty list instead of null }'","output":"public List<Element> previousElementSiblings() { if (parentNode == null) { return Collections.emptyList(); } List<Element> siblings = parent().childElementsList(); int index = indexInList(this, siblings); Validate.notNull(index); if (index > 0 && index < siblings.size()) { return siblings.subList(0, index); } return Collections.emptyList(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For other calls of scheduleDirect, use: suggestion Schedulers.io().scheduleDirect(new Runnable() {'\nThe code is: 'private void saveToStorage(final Location coordinates) { <START> Schedulers.io().scheduleDirect(() -> { <END> \/\/ For other calls of scheduleDirect, use: suggestion Schedulers.io().scheduleDirect(new Runnable() { DataStore.saveTrailpoint(coordinates); }); }'","output":"private void saveToStorage(final Location coordinates) { Schedulers.io().scheduleDirect(new Runnable() { @Override public void run() { DataStore.saveTrailpoint(coordinates); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For consistency other infrastructure components, suggest do builder.validate() call in constructor'\nThe code is: '<START> protected AbstractEventGateway(Builder builder) { <END> \/\/ For consistency other infrastructure components, suggest do builder.validate() call in constructor this.eventBus = builder.eventBus; this.dispatchInterceptors = builder.dispatchInterceptors; }'","output":"protected AbstractEventGateway(Builder builder) { builder.validate(); this.eventBus = builder.eventBus; this.dispatchInterceptors = builder.dispatchInterceptors; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need flush? dealing single stream anyway, writes serialized (and synchronize this anyway), I care order long chunks interleaved, happening write chunk synchronized'\nThe code is: 'public InputStream wrap(InputStream inputStream) { if (inputStream == null) return null; ByteArrayOutputStream buffer = new ByteArrayOutputStream(); OutputStream tee = new FilterOutputStream(buffer) { @Override public void close() throws IOException { synchronized (FileStreamDumper.this) { dumpOutput.write(buffer.toByteArray()); <START> dumpOutput.flush(); <END> \/\/ Do need flush? dealing single stream anyway, writes serialized (and synchronize this anyway), I care order long chunks interleaved, happening write chunk synchronized } super.close(); } }; return new TeeInputStream(inputStream, tee, true); }'","output":"public InputStream wrap(InputStream inputStream) { if (inputStream == null) return null; ByteArrayOutputStream buffer = new ByteArrayOutputStream(); OutputStream tee = new FilterOutputStream(buffer) { @Override public void close() throws IOException { synchronized (FileStreamDumper.this) { dumpOutput.write(buffer.toByteArray()); } super.close(); } }; return new TeeInputStream(inputStream, tee, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is below, I fine if want is. java for (final Element element : children) { Position.setY(element, ++parentY); }'\nThe code is: 'public void setInitialPositionY(final HTMLElement dragAndDropElement, final List<HTMLElement> children) { Integer parentY = Position.getY(dragAndDropElement); <START> for (final Element element : children) { parentY++; Position.setY(element, parentY); <END> \/\/ This is below, I fine if want is. java for (final Element element : children) { Position.setY(element, ++parentY); } } }'","output":"public void setInitialPositionY(final HTMLElement dragAndDropElement, final List<HTMLElement> children) { Integer parentY = Position.getY(dragAndDropElement); for (final Element element : children) { Position.setY(element, ++parentY); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this monotonic, nanoTime() for measuring elapsed time'\nThe code is: 'public void check() { if (timeOut > 0 && <START> System.currentTimeMillis() <END> \/\/ this monotonic, nanoTime() for measuring elapsed time - startTime > timeOut) { throw new TaskCancelledException(\"Timed out\"); } }'","output":"public void check() { if (timeOut > 0 && System.nanoTime() - startTime > timeOut) { throw new TaskCancelledException(\"Timed out\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call notFound instead of returning null'\nThe code is: 'public List getList(String key) { for (Config child : children) { if (child.containsKey(key)) { return child.getList(key); } } <START> return null; <END> \/\/ call notFound instead of returning null }'","output":"public List getList(String key) { for (Config child : children) { if (child.containsKey(key)) { return child.getList(key); } } return notFound(key); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Tree.Kind instead, remove import'\nThe code is: '<START> public List<Kind> nodesToVisit() { <END> \/\/ Tree.Kind instead, remove import return ImmutableList.of(Tree.Kind.SWITCH_STATEMENT); }'","output":"public List<Tree.Kind> nodesToVisit() { return ImmutableList.of(Tree.Kind.SWITCH_STATEMENT); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Objects.requireNonNull'\nThe code is: 'BundleBuilder(JUnitFramework ws) { <START> checkNonNullArgument(ws, \"'ws' cannot be null\"); <END> \/\/ Objects.requireNonNull this.ws = ws; bundleSymbolicName(\"test-\" + JUnitFrameworkBuilder.counter.incrementAndGet()); }'","output":"BundleBuilder(JUnitFramework ws) { requireNonNull(ws, \"'ws' cannot be null\"); this.ws = ws; bundleSymbolicName(\"test-\" + JUnitFrameworkBuilder.counter.incrementAndGet()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"url null\"? a completed sentence'\nThe code is: 'public AVideo(URL url) { if (url == null) <START> throw new IllegalArgumentException(\"null url\"); <END> \/\/ \"url null\"? a completed sentence _name = getName(url); _url = url; _isdata = DYNAMIC_STREAM; _data = null; _file = null; }'","output":"public AVideo(URL url) { if (url == null) throw new IllegalArgumentException(\"url cannot be null\"); _name = getName(url); _url = url; _isdata = DYNAMIC_STREAM; _data = null; _file = null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need super(), if class is inheriting a super class'\nThe code is: 'public Target(String targetUriAsString) { <START> super(); <END> \/\/ Do need super(), if class is inheriting a super class Assert.hasText(targetUriAsString, \"The provided targetUriAsString must neither be null nor empty.\"); this.targetUri = URI.create(targetUriAsString); }'","output":"public Target(String targetUriAsString) { Assert.hasText(targetUriAsString, \"The provided targetUriAsString must neither be null nor empty.\"); this.targetUri = URI.create(targetUriAsString); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.singletonList fractionally more efficient'\nThe code is: 'public List<String> getResourcesTypes() { <START> return Lists.newArrayList(\"brooklyn.nodes.Compute\"); <END> \/\/ Collections.singletonList fractionally more efficient }'","output":"public List<String> getResourcesTypes() { return Collections.singletonList(\"brooklyn.nodes.Compute\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add brackets this expression more easy understand'\nThe code is: 'protected boolean includeJavaEngineIndicator() { for (ModelElementIndicator modelElementIndicator : this.treeViewer.getModelElementIndicator()) { if (modelElementIndicator.containsAny(IndicatorEnum.getJavaIndicatorsEnum()) || modelElementIndicator.contains(IndicatorEnum.UserDefinedIndicatorEnum) <START> && searchJUDI(modelElementIndicator, true)) { <END> \/\/ add brackets this expression more easy understand return true; } } return false; }'","output":"protected boolean includeJavaEngineIndicator() { for (ModelElementIndicator modelElementIndicator : this.treeViewer.getModelElementIndicator()) { if (modelElementIndicator.containsAny(IndicatorEnum.getJavaIndicatorsEnum()) || (modelElementIndicator.contains(IndicatorEnum.UserDefinedIndicatorEnum) && searchJUDI( modelElementIndicator, true))) { return true; } } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is common rule? I invertring boolean condition? smart question :). I mean, is more readable? if ( propertyEntries.isEmpty() ) { return null; } return first( propertyEntries) ; }'\nThe code is: 'public PropertyEntry getShallowestProperty() { <START> if ( !propertyEntries.isEmpty() ) { <END> \/\/ Is common rule? I invertring boolean condition? smart question :). I mean, is more readable? if ( propertyEntries.isEmpty() ) { return null; } return first( propertyEntries) ; } return first( propertyEntries ); } return null; }'","output":"public PropertyEntry getShallowestProperty() { if ( propertyEntries.isEmpty() ) { return null; } return first( propertyEntries ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exception'\nThe code is: 'public long getLong(String key) throws NumberFormatException { String setting = items.get(key); if (setting == null) { throw new NumberFormatException( \"There is no setting associated with the key \\\"\" + key + \"\\\"\"); } <START> return Long.valueOf(setting).longValue(); <END> \/\/ exception }'","output":"public long getLong(String key) throws NumberFormatException { String setting = items.get(key); if (setting == null) { throw new NumberFormatException( \"There is no setting associated with the key \\\"\" + key + \"\\\"\"); } return Long.parseLong(setting); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a default switch'\nThe code is: 'public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, \"otherId\"); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; } <START> return false; <END> \/\/ a default switch }'","output":"public boolean matches(ExternalId otherId) { ArgChecker.notNull(otherId, \"otherId\"); switch (searchType) { case EXACT: return ImmutableSet.of(otherId).equals(externalIds); case ALL: return ImmutableSet.of(otherId).containsAll(externalIds); case ANY: return contains(otherId); case NONE: return contains(otherId) == false; default: return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method changed private'\nThe code is: '<START> public void <END> \/\/ this method changed private setBuyOrders(HashMap<String, ArrayList<Order>> buyOrders) { this.buyOrders = buyOrders; }'","output":"private void setBuyOrders(HashMap<String, ArrayList<Order>> buyOrders) { this.buyOrders = buyOrders; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this of for in init is false. I in line 442 of GlusterVolumeSnapshotListModel snapshotModel#getDisableCliSchedule#setEntity right'\nThe code is: 'public void setDisableCliSchedule(EntityModel<Boolean> value) { this.disableCliSchedule = value; <START> this.disableCliSchedule.setIsAvailable(value.getEntity()); <END> \/\/ this of for in init is false. I in line 442 of GlusterVolumeSnapshotListModel snapshotModel#getDisableCliSchedule#setEntity right }'","output":"public void setDisableCliSchedule(EntityModel<Boolean> value) { this.disableCliSchedule = value; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Replace this(in, null)'\nThe code is: 'public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this.classLoader = Thread.currentThread().getContextClassLoader(); <END> \/\/ Replace this(in, null) }'","output":"public TCCLObjectInputStream(InputStream in) throws IOException { this(in, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wrong, be: return message;'\nThe code is: 'public String getMessage() { <START> return name; <END> \/\/ wrong, be: return message; }'","output":"public String getMessage() { return message; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@ekondrashev here, declare Exception thrown'\nThe code is: '<START> public void testsHeaderNotAvailable() throws IOException { <END> \/\/ @ekondrashev here, declare Exception thrown MatcherAssert.assertThat( new RsWithBody(\"<html><\/html>\"), new HmRsHeader( Matchers.not( Matchers.hasEntry( \"cache-control\", \"no-cache, no-store\" ) ) ) ); }'","output":"public void testsHeaderNotAvailable() throws Exception { MatcherAssert.assertThat( new RsWithBody(\"<html><\/html>\"), new HmRsHeader( Matchers.not( Matchers.hasEntry( \"cache-control\", \"no-cache, no-store\" ) ) ) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Character \"char\" <LINK_0> This is returning a char (primitive type) is \"==\"test works I think, if returning Character (object wrapper for char) need \".equals\"'\nThe code is: 'private JsonParser getParser(String data) throws IOException { <START> Character firstChar = data.charAt(0); <END> \/\/ Character \"char\" <LINK_0> This is returning a char (primitive type) is \"==\"test works I think, if returning Character (object wrapper for char) need \".equals\" if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }'","output":"private JsonParser getParser(String data) throws IOException { char firstChar = data.charAt(0); if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I cast here, parametrize cache directly: verifierNode.<String, Integer>cache(CACHE_NAME).get(entry.getKey())'\nThe code is: 'private void runOperation(Ignite verifierNode, BiConsumer<String, T2<String, Integer>> c) { T2<String, Integer> entry = entry(); c.accept(CACHE_NAME, entry); <START> assertThat((Integer)(verifierNode.cache(CACHE_NAME).get(entry.getKey())), is(entry.getValue())); <END> \/\/ I cast here, parametrize cache directly: verifierNode.<String, Integer>cache(CACHE_NAME).get(entry.getKey()) }'","output":"private void runOperation(Ignite verifierNode, BiConsumer<String, T2<String, Integer>> c) { T2<String, Integer> entry = entry(); c.accept(CACHE_NAME, entry); assertThat(verifierNode.<String, Integer>cache(CACHE_NAME).get(entry.getKey()), is(entry.getValue())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean'\nThe code is: 'public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { <START> this.showMigrationEvents = notNull(\"showMigrationEvents\", showMigrationEvents); <END> \/\/ Remove this line. sense for a primitive value. happening is primitive boolean is auto-boxed a Boolean return this; }'","output":"public ChangeStreamIterable<TResult> showMigrationEvents(final boolean showMigrationEvents) { this.showMigrationEvents = showMigrationEvents; return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public? in package comparator Cell types'\nThe code is: '<START> public static boolean matchingColumn(final Cell left, final byte lFamLen, final int lQualLength, <END> \/\/ public? in package comparator Cell types final Cell right, final byte rFamLen, final int rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }'","output":"private static boolean matchingColumn(final Cell left, final byte lFamLen, final int lQualLength, final Cell right, final byte rFamLen, final int rQualLength) { if (!matchingFamily(left, lFamLen, right, rFamLen)) { return false; } return matchingQualifier(left, lQualLength, right, rQualLength); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> int getSpacing() { <END> \/\/ public return 1; }'","output":"public int getSpacing() { return 1; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change to: return new RuleMemberValidator(this); (see Effective Java, 2nd edition)'\nThe code is: 'RuleMemberValidator build() { <START> return new RuleMemberValidator(fAnnotation, fMethods, fValidatorStrategies); <END> \/\/ change to: return new RuleMemberValidator(this); (see Effective Java, 2nd edition) }'","output":"RuleMemberValidator build() { return new RuleMemberValidator(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this public? extender of annotation, I this is I need invoke expect underlying framework do necssary optimizations'\nThe code is: '<START> public boolean isInVisibleLines() { <END> \/\/ this public? extender of annotation, I this is I need invoke expect underlying framework do necssary optimizations return support.isInVisibleLines(this); }'","output":"protected boolean isInVisibleLines() { return support.isInVisibleLines(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'THREAD-SAFETY This is a poor construct for a thread-safe class. save (that much) memory, solved a volatile boolean set false a default instead'\nThe code is: 'public ChatComponent setUnderlined(boolean underlined) { <START> $lock.writeLock().lock(); <END> \/\/ THREAD-SAFETY This is a poor construct for a thread-safe class. save (that much) memory, solved a volatile boolean set false a default instead if (this.underlined == null) this.underlined = new AtomicBoolean(underlined); else this.underlined.set(underlined); $lock.writeLock().unlock(); return this; }'","output":"public ChatComponent setUnderlined(boolean underlined) { if (this.underlined == null) this.underlined = new AtomicBoolean(underlined); else this.underlined.set(underlined); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I do this defaulting logic. sense if this is a LSH parsed LS backend query hints provided engine. sense if this LSH is a builder end user wanting customize hints of a query. if a specific hint is set in customization, engine static default, overridden engine-specific options query specification. I suggest removing defaulting logic getters. defaulting logic in backend achieved extracting some of logic of ViatraQueryEngineImpl.overrideKnownHints() a public static method, LS backend combine parsed LSH LSH.getDefault()'\nThe code is: 'public boolean isUseBase() { <START> if (useBase == null){ <END> \/\/ I do this defaulting logic. sense if this is a LSH parsed LS backend query hints provided engine. sense if this LSH is a builder end user wanting customize hints of a query. if a specific hint is set in customization, engine static default, overridden engine-specific options query specification. I suggest removing defaulting logic getters. defaulting logic in backend achieved extracting some of logic of ViatraQueryEngineImpl.overrideKnownHints() a public static method, LS backend combine parsed LSH LSH.getDefault() return getDefault().useBase; } return useBase; }'","output":"public boolean isUseBase() { return useBase; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I keeping this method is a right design setScrollTargetCallback is preferred call in onCreate change in other states of Activity \/ Fragment lifecycle calling this method is redundant. update yesterday, mScrollTargetCallback is set, prioritize result this method first. that, more flexible now. return mScrollTargetCallback != null ? mScrollTargetCallback.callback(target) : getSupportedScrollTarget(target); I prefer setBehaviorScrollTargetCallback method rollback some changes in Behavior class. rest good merge'\nThe code is: 'public void setScrollTargetCallback(ScrollTargetCallback scrollTargetCallback) { mScrollTargetCallback = scrollTargetCallback; <START> setBehaviorScrollTargetCallback(); <END> \/\/ I keeping this method is a right design setScrollTargetCallback is preferred call in onCreate change in other states of Activity \/ Fragment lifecycle calling this method is redundant. update yesterday, mScrollTargetCallback is set, prioritize result this method first. that, more flexible now. return mScrollTargetCallback != null ? mScrollTargetCallback.callback(target) : getSupportedScrollTarget(target); I prefer setBehaviorScrollTargetCallback method rollback some changes in Behavior class. rest good merge }'","output":"public void setScrollTargetCallback(ScrollTargetCallback scrollTargetCallback) { mScrollTargetCallback = scrollTargetCallback; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consumerProperties is non-null in this class, do !consumerProperties.isEmpty() here'\nThe code is: 'public Properties getConsumerProperties(String inputChannelName) { if (isPartitionedConsumer(inputChannelName)) { Properties channelConsumerProperties = new Properties(); <START> if (consumerProperties != null) { <END> \/\/ consumerProperties is non-null in this class, do !consumerProperties.isEmpty() here channelConsumerProperties.putAll(consumerProperties); } channelConsumerProperties.setProperty(BinderProperties.COUNT, Integer.toString(getInstanceCount())); channelConsumerProperties.setProperty(BinderProperties.PARTITION_INDEX, Integer.toString(getInstanceIndex())); return channelConsumerProperties; } else { return getConsumerProperties(); } }'","output":"public Properties getConsumerProperties(String inputChannelName) { if (isPartitionedConsumer(inputChannelName)) { Properties channelConsumerProperties = new Properties(); channelConsumerProperties.putAll(consumerProperties); channelConsumerProperties.setProperty(BinderProperties.COUNT, Integer.toString(getInstanceCount())); channelConsumerProperties.setProperty(BinderProperties.PARTITION_INDEX, Integer.toString(getInstanceIndex())); return channelConsumerProperties; } else { return getConsumerProperties(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please rename script'\nThe code is: 'public void setUp() throws Exception { setBrickPosition = 1; changeBrickPosition = 2; <START> Script project = BrickTestUtils.createProjectAndGetStartScript(\"variableBricksTest\"); <END> \/\/ please rename script project.addBrick(new SetVariableBrick()); project.addBrick(new ChangeVariableBrick()); baseActivityTestRule.launchActivity(null); }'","output":"public void setUp() throws Exception { setBrickPosition = 1; changeBrickPosition = 2; Script script = BrickTestUtils.createProjectAndGetStartScript(\"variableBricksTest\"); script.addBrick(new SetVariableBrick()); script.addBrick(new ChangeVariableBrick()); baseActivityTestRule.launchActivity(null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"return this.getRuntimeInfo(engine, connectorTopology, GoogleDriveConnectionDefinition.SOURCE_CLASS)\" avoid code redundance. (ok lines...)'\nThe code is: 'public RuntimeInfo getRuntimeInfo(ExecutionEngine engine, ComponentProperties properties, ConnectorTopology connectorTopology) { <START> assertEngineCompatibility(engine); <END> \/\/ \"return this.getRuntimeInfo(engine, connectorTopology, GoogleDriveConnectionDefinition.SOURCE_CLASS)\" avoid code redundance. (ok lines...) assertConnectorTopologyCompatibility(connectorTopology); return getRuntimeInfo(GoogleDriveConnectionDefinition.SOURCE_CLASS); }'","output":"public RuntimeInfo getRuntimeInfo(ExecutionEngine engine, ComponentProperties properties, ConnectorTopology connectorTopology) { return this.getRuntimeInfo(engine, connectorTopology, GoogleDriveConnectionDefinition.SOURCE_CLASS); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is for Jackson, private get rid of @Deprecated if want'\nThe code is: '<START> public SeekableStreamDataSourceMetadata getCurrentCheckPoint() <END> \/\/ this is for Jackson, private get rid of @Deprecated if want { return checkpointMetadata; }'","output":"private SeekableStreamDataSourceMetadata getCurrentCheckPoint() { return checkpointMetadata; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'pre-compute this instead? tokens immutable set in constructor'\nThe code is: 'public boolean requiresTransaction() { <START> return tokens.stream().filter(t -> t.requiresTransaction()).findAny().isPresent(); <END> \/\/ pre-compute this instead? tokens immutable set in constructor }'","output":"public boolean requiresTransaction() { return requiresTransaction; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for getInstance(), container passed'\nThe code is: 'public SpongeExecutorService get() { <START> return this.schedulerService.createAsyncExecutor(this.container.getInstance()); <END> \/\/ need for getInstance(), container passed }'","output":"public SpongeExecutorService get() { return this.schedulerService.createAsyncExecutor(this.container); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Default false'\nThe code is: 'default boolean bypassCache() { <START> return true; <END> \/\/ Default false }'","output":"default boolean bypassCache() { return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If add new JSON published deal front-end of this project, more reasonable me'\nThe code is: '<START> public void publish(ChatRoom chatRoom, TranslationResult result) { <END> \/\/ If add new JSON published deal front-end of this project, more reasonable me String name = result.getName(); String translation = result.getTranslatedText(); String toSend = name + \": \" + translation; super.sendMessage(chatRoom, toSend); }'","output":"public void publish(ChatRoom chatRoom, TranslationResult result) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove unused variable accesResultCode. fixes typo in name ;-)'\nThe code is: 'private SetRequestParameter getSeasonsRequest(final ClientConnection conn, final List<SeasonProfile> seasonProfileList) throws IOException { final RequestParameterFactory factory = new RequestParameterFactory(CLASS_ID, OBIS_CODE, 7); final DataObject seasonsArray = this.seasonProfileConverter.convert(seasonProfileList); LOGGER.info(\"getSeasonsRequest: debug output: {}\", this.dlmsHelperService.getDebugInfo(seasonsArray)); <START> final AccessResultCode accesResultCode = AccessResultCode.SUCCESS; <END> \/\/ remove unused variable accesResultCode. fixes typo in name ;-) final SetRequestParameter request = factory.createSetRequestParameter(seasonsArray); return request; }'","output":"private SetRequestParameter getSeasonsRequest(final ClientConnection conn, final List<SeasonProfile> seasonProfileList) throws IOException { final RequestParameterFactory factory = new RequestParameterFactory(CLASS_ID, OBIS_CODE, 7); final DataObject seasonsArray = this.seasonProfileConverter.convert(seasonProfileList); LOGGER.info(\"getSeasonsRequest: debug output: {}\", this.dlmsHelperService.getDebugInfo(seasonsArray)); final SetRequestParameter request = factory.createSetRequestParameter(seasonsArray); return request; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Happy-Neko here, IndexOutOfBoundsException custom message'\nThe code is: 'public void add(final int index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { <START> throw new IllegalArgumentException(this.message, ex); <END> \/\/ @Happy-Neko here, IndexOutOfBoundsException custom message } }'","output":"public void add(final int index, final T element) { try { this.origin.add(index, element); } catch (final IndexOutOfBoundsException ex) { throw this.wrapException(ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please NotImplementedException()'\nThe code is: 'public MapSqlParameterMapper<GlusterHookEntity> getBatchMapper() { <START> throw new RuntimeException(\"Unsupported operation\"); <END> \/\/ please NotImplementedException() }'","output":"public MapSqlParameterMapper<GlusterHookEntity> getBatchMapper() { throw new NotImplementedException(\"Unsupported operation\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList'\nThe code is: '<START> public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { <END> \/\/ Please, write in line: @Override public reason copy-paste implementation mapKeyToPrimaryAndBackupsList A.notNull(key, \"key\"); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }'","output":"@Override public List<ClusterNode> mapKeyToPrimaryAndBackupsList(K key) { A.notNull(key, \"key\"); return cctx.affinity().nodesByPartition(partition(key), topologyVersion()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'checkNotNull constructor params Ditto for other constructors'\nThe code is: 'public EventListWriter(AnnotationRegistry<Event> annotationRegistry) { <START> this.annotationRegistry = annotationRegistry; <END> \/\/ checkNotNull constructor params Ditto for other constructors }'","output":"public EventListWriter(AnnotationRegistry<Event> annotationRegistry) { this.annotationRegistry = checkNotNull(annotationRegistry); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'String.valueof(String).toString();? return string, final'\nThe code is: 'public @Nullable String toString() { <START> return String.valueOf(fValue); <END> \/\/ String.valueof(String).toString();? return string, final }'","output":"public @Nullable String toString() { return fValue; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ioStatisticsStore.toString() too; get logging API is resilience failures'\nThe code is: '@Override public String toString() { final StringBuilder outputStreamStats = new StringBuilder( \"OutputStream Statistics{\"); <START> outputStreamStats.append(IOStatisticsLogging.ioStatisticsSourceToString(ioStatisticsStore)); <END> \/\/ ioStatisticsStore.toString() too; get logging API is resilience failures outputStreamStats.append(\"}\"); return outputStreamStats.toString(); }'","output":"@Override public String toString() { final StringBuilder outputStreamStats = new StringBuilder( \"OutputStream Statistics{\"); outputStreamStats.append(ioStatisticsStore.toString()); outputStreamStats.append(\"}\"); return outputStreamStats.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Test(expected = ...), above'\nThe code is: 'public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, \"something\"); BluefloodServiceStarterException ex = null; try { BluefloodServiceStarter.validateCassandraHosts(); } catch (BluefloodServiceStarterException e) { ex = e; } <START> assertNotNull(ex); <END> \/\/ @Test(expected = ...), above assertEquals(-1, ex.getStatus()); }'","output":"public void testInvalidCassandraHostsFailsValidation() { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.CASSANDRA_HOSTS, \"something\"); BluefloodServiceStarter.validateCassandraHosts(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'transform return null. if changed need unchange it. #getRule(...) throw a NotFoundException if ruleId present in database. transform.appToRest throw errors prevent method returning a valid rule'\nThe code is: 'private RestRule getRuleInternal(String ruleId, User user) { Rule input = getRule(ruleId, user); RestRule restRule = ruleTransform.appToRest(input, user); <START> if(restRule == null) { <END> \/\/ transform return null. if changed need unchange it. #getRule(...) throw a NotFoundException if ruleId present in database. transform.appToRest throw errors prevent method returning a valid rule throw new NotFoundException(\"Rule not found: '%s'\", ruleId); } return restRule; }'","output":"private RestRule getRuleInternal(String ruleId, User user) { Rule input = getRule(ruleId, user); RestRule restRule = ruleTransform.appToRest(input, user); return restRule; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'in other classes throw UnsupportedOperation'\nThe code is: 'protected Response performRemove(String id) { <START> return null; <END> \/\/ in other classes throw UnsupportedOperation }'","output":"protected Response performRemove(String id) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo. modify adjusted'\nThe code is: 'public long reload() { Long adjustedValue = jdbcTemplate.queryForObject(adjustedValueQuery, Long.class); if (adjustedValue == null) { adjustedValue = cachedAdjustedValue.get(); logger.warn(\"adjusted value is null. use {}\", adjustedValue); } else if (isUseCache()) { <START> logger.debug(\"cache adjustd value = {}\", adjustedValue); <END> \/\/ typo. modify adjusted cachedAdjustedValue.set(adjustedValue); } return adjustedValue; }'","output":"public long reload() { Long adjustedValue = jdbcTemplate.queryForObject(adjustedValueQuery, Long.class); if (adjustedValue == null) { adjustedValue = cachedAdjustedValue.get(); logger.warn(\"adjusted value is null. use {}\", adjustedValue); } else if (isUseCache()) { logger.debug(\"cache adjusted value = {}\", adjustedValue); cachedAdjustedValue.set(adjustedValue); } return adjustedValue; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'OPAQUE'\nThe code is: 'public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (int x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } <START> gc.setAlpha(BLACK.getAlpha()); <END> \/\/ OPAQUE }'","output":"public void drawGridLines(Rectangle bounds, GC gc) { if (!fGridLinesVisible) { return; } gc.setForeground(fGridLineColor); gc.setAlpha(fGridLineColor.getAlpha()); for (int x : fTimeGraphScale.getTickList()) { gc.drawLine(x, bounds.y, x, bounds.y + bounds.height); } gc.setAlpha(OPAQUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need print a test'\nThe code is: 'public void visit(QueryMetadata.Builder queryBuilder) { <START> System.out.println(queryBuilder.getNodeId()); <END> \/\/ do need print a test ids.add(queryBuilder.getNodeId()); super.visit(queryBuilder); }'","output":"public void visit(QueryMetadata.Builder queryBuilder) { ids.add(queryBuilder.getNodeId()); super.visit(queryBuilder); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this needed? this removed for efficiency reasons (but I this method is used...)'\nThe code is: 'protected ILScore convert(InformationLoss<?> other) { if (other == null) return null; <START> if (!other.getClass().equals(this.getClass())) { <END> \/\/ Is this needed? this removed for efficiency reasons (but I this method is used...) throw new IllegalArgumentException(\"Incompatible class (\" + other.getClass().getSimpleName() + \")\"); } else { return (ILScore)other; } }'","output":"protected ILScore convert(InformationLoss<?> other) { if (other == null) return null; return (ILScore)other; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this equals assymetrical, if this is a subclass of o this.equals(o) true while o.equals(this) false'\nThe code is: 'public boolean equals(Object o) { if (this == o) return true; if (o == null || <START> !getClass().isAssignableFrom(o.getClass())) return <END> \/\/ this equals assymetrical, if this is a subclass of o this.equals(o) true while o.equals(this) false false; NamedObject that = (NamedObject)o; if (!myName.equals(that.myName)) return false; if (!myValues.equals(that.myValues)) return false; return true; }'","output":"public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof NamedObject)) return false; NamedObject that = (NamedObject)o; if (!myName.equals(that.myName)) return false; if (!myValues.equals(that.myValues)) return false; return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'constructor public'\nThe code is: '<START> public AbstractFFmpegStreamBuilder() { <END> \/\/ constructor public this.parent = null; }'","output":"protected AbstractFFmpegStreamBuilder() { this.parent = null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is a static non-instantiable class, change constructor visibility private'\nThe code is: '<START> public CommonPathCapabilities() { <END> \/\/ This is a static non-instantiable class, change constructor visibility private }'","output":"private CommonPathCapabilities() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '<LINK_0> . @dwnusbaum added a utility method for recently, replace dir.toPath() byt fileToPath(dir)'\nThe code is: 'public static File mkdirs(File dir) throws IOException { try { return Files.createDirectories(dir.toPath()).toFile(); <START> } catch (UnsupportedOperationException e) { <END> \/\/ <LINK_0> . @dwnusbaum added a utility method for recently, replace dir.toPath() byt fileToPath(dir) throw new IOException(e); } }'","output":"public static File mkdirs(File dir) throws IOException { try { return Files.createDirectories(fileToPath(dir)).toFile(); } catch (UnsupportedOperationException e) { throw new IOException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'BTW java.util.Objects this a bit simpler'\nThe code is: 'public int hashCode() { int result = name.hashCode(); <START> result = 31 * result + (version != null ? version.hashCode(): 0); <END> \/\/ BTW java.util.Objects this a bit simpler return result; }'","output":"public int hashCode() { return Objects.hash(name, version); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'requireNonNull'\nThe code is: 'public MissingParameterException(String parameterName) { super(ERROR_CODE); <START> this.parameterName = parameterName; <END> \/\/ requireNonNull }'","output":"public MissingParameterException(String parameterName) { super(ERROR_CODE); this.parameterName = requireNonNull(parameterName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is null right do default do throw new UnsuportedOperationException()'\nThe code is: 'default JobInstance getLastJobInstance(String jobName) { <START> return null; <END> \/\/ Is null right do default do throw new UnsuportedOperationException() }'","output":"default JobInstance getLastJobInstance(String jobName) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);'\nThe code is: 'public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartErrorEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, getStartEventType()); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, \"\"); <END> \/\/ suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE); assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }'","output":"public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartErrorEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, getStartEventType()); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE); assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This boolean now. Boolean imply null'\nThe code is: '<START> public Boolean isFileTypeValid() { <END> \/\/ This boolean now. Boolean imply null return getComponentModel().validFileType; }'","output":"public boolean isFileTypeValid() { return getComponentModel().validFileType; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this need public either'\nThe code is: '<START> public void setRowGroupSizeThreshold(long rowGroupSizeThreshold) { <END> \/\/ this need public either this.rowGroupSizeThreshold = rowGroupSizeThreshold; }'","output":"void setRowGroupSizeThreshold(long rowGroupSizeThreshold) { this.rowGroupSizeThreshold = rowGroupSizeThreshold; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need this'\nThe code is: 'public static gov.hhs.fha.nhinc.patientdiscovery.persistence.HibernateUtil getPatientDiscoveryHibernateUtil() { ClassPathXmlApplicationContext context = ClassPathSingleton.CONTEXT; <START> LOG.debug(\"Memory address getPatientDiscoveryHibernateUtil {}\", context.getId()); <END> \/\/ Do need this if (patientDiscoveryHibernateUtil == null) { patientDiscoveryHibernateUtil = context.getBean(NhincConstants.PATIENT_DISCOVERY_HIBERNATE_BEAN, gov.hhs.fha.nhinc.patientdiscovery.persistence.HibernateUtil.class); } return patientDiscoveryHibernateUtil; }'","output":"public static gov.hhs.fha.nhinc.patientdiscovery.persistence.HibernateUtil getPatientDiscoveryHibernateUtil() { ClassPathXmlApplicationContext context = ClassPathSingleton.CONTEXT; if (patientDiscoveryHibernateUtil == null) { patientDiscoveryHibernateUtil = context.getBean(NhincConstants.PATIENT_DISCOVERY_HIBERNATE_BEAN, gov.hhs.fha.nhinc.patientdiscovery.persistence.HibernateUtil.class); } return patientDiscoveryHibernateUtil; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'refer spmMap \"this\". Please consistent'\nThe code is: 'public void setSpmMap(String spId, Host host) { <START> spmMap.put(spId, host); <END> \/\/ refer spmMap \"this\". Please consistent }'","output":"public void setSpmMap(String spId, Host host) { this.spmMap.put(spId, host); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add a check Objects.requireNonNull(supplier, \"supplier is null\");'\nThe code is: '<START> static <E,T> Validation<E,T> valid(Supplier<? extends T> supplier) { <END> \/\/ Please add a check Objects.requireNonNull(supplier, \"supplier is null\"); return new Valid<>(supplier.get()); }'","output":"static <E,T> Validation<E,T> valid(Supplier<? extends T> supplier) { Objects.requireNonNull(supplier, \"supplier is null\"); return new Valid<>(supplier.get()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please change usageEventDao. reason in modern days prefixes'\nThe code is: 'private void saveUsageEvent(String usageType, long accountId, long zoneId, long resourceId, String resourceName, Long offeringId, Long templateId, String resourceType, Map<String, String> details) { UsageEventVO usageEvent = new UsageEventVO(usageType, accountId, zoneId, resourceId, resourceName, offeringId, templateId, resourceType); <START> _usageEventDao.persist(usageEvent); <END> \/\/ please change usageEventDao. reason in modern days prefixes _usageEventDao.saveDetails(usageEvent.getId(), details); }'","output":"private void saveUsageEvent(String usageType, long accountId, long zoneId, long resourceId, String resourceName, Long offeringId, Long templateId, String resourceType, Map<String, String> details) { UsageEventVO usageEvent = new UsageEventVO(usageType, accountId, zoneId, resourceId, resourceName, offeringId, templateId, resourceType); usageEventDao.persist(usageEvent); usageEventDao.saveDetails(usageEvent.getId(), details); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If a thread need this. scheduled executor send pings client please. Cancel executor a future'\nThe code is: 'private void shutdown(boolean fail) { <START> this.ttlLatch.countDown(); <END> \/\/ If a thread need this. scheduled executor send pings client please. Cancel executor a future if (fail) { transportConnection.forceClose(); } else { transportConnection.close(); } }'","output":"private void shutdown(boolean fail) { if (fail) { transportConnection.forceClose(); } else { transportConnection.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'constant FINGERID_VERSION instead of calling a private method fingerIdVersion()'\nThe code is: 'private URIBuilder getFingerIdURI(String path) throws URISyntaxException { if (path == null) path = \"\"; URIBuilder builder = new URIBuilder(FINGERID_SOURCE); <START> builder.setPath(\"\/csi-fingerid-\" + FingerIdWebMethod.fingerIdVersion() + path); <END> \/\/ constant FINGERID_VERSION instead of calling a private method fingerIdVersion() return builder; }'","output":"private URIBuilder getFingerIdURI(String path) throws URISyntaxException { if (path == null) path = \"\"; URIBuilder builder = new URIBuilder(FINGERID_SOURCE); builder.setPath(\"\/csi-fingerid-\" + FINGERID_VERSION + path); return builder; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove'\nThe code is: 'public void onAuthCreated(BoxAuthentication.BoxAuthenticationInfo info) { mFolderApi = new BoxApiFolder(mSession); mFileApi = new BoxApiFile(mSession); <START> mMetadataApi = new BoxApiMetadata(mSession); <END> \/\/ Remove loadRootFolder(); }'","output":"public void onAuthCreated(BoxAuthentication.BoxAuthenticationInfo info) { mFolderApi = new BoxApiFolder(mSession); mFileApi = new BoxApiFile(mSession); loadRootFolder(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return () -> \"1\";'\nThe code is: 'public void filter(ContainerRequestContext containerRequestContext) throws IOException { containerRequestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { <START> return new Principal() { @Override public String getName() { return \"1\"; } }; <END> \/\/ suggestion return () -> \"1\"; } @Override public boolean isUserInRole(String s) { return false; } @Override public boolean isSecure() { return false; } @Override public String getAuthenticationScheme() { return null; } }); }'","output":"public void filter(ContainerRequestContext containerRequestContext) throws IOException { containerRequestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return () -> \"1\"; } @Override public boolean isUserInRole(String s) { return false; } @Override public boolean isSecure() { return false; } @Override public String getAuthenticationScheme() { return null; } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (s==null) throw new IOException(\"Reader side abandoned\", allocatedAt);'\nThe code is: 'private FastPipedInputStream sink() throws IOException { FastPipedInputStream s = sink.get(); <START> if (s==null) throw (IOException) new IOException(\"Reader side has already been abandoned\", allocatedAt); <END> \/\/ suggestion if (s==null) throw new IOException(\"Reader side abandoned\", allocatedAt); return s; }'","output":"private FastPipedInputStream sink() throws IOException { FastPipedInputStream s = sink.get(); if (s==null) throw new IOException(\"Reader side has already been abandoned\", allocatedAt); return s; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'work OutputStreamWriter? is, body of this method consist of: write(in, new OutputStreamWriter(out));'\nThe code is: '<START> static public void write(Reader in, OutputStream out) throws IOException { <END> \/\/ work OutputStreamWriter? is, body of this method consist of: write(in, new OutputStreamWriter(out)); try { char[] charArray = new char[BUFFER_SIZE * 2]; byte[] byteArray; while (in.read(charArray) != -1) { byteArray = new String(charArray).getBytes(StandardCharsets.UTF_8); out.write(byteArray); } } finally { in.close(); } }'","output":"static public void write(Reader in, OutputStream out) throws IOException { write(in, new OutputStreamWriter(out)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'necessary here. handled parseAny'\nThe code is: 'public RevCommit parseCommit(final AnyObjectId id) throws MissingObjectException, IncorrectObjectTypeException, IOException { <START> initializeShallowCommits(); <END> \/\/ necessary here. handled parseAny RevObject c = peel(parseAny(id)); if (!(c instanceof RevCommit)) throw new IncorrectObjectTypeException(id.toObjectId(), Constants.TYPE_COMMIT); return (RevCommit) c; }'","output":"public RevCommit parseCommit(final AnyObjectId id) throws MissingObjectException, IncorrectObjectTypeException, IOException { RevObject c = peel(parseAny(id)); if (!(c instanceof RevCommit)) throw new IncorrectObjectTypeException(id.toObjectId(), Constants.TYPE_COMMIT); return (RevCommit) c; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Throw proper exception if is supported: - NullPointerException if command == null. - IllegalArgumentException if frameID < 0 if frameID > 255'\nThe code is: '<START> public ATCommandPacket(int frameID, String command, byte[] parameter) { <END> \/\/ Throw proper exception if is supported: - NullPointerException if command == null. - IllegalArgumentException if frameID < 0 if frameID > 255 super(XBeeAPIType.AT_COMMAND); this.frameID = frameID; this.command = command; this.parameter = parameter; }'","output":"public ATCommandPacket(int frameID, String command, byte[] parameter) { super(APIFrameType.AT_COMMAND); if (command == null) throw new NullPointerException(\"Command cannot be null.\"); if (frameID < 0 || frameID > 255) throw new IllegalArgumentException(\"Frame ID must be between 0 and 255.\"); this.frameID = frameID; this.command = command; this.parameter = parameter; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for otherNonCodedConceptUuid'\nThe code is: 'public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { <START> Concept concept = Context.getConceptService().getConceptByUuid(otherNonCodedConceptUuid); <END> \/\/ for otherNonCodedConceptUuid Assert.assertTrue(new Allergen(null, concept, \"other value\").isSameAllergen(new Allergen(null, concept, \"OTHER VALUE\"))); }'","output":"public void isSameAllergen_shouldBeCaseInsensitiveForNonCodedAllergen() { Concept concept = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid()); Assert.assertTrue(new Allergen(null, concept, \"other value\").isSameAllergen(new Allergen(null, concept, \"OTHER VALUE\"))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '=> OptaPlanner optaplanner'\nThe code is: 'public String getImplementedCapability() { <START> return \"Optaplanner\"; <END> \/\/ => OptaPlanner optaplanner }'","output":"public String getImplementedCapability() { return \"OptaPlanner\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'well, need call .getValue() here'\nThe code is: 'public void deleteDigitalTwin(String digitalTwinId) { <START> deleteDigitalTwinWithResponse(digitalTwinId, new RequestOptions(), Context.NONE).getValue(); <END> \/\/ well, need call .getValue() here }'","output":"public void deleteDigitalTwin(String digitalTwinId) { deleteDigitalTwinWithResponse(digitalTwinId, new DeleteDigitalTwinRequestOptions(), Context.NONE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If declare fileRoot Optional, initialize one-liner: java Optional.ofNullable(options.get(\"fileRoot\")).map(File::new)'\nThe code is: 'public void configure(Map<String, String> options) { useCache = Optional.ofNullable(options.get(\"cache\")) .map(Boolean::parseBoolean) .orElse(true); if (options.containsKey(\"fileRoot\")) { <START> fileRoot = new File(options.get(\"fileRoot\")); <END> \/\/ If declare fileRoot Optional, initialize one-liner: java Optional.ofNullable(options.get(\"fileRoot\")).map(File::new) } }'","output":"public void configure(Map<String, String> options) { useCache = Optional.ofNullable(options.get(\"cache\")).map(Boolean::parseBoolean).orElse(true); fileRoot = Optional.ofNullable(options.get(\"fileRoot\")).map(File::new); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This registered HC'\nThe code is: 'public void registerAttributes(ManagementResourceRegistration resourceRegistration) { AbstractWriteAttributeHandler writeAttribute = new ActiveMQReloadRequiredHandlers.WriteAttributeHandler(ATTRIBUTES); for (AttributeDefinition attribute : ATTRIBUTES) { resourceRegistration.registerReadWriteAttribute(attribute, null, writeAttribute); } <START> HAPolicySynchronizationStatusReadHandler.registerMasterAttributes(resourceRegistration); <END> \/\/ This registered HC }'","output":"public void registerAttributes(ManagementResourceRegistration resourceRegistration) { AbstractWriteAttributeHandler writeAttribute = new ActiveMQReloadRequiredHandlers.WriteAttributeHandler(ATTRIBUTES); for (AttributeDefinition attribute : ATTRIBUTES) { resourceRegistration.registerReadWriteAttribute(attribute, null, writeAttribute); } if(registerRuntime) { HAPolicySynchronizationStatusReadHandler.registerMasterAttributes(resourceRegistration); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catch exceptions vn.shutdown() ensure ReverseDNSCache.m_es.shutdown() is invoked'\nThe code is: 'public void shutdown() throws InterruptedException { for (VoltNetwork vn : m_networks) { vn.shutdown(); } <START> ReverseDNSCache.m_es.shutdown(); <END> \/\/ catch exceptions vn.shutdown() ensure ReverseDNSCache.m_es.shutdown() is invoked }'","output":"public void shutdown() throws InterruptedException { for (VoltNetwork vn : m_networks) { vn.shutdown(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return \"\", do need pass safeName()'\nThe code is: 'public String getName() { if(getEcoreOperation() == null) { <START> return safeName(\"null\"); <END> \/\/ return \"\", do need pass safeName() } return safeName(getEcoreOperation().getName()); }'","output":"public String getName() { if(getEcoreOperation() == null) { return \"\"; } return safeName(getEcoreOperation().getName()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This process is referenced in this test class'\nThe code is: 'protected List<String> getProcessDefinitionFiles() { List<String> processes = new ArrayList<String>(); processes.add(\"cases\/EmptyCase.bpmn2\"); processes.add(\"cases\/UserTaskCase.bpmn2\"); <START> processes.add(\"processes\/UserTaskProcess.bpmn2\"); <END> \/\/ This process is referenced in this test class return processes; }'","output":"protected List<String> getProcessDefinitionFiles() { List<String> processes = new ArrayList<String>(); processes.add(\"cases\/EmptyCase.bpmn2\"); processes.add(\"cases\/UserTaskCase.bpmn2\"); return processes; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Hmm, caller invoking a full AccountSshKey object in hand. pass time database column initialize this field, assume is null'\nThe code is: 'SshKeyCacheEntry(final AccountSshKey.Id i, final PublicKey k) { id = i; publicKey = k; <START> lastUsed = null; <END> \/\/ Hmm, caller invoking a full AccountSshKey object in hand. pass time database column initialize this field, assume is null }'","output":"SshKeyCacheEntry(final AccountSshKey.Id i, final PublicKey k) { id = i; publicKey = k; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is a className instead of beanName here'\nThe code is: '<START> public DynamicRepositoryLocationLoader(ApplicationContext applicationContext, String beanName) { <END> \/\/ Is a className instead of beanName here this.delegated = applicationContext.getBean(beanName, RepositoryLocationLoader.class); }'","output":"public DynamicRepositoryLocationLoader(ApplicationContext applicationContext, String beanName) { this(applicationContext.getBean(beanName, RepositoryLocationLoader.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'o'\nThe code is: 'public void onComplete() { <START> ObservableSource<? extends R> p = other; <END> \/\/ o if (p == null) { downstream.onComplete(); } else { other = null; p.subscribe(this); } }'","output":"public void onComplete() { ObservableSource<? extends R> o = other; if (o == null) { downstream.onComplete(); } else { other = null; o.subscribe(this); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add cmd.getDhcpOptions log message assist operational debugging'\nThe code is: 'private Answer executeRequest(UpdateDhcpOptionVspCommand cmd) { try { isNuageVspManagerLoaded(); _nuageVspGuruClient.applyDhcpOptions(cmd.getDhcpOptions(), cmd.getNetwork()); return new Answer(cmd, true, \"Update DhcpOptions on VM's in network: \" + cmd.getNetwork().getName() + \" on Nuage VSD \" + _hostName); } catch (ExecutionException | ConfigurationException e) { <START> s_logger.error(\"Failure during \" + cmd + \" on Nuage VSD \" + _hostName, e); <END> \/\/ Please add cmd.getDhcpOptions log message assist operational debugging return new Answer(cmd, e); } }'","output":"private Answer executeRequest(UpdateDhcpOptionVspCommand cmd) { try { isNuageVspManagerLoaded(); _nuageVspGuruClient.applyDhcpOptions(cmd.getDhcpOptions(), cmd.getNetwork()); return new Answer(cmd, true, \"Update DhcpOptions on VM's in network: \" + cmd.getNetwork().getName() + \" on Nuage VSD \" + _hostName); } catch (ExecutionException | ConfigurationException e) { s_logger.error(\"Failure during \" + cmd.toDetailString() + \" on Nuage VSD \" + _hostName, e); return new Answer(cmd, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'initialized map line 24, again'\nThe code is: 'public LRUCache(int capacity) { this.capacity = capacity; count = 0; <START> map = new HashMap<>(); <END> \/\/ initialized map line 24, again head = new DoubleLinkedList(0, 0); tail = new DoubleLinkedList(0, 0); head.next = tail; tail.pre = head; head.pre = null; tail.next = null; }'","output":"public LRUCache(int capacity) { this.capacity = capacity; count = 0; head = new DoubleLinkedList(0, 0); tail = new DoubleLinkedList(0, 0); head.next = tail; tail.pre = head; head.pre = null; tail.next = null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I personally prefer if methods \"external API\" public. Yes, outer class call private methods directly, IDEs show public methods differently, filter out non-public methods browsing, etc'\nThe code is: '<START> private String expectedDiff() { <END> \/\/ I personally prefer if methods \"external API\" public. Yes, outer class call private methods directly, IDEs show public methods differently, filter out non-public methods browsing, etc return extractDiff(expected); }'","output":"public String expectedDiff() { return extractDiff(expected); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This AFAIK lead creation of a PostgreSQLContainer postgis is in JDBC url'\nThe code is: 'public boolean supports(String databaseType) { return databaseType.equals(PostgreSQLContainer.NAME) <START> || databaseType.equals(PostgisContainer.NAME); <END> \/\/ This AFAIK lead creation of a PostgreSQLContainer postgis is in JDBC url }'","output":"public boolean supports(String databaseType) { return databaseType.equals(PostgreSQLContainer.NAME); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Unnecessary braces'\nThe code is: 'public void apply(Project project) { SarosEclipseExtension e = project.getExtensions().create(EXTENSION_NAME, SarosEclipseExtension.class); project.afterEvaluate( <START> (p) -> { <END> \/\/ Unnecessary braces configureEclipseAfterEvaluate(p, e); }); }'","output":"public void apply(Project project) { SarosEclipseExtension e = project.getExtensions().create(EXTENSION_NAME, SarosEclipseExtension.class); project.afterEvaluate(p -> configureEclipseAfterEvaluate(p, e)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '+static'\nThe code is: '<START> private void checkPercentageValidity(int percentage, String message) { <END> \/\/ +static if (percentage < 0 || percentage > 100) { throw new IllegalArgumentException(message); } }'","output":"private static void checkPercentageValidity(int percentage, String message) { if (percentage < 0 || percentage > 100) { throw new IllegalArgumentException(message); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I error, logged \"debug\" level'\nThe code is: 'public ResponseEntity<Problem> conflict(final ConflictException ex, final NativeWebRequest request) { <START> LOG.error(ex.getMessage(), ex); <END> \/\/ I error, logged \"debug\" level return Responses.create(Response.Status.CONFLICT, ex.getMessage(), request); }'","output":"public ResponseEntity<Problem> conflict(final ConflictException ex, final NativeWebRequest request) { LOG.debug(ex.getMessage(), ex); return Responses.create(Response.Status.CONFLICT, ex.getMessage(), request); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'availableEmptyExpressions Some interpreter do provide a prefix a suffix'\nThe code is: 'protected void setUp() throws Exception { super.setUp(); <START> availablePrefixes = <END> \/\/ availableEmptyExpressions Some interpreter do provide a prefix a suffix CompoundInterpreter.INSTANCE.getAllNewEmtpyExpressions(); assertFalse(\"At least one interpreter should be declared\", availablePrefixes.isEmpty()); DiagramDescription diagramDescription = DescriptionFactory.eINSTANCE.createDiagramDescription(); interpreterContext = SiriusInterpreterContextFactory.createInterpreterContext(diagramDescription, DescriptionPackage.Literals.DIAGRAM_DESCRIPTION__PRECONDITION_EXPRESSION); }'","output":"protected void setUp() throws Exception { super.setUp(); availableEmptyExpressions = CompoundInterpreter.INSTANCE.getAllNewEmtpyExpressions(); assertFalse(\"At least one interpreter should be declared\", availableEmptyExpressions.isEmpty()); DiagramDescription diagramDescription = DescriptionFactory.eINSTANCE.createDiagramDescription(); interpreterContext = SiriusInterpreterContextFactory.createInterpreterContext(diagramDescription, DescriptionPackage.Literals.DIAGRAM_DESCRIPTION__PRECONDITION_EXPRESSION); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import utf8Slice'\nThe code is: 'public static Slice toQuadKey(@SqlType(BingTileType.NAME) long input) { <START> return Slices.utf8Slice(BingTile.decode(input).toQuadKey()); <END> \/\/ static import utf8Slice }'","output":"public static Slice toQuadKey(@SqlType(BingTileType.NAME) long input) { return utf8Slice(BingTile.decode(input).toQuadKey()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This UnsupportedOperationException, IllegalStateException'\nThe code is: 'public Cookie getCookie(String cookieName) { <START> throw new IllegalStateException(\"Not supported yet\"); <END> \/\/ This UnsupportedOperationException, IllegalStateException }'","output":"public Cookie getCookie(String cookieName) { throw new UnsupportedOperationException(\"Not supported yet\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check of missing resource'\nThe code is: 'private JSONArray buildWarnings() { try { String warningsText = IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream(\"warnings.json\")); <START> JSONArray warnings = JSONArray.fromObject(warningsText); <END> \/\/ check of missing resource return warnings; } catch (IOException e) { return new JSONArray(); } }'","output":"private JSONArray buildWarnings() throws IOException { String warningsText = IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream(\"warnings.json\")); JSONArray warnings = JSONArray.fromObject(warningsText); return warnings; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'loads of findbugs for potential NPE this style getInstance() return null'\nThe code is: 'public MarkupFormatter getMarkupFormatter() { <START> return getJenkins().getMarkupFormatter(); <END> \/\/ loads of findbugs for potential NPE this style getInstance() return null }'","output":"public MarkupFormatter getMarkupFormatter() { return Jenkins.getInstance().getMarkupFormatter(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do if(!mService.isControlEnabled()) { setSystemAudioMode(false); }'\nThe code is: 'private void disableSystemAudioIfExist() { assertRunOnServiceThread(); if (getAvrDeviceInfo() == null) { return; } removeAction(SystemAudioActionFromAvr.class); removeAction(SystemAudioActionFromTv.class); removeAction(SystemAudioAutoInitiationAction.class); removeAction(SystemAudioStatusAction.class); removeAction(VolumeControlAction.class); <START> setSystemAudioMode(false); <END> \/\/ do if(!mService.isControlEnabled()) { setSystemAudioMode(false); } }'","output":"private void disableSystemAudioIfExist() { assertRunOnServiceThread(); if (getAvrDeviceInfo() == null) { return; } removeAction(SystemAudioActionFromAvr.class); removeAction(SystemAudioActionFromTv.class); removeAction(SystemAudioAutoInitiationAction.class); removeAction(SystemAudioStatusAction.class); removeAction(VolumeControlAction.class); if (!mService.isControlEnabled()) { setSystemAudioMode(false); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Hi, existing object ids start 1 define voId\/groupId=0 default, safely like: session.isVoAdmin(voId) || session.isGroupAdmin(groupId) in IF'\nThe code is: 'public boolean isAuthorized() { if (session.isVoAdmin(voId)) { return true; } else { <START> return group != null && session.isGroupAdmin(groupId); <END> \/\/ Hi, existing object ids start 1 define voId\/groupId=0 default, safely like: session.isVoAdmin(voId) || session.isGroupAdmin(groupId) in IF } }'","output":"public boolean isAuthorized() { return (session.isVoAdmin(voId) || session.isGroupAdmin(groupId)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Configure 'Verified' label\"'\nThe code is: 'public void postRun() throws Exception { Config cfg = allProjectsConfig.load(); if (installVerified) { cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, \"MaxWithBlock\"); cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] {\"-1 Fails\", \" 0 No score\", \"+1 Verified\"})); <START> allProjectsConfig.save(\"Review Label Initialization\"); <END> \/\/ \"Configure 'Verified' label\" } }'","output":"public void postRun() throws Exception { Config cfg = allProjectsConfig.load(); if (installVerified) { cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, \"MaxWithBlock\"); cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] {\"-1 Fails\", \" 0 No score\", \"+1 Verified\"})); allProjectsConfig.save(\"Configure 'Verified' label\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for wait, DefaultShell wait'\nThe code is: 'private void removeIncludeExcludeWithHandler() { new PushButton(\"Remove...\").click(); <START> new WaitUntil(new ShellIsAvailable(\"Confirmation\")); <END> \/\/ need for wait, DefaultShell wait new DefaultShell(\"Confirmation\"); new PushButton(\"OK\").click(); }'","output":"private void removeIncludeExcludeWithHandler() { new PushButton(\"Remove...\").click(); new DefaultShell(\"Confirmation\"); new PushButton(\"OK\").click(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Another place note boolean is unused'\nThe code is: '<START> public TimestampService createTimestampService(KeyValueService rawKvs, boolean initializeAsync) { <END> \/\/ Another place note boolean is unused AtlasDbVersion.ensureVersionReported(); return new InMemoryTimestampService(); }'","output":"public TimestampService createTimestampService(KeyValueService rawKvs, boolean initializeAsync) { if (initializeAsync) { log.warn(\"Asynchronous initialization not implemented, will initialize synchronousy.\"); } AtlasDbVersion.ensureVersionReported(); return new InMemoryTimestampService(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Sets.newHashSet'\nThe code is: 'public void handleCheckStateChangedEvent(Collection<ITmfTreeViewerEntry> entries) { cancelUpdate(); Iterable<TmfGenericTreeEntry> counterEntries = Iterables.filter(entries, TmfGenericTreeEntry.class); Collection<@NonNull Long> selectedIds = <START> Lists.newArrayList(Iterables.transform(counterEntries, <END> \/\/ Sets.newHashSet e -> e.getModel().getId())); if (!selectedIds.containsAll(fSelectedIds)) { clearContent(); } fSelectedIds = selectedIds; updateContent(); }'","output":"public void handleCheckStateChangedEvent(Collection<ITmfTreeViewerEntry> entries) { cancelUpdate(); Iterable<TmfGenericTreeEntry> counterEntries = Iterables.filter(entries, TmfGenericTreeEntry.class); Collection<@NonNull Long> selectedIds = Sets.newHashSet(Iterables.transform(counterEntries, e -> e.getModel().getId())); if (!selectedIds.containsAll(fSelectedIds)) { clearContent(); } fSelectedIds = selectedIds; updateContent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If dedicated java.time methods TimestampUtils this longer necessary'\nThe code is: 'public void tearDown() throws SQLException { <START> TimeZone.setDefault(saveTZ); <END> \/\/ If dedicated java.time methods TimestampUtils this longer necessary TestUtil.dropTable(con, \"table1\"); TestUtil.closeDB(con); }'","output":"public void tearDown() throws SQLException { TestUtil.dropTable(con, \"table1\"); TestUtil.closeDB(con); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '!Objects.equals('\nThe code is: 'public boolean removeRoute(@NonNull RouteInfo route) { if <START> (Objects.equals(mIfaceName, <END> \/\/ !Objects.equals( route.getInterface())) { return false; } int i = findRouteIndexByDestination(route); if (i == -1) { return false; } mRoutes.remove(i); return true; }'","output":"public boolean removeRoute(@NonNull RouteInfo route) { if (!Objects.equals(mIfaceName, route.getInterface())) { return false; } int i = findRouteIndexByDestination(route); if (i == -1) { return false; } mRoutes.remove(i); return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Suseika please remove assert,'\nThe code is: 'private Node createImportedNode(final Node node) { <START> assert !(node instanceof Document); <END> \/\/ @Suseika please remove assert, final Document document; try { document = DFACTORY.newDocumentBuilder().newDocument(); } catch (final ParserConfigurationException ex) { throw new IllegalStateException(ex); } final Node imported = document.importNode(node, true); document.appendChild(imported); return imported; }'","output":"private Node createImportedNode(final Node node) { final Document document; try { document = DFACTORY.newDocumentBuilder().newDocument(); } catch (final ParserConfigurationException ex) { throw new IllegalStateException(ex); } final Node imported = document.importNode(node, true); document.appendChild(imported); return imported; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'list in place of newArrayList, is a bit lighter read'\nThe code is: 'protected void verify_internal_effects() { <START> verify(iterables).assertHasOnlyOneElementSatisfying(info(), newArrayList(internalArray()), consumer); <END> \/\/ list in place of newArrayList, is a bit lighter read }'","output":"protected void verify_internal_effects() { verify(iterables).assertHasOnlyOneElementSatisfying(info(), list(internalArray()), consumer); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consider giving empty list instead of null'\nThe code is: 'public List<ImmutableBitSet> getKeys() { <START> return null; <END> \/\/ consider giving empty list instead of null }'","output":"public List<ImmutableBitSet> getKeys() { return Collections.emptyList(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this onCompletion(null, gse)'\nThe code is: 'public void closeJob(GeneralSecurityException gse) { <START> callback.onCompletion(new EncryptJobResult(null, null, null), gse); <END> \/\/ this onCompletion(null, gse) }'","output":"public void closeJob(GeneralSecurityException gse) { callback.onCompletion(null, gse); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simpler if MalformedURLException converted a RuntimeException in getJob method throws is required'\nThe code is: '<START> public void jobsGridPortlet_fillColumnsFirst() throws MalformedURLException { <END> \/\/ simpler if MalformedURLException converted a RuntimeException in getJob method throws is required createFreeStyleJob(); createFreeStyleJob(); createFreeStyleJob(); createFreeStyleJob(); DashboardView v = createDashboardView(); JobsGridPortlet jobsGridPortlet = v.addBottomPortlet(JobsGridPortlet.class); jobsGridPortlet.setNumberOfColumns(3); jobsGridPortlet.setFillColumnFirst(true); v.save(); assertThat(jobsGridPortlet.getJob(1, 3), nullValue()); assertThat(jobsGridPortlet.getJob(2, 2), notNullValue()); }'","output":"public void jobsGridPortlet_fillColumnsFirst() { createFreeStyleJob(); createFreeStyleJob(); createFreeStyleJob(); createFreeStyleJob(); DashboardView v = createDashboardView(); JobsGridPortlet jobsGridPortlet = v.addBottomPortlet(JobsGridPortlet.class); jobsGridPortlet.setNumberOfColumns(3); jobsGridPortlet.setFillColumnFirst(true); v.save(); assertThat(jobsGridPortlet.getJob(1, 3), nullValue()); assertThat(jobsGridPortlet.getJob(2, 2), notNullValue()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Logging standard output'\nThe code is: 'protected void onPostExecute(Integer[] result){ <START> System.out.println(\"onPostExecute\"); <END> \/\/ Logging standard output if(result[0] == SUCCESS) { Toast.makeText(EncryptedSharedHealthRecordSyncTask.context, \"Uploaded \" + result[1] +\" SHR Data items\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(EncryptedSharedHealthRecordSyncTask.context, \"Error Uploading SHR Data. Uploaded \" + result[1] + \", Failed \" + result[2], Toast.LENGTH_SHORT).show(); } syncInProgress = false; }'","output":"protected void onPostExecute(Integer[] result){ if(result[0] == SUCCESS) { Toast.makeText(EncryptedSharedHealthRecordSyncTask.context, \"Uploaded \" + result[1] +\" SHR Data items\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(EncryptedSharedHealthRecordSyncTask.context, \"Error Uploading SHR Data. Uploaded \" + result[1] + \", Failed \" + result[2], Toast.LENGTH_SHORT).show(); } syncInProgress = false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'include MalformedURLException cause'\nThe code is: 'public byte[] getFirmwareImage(final String firmwareIdentification) throws FirmwareImageFactoryException { try { URL downloadUrl = new URL(this.url + firmwareIdentification); this.checkUrl(downloadUrl); return this.download(downloadUrl); } catch (final MalformedURLException e) { <START> throw new FirmwareImageFactoryException(EXCEPTION_MSG_MALFORMED_URL + this.url + firmwareIdentification); <END> \/\/ include MalformedURLException cause } catch (final IOException e) { throw new FirmwareImageFactoryException(EXCEPTION_MSG_FIRMWARE_NOT_RETRIEVED, e); } }'","output":"public byte[] getFirmwareImage(final String firmwareIdentification) throws FirmwareImageFactoryException { try { URL downloadUrl = new URL(this.url + firmwareIdentification); this.checkUrl(downloadUrl); return this.download(downloadUrl); } catch (final MalformedURLException e) { throw new FirmwareImageFactoryException(EXCEPTION_MSG_MALFORMED_URL + this.url + firmwareIdentification, e); } catch (final IOException e) { throw new FirmwareImageFactoryException(EXCEPTION_MSG_FIRMWARE_NOT_RETRIEVED, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class)'\nThe code is: 'public boolean isApplicable(Class<? extends Item> itemClass) { <START> if (itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class)) { <END> \/\/ return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class) return true; } else { return false; } }'","output":"public boolean isApplicable(Class<? extends Item> itemClass) { return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'public List<PlanNode> getSources() { <START> return Collections.singletonList(source); <END> \/\/ static import }'","output":"public List<PlanNode> getSources() { return singletonList(source); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'send null instead'\nThe code is: 'public void showMenuStep(Message<MenuItem> doneCallback, String textToShow, List<String> menuItems, String defaultValue) { <START> doneCallback.send(new MenuItem(\"\", 0)); <END> \/\/ send null instead }'","output":"public void showMenuStep(Message<MenuItem> doneCallback, String textToShow, List<String> menuItems, String defaultValue) { doneCallback.send(null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this override database value? if is another date? Remove this defaults database used'\nThe code is: 'public RtuDevice(final String deviceIdentification) { super(deviceIdentification); <START> this.lastCommunicationTime = new GregorianCalendar(2001, 0, 1).getTime(); <END> \/\/ this override database value? if is another date? Remove this defaults database used }'","output":"public RtuDevice(final String deviceIdentification) { super(deviceIdentification); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this(new ArrayList<Integer>(other.pattern));'\nThe code is: 'public JsonPattern(JsonPattern other) { <START> pattern = new ArrayList<Integer>(other.pattern); <END> \/\/ this(new ArrayList<Integer>(other.pattern)); }'","output":"public JsonPattern(JsonPattern other) { this(new ArrayList<Integer>(other.pattern)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for consistency, please final boolean actual'\nThe code is: 'public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(\"SomeOtherClass\"); <START> boolean actual = check.accepts(rule, context); <END> \/\/ for consistency, please final boolean actual assertFalse(actual); }'","output":"public void testAcceptWhenIsNotExpectedClass() { when(rule.getId()).thenReturn(\"SomeOtherClass\"); final boolean actual = check.accepts(rule, context); assertFalse(actual); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'verify text boundaries correct? Verifying simply set boundaries text decorator is ascertain values set'\nThe code is: 'public void testTextWrapBoundariesUpdates() { tested.refresh(); <START> verify(textDecorator).setTextBoundaries(any()); <END> \/\/ verify text boundaries correct? Verifying simply set boundaries text decorator is ascertain values set }'","output":"public void testTextWrapBoundariesUpdates() { tested.refresh(); verify(textDecorator).setTextBoundaries(PATH.getBoundingBox()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'valueof? Id is a String'\nThe code is: 'public String getGuid() { <START> return String.valueOf(id); <END> \/\/ valueof? Id is a String }'","output":"public String getGuid() { return id; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a lambda here: (rowExpression, level, session) -> rowExpression'\nThe code is: 'public void setup() { metadata = createTestMetadataManager(); domainTranslator = new RowExpressionDomainTranslator(metadata); <START> columnExtractor = new SubfieldExtractor(new FunctionResolution(metadata.getFunctionManager()), new NoopExpressionOptimizer(), TestingSession.SESSION); <END> \/\/ a lambda here: (rowExpression, level, session) -> rowExpression }'","output":"public void setup() { metadata = createTestMetadataManager(); domainTranslator = new RowExpressionDomainTranslator(metadata); columnExtractor = new SubfieldExtractor( new FunctionResolution(metadata.getFunctionManager()), (rowExpression, level, session) -> rowExpression, TestingSession.SESSION); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);'\nThe code is: 'public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateSignalEventCatching emptyTopEvent = getCatchingIntermediateNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_OUTGOING_EDGE); assertGeneralSet(emptyTopEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, \"\"); <END> \/\/ suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE); assertDataIOSet(emptyTopEvent.getDataIOSet(), EMPTY_VALUE); }'","output":"public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateSignalEventCatching emptyTopEvent = getCatchingIntermediateNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_OUTGOING_EDGE); assertGeneralSet(emptyTopEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE); assertDataIOSet(emptyTopEvent.getDataIOSet(), EMPTY_VALUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Formatting'\nThe code is: 'public void executeCommand(UICommand command) { super.executeCommand(command); if (command == getNewCommand()) { newSubnet(); <START> } <END> \/\/ Formatting else if (command == getRemoveCommand()) { remove(); } else if (\"Cancel\".equals(command.getName())) { cancel(); } }'","output":"public void executeCommand(UICommand command) { super.executeCommand(command); if (command == getNewCommand()) { newSubnet(); } else if (command == getRemoveCommand()) { remove(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Changing of setting unexpected side effect of repeatUntil. Please ensure toggle is set previous setting 'repeat' I a user want repeat feature set 'do throw' setting call (before initial call is repeated calling of 'repeat' methods). toggling in code removed altogether'\nThe code is: 'public boolean repeatUntilResponseStatusIs(final int expectedStatus) { <START> doNotThrowExceptionOnHttpRequestFailure(); <END> \/\/ Changing of setting unexpected side effect of repeatUntil. Please ensure toggle is set previous setting 'repeat' I a user want repeat feature set 'do throw' setting call (before initial call is repeated calling of 'repeat' methods). toggling in code removed altogether return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }'","output":"public boolean repeatUntilResponseStatusIs(final int expectedStatus) { return repeatUntil( new RepeatLastCall() { @Override public boolean isFinished() { return responseStatus() == expectedStatus; } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![MINOR](<LINK_2> 'Severity: MINOR') Remove redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>'\nThe code is: 'public static String sanitizeKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> \/\/ ![MINOR](<LINK_2> 'Severity: MINOR') Remove redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); }'","output":"public static String sanitizeKey(final Contentlet vanityUrl) throws DotDataException, DotSecurityException { Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'original behaviour skip writing memory cache well, this same. java return memoryPolicy(NO_CACHE, NO_STORE);'\nThe code is: '@Deprecated public RequestCreator skipMemoryCache() { <START> return memoryPolicy(NO_CACHE); <END> \/\/ original behaviour skip writing memory cache well, this same. java return memoryPolicy(NO_CACHE, NO_STORE); }'","output":"@Deprecated public RequestCreator skipMemoryCache() { return memoryPolicy(NO_CACHE, NO_STORE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want fix typo while around... :)'\nThe code is: 'public void clearCache() { Enumeration<IReferenceCollection> <START> elementss = <END> \/\/ want fix typo while around... :) fApiComponentCache.elements(); while (elementss.hasMoreElements()) { IReferenceCollection reference = elementss.nextElement(); reference.clear(); } fApiComponentCache.flush(); }'","output":"public void clearCache() { Enumeration<IReferenceCollection> elements = fApiComponentCache.elements(); while (elements.hasMoreElements()) { IReferenceCollection reference = elements.nextElement(); reference.clear(); } fApiComponentCache.flush(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: UnsupportedOperationException, NotImplementedException is reflection-specific'\nThe code is: 'public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) { <START> throw new NotImplementedException(); <END> \/\/ nit: UnsupportedOperationException, NotImplementedException is reflection-specific }'","output":"public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: getTypeName is a new one, fine e.getClass().getName() e.getClass().getCanonicalName() simpler'\nThe code is: 'private boolean isHostHealthy(InetSocketAddress host) { try { CassandraClientPoolingContainer testingContainer = currentPools.get(host); testingContainer.runWithPooledResource(describeRing); testingContainer.runWithPooledResource(validatePartitioner); return true; } catch (Exception e) { log.warn(\"We tried to add {} back into the pool, but got an exception\" + \" that caused us to distrust this host further. Exception message was: {} : {}\", SafeArg.of(\"host\", host), <START> SafeArg.of(\"exceptionClass\", e.getClass().getTypeName()), <END> \/\/ nit: getTypeName is a new one, fine e.getClass().getName() e.getClass().getCanonicalName() simpler UnsafeArg.of(\"exceptionMessage\", e.getMessage())); return false; } }'","output":"private boolean isHostHealthy(InetSocketAddress host) { try { CassandraClientPoolingContainer testingContainer = currentPools.get(host); testingContainer.runWithPooledResource(describeRing); testingContainer.runWithPooledResource(validatePartitioner); return true; } catch (Exception e) { log.warn(\"We tried to add {} back into the pool, but got an exception\" + \" that caused us to distrust this host further. Exception message was: {} : {}\", SafeArg.of(\"host\", host), SafeArg.of(\"exceptionClass\", e.getClass().getCanonicalName()), UnsafeArg.of(\"exceptionMessage\", e.getMessage())); return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this need public right'\nThe code is: '<START> public int appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { <END> \/\/ this need public right rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }'","output":"int appendFromDirectly(byte[] byteArray, int offset, int length) throws IOException { rollOverIfRequired(length); return activeSegment.appendFromDirectly(byteArray, offset, length); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inlined'\nThe code is: 'public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { <START> final boolean expected = false; <END> \/\/ inlined checkCanUserSeeProcessInstanceWhenApiReturn(expected); }'","output":"public void should_canUserSeeProcessInstance_call_engine_api_false() throws Exception { checkCanUserSeeProcessInstanceWhenApiReturn(false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'full control of expected data, right? self-sanitize (I if term exists?) data in expected'\nThe code is: 'private void equalizeIrrelevantData(AccountAttributes expected, AccountAttributes actual) { expected.createdAt = actual.createdAt; if (actual.studentProfile == null) { expected.studentProfile = null; } else { if (expected.studentProfile == null) { expected.studentProfile = new StudentProfileAttributes(); expected.studentProfile.googleId = actual.googleId; } expected.studentProfile.modifiedDate = actual.studentProfile.modifiedDate; <START> expected.sanitizeForSaving(); <END> \/\/ full control of expected data, right? self-sanitize (I if term exists?) data in expected } }'","output":"private void equalizeIrrelevantData(AccountAttributes expected, AccountAttributes actual) { expected.createdAt = actual.createdAt; if (actual.studentProfile == null) { expected.studentProfile = null; } else { if (expected.studentProfile == null) { expected.studentProfile = new StudentProfileAttributes(); expected.studentProfile.googleId = actual.googleId; } expected.studentProfile.modifiedDate = actual.studentProfile.modifiedDate; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return null callers deal null want. This default STRING in _all_ cases of deserializing ValueType, unforeseen ideal behavior'\nThe code is: 'public static ValueType fromString(String name) { if (name == null) { <START> return ValueType.STRING; <END> \/\/ return null callers deal null want. This default STRING in _all_ cases of deserializing ValueType, unforeseen ideal behavior } return valueOf(name.toUpperCase()); }'","output":"public static ValueType fromString(String name) { if (name == null) { return null; } return valueOf(name.toUpperCase()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ResourceUtils.closeOrLog(istream)'\nThe code is: 'public static KijiTableImportDescriptor createFromEffectiveJson(InputStream istream) throws IOException { try { final TableImportDescriptorDesc desc = readTableImportMappingDescFromJSON(istream); final KijiTableImportDescriptor layout = new KijiTableImportDescriptor(desc); return layout; } finally { <START> IOUtils.closeQuietly(istream); <END> \/\/ ResourceUtils.closeOrLog(istream) } }'","output":"public static KijiTableImportDescriptor createFromEffectiveJson(InputStream istream) throws IOException { try { final TableImportDescriptorDesc desc = readTableImportMappingDescFromJSON(istream); final KijiTableImportDescriptor layout = new KijiTableImportDescriptor(desc); return layout; } finally { ResourceUtils.closeOrLog(istream); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For consistency project, please remove final keyword here'\nThe code is: 'private ConcurrentHashMap<String, ClientRegistration> toConcurrentMap(List<ClientRegistration> registrations) { <START> final ConcurrentHashMap<String, ClientRegistration> result = new ConcurrentHashMap<>(); <END> \/\/ For consistency project, please remove final keyword here for (ClientRegistration registration : registrations) { result.put(registration.getRegistrationId(), registration); } return result; }'","output":"private ConcurrentHashMap<String, ClientRegistration> toConcurrentMap(List<ClientRegistration> registrations) { ConcurrentHashMap<String, ClientRegistration> result = new ConcurrentHashMap<>(); for (ClientRegistration registration : registrations) { result.put(registration.getRegistrationId(), registration); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is a leftover I assume'\nThe code is: 'public T one(final String id) { try { return reactiveSupport.one(id).block(); } catch(DocumentNotFoundException dnfe){ <START> dnfe.printStackTrace(); <END> \/\/ this is a leftover I assume return null; } }'","output":"public T one(final String id) { return reactiveSupport.one(id).block(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'K9.DEBUG is constant tied \"debug logging\" setting. Please BuildConfig.DEBUG'\nThe code is: 'public void debugClearMessagesLocally(final List<LocalMessage> messages) { <START> if (!K9.DEBUG) { <END> \/\/ K9.DEBUG is constant tied \"debug logging\" setting. Please BuildConfig.DEBUG throw new AssertionError(\"method must only be used in debug build!\"); } putBackground(\"debugClearLocalMessages\", null, new Runnable() { @Override public void run() { for (LocalMessage message : messages) { try { message.debugClearLocalData(); } catch (MessagingException e) { throw new AssertionError(\"clearing local message content failed!\", e); } } } }); }'","output":"public void debugClearMessagesLocally(final List<LocalMessage> messages) { if (!BuildConfig.DEBUG) { throw new AssertionError(\"method must only be used in debug build!\"); } putBackground(\"debugClearLocalMessages\", null, new Runnable() { @Override public void run() { for (LocalMessage message : messages) { try { message.debugClearLocalData(); } catch (MessagingException e) { throw new AssertionError(\"clearing local message content failed!\", e); } } } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this !useHyphens'\nThe code is: 'public String generateUuid() { String uuid = UUID.randomUUID().toString(); <START> if (useHyphens) { <END> \/\/ I this !useHyphens uuid = uuid.replaceAll(\"-\", \"\"); } return uuid; }'","output":"public String generateUuid() { String uuid = UUID.randomUUID().toString(); if (!useHyphens) { uuid = uuid.replaceAll(\"-\", \"\"); } return uuid; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please \"something <operator> null\" convention'\nThe code is: 'protected Locale getLocaleFromRequest(final HttpServletRequest request) { String localeString = getLocaleStringFromReferer(request); <START> if (null == localeString) { <END> \/\/ Please \"something <operator> null\" convention localeString = getLocaleStringFromPath(request.getPathInfo()); } Locale locale = LocaleUtils.getLocaleFromString(localeString, true); return locale; }'","output":"protected Locale getLocaleFromRequest(final HttpServletRequest request) { String localeString = getLocaleStringFromReferer(request); if (localeString == null) { localeString = getLocaleStringFromPath(request.getPathInfo()); } Locale locale = LocaleUtils.getLocaleFromString(localeString, true); return locale; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please remove decrease log level TRACE'\nThe code is: 'public void activate() { <START> logger.debug(\"activate() is called!\"); <END> \/\/ please remove decrease log level TRACE }'","output":"public void activate() { logger.trace(\"activate() is called!\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'stopped'\nThe code is: 'public void deactivate() { super.deactivate(); <START> logger.debug(\"DD-WRT binding has been started.\"); <END> \/\/ stopped }'","output":"public void deactivate() { super.deactivate(); logger.debug(\"DD-WRT binding has been stopped.\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please follow existing code style spaces'\nThe code is: 'public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); <START> if(sleepMs > MAX_DELAY){ <END> \/\/ Please follow existing code style spaces sleepMs = MAX_DELAY; } TimeUnit.MILLISECONDS.sleep(sleepMs); }'","output":"public void sleep(int retryCount) throws InterruptedException { long sleepMs = (long) (baseSleepTimeMs * Math.pow(2, retryCount)); TimeUnit.MILLISECONDS.sleep(sleepMs); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check needed throw IllegalArgumentException()'\nThe code is: 'public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException { SSLEngine e = sslcontext.createSSLEngine(); e.setUseClientMode(false); <START> if (sslParameters != null) { <END> \/\/ check needed throw IllegalArgumentException() e.setSSLParameters(sslParameters); } return new SSLSocketChannel2(channel, e, exec, key); }'","output":"public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException { SSLEngine e = sslcontext.createSSLEngine(); e.setUseClientMode(false); e.setSSLParameters(sslParameters); return new SSLSocketChannel2(channel, e, exec, key); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I \"resolve\" fits other strategy names have'\nThe code is: 'public String getName() { <START> return \"StrategyResolve\"; <END> \/\/ I \"resolve\" fits other strategy names have }'","output":"public String getName() { return \"resolve\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add context here'\nThe code is: 'public String toString() { <START> return \"KinesisSupervisorSpec{\" + <END> \/\/ add context here \"dataSchema=\" + getDataSchema() + \", tuningConfig=\" + getTuningConfig() + \", ioConfig=\" + getIoConfig() + \", suspended=\" + isSuspended() + '}'; }'","output":"public String toString() { return \"KinesisSupervisorSpec{\" + \"dataSchema=\" + getDataSchema() + \", tuningConfig=\" + getTuningConfig() + \", ioConfig=\" + getIoConfig() + \", suspended=\" + isSuspended() + \", context=\" + getContext() + '}'; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If description is sanitized constructor, I this is needed anymore. a simple return questionDescription do'\nThe code is: 'public Text getQuestionDescription() { return questionDescription == null ? null <START> : new Text(Sanitizer.sanitizeForRichText(questionDescription.getValue())); <END> \/\/ If description is sanitized constructor, I this is needed anymore. a simple return questionDescription do }'","output":"public Text getQuestionDescription() { return questionDescription; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion: ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources();'\nThe code is: 'private synchronized void deleteFailedCommand(Command command) { int indexOfCommand = mCommandList.indexOf(command); <START> mCommandList.remove(indexOfCommand); <END> \/\/ suggestion: ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }'","output":"private synchronized void deleteFailedCommand(Command command) { int indexOfCommand = mCommandList.indexOf(command); ((BaseCommand) mCommandList.remove(indexOfCommand)).freeResources(); mCommandCounter--; mCommandIndex--; if (mCommandCounter == 1) { UndoRedoManager.getInstance().update( UndoRedoManager.StatusMode.DISABLE_UNDO); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Removing blocks this pack a bad idea. system calls remove(DsfPackFile) a pretty good notion pack file is longer part of repository, memory sitting is useless. I bother this \"optimization\", cache eviction algorithm eventually kill blocks anyway, accessed. If is pressure cache evict (because at\/under target size), is pressure spend CPU time evict this dead pack's blocks. cache \"up to\" target size of memory promised it, rest of system hands part of heap'\nThe code is: '<START> void remove(DfsPackFile pack) { packCache.remove(pack.getPackDescription()); removeRef(pack.key); <END> \/\/ Removing blocks this pack a bad idea. system calls remove(DsfPackFile) a pretty good notion pack file is longer part of repository, memory sitting is useless. I bother this \"optimization\", cache eviction algorithm eventually kill blocks anyway, accessed. If is pressure cache evict (because at\/under target size), is pressure spend CPU time evict this dead pack's blocks. cache \"up to\" target size of memory promised it, rest of system hands part of heap }'","output":"void remove(DfsPackFile pack) { packCache.remove(pack.getPackDescription()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'support string \"true\" \"false\" conversion'\nThe code is: 'public void checkStoreSchema(ResourceSchema.ResourceFieldSchema schema) throws IOException { switch (schema.getType()) { case DataType.CHARARRAY: case DataType.INTEGER: case DataType.LONG: case DataType.FLOAT: case DataType.DOUBLE: <START> return; <END> \/\/ support string \"true\" \"false\" conversion } throw new IOException(\"Pig type '\" + DataType.findTypeName(schema.getType()) + \"' unsupported\"); }'","output":"public void checkStoreSchema(ResourceSchema.ResourceFieldSchema schema) throws IOException { switch (schema.getType()) { case DataType.CHARARRAY: case DataType.INTEGER: case DataType.LONG: case DataType.FLOAT: case DataType.DOUBLE: case DataType.BOOLEAN: return; } throw new IOException(\"Pig type '\" + DataType.findTypeName(schema.getType()) + \"' unsupported\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this'\nThe code is: 'public void updateShouldUpdateEmailMeStateToFalse() throws Exception { User user = new User(\"user-1\"); user.enable(); user.setEmailMe(true); addUser(user); HttpLocalizedOperationResult result = new HttpLocalizedOperationResult(); userService.save(user, TriState.UNSET, TriState.FALSE, null, null, result); assertThat(result.isSuccessful(), is(true)); assertThat(user.isEmailMe(), is(false)); <START> ; <END> \/\/ Remove this }'","output":"public void updateShouldUpdateEmailMeStateToFalse() throws Exception { User user = new User(\"user-1\"); user.enable(); user.setEmailMe(true); addUser(user); HttpLocalizedOperationResult result = new HttpLocalizedOperationResult(); userService.save(user, TriState.UNSET, TriState.FALSE, null, null, result); assertThat(result.isSuccessful(), is(true)); assertThat(user.isEmailMe(), is(false)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'RuntimeException'\nThe code is: 'private Optional<LocalMemoryContext> getSystemMemoryContext() { try { return Optional.of(systemMemoryContextSupplier.get()); } <START> catch (Exception ignored) { <END> \/\/ RuntimeException } return Optional.empty(); }'","output":"private Optional<LocalMemoryContext> getSystemMemoryContext() { try { return Optional.of(systemMemoryContextSupplier.get()); } catch (RuntimeException ignored) { } return Optional.empty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I teamcity is complaining Exception is thrown'\nThe code is: '<START> public void testGetDependentFields() throws Exception <END> \/\/ I teamcity is complaining Exception is thrown { List<String> dependentFields = fac.getDependentFields(); assertEquals(1, dependentFields.size()); assertEquals(\"field\", dependentFields.get(0)); }'","output":"public void testGetDependentFields() { List<String> dependentFields = fac.getDependentFields(); assertEquals(1, dependentFields.size()); assertEquals(\"field\", dependentFields.get(0)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need this method final rest'\nThe code is: '<START> public final InetSocketAddress getSource() { <END> \/\/ do need this method final rest return endpoint.getAddress(); }'","output":"public InetSocketAddress getSource() { return endpoint.getAddress(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logger'\nThe code is: 'private void displayDetails(String period, String unit, String dataType) throws Exception { <START> System.out.println(\"***********************************************\"); <END> \/\/ logger System.out.println(\"executing for:\"); System.out.println(unit + \"(\" + period + \")\"); System.out.println(\"dataType=\" + dataType); System.out.println(\"***********************************************\"); }'","output":"private void displayDetails(String period, String unit, String dataType) throws Exception { logger.info(\"***********************************************\"); logger.info(\"executing for:\"); logger.info(unit + \"(\" + period + \")\"); logger.info(\"dataType=\" + dataType); logger.info(\"***********************************************\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return new FormulaShifter(... is fine. need store returned in instance'\nThe code is: 'public static FormulaShifter createForRowShift(int externSheetIndex, String sheetName, int firstMovedRowIndex, int lastMovedRowIndex, int numberOfRowsToMove, SpreadsheetVersion version) { FormulaShifter instance = new FormulaShifter(externSheetIndex, sheetName, firstMovedRowIndex, lastMovedRowIndex, numberOfRowsToMove, ShiftMode.RowMove, version); <START> return instance; <END> \/\/ return new FormulaShifter(... is fine. need store returned in instance }'","output":"public static FormulaShifter createForRowShift(int externSheetIndex, String sheetName, int firstMovedRowIndex, int lastMovedRowIndex, int numberOfRowsToMove, SpreadsheetVersion version) { return new FormulaShifter(externSheetIndex, sheetName, firstMovedRowIndex, lastMovedRowIndex, numberOfRowsToMove, ShiftMode.RowMove, version); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return \"<LINK_1>\";'\nThe code is: 'private static String getHBaseDownloadUrl() { <START> return \"<LINK_0>\"; <END> \/\/ suggestion return \"<LINK_1>\"; }'","output":"private static String getHBaseDownloadUrl() { return \"<LINK_1>\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this synchronization unnecessary'\nThe code is: 'public void onClose(Client client) { <START> synchronized(clients) { <END> \/\/ this synchronization unnecessary clients.remove(client); } }'","output":"public void onClose(Client client) { clients.remove(client); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method create a method \"active\" alias this method'\nThe code is: '<START> public ProductDiscountDraftBuilder isActive(final Boolean isActive) { <END> \/\/ this method create a method \"active\" alias this method this.isActive = isActive; return this; }'","output":"public ProductDiscountDraftBuilder isActive(final Boolean isActive) { this.active = isActive; return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion bean.setSourceSet(new HashSet<>());'\nThe code is: 'public SetFactoryBean ldapAuthenticationHandlerSetFactoryBean() { val bean = new SetFactoryBean() { @Override protected void destroyInstance(final Set set) { set.forEach(Unchecked.consumer(handler -> { ((DisposableBean) handler).destroy(); })); } }; <START> bean.setSourceSet(new HashSet()); <END> \/\/ suggestion bean.setSourceSet(new HashSet<>()); return bean; }'","output":"public SetFactoryBean ldapAuthenticationHandlerSetFactoryBean() { val bean = new SetFactoryBean() { @Override protected void destroyInstance(final Set set) { set.forEach(Unchecked.consumer(handler -> ((DisposableBean) handler).destroy() )); } }; bean.setSourceSet(new HashSet<>()); return bean; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'class exist'\nThe code is: 'public void start(@Nullable BundleContext context) throws Exception { super.start(context); plugin = this; try { <START> Class.forName(\"org.eclipse.tracecompass.tracing.rcp.ui.cli.CliParserExtension\"); <END> \/\/ class exist } catch (ClassNotFoundException e) { return; } }'","output":"public void start(@Nullable BundleContext context) throws Exception { super.start(context); plugin = this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'double ;;'\nThe code is: 'public SelectorFilter( String dimension, String value, ExtractionFn extractionFn ) { this.dimension = dimension; <START> this.value = Strings.nullToEmpty(value);; <END> \/\/ double ;; this.extractionFn = extractionFn; }'","output":"public SelectorFilter( String dimension, String value, ExtractionFn extractionFn ) { this.dimension = dimension; this.value = Strings.nullToEmpty(value); this.extractionFn = extractionFn; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, \"cacheConfig is null\").isValidationEnabled();'\nThe code is: 'public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, \"hiveHdfsConfiguration is null\"); this.cacheManager = requireNonNull(cacheManager, \"CacheManager is null\"); <START> cacheConfig = requireNonNull(cacheConfig, \"cacheConfig is null\"); <END> \/\/ nit: this.cacheValidationEnabled = requireNonNull(cacheConfig, \"cacheConfig is null\").isValidationEnabled(); this.cacheValidationEnabled = cacheConfig.isValidationEnabled(); }'","output":"public RaptorCachingHdfsConfiguration( @ForCachingFileSystem RaptorHdfsConfiguration hiveHdfsConfiguration, CacheConfig cacheConfig, CacheManager cacheManager) { this.hiveHdfsConfiguration = requireNonNull(hiveHdfsConfiguration, \"hiveHdfsConfiguration is null\"); this.cacheManager = requireNonNull(cacheManager, \"CacheManager is null\"); this.cacheValidationEnabled = requireNonNull(cacheConfig, \"cacheConfig is null\").isValidationEnabled(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: this event()'\nThe code is: 'public String selector() { <START> return FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.name(); <END> \/\/ nit: this event() }'","output":"public String selector() { return FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.event(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Optional: remove \"debug\" in print statement'\nThe code is: 'public static String getGatewayAlias(String url) { if (StringUtils.isNotBlank(url)) { String urlKey = getUrlKey(url); String gatewayAlias = gatewayAliasMapping.get(urlKey); if(StringUtils.isNotBlank(gatewayAlias)){ <START> LOG.debug(\"debug--found url:{}, gatewayAlias:{}\", url, gatewayAlias); <END> \/\/ Optional: remove \"debug\" in print statement return gatewayAlias; } } return getInstance().getPrivateKeyAlias(); }'","output":"public static String getGatewayAlias(String url) { if (StringUtils.isNotBlank(url)) { String urlKey = getUrlKey(url); String gatewayAlias = gatewayAliasMapping.get(urlKey); if(StringUtils.isNotBlank(gatewayAlias)){ LOG.debug(\"found url:{}, gatewayAlias:{}\", url, gatewayAlias); return gatewayAlias; } } return getInstance().getPrivateKeyAlias(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This reverted private'\nThe code is: '<START> public void appendNewLine(String content) { <END> \/\/ This reverted private waitForElementByElement(sourceModeTextArea); sourceModeTextArea.sendKeys(Keys.ENTER); sourceModeTextArea.sendKeys(content); PageObjectLogging.log(\"appendNewLine\", \"text \"+content+\" added to the source mode in new line\", true); }'","output":"private void appendNewLine(String content) { waitForElementByElement(sourceModeTextArea); sourceModeTextArea.sendKeys(Keys.ENTER); sourceModeTextArea.sendKeys(content); PageObjectLogging.log(\"appendNewLine\", \"text \"+content+\" added to the source mode in new line\", true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consider leave constructor add new'\nThe code is: 'public void getFileName_ReturnsFileNameForSVG() { <START> Embedding embedding = new Embedding(\"image\/svg+xml\", \"some data\", null); <END> \/\/ consider leave constructor add new String fileName = embedding.getFileName(); assertThat(fileName).isEqualTo(\"embedding_-642587818.svg\"); }'","output":"public void getFileName_ReturnsFileNameForSVG() { Embedding embedding = new Embedding(\"image\/svg+xml\", \"some data\"); String fileName = embedding.getFileName(); assertThat(fileName).isEqualTo(\"embedding_-642587818.svg\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'executorService.shutdown() well'\nThe code is: 'public void stop() { <START> running = false; <END> \/\/ executorService.shutdown() well }'","output":"public void stop() { running = false; executorService.shutdown(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'needed copy again'\nThe code is: 'public void generateReport_OnInvalidPath_ThrowsException() { <START> setUpWithJson(SAMPLE_JSON); <END> \/\/ needed copy again page = new FeaturesOverviewPage(reportResult, configuration) { @Override public String getWebPage() { return StringUtils.EMPTY; } }; thrown.expect(ValidationException.class); Deencapsulation.invoke(page, \"generatePage\"); }'","output":"public void generateReport_OnInvalidPath_ThrowsException() { page = new FeaturesOverviewPage(reportResult, configuration) { @Override public String getWebPage() { return StringUtils.EMPTY; } }; thrown.expect(ValidationException.class); Deencapsulation.invoke(page, \"generatePage\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'essageQueue.RegisterBankAccount_PushMessage'\nThe code is: 'public MessageQueue queue() { <START> return MessageQueue.CertificationSuccess_PushMessage; <END> \/\/ essageQueue.RegisterBankAccount_PushMessage }'","output":"public MessageQueue queue() { return MessageQueue.RegisterBankAccount_PushMessage; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This platform default character encoding. good explicit, please publicCertificate.getBytes(StandardCharsets.UTF_8) instead'\nThe code is: 'public byte[] getPublicCertificate() { <START> return publicCertificate.getBytes(); <END> \/\/ This platform default character encoding. good explicit, please publicCertificate.getBytes(StandardCharsets.UTF_8) instead }'","output":"public byte[] getPublicCertificate() { return publicCertificate.getBytes(StandardCharsets.UTF_8); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrap this try-catch return Mono.error() if exceptions. For reference, other async clients'\nThe code is: 'public Mono<DetectLanguageResult> detectLanguage(String text) { <START> return detectLanguageWithResponse(text, defaultCountryHint).flatMap(FluxUtil::toMono); <END> \/\/ Wrap this try-catch return Mono.error() if exceptions. For reference, other async clients }'","output":"public Mono<DetectLanguageResult> detectLanguage(String text) { try { return detectLanguageWithResponse(text, defaultCountryHint).flatMap(FluxUtil::toMono); } catch (RuntimeException ex) { return monoError(logger, ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'probalby Objects.equals more safe apply in case reassingmentsInfo is null some point'\nThe code is: 'public boolean equals(Object o) { if (o instanceof ReassignmentSet) { ReassignmentSet other = (ReassignmentSet) o; <START> return reassignmentsInfo.equals(other.reassignmentsInfo); <END> \/\/ probalby Objects.equals more safe apply in case reassingmentsInfo is null some point } return false; }'","output":"public boolean equals(Object o) { if (o instanceof ReassignmentSet) { ReassignmentSet other = (ReassignmentSet) o; return Objects.equals(reassignmentsInfo, other.reassignmentsInfo); } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: suggestion log.error(\"User [%s] role [%s], role object found.\", user.getName(), roleName);'\nThe code is: 'private Set<BasicAuthorizerRole> getRolesForUser( BasicAuthorizerUser user, Map<String, BasicAuthorizerRole> roleMap ) { Set<BasicAuthorizerRole> roles = new HashSet<>(); for (String roleName : user.getRoles()) { BasicAuthorizerRole role = roleMap.get(roleName); if (role == null) { <START> log.error(\"User [%s] had role [%s], but role was not found.\", user.getName(), roleName); <END> \/\/ nit: suggestion log.error(\"User [%s] role [%s], role object found.\", user.getName(), roleName); } else { roles.add(role); } } return roles; }'","output":"private Set<BasicAuthorizerRole> getRolesForUser( BasicAuthorizerUser user, Map<String, BasicAuthorizerRole> roleMap ) { Set<BasicAuthorizerRole> roles = new HashSet<>(); for (String roleName : user.getRoles()) { BasicAuthorizerRole role = roleMap.get(roleName); if (role == null) { log.error(\"User [%s] had role [%s], but role object was not found.\", user.getName(), roleName); } else { roles.add(role); } } return roles; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary storing of local variable convertedStreamRecord'\nThe code is: 'public void testToStreamRecordV2WhenNewImageIsNull() { com.amazonaws.services.lambda.runtime.events.models.dynamodb.StreamRecord streamRecord = streamRecord_event.clone(); streamRecord.setNewImage(null); Assertions.assertDoesNotThrow(() -> { <START> StreamRecord convertedStreamRecord = DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); <END> \/\/ unnecessary storing of local variable convertedStreamRecord }); }'","output":"public void testToStreamRecordV2WhenNewImageIsNull() { com.amazonaws.services.lambda.runtime.events.models.dynamodb.StreamRecord streamRecord = streamRecord_event.clone(); streamRecord.setNewImage(null); Assertions.assertDoesNotThrow(() -> { DynamodbStreamRecordTransformer.toStreamRecordV2(streamRecord); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion LOGGER.error(\"Updating remote repository failed\",e);'\nThe code is: 'public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException { try { gitHandler.updateLocalRepository(); } catch (GitAPIException e) { LOGGER.info(\"Updating repository from remote failed\"); } persistResults(crawlResults); study.setLastSearchDate(LocalDate.now()); persistStudy(); try { gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now()); } catch (GitAPIException e) { <START> LOGGER.info(\"Updating remote repository failed\"); <END> \/\/ suggestion LOGGER.error(\"Updating remote repository failed\",e); } }'","output":"public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException { try { gitHandler.updateLocalRepository(); } catch (GitAPIException e) { LOGGER.error(\"Updating repository from remote failed\"); } persistResults(crawlResults); study.setLastSearchDate(LocalDate.now()); persistStudy(); try { gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now()); } catch (GitAPIException e) { LOGGER.error(\"Updating remote repository failed\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add codec toString()'\nThe code is: 'public String toString() { <START> return \"ChronicleLogTailer{\" + \"basePath='\" + basePath + '\\'' + \", id=\" + id + \", closed=\" + closed + '}'; <END> \/\/ Add codec toString() }'","output":"public String toString() { return \"ChronicleLogTailer{\" + \"basePath='\" + basePath + '\\'' + \", id=\" + id + \", closed=\" + closed + \", codec=\" + codec + '}'; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'index is guaranteed non-null, index.equals(indexInterpolated) is sufficient'\nThe code is: 'private void validate() { ArgChecker.inOrderNotEqual(startDate, endDate, \"startDate\", \"endDate\"); <START> if (indexInterpolated != null && indexInterpolated.equals(index)) { <END> \/\/ index is guaranteed non-null, index.equals(indexInterpolated) is sufficient throw new IllegalArgumentException(\"Interpolation requires two different indices\"); } }'","output":"private void validate() { ArgChecker.inOrderNotEqual(startDate, endDate, \"startDate\", \"endDate\"); if (index.equals(indexInterpolated)) { throw new IllegalArgumentException(\"Interpolation requires two different indices\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again, I understand this is needed? in AbstractNetworkPopupPresenterWidget'\nThe code is: 'public void updateVisibility() { super.updateVisibility(); messageLabel.setVisible(false); <START> subnetTab.setVisible(exportEditor.asCheckBox().getValue()); <END> \/\/ Again, I understand this is needed? in AbstractNetworkPopupPresenterWidget }'","output":"public void updateVisibility() { super.updateVisibility(); messageLabel.setVisible(false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check this prints messages decent grammar? sure, \"cluster name ... service name ...\"'\nThe code is: 'private String buildMessageForCompositeName(String clusterName, String serviceName) { <START> return String.format(\"cluster name <%s>, name <%s>\", <END> \/\/ check this prints messages decent grammar? sure, \"cluster name ... service name ...\" clusterName, serviceName); }'","output":"private String buildMessageForCompositeName(String clusterName, String serviceName) { return String.format(\"cluster name <%s>, service name <%s>\", clusterName, serviceName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'follow singleton pattern. add private prevent others call new AdapterPatientDiscoveryProxyWebServiceHelper()'\nThe code is: '<START> AdapterPatientDiscoveryProxyWebServiceHelper() { <END> \/\/ follow singleton pattern. add private prevent others call new AdapterPatientDiscoveryProxyWebServiceHelper() }'","output":"private AdapterPatientDiscoveryProxyWebServiceHelper() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, call this(,,)'\nThe code is: 'public GetTaskListCommandParameters(Guid vdsId) { super(vdsId); storagePoolId = null; <START> compatbilityVersion = null; <END> \/\/ here, call this(,,) }'","output":"public GetTaskListCommandParameters(Guid vdsId) { super(vdsId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '_protected_ allow users override if want'\nThe code is: 'private synchronized void asyncAuth(int cmd, Buffer buffer, boolean authed) { <START> try { <END> \/\/ _protected_ allow users override if want if (authed) { handleAuthenticationSuccess(cmd, buffer); } else { handleAuthenticationFailure(cmd, buffer); } } catch (Exception e) { log.warn(\"Error performing async authentication: {}\", e.getMessage(), e); } }'","output":"protected synchronized void asyncAuth(int cmd, Buffer buffer, boolean authed) { try { if (authed) { handleAuthenticationSuccess(cmd, buffer); } else { handleAuthenticationFailure(cmd, buffer); } } catch (Exception e) { log.warn(\"Error performing async authentication: {}\", e.getMessage(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this warning\/error info? thoughts channels in kogito envelope. some of envelope? is small subparts\/panels\/components of editor registered shortcuts common envelope is present'\nThe code is: 'public KeyboardShortcutsApi produce() { if (WindowRef.isEnvelopeAvailable()) { return new KeyboardShortcutsService(); } <START> DomGlobal.console.info(\"[KeyboardShortcutsServiceProducer] Envelope API is not available. Producing NoOpKeyboardShortcutsService\"); <END> \/\/ this warning\/error info? thoughts channels in kogito envelope. some of envelope? is small subparts\/panels\/components of editor registered shortcuts common envelope is present return new NoOpKeyboardShortcutsService(); }'","output":"public KeyboardShortcutsApi produce() { if (WindowRef.isEnvelopeAvailable()) { return new KeyboardShortcutsService(); } DomGlobal.console.debug(\"[KeyboardShortcutsServiceProducer] Envelope API is not available. Producing NoOpKeyboardShortcutsService\"); return new NoOpKeyboardShortcutsService(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Histogram everywhere, replace AbstractHistogram::reset Histogram::reset'\nThe code is: 'private void reset() { <START> allHistograms.forEach(AbstractHistogram::reset); <END> \/\/ Histogram everywhere, replace AbstractHistogram::reset Histogram::reset }'","output":"private void reset() { allHistograms.forEach(Histogram::reset); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This deleted'\nThe code is: 'protected void beforeTest() { beforeTestSetup(); <START> client = clientSetup(pipeline -> new KeyClientBuilder() .vaultUrl(getEndpoint()) .pipeline(pipeline) .buildClient()); <END> \/\/ This deleted }'","output":"protected void beforeTest() { beforeTestSetup(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this(new WithTextMatcher(title) removing title attribute'\nThe code is: 'public DialogWithTitle(String title) { <START> this.title = title; <END> \/\/ this(new WithTextMatcher(title) removing title attribute }'","output":"public DialogWithTitle(String title) { this(new WithTextMatcher(title)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please pass original exception parameter. in case'\nThe code is: 'public static Optional<String> getShortScienceSearchURL(BibEntry entry) { return entry.getField(StandardField.TITLE).map(title -> { URIBuilder uriBuilder; try { uriBuilder = new URIBuilder(SHORTSCIENCE_SEARCH_URL); } catch (URISyntaxException e) { <START> throw new AssertionError(\"ShortScience URL is invalid.\"); <END> \/\/ Please pass original exception parameter. in case } uriBuilder.addParameter(\"q\", title); return uriBuilder.toString(); }); }'","output":"public static Optional<String> getShortScienceSearchURL(BibEntry entry) { return entry.getField(StandardField.TITLE).map(title -> { URIBuilder uriBuilder; try { uriBuilder = new URIBuilder(SHORTSCIENCE_SEARCH_URL); } catch (URISyntaxException e) { throw new AssertionError(\"ShortScience URL is invalid.\", e); } uriBuilder.addParameter(\"q\", title); return uriBuilder.toString(); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a WARN instead of a debug'\nThe code is: 'private void backoff(int numberOfAttempts) { try { long sleepMillis = (long) Math.pow(2, numberOfAttempts) * 50; <START> LOGGER.debug(\"Throttled by DynamoDB, sleeping for {} ms.\", sleepMillis); <END> \/\/ this a WARN instead of a debug Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(\"Interrupted while attempting exponential backoff.\"); } }'","output":"private void backoff(int numberOfAttempts) { try { long sleepMillis = (long) Math.pow(2, numberOfAttempts) * 50; LOGGER.warn(\"Throttled by DynamoDB, sleeping for {} ms.\", sleepMillis); Thread.sleep(sleepMillis); } catch (InterruptedException e) { LOGGER.error(\"Interrupted while attempting exponential backoff.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion \") returns null.\"); memberAccessor null, returns null'\nThe code is: 'public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), \"Constraint configuration provider (\" + constraintConfigurationMemberAccessor + <START> \") is null.\"); <END> \/\/ suggestion \") returns null.\"); memberAccessor null, returns null return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }'","output":"public Function<Solution_, Score<?>> createExtractor() { SolutionDescriptor<Solution_> solutionDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor(); MemberAccessor constraintConfigurationMemberAccessor = solutionDescriptor.getConstraintConfigurationMemberAccessor(); return (Solution_ solution) -> { Object constraintConfiguration = Objects.requireNonNull(constraintConfigurationMemberAccessor.executeGetter(solution), \"Constraint configuration provider (\" + constraintConfigurationMemberAccessor + \") returns null.\"); return (Score<?>) memberAccessor.executeGetter(constraintConfiguration); }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for you. change class AssetReport'\nThe code is: '<START> public Report getReport() { return this.report; } <END> \/\/ for you. change class AssetReport'","output":"public AssetReport getReport() { return this.report; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'cast List'\nThe code is: 'protected List<Guid> executeHSMGetStorageDomainsList(HSMGetStorageDomainsListVDSCommandParameters parameters) { <START> return (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters).getReturnValue(); <END> \/\/ cast List }'","output":"protected List<Guid> executeHSMGetStorageDomainsList(HSMGetStorageDomainsListVDSCommandParameters parameters) { return (List<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters).getReturnValue(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this necessary'\nThe code is: 'public Trader(String name, double cashInHand) { <START> super(); <END> \/\/ Is this necessary this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }'","output":"public Trader(String name, double cashInHand) { this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this::performLoadBalancing'\nThe code is: 'private void enableLoadBalancer() { if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) { log.info(\"Start scheduling to enable vds load balancer\"); <START> executor.scheduleWithFixedDelay(() -> performLoadBalancing(), <END> \/\/ this::performLoadBalancing Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES); log.info(\"Finished scheduling to enable vds load balancer\"); } }'","output":"private void enableLoadBalancer() { if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) { log.info(\"Start scheduling to enable vds load balancer\"); executor.scheduleWithFixedDelay(this::performLoadBalancing, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES); log.info(\"Finished scheduling to enable vds load balancer\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'import static method for remove Assert'\nThe code is: 'public void parserShouldReturnGlobPattern() throws Exception { <START> Assert.assertEquals(\"**\/*.csv\", locustParser.getDefaultGlobPattern()); <END> \/\/ import static method for remove Assert }'","output":"public void parserShouldReturnGlobPattern() throws Exception { assertEquals(\"**\/*.csv\", locustParser.getDefaultGlobPattern()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove log altogether, this added for debugging purposes. I is bad practice log for debugging instead of Android Studio's debugger. breakpoints ftw! :smile:'\nThe code is: 'public static void pauseFlash() { <START> Log.d(TAG, \"pauseFlash()\"); <END> \/\/ remove log altogether, this added for debugging purposes. I is bad practice log for debugging instead of Android Studio's debugger. breakpoints ftw! :smile: if (!paused && isAvailable()) { paused = true; if (isOn()) { startAgain = true; flashOff(); } } }'","output":"public static void pauseFlash() { if (!paused && isAvailable()) { paused = true; if (isOn()) { startAgain = true; flashOff(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'calling this method subscribe in presenter'\nThe code is: 'public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); super.setPresenter(mPresenter); setHasOptionsMenu(true); <START> ((PatientDashboardDetailsPresenter) mPresenter).updatePatientDataFromServer(); <END> \/\/ calling this method subscribe in presenter }'","output":"public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); super.setPresenter(mPresenter); setHasOptionsMenu(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'log this if runnables is empty'\nThe code is: 'protected void killSpawnedThreads() { List<Runnable> runnables = defaultExecutorService.shutdownNow(); <START> log.errorf(\"There were runnables %s left uncompleted in test %s\", runnables, getClass().getSimpleName()); <END> \/\/ log this if runnables is empty for (TrackingThreadFactory factory : requestedThreadFactories) { checkFactoryForLeaks(factory); } }'","output":"protected void killSpawnedThreads() { List<Runnable> runnables = defaultExecutorService.shutdownNow(); if (!runnables.isEmpty()) { log.errorf(\"There were runnables %s left uncompleted in test %s\", runnables, getClass().getSimpleName()); } for (TrackingThreadFactory factory : requestedThreadFactories) { checkFactoryForLeaks(factory); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this'\nThe code is: 'public void setSeek(SeekCommand seekCommand) { <START> this.fSeek = seekCommand; <END> \/\/ remove this }'","output":"public void setSeek(SeekCommand seekCommand) { fSeek = seekCommand; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'debug leftover'\nThe code is: 'public boolean apply(Map.Entry mapEntry) { <START> Thread.dumpStack(); <END> \/\/ debug leftover PREDICATE_APPLY_COUNT.incrementAndGet(); return true; }'","output":"public boolean apply(Map.Entry mapEntry) { PREDICATE_APPLY_COUNT.incrementAndGet(); return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Hmmm...in hind sight move this debug sensitive data automatically logged'\nThe code is: 'public void completeTaskExecution(long executionId, Integer exitCode, Date endTime, String exitMessage) { initialize(); validateExitInformation(executionId, exitCode, endTime); exitMessage = trimExitMessage(exitMessage); taskExecutionDao.completeTaskExecution(executionId, exitCode, endTime, exitMessage); <START> logger.info(\"Updating: TaskExecution with executionId=\"+executionId <END> \/\/ Hmmm...in hind sight move this debug sensitive data automatically logged + \" with the following {\" + \"exitCode=\" + exitCode + \", endTime=\" + endTime + \", exitMessage='\" + exitMessage + '\\'' + '}'); }'","output":"public void completeTaskExecution(long executionId, Integer exitCode, Date endTime, String exitMessage) { initialize(); validateExitInformation(executionId, exitCode, endTime); exitMessage = trimExitMessage(exitMessage); taskExecutionDao.completeTaskExecution(executionId, exitCode, endTime, exitMessage); logger.debug(\"Updating: TaskExecution with executionId=\"+executionId + \" with the following {\" + \"exitCode=\" + exitCode + \", endTime=\" + endTime + \", exitMessage='\" + exitMessage + '\\'' + '}'); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> protected AddCinderStorageDomainCommand(Guid <END> \/\/ public commandId) { super(commandId); }'","output":"public AddCinderStorageDomainCommand(Guid commandId) { super(commandId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want a LinkedList here, I ArrayList constructor allocates array initial size 10'\nThe code is: 'public List<Pool> createPoolsForSubscription(Subscription sub) { <START> return createPoolsForSubscription(sub, new ArrayList<Pool>()); <END> \/\/ want a LinkedList here, I ArrayList constructor allocates array initial size 10 }'","output":"public List<Pool> createPoolsForSubscription(Subscription sub) { return createPoolsForSubscription(sub, new LinkedList<Pool>()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename this endpointStates'\nThe code is: 'public Flux<AmqpEndpointState> getEndpointStates() { <START> return connectionStates; <END> \/\/ rename this endpointStates }'","output":"public Flux<AmqpEndpointState> getEndpointStates() { return endpointStates; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'priorities reversed: get creds properties fall env'\nThe code is: 'public GsUploadManager(SecorConfig config) throws Exception { super(config); <START> String credentialPath = System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"); <END> \/\/ priorities reversed: get creds properties fall env if (credentialPath == null) { credentialPath = mConfig.getGsCredentialsPath(); } mClient = getService(credentialPath); }'","output":"public GsUploadManager(SecorConfig config) throws Exception { super(config); mClient = getService(mConfig.getGsCredentialsPath()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Misc.free() null check'\nThe code is: 'public void close() { Misc.free(writerPool); Misc.free(readerPool); <START> if (null != backupWriterPool) { <END> \/\/ Misc.free() null check Misc.free(backupWriterPool); } }'","output":"public void close() { Misc.free(writerPool); Misc.free(readerPool); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IDE is warning a bunch of exceptions declared thrown in methods'\nThe code is: 'public CompletableFuture<Void> prepareSnapshot( ChannelStateWriter channelStateWriter, <START> long checkpointId) throws IOException { <END> \/\/ IDE is warning a bunch of exceptions declared thrown in methods throw new UnsupportedOperationException(\"Checkpoints are not supported for sorting inputs\"); }'","output":"public CompletableFuture<Void> prepareSnapshot( ChannelStateWriter channelStateWriter, long checkpointId) { throw new UnsupportedOperationException(\"Checkpoints are not supported for sorting inputs\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'trim()? if <p> Hello\\nthere <\/p>, I want <p> is html node'\nThe code is: 'public String getWholeText(){ final StringBuilder accum = new StringBuilder(); new NodeTraversor(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; accum.append(textNode.getWholeText()); } } public void tail(Node node, int depth) { } }).traverse(this); <START> return accum.toString().trim(); <END> \/\/ trim()? if <p> Hello\\nthere <\/p>, I want <p> is html node }'","output":"public String getWholeText(){ final StringBuilder accum = new StringBuilder(); new NodeTraversor(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; accum.append(textNode.getWholeText()); } } public void tail(Node node, int depth) { } }).traverse(this); return accum.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'moving this constructor'\nThe code is: 'private Connection<ShuffleControlMessage> getConnection(final String endPointId) { if (connectionFactory == null) { connectionFactory = networkSetup.getControlConnectionFactory(); } <START> <END> \/\/ moving this constructor synchronized (connectionMap) { if (!connectionMap.containsKey(endPointId)) { connectionMap.put(endPointId, connectionFactory.newConnection(idFactory.getNewInstance(endPointId))); } return connectionMap.get(endPointId); } }'","output":"private Connection<ShuffleControlMessage> getConnection(final String endPointId) { synchronized (connectionMap) { if (!connectionMap.containsKey(endPointId)) { connectionMap.put(endPointId, connectionFactory.newConnection(idFactory.getNewInstance(endPointId))); } return connectionMap.get(endPointId); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This replaced method reference, i.e. pipelineFactory = Channels::pipeline'\nThe code is: 'private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; boolean enableCompression = compressionType.equalsIgnoreCase(\"deflate\"); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { <START> pipelineFactory = () -> Channels.pipeline(); <END> \/\/ This replaced method reference, i.e. pipelineFactory = Channels::pipeline } return pipelineFactory; }'","output":"private ChannelPipelineFactory initChannelPipelineFactory() { ChannelPipelineFactory pipelineFactory; boolean enableCompression = compressionType.equalsIgnoreCase(\"deflate\"); if (enableCompression || enableSsl || enableIpFilter) { pipelineFactory = new AdvancedChannelPipelineFactory( enableCompression, enableSsl, keystore, keystorePassword, keystoreType, enableIpFilter, patternRuleConfigDefinition); } else { pipelineFactory = Channels::pipeline; } return pipelineFactory; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need session variable anymore'\nThe code is: '<START> private void sendOnOpenMessage(ChannelHandlerContext ctx, boolean isSecured, String uri) throws URISyntaxException { <END> \/\/ Do need session variable anymore cMsg = new StatusCarbonMessage(org.wso2.carbon.messaging.Constants.STATUS_OPEN, 0, null); Session session = new WebSocketSessionImpl(ctx, isSecured, uri, channelId); setupCarbonMessage(ctx); cMsg.setProperty(Constants.CONNECTION, Constants.UPGRADE); cMsg.setProperty(Constants.UPGRADE, Constants.WEBSOCKET_UPGRADE); publishToMessageProcessor(cMsg); }'","output":"private void sendOnOpenMessage(ChannelHandlerContext ctx, boolean isSecured, String uri) throws URISyntaxException { cMsg = new StatusCarbonMessage(org.wso2.carbon.messaging.Constants.STATUS_OPEN, 0, null); setupCarbonMessage(ctx); cMsg.setProperty(Constants.CONNECTION, Constants.UPGRADE); cMsg.setProperty(Constants.UPGRADE, Constants.WEBSOCKET_UPGRADE); publishToMessageProcessor(cMsg); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw exception'\nThe code is: 'public static <T> FactorComparator<T> create(String factorName, int weight, Comparator<T> comparator){ if (null == factorName || factorName == \"\" || weight < 0 || null == comparator){ logger.error(\"failed to create instance of FactorComparator, at least one of the input paramters are invalid\"); <START> return null; <END> \/\/ throw exception } return new FactorComparator<T>(factorName,weight,comparator); }'","output":"public static <T> FactorComparator<T> create(String factorName, int weight, Comparator<T> comparator){ if (null == factorName || factorName.length() == 0 || weight < 0 || null == comparator){ logger.error(\"failed to create instance of FactorComparator, at least one of the input paramters are invalid\"); return null; } return new FactorComparator<T>(factorName,weight,comparator); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method is good assumptions (that is: toString() produces good SQL literal), private'\nThe code is: '<START> public static <T> DataType<T> dataType(String insertType, Type prestoResultType) <END> \/\/ this method is good assumptions (that is: toString() produces good SQL literal), private { return new DataType<>(insertType, prestoResultType, Object::toString, Function.identity()); }'","output":"private static <T> DataType<T> dataType(String insertType, Type prestoResultType) { return new DataType<>(insertType, prestoResultType, Object::toString, Function.identity()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename startTime startTimeNs'\nThe code is: 'void start(Bench bench, String action) { this.currentAction = bench.getName() + \": \" + action; <START> this.startTime = System.nanoTime(); <END> \/\/ rename startTime startTimeNs }'","output":"void start(Bench bench, String action) { this.currentAction = bench.getName() + \": \" + action; this.startTimeNs = System.nanoTime(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change text \"add\" \"Add\"'\nThe code is: 'public String getDescription() { <START> return \"add network partition deployment\"; <END> \/\/ change text \"add\" \"Add\" }'","output":"public String getDescription() { return \"Add network partition deployment\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I modify code a call time ImageUtil.getInstance().getDimension(getFileAsset()) store dimension in a private variable, load file get height width in instance. check if dimension is null get proper'\nThe code is: 'public int getHeight() { int height = 0; try { <START> height = ImageUtil.getInstance().getDimension(getFileAsset()).height; <END> \/\/ I modify code a call time ImageUtil.getInstance().getDimension(getFileAsset()) store dimension in a private variable, load file get height width in instance. check if dimension is null get proper } catch(Exception e) { Logger.error(this, e.getMessage()); } return height; }'","output":"public int getHeight() { try { if (fileDimension.height == 0) { fileDimension = ImageUtil.getInstance().getDimension(getFileAsset()); } } catch (Exception e) { Logger.error(this, e.getMessage()); } return fileDimension.height; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ImmutableList.builder()'\nThe code is: 'public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) { <START> List<ScalarImplementationChoice> implementationChoices = new ArrayList<>(); <END> \/\/ ImmutableList.builder() for (PolymorphicScalarFunctionChoice choice : choices) { implementationChoices.add(getScalarFunctionImplementationChoice(boundVariables, typeManager, functionRegistry, choice)); } return new ScalarFunctionImplementation(implementationChoices, deterministic); }'","output":"public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) { ImmutableList.Builder<ScalarImplementationChoice> implementationChoices = ImmutableList.builder(); for (PolymorphicScalarFunctionChoice choice : choices) { implementationChoices.add(getScalarFunctionImplementationChoice(boundVariables, typeManager, functionRegistry, choice)); } return new ScalarFunctionImplementation(implementationChoices.build(), deterministic); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: standard practice is static import'\nThe code is: 'private void examinedEnoughCellsIs(boolean expected) { CellsToSweepPartitioningIterator.ExaminedCellLimit limit = new CellsToSweepPartitioningIterator.ExaminedCellLimit(startingRow.getBytes(), maxCellsToExamine); <START> assertThat(limit.examinedEnoughCells(cellsExamined, cell()), Matchers.is(expected)); <END> \/\/ nit: standard practice is static import }'","output":"private void examinedEnoughCellsIs(boolean expected) { CellsToSweepPartitioningIterator.ExaminedCellLimit limit = new CellsToSweepPartitioningIterator.ExaminedCellLimit(startingRow.getBytes(), maxCellsToExamine); assertThat(limit.examinedEnoughCells(cellsExamined, cell()), is(expected)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'convulotions list array'\nThe code is: 'Type leastUpperBound(List<Type> typeAlternatives) { <START> return types.leastUpperBound(typeAlternatives.toArray(new Type[typeAlternatives.size()])); <END> \/\/ convulotions list array }'","output":"Type leastUpperBound(List<Type> typeAlternatives) { return types.leastUpperBound(typeAlternatives); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Long.valueOf() instead of new Long() - for performance reasons'\nThe code is: 'public Long getUuid() { <START> return new Long(artifact.getArtId()); <END> \/\/ Long.valueOf() instead of new Long() - for performance reasons }'","output":"public Long getUuid() { return Long.valueOf(artifact.getArtId()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return false here'\nThe code is: 'public boolean isObjectFactory() { <START> return getTargetTypeParameter() != null || getParameters().isEmpty(); <END> \/\/ return false here }'","output":"public boolean isObjectFactory() { return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I meant getFileName(), this compile'\nThe code is: 'public static boolean hasBlockCompressedExtension(final Path path) { <START> return hasBlockCompressedExtension(path.getName().toString()); <END> \/\/ I meant getFileName(), this compile }'","output":"public static boolean hasBlockCompressedExtension(final Path path) { return hasBlockCompressedExtension(path.getFileName().toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'QueryTypeDescriptorImpl -> GridQueryTypeDescriptor'\nThe code is: '<START> public @Nullable QueryTypeDescriptorImpl typeDescriptor(@Nullable String cacheName, String typeName) { <END> \/\/ QueryTypeDescriptorImpl -> GridQueryTypeDescriptor return typesByName.get(new QueryTypeNameKey(cacheName, typeName)); }'","output":"public @Nullable GridQueryTypeDescriptor typeDescriptor(@Nullable String cacheName, String typeName) { return typesByName.get(new QueryTypeNameKey(cacheName, typeName)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.unmodifiableList work in PyStatementListTreeImpl'\nThe code is: 'public List<Tree> children() { <START> return elements.stream().map(element -> (Tree) element).collect(Collectors.toList()); <END> \/\/ Collections.unmodifiableList work in PyStatementListTreeImpl }'","output":"public List<Tree> children() { return Collections.unmodifiableList(elements); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I \"Liquid Glass\"'\nThe code is: 'public static void addSmelting(int fluidOutput, IItemStack itemInput, int meltingPoint) { FluidStack fluid = FluidRegistry.getFluidStack(\"glass\", fluidOutput); if (fluid == null){ <START> LogHelper.logWarning(\"Liquid Class is null for the Thermionic Fabricator\"); <END> \/\/ I \"Liquid Glass\" return; } ModTweaker.LATE_ADDITIONS.add(new AddSmelting(new FabricatorSmeltingRecipe(toStack(itemInput), fluid, meltingPoint))); }'","output":"public static void addSmelting(int fluidOutput, IItemStack itemInput, int meltingPoint) { FluidStack fluid = FluidRegistry.getFluidStack(\"glass\", fluidOutput); if (fluid == null){ LogHelper.logWarning(\"Liquid Glass is null for the Thermionic Fabricator\"); return; } ModTweaker.LATE_ADDITIONS.add(new AddSmelting(new FabricatorSmeltingRecipe(toStack(itemInput), fluid, meltingPoint))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.removeCallbacksAndMessages(null) instead. Done in Patch set 2'\nThe code is: 'public void dispose() { phone.mCM.unregisterForSIMLockedOrAbsent(this); phone.mCM.unregisterForOffOrNotAvailable(this); phone.mCM.unregisterForSIMReady(this); <START> this.removeCallbacksAndMessages(null); <END> \/\/ this.removeCallbacksAndMessages(null) instead. Done in Patch set 2 this.absentRegistrants = null; this.pinLockedRegistrants = null; this.networkLockedRegistrants = null; this.status = null; this.phone = null; }'","output":"public void dispose() { phone.mCM.unregisterForSIMLockedOrAbsent(this); phone.mCM.unregisterForOffOrNotAvailable(this); phone.mCM.unregisterForSIMReady(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@rezita, isLightModeCahnged renamed isLightModeChanged'\nThe code is: 'public void onResume(Activity activity) { <START> if (isLightModeCahnged(activity)) { <END> \/\/ @rezita, isLightModeCahnged renamed isLightModeChanged Intent intent = activity.getIntent(); activity.finish(); activity.overridePendingTransition(0, 0); activity.startActivity(intent); activity.overridePendingTransition(0, 0); } }'","output":"public void onResume(Activity activity) { if (isLightModeChanged(activity)) { Intent intent = activity.getIntent(); activity.finish(); activity.overridePendingTransition(0, 0); activity.startActivity(intent); activity.overridePendingTransition(0, 0); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'code smells errorElements parseAs static'\nThe code is: '<START> private JBIterable<PsiErrorElement> errorElements(PsiElement root) { <END> \/\/ code smells errorElements parseAs static return SyntaxTraverser.psiTraverser(root).traverse().filter(PsiErrorElement.class); }'","output":"private static JBIterable<PsiErrorElement> errorElements(PsiElement root) { return SyntaxTraverser.psiTraverser(root).traverse().filter(PsiErrorElement.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getter\/setters plain, tricks. Instead creating endpoint in component, set security provider endpoint correctly'\nThe code is: 'public UndertowSecurityProvider getSecurityProvider() { <START> if (this.securityProvider == null) { <END> \/\/ getter\/setters plain, tricks. Instead creating endpoint in component, set security provider endpoint correctly return getComponent().getSecurityProvider(); } return this.securityProvider; }'","output":"public UndertowSecurityProvider getSecurityProvider() { return this.securityProvider; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer \"Context: \" + getId()'\nThe code is: 'public String toString() { return getId(); <START> } <END> \/\/ prefer \"Context: \" + getId()'","output":"public String toString() { return \"Context: \" + getId(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java Pager.builder().withPageSize(1).orderBy(Order.unspecified)).build() replaced by: java Pager.single()'\nThe code is: 'default boolean anyExists() { <START> return entities(Pager.builder().withPageSize(1).orderBy(Order.unspecified()).build()).hasNext(); <END> \/\/ java Pager.builder().withPageSize(1).orderBy(Order.unspecified)).build() replaced by: java Pager.single() }'","output":"default boolean anyExists() { return entities(Pager.single()).hasNext(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'job.getName() extracted variable for more readability'\nThe code is: 'public static void killRunningImageJobs() { Job[] currentJobs = Job.getJobManager().find(null); for (Job job : currentJobs) { <START> if (job.getName().startsWith(JOB_PULLING_DOCKER_IMAGE) || job.getName().startsWith(JOB_TAGGING_IMAGE) <END> \/\/ job.getName() extracted variable for more readability || job.getName().startsWith(JOB_PUSHING_DOCKER_IMAGE)|| job.getName().startsWith(JOB_OPENNING_CONNECTION)) { job.cancel(); } } }'","output":"public static void killRunningImageJobs() { Job[] currentJobs = Job.getJobManager().find(null); for (Job job : currentJobs) { String jobName = job.getName(); if (jobName.startsWith(JOB_PULLING_DOCKER_IMAGE) || jobName.startsWith(JOB_TAGGING_IMAGE) || jobName.startsWith(JOB_PUSHING_DOCKER_IMAGE)|| jobName.startsWith(JOB_OPENNING_CONNECTION)) { job.cancel(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This needed'\nThe code is: 'public DRCatalogDiffEngine(Catalog localCatalog, Catalog remoteCatalog) { super(localCatalog, remoteCatalog); <START> localCatalog.getClusters().get(\"cluster\").getDrclusterid(); <END> \/\/ This needed }'","output":"public DRCatalogDiffEngine(Catalog localCatalog, Catalog remoteCatalog) { super(localCatalog, remoteCatalog); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I add a CommonHelper.assertNotNull for customParams'\nThe code is: 'public void setCustomParams(final Map<String, Object> customParams) { <START> this.customParams = customParams; <END> \/\/ I add a CommonHelper.assertNotNull for customParams }'","output":"public void setCustomParams(final Map<String, Object> customParams) { CommonHelper.assertNotNull(\"customParams\", customParams); this.customParams = customParams; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this behavior. setDebugging affect indicators'\nThe code is: '@SuppressWarnings(\"UnusedDeclaration\") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); <START> setLoggingEnabled(debugging); <END> \/\/ remove this behavior. setDebugging affect indicators }'","output":"@SuppressWarnings(\"UnusedDeclaration\") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do want system default charset UTF-8 for example always'\nThe code is: 'private Supplier<CharReadable> fileAsCharReadable( File file ) { return () -> { try { <START> return Readables.wrap( fs.openAsReader( file, Charset.defaultCharset() ) ); <END> \/\/ do want system default charset UTF-8 for example always } catch ( IOException e ) { throw new UncheckedIOException( e ); } }; }'","output":"private Supplier<CharReadable> fileAsCharReadable( File file ) { return () -> { try { return Readables.wrap( fs.openAsReader( file, StandardCharsets.UTF_8 ) ); } catch ( IOException e ) { throw new UncheckedIOException( e ); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please change log level debug'\nThe code is: 'protected Response invokeGet(String docsUri) { <START> logger.info(\"[GET] \" + docsUri); <END> \/\/ please change log level debug WebTarget clientRequest = httpClient.target(docsUri); return clientRequest.request().get(); }'","output":"protected Response invokeGet(String docsUri) { logger.debug(\"[GET] \" + docsUri); WebTarget clientRequest = httpClient.target(docsUri); return clientRequest.request().get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'odd a public constructor, other access it. access getters instead of access private fields'\nThe code is: '<START> public MutationException(Row mutation, Throwable throwable) { <END> \/\/ odd a public constructor, other access it. access getters instead of access private fields this.mutation = mutation; this.throwable = throwable; }'","output":"private MutationException(Row mutation, Throwable throwable) { this.mutation = mutation; this.throwable = throwable; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'visibility remain package-private'\nThe code is: '<START> public boolean useBindVariables() { <END> \/\/ visibility remain package-private return true; }'","output":"boolean useBindVariables() { return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'i==0 i==2'\nThe code is: 'public void propagate(int i, int mask) throws ContradictionException { <START> if (i == 2) { <END> \/\/ i==0 i==2 sdm.freeze(); sdm.forEach(elemRem, SetEventType.REMOVE_FROM_ENVELOPE); sdm.unfreeze(); } if (iv.isInstantiated()) { set.addToKernel(iv.getValue(), aCause); setPassive(); } }'","output":"public void propagate(int i, int mask) throws ContradictionException { if (i == 0) { sdm.freeze(); sdm.forEach(elemRem, SetEventType.REMOVE_FROM_ENVELOPE); sdm.unfreeze(); } if (iv.isInstantiated()) { set.addToKernel(iv.getValue(), aCause); setPassive(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: NullPointerException'\nThe code is: 'protected Merger(final Repository local) { if (local == null) { throw new <START> IllegalArgumentException(JGitText.get().repositoryIsRequired); <END> \/\/ nit: NullPointerException } db = local; inserter = local.newObjectInserter(); reader = inserter.newReader(); walk = new RevWalk(reader); }'","output":"protected Merger(final Repository local) { if (local == null) { throw new NullPointerException(JGitText.get().repositoryIsRequired); } db = local; inserter = local.newObjectInserter(); reader = inserter.newReader(); walk = new RevWalk(reader); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call updateSelected(rows) well? getMaxSize() method, selected array able hold max number of rows'\nThe code is: 'public void ensureSize(int rows) { for(int i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); <START> } <END> \/\/ call updateSelected(rows) well? getMaxSize() method, selected array able hold max number of rows }'","output":"public void ensureSize(int rows) { for(int i=0; i < cols.length; ++i) { cols[i].ensureSize(rows, false); } updateSelected(rows); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertEquals param order is expected, actual, this (and other assertions) written java assertEquals(\"Max Mustermann\", info.name);'\nThe code is: 'public void splitCompleteUserIdShouldReturnAll3Components() throws Exception { OpenPgpUtils.UserInfo info = OpenPgpUtils.splitUserId(\"Max Mustermann (this is a comment) <max@example.com>\"); <START> assertEquals(info.name, \"Max Mustermann\"); <END> \/\/ assertEquals param order is expected, actual, this (and other assertions) written java assertEquals(\"Max Mustermann\", info.name); assertEquals(info.comment, \"this is a comment\"); assertEquals(info.email, \"max@example.com\"); }'","output":"public void splitCompleteUserIdShouldReturnAll3Components() throws Exception { OpenPgpUtils.UserInfo info = OpenPgpUtils.splitUserId(\"Max Mustermann (this is a comment) <max@example.com>\"); assertEquals(\"Max Mustermann\", info.name); assertEquals(\"this is a comment\", info.comment); assertEquals(\"max@example.com\", info.email); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Adapter'\nThe code is: 'public View getBannerView() { if(mBannerView == null) { <START> Log.v(TAG, \"Unity Ads Adaptor null banner view\"); <END> \/\/ Adapter } else { Log.v(TAG, \"Unity Ads Adaptor provided a banner view for placement: \" + mBannerView.getPlacementId()); } return mBannerView; }'","output":"public View getBannerView() { return mBannerView; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'final'\nThe code is: '<START> protected JaxbListWrapper<OnmsIpInterface> createListWrapper(Collection<OnmsIpInterface> list) { <END> \/\/ final return new OnmsIpInterfaceList(list); }'","output":"protected final JaxbListWrapper<OnmsIpInterface> createListWrapper(Collection<OnmsIpInterface> list) { return new OnmsIpInterfaceList(list); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@lautarobock declare throws Exception, [recommendations here](<LINK_0>'\nThe code is: '<START> public void testEmpty() throws IOException { <END> \/\/ @lautarobock declare throws Exception, [recommendations here](<LINK_0> MatcherAssert.assertThat( new PsAll(new ArrayList<Pass>(0), 0).enter(new RqFake()).has(), Matchers.is(false) ); }'","output":"public void testEmpty() throws Exception { MatcherAssert.assertThat( new PsAll(new ArrayList<Pass>(0), 0).enter(new RqFake()).has(), Matchers.is(false) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'double semi-colon'\nThe code is: 'public void handle(EquivalenceResult<T> result) { try { <START> sender.sendMessage(messageFrom(result));; <END> \/\/ double semi-colon } catch (Exception e) { log.error(\"Failed to send equiv update message: \" + result.subject(), e); } }'","output":"public void handle(EquivalenceResult<T> result) { try { sender.sendMessage(messageFrom(result)); } catch (Exception e) { log.error(\"Failed to send equiv update message: \" + result.subject(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'boolean too'\nThe code is: '<START> public Boolean getKeepNullColumns() <END> \/\/ boolean too { return keepNullColumns; }'","output":"public boolean getKeepNullColumns() { return keepNullColumns; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace this return ArrayUtils.contains(parts, \"multipart\/form-data\");'\nThe code is: 'public static boolean isMultiPartForm(@CheckForNull String contentType) { if (contentType == null) { return false; } String[] parts = contentType.split(\";\"); if (parts.length == 0) { return false; } <START> for (String part : parts) { <END> \/\/ replace this return ArrayUtils.contains(parts, \"multipart\/form-data\"); if (\"multipart\/form-data\".equals(part)) { return true; } } return false; }'","output":"public static boolean isMultiPartForm(@CheckForNull String contentType) { if (contentType == null) { return false; } String[] parts = contentType.split(\";\"); return ArrayUtils.contains(parts, \"multipart\/form-data\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rly'\nThe code is: 'public void testFailedAmendWithNoQcowVolumes() { DiskImage oldDisk = createDiskImage(); oldDisk.setQcowCompat(QcowCompat.QCOW2_V2); when(diskDao.get(diskImageGuid)).thenReturn(oldDisk); DiskImage newDisk = DiskImage.copyOf(oldDisk); newDisk.setQcowCompat(QcowCompat.QCOW2_V3); command.getParameters().setDiskInfo(newDisk); initializeCommand(); ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK); verify(command, <START> times(0)).amendDiskImage(); <END> \/\/ rly }'","output":"public void testFailedAmendWithNoQcowVolumes() { DiskImage oldDisk = createDiskImage(); oldDisk.setQcowCompat(QcowCompat.QCOW2_V2); when(diskDao.get(diskImageGuid)).thenReturn(oldDisk); DiskImage newDisk = DiskImage.copyOf(oldDisk); newDisk.setQcowCompat(QcowCompat.QCOW2_V3); command.getParameters().setDiskInfo(newDisk); initializeCommand(); ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK); verify(command, never()).amendDiskImage(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is a standalone function. do return InetAdress.get... here, remove temporary variable'\nThe code is: 'private static InetAddress toInetAddress(Slice ipAddress) { InetAddress address; try { <START> address = InetAddress.getByAddress(ipAddress.getBytes()); <END> \/\/ this is a standalone function. do return InetAdress.get... here, remove temporary variable } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid IP address binary: \" + ipAddress.toStringUtf8(), e); } return address; }'","output":"private static InetAddress toInetAddress(Slice ipAddress) { try { return InetAddress.getByAddress(ipAddress.getBytes()); } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid IP address binary: \" + ipAddress.toStringUtf8(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename stopAt stopAtNs'\nThe code is: 'public void start() { stopAt = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(MAX_PROCESSING_TIME); <START> } <END> \/\/ rename stopAt stopAtNs'","output":"public void start() { stopAtNs = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(MAX_PROCESSING_TIME); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer condition check lookup.getCount() a big deal'\nThe code is: 'private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); <START> if (iterator.termLengthAccumulator > 0) { <END> \/\/ prefer condition check lookup.getCount() a big deal double averageLength = (double) iterator.termLengthAccumulator \/ lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }'","output":"private WFSTCompletionLookup build(final IndexReader indexReader, final String field) throws IOException { WFSTInputIterator iterator = new WFSTInputIterator( new LuceneDictionary(indexReader, field).getEntryIterator(), indexReader, field, getSearchCounts(field)); WFSTCompletionLookup lookup = createWFST(); lookup.build(iterator); if (lookup.getCount() > 0) { double averageLength = (double) iterator.termLengthAccumulator \/ lookup.getCount(); averageLengths.put(field, averageLength); } return lookup; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here. I this line is needed'\nThe code is: 'public void invalidAccountTokenWithKubernetesApiMode() { Map<String, Comparable> properties = new HashMap<String, Comparable>(); <START> properties.put(SERVICE_DNS.key(), null); <END> \/\/ here. I this line is needed properties.put(KUBERNETES_CA_CERTIFICATE.key(), TEST_CA_CERTIFICATE); new KubernetesConfig(properties); }'","output":"public void invalidAccountTokenWithKubernetesApiMode() { Map<String, Comparable> properties = new HashMap<String, Comparable>(); properties.put(KUBERNETES_CA_CERTIFICATE.key(), TEST_CA_CERTIFICATE); new KubernetesConfig(properties); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a personal taste, I prefer: java if (m_count >= m_objects.length) { throw new NoSuchElementException(); } return m_objects[m_count++];'\nThe code is: 'public Object[] next() { <START> if (m_count < m_objects.length) { <END> \/\/ a personal taste, I prefer: java if (m_count >= m_objects.length) { throw new NoSuchElementException(); } return m_objects[m_count++]; return m_objects[m_count++]; } else { throw new NoSuchElementException(); } }'","output":"public Object[] next() { if (m_count >= m_objects.length) { throw new NoSuchElementException(); } return m_objects[m_count++]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'computeIfAbsent instead'\nThe code is: 'private Object getLock(ObjectName objectName) { if (locks.get(objectName) == null) { locks.putIfAbsent(objectName, new Object()); } <START> return locks.get(objectName); <END> \/\/ computeIfAbsent instead }'","output":"private Object getLock(ObjectName objectName) { return locks.computeIfAbsent(objectName, k -> new Object()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This handled in item.getLabel()'\nThe code is: 'public String getText(final Object element) { Item item = (Item) element; <START> String label = item.getLabel(); if (label == null || label.trim().length() == 0) { label = item.getViewpoint().getName(); } <END> \/\/ This handled in item.getLabel() return label; }'","output":"public String getText(final Object element) { Item item = (Item) element; return item.getLabel(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need a boxed primitive here'\nThe code is: '<START> private Boolean shouldIncludeUnavailableModifier(final SwiftParser.CodeBlockContext ctx) { <END> \/\/ do need a boxed primitive here if (ctx == null || ctx.statements() == null) { return false; } final List<SwiftParser.StatementContext> statements = ctx.statements().statement(); return statements.size() == 1 && FATAL_ERROR.equals(statements.get(0).getStart().getText()); }'","output":"private boolean shouldIncludeUnavailableModifier(final SwiftParser.CodeBlockContext ctx) { if (ctx == null || ctx.statements() == null) { return false; } final List<SwiftParser.StatementContext> statements = ctx.statements().statement(); return statements.size() == 1 && FATAL_ERROR.equals(statements.get(0).getStart().getText()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'DateUtil.now()'\nThe code is: 'private int daysWithoutPasswordChange(MotechUser user) { <START> return Days.daysBetween(user.getLastPasswordChange(), DateTime.now()).getDays(); <END> \/\/ DateUtil.now() }'","output":"private int daysWithoutPasswordChange(MotechUser user) { return Days.daysBetween(user.getLastPasswordChange(), DateUtil.now()).getDays(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this assert here. Do want asserts in code'\nThe code is: 'public synchronized void report(int seqnum, long time) { cache.put(seqnum, time); <START> assert(cache.size() <= cache.maxSize); <END> \/\/ this assert here. Do want asserts in code }'","output":"public synchronized void report(int seqnum, long time) { cache.put(seqnum, time); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static'\nThe code is: '<START> private boolean nullOrEmpty(List<?> list) { <END> \/\/ static return list == null || list.isEmpty(); }'","output":"private static boolean nullOrEmpty(List<?> list) { return list == null || list.isEmpty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this test is green, assertion _check_ called. check concrete value, i.e. java assertThat(oneToOne).isEqualTo(Option.some(\"One\"));'\nThe code is: 'public void shouldReturnSome() { Option<String> oneToOne = HashMap.of(1, \"One\").lift().apply(1); <START> assertThat(oneToOne instanceof Option.Some); <END> \/\/ I this test is green, assertion _check_ called. check concrete value, i.e. java assertThat(oneToOne).isEqualTo(Option.some(\"One\")); }'","output":"public void shouldReturnSome() { Option<String> oneToOne = HashMap.of(1, \"One\").lift().apply(1); assertThat(oneToOne).isEqualTo(Option.some(\"One\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'peer class loading'\nThe code is: '@Override protected IgniteConfiguration getConfiguration(final String gridName) throws Exception { final IgniteConfiguration cfg = super.getConfiguration(gridName); <START> cfg.setPeerClassLoadingEnabled(true); <END> \/\/ peer class loading cfg.setClientMode(gridName.contains(\"client\")); return cfg; }'","output":"@Override protected IgniteConfiguration getConfiguration(final String gridName) throws Exception { final IgniteConfiguration cfg = super.getConfiguration(gridName); cfg.setClientMode(gridName.contains(\"client\")); return cfg; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please factor out this hardcoded path segment'\nThe code is: 'private String mountNfs(Connection conn, String remoteDir, String localDir) { if (localDir == null) { <START> localDir = \"\/var\/cloud_mount\/\" + UUID.nameUUIDFromBytes(remoteDir.getBytes()); <END> \/\/ please factor out this hardcoded path segment } return callHostPlugin(conn, \"cloud-plugin-storage\", \"mountNfsSecondaryStorage\", \"localDir\", localDir, \"remoteDir\", remoteDir); }'","output":"private String mountNfs(Connection conn, String remoteDir, String localDir) { if (localDir == null) { localDir = BASE_MOUNT_POINT_ON_REMOTE + UUID.nameUUIDFromBytes(remoteDir.getBytes()); } return callHostPlugin(conn, \"cloud-plugin-storage\", \"mountNfsSecondaryStorage\", \"localDir\", localDir, \"remoteDir\", remoteDir); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is is a rename refactoring a bit wrong :)'\nThe code is: 'public String getMessage() { <START> return String.format(\"No items to createDefault feed %s\", spec); <END> \/\/ I is is a rename refactoring a bit wrong :) }'","output":"public String getMessage() { return String.format(\"No items to create feed %s\", spec); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I implement this (just return null). A long a fixed size, putLong() in HTInterval write file. This method more for string, structs, etc. want serialize'\nThe code is: 'public byte[] toByteArray() { <START> return ByteBuffer.allocate(8).putLong(valueLong).array(); <END> \/\/ I implement this (just return null). A long a fixed size, putLong() in HTInterval write file. This method more for string, structs, etc. want serialize }'","output":"public byte[] toByteArray() { return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'UnsupportedOperationException reasonable here'\nThe code is: 'public Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> getInsertRuntime(IDataSource<String> dataSource, IOperatorSchema propagatedSchema, IVariableTypeEnvironment typeEnv, List<LogicalVariable> keys, LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterKeyFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec, boolean bulkload) throws AlgebricksException { <START> return null; <END> \/\/ UnsupportedOperationException reasonable here }'","output":"public Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> getInsertRuntime(IDataSource<String> dataSource, IOperatorSchema propagatedSchema, IVariableTypeEnvironment typeEnv, List<LogicalVariable> keys, LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterKeyFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec, boolean bulkload) throws AlgebricksException { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do this in constructor, field fTopNode final'\nThe code is: 'public TmfStatisticsTreeNode getTop() { if (fTopNode == null) { fTopNode = this; while (fTopNode.getParent() != null && fTopNode.getParent().getParent() != null) { fTopNode = fTopNode.getParent(); <START> } <END> \/\/ do this in constructor, field fTopNode final } return fTopNode; }'","output":"public TmfStatisticsTreeNode getTop() { return fTopNode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I suggest InternationalizationKt.getRootLocalizer().formatText(key) instead. returns key if translation'\nThe code is: 'private String i18n(String key) { <START> String result = GanttLanguage.getInstance().getText(key); <END> \/\/ I suggest InternationalizationKt.getRootLocalizer().formatText(key) instead. returns key if translation if (result== null){ result = key; } return result; }'","output":"private String i18n(String key) { return InternationalizationKt.getRootLocalizer().formatText(key); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this key'\nThe code is: 'public String getCrepoKey() { <START> return entry; <END> \/\/ this key }'","output":"public String getCrepoKey() { return key; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'spaces OK in namespace strings'\nThe code is: 'public Optional<String> namespace() { <START> return Optional.of(\"Jdbc namespace\"); <END> \/\/ spaces OK in namespace strings }'","output":"public Optional<String> namespace() { return Optional.empty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'naming: consider renaming this line 849 elapsedMillis? you'\nThe code is: 'public void test_sleepJ() { long stime = 0, ftime = 0; try { stime = System.currentTimeMillis(); Thread.sleep(1000); ftime = System.currentTimeMillis(); } catch (InterruptedException e) { fail(\"Unexpected interrupt received\"); } long <START> result = <END> \/\/ naming: consider renaming this line 849 elapsedMillis? you ftime - stime; assertTrue(\"Failed to sleep long enough: \" + result, result >= 998); assertTrue(\"Overslept: \" + result, result <= 1300); }'","output":"public void test_sleepJ() { long stime = 0, ftime = 0; try { stime = System.currentTimeMillis(); Thread.sleep(1000); ftime = System.currentTimeMillis(); } catch (InterruptedException e) { fail(\"Unexpected interrupt received\"); } long elapsedMillis = ftime - stime; assertTrue(\"Failed to sleep long enough: \" + elapsedMillis, elapsedMillis >= 998); assertTrue(\"Overslept: \" + elapsedMillis, elapsedMillis <= 1300); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If sourceProcessingDetails is initialized new HashSet<>() instead of null check here'\nThe code is: 'public Set<SourceProcessingDetails> getProcessingDetails() { <START> if (sourceProcessingDetails == null) { <END> \/\/ If sourceProcessingDetails is initialized new HashSet<>() instead of null check here sourceProcessingDetails = new HashSet<>(); } return sourceProcessingDetails; }'","output":"public Set<SourceProcessingDetails> getProcessingDetails() { return sourceProcessingDetails; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Currently, TestParquetFileWriter this method. If is required public I suggest package protected'\nThe code is: '<START> public void writeBloomFilter(BloomFilter bloomFilter) { <END> \/\/ Currently, TestParquetFileWriter this method. If is required public I suggest package protected currentBloomFilters.add(bloomFilter); }'","output":"void writeBloomFilter(BloomFilter bloomFilter) { currentBloomFilters.add(bloomFilter); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line necessary'\nThe code is: 'public BudgetGoal() { <START> super(); <END> \/\/ This line necessary }'","output":"public BudgetGoal() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is return empty collection Collections.emptyList() more null-safe'\nThe code is: '<START> public List<Map<String, String>> query(String queryStr) { <END> \/\/ I is return empty collection Collections.emptyList() more null-safe return null; }'","output":"public List<Map<String, String>> query(String queryStr) { return Collections.emptyList(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'variable renamed isFrozen well? more grammatically correct :wink:'\nThe code is: 'public boolean isFrozen() { <START> return isFreeze; <END> \/\/ variable renamed isFrozen well? more grammatically correct :wink: }'","output":"public boolean isFrozen() { return isFrozen; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change !isAnalyticsActive()'\nThe code is: 'public static void initAnalytics(Context context) { <START> if (isAnalyticsActive() == false) { <END> \/\/ change !isAnalyticsActive() GoogleAnalytics.getInstance(context).setAppOptOut(true); } if (BuildConfig.DEBUG) { GoogleAnalytics.getInstance(context).setDryRun(true); } }'","output":"public static void initAnalytics(Context context) { if (!isAnalyticsActive()) { GoogleAnalytics.getInstance(context).setAppOptOut(true); } if (BuildConfig.DEBUG) { GoogleAnalytics.getInstance(context).setDryRun(true); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'negative logic'\nThe code is: 'public <X> ExtendedQueryResult<T> orderDesc(SingularAttribute<T, X> attribute, boolean appendEntityName) { lastPaginatedQuery = null; <START> if (!context.getRepositoryMethod().isQuery()) { <END> \/\/ negative logic context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.DESC)); } else { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } return this; }'","output":"public <X> ExtendedQueryResult<T> orderDesc(SingularAttribute<T, X> attribute, boolean appendEntityName) { lastPaginatedQuery = null; if (context.getRepositoryMethod().isQuery()) { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } else { context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.DESC)); } return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logic switch, this true (former behavior)'\nThe code is: 'public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> false); <END> \/\/ logic switch, this true (former behavior) }'","output":"public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need this anylonger'\nThe code is: 'public ExtensionBootstrapper(final ServletContext context, final Configuration configuration) { this.configuration = configuration; this.context = context; <START> this.context.setAttribute(ExtensionContext.class.getName(), ExtensionController.getInstance()); <END> \/\/ do need this anylonger ExtensionController.getInstance().init(this.context); }'","output":"public ExtensionBootstrapper(final ServletContext context, final Configuration configuration) { this.configuration = configuration; this.context = context; ExtensionController.getInstance().init(this.context); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this consumer simplified lambda leaving decision you. selectedKieSession -> onSelectionChange()'\nThe code is: 'public void setKSessions(final List<String> ksessions) { String[] names = ksessions.toArray(new String[ksessions.size()]); ksessionSelect.setup(ksessionSelectContainer, buildOptions(names), names[0], new Consumer<String>() { @Override public void accept(String s) { onSelectionChange(); } <START> }); <END> \/\/ this consumer simplified lambda leaving decision you. selectedKieSession -> onSelectionChange() }'","output":"public void setKSessions(final List<String> ksessions) { String[] names = ksessions.toArray(new String[ksessions.size()]); ksessionSelect.setup(ksessionSelectContainer, buildOptions(names), names[0], s -> onSelectionChange()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Likewise.'\nThe code is: 'public void handleUnimprovedDaysSpentInputChange( ChangeEvent event ) { try { Long value = unimprovedDaysSpentInput.getValue().isEmpty() ? null : Long.parseLong( unimprovedDaysSpentInput.getValue() ); presenter.onUnimprovedDaysSpentChange( value ); } catch ( NumberFormatException e ) { <START> <END> \/\/ Likewise. } }'","output":"public void handleUnimprovedDaysSpentInputChange( ChangeEvent event ) { boolean isNumeric = unimprovedDaysSpentInput.getValue().matches( \"\\\\d+\" ); if (isNumeric) { presenter.onUnimprovedDaysSpentChange( Long.parseLong( unimprovedDaysSpentInput.getValue() ) ); } else { presenter.onUnimprovedDaysSpentChange( 0l ); unimprovedDaysSpentInput.setValue( \"0\" ); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'curious this change. Is necessary'\nThe code is: 'private static String initMiniCluster(Configuration conf, ReadOnlyProps overrideProps) { setUpConfigForMiniCluster(conf, overrideProps); utility = new HBaseTestingUtility(conf); try { <START> utility.startMiniCluster(NUM_SLAVES_BASE, true); <END> \/\/ curious this change. Is necessary return getLocalClusterUrl(utility); } catch (Throwable t) { throw new RuntimeException(t); } }'","output":"private static String initMiniCluster(Configuration conf, ReadOnlyProps overrideProps) { setUpConfigForMiniCluster(conf, overrideProps); utility = new HBaseTestingUtility(conf); try { utility.startMiniCluster(NUM_SLAVES_BASE); return getLocalClusterUrl(utility); } catch (Throwable t) { throw new RuntimeException(t); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change this INFO'\nThe code is: 'private Connection getConnectionWithRetry(String connectionURL) { Connection connection=null; try{ connection = getConnectionWithRetry(connectionURL, true); } catch (Exception e) { <START> LOG.error(\"Failed to get connection with namespace enabled\", e); <END> \/\/ Change this INFO try { connection = getConnectionWithRetry(connectionURL, false); } catch (Exception ex) { LOG.error(\"Failed to get connection without namespace enabled\", ex); } } return connection; }'","output":"private Connection getConnectionWithRetry(String connectionURL) { Connection connection=null; try{ connection = getConnectionWithRetry(connectionURL, true); } catch (Exception e) { LOG.info(\"Failed to get connection with namespace enabled\", e); try { connection = getConnectionWithRetry(connectionURL, false); } catch (Exception ex) { LOG.info(\"Failed to get connection without namespace enabled\", ex); } } return connection; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I understand this is required. discuss tomorrow'\nThe code is: 'public static OzoneClient getRpcClient(String omServiceId, Configuration config) throws IOException { Preconditions.checkNotNull(omServiceId); Preconditions.checkNotNull(config); <START> config.set(OZONE_OM_ADDRESS_KEY, omServiceId); <END> \/\/ I understand this is required. discuss tomorrow return getClient(getClientProtocol(config, omServiceId), config); }'","output":"public static OzoneClient getRpcClient(String omServiceId, Configuration config) throws IOException { Preconditions.checkNotNull(omServiceId); Preconditions.checkNotNull(config); return getClient(getClientProtocol(config, omServiceId), config); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return permits.computeIfAbsent(name, n -> new MemberCapacityPermit(n, config.getCapacity())); instead'\nThe code is: 'CapacityPermit permitFor(String name, ScheduledExecutorConfig config) { <START> CapacityPermit permit = permits.get(name); <END> \/\/ return permits.computeIfAbsent(name, n -> new MemberCapacityPermit(n, config.getCapacity())); instead if (permit == null) { CapacityPermit newPermit = new MemberCapacityPermit(name, config.getCapacity()); permit = permits.putIfAbsent(name, newPermit); permit = (permit == null) ? newPermit : permit; } return permit; }'","output":"CapacityPermit permitFor(String name, ScheduledExecutorConfig config) { return permits.computeIfAbsent(name, n -> new MemberCapacityPermit(n, config.getCapacity())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Exception is thrown'\nThe code is: '<START> public void testSequenceFlowSupplier() throws Exception { <END> \/\/ Exception is thrown final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }'","output":"public void testSequenceFlowSupplier() { final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw new IllegalStateException(e)? instead'\nThe code is: 'public void bind() { try { afterBind(); } catch (Exception e) { <START> e.printStackTrace(); <END> \/\/ throw new IllegalStateException(e)? instead } }'","output":"public void bind() { try { afterBind(); } catch (Exception e) { throw new IllegalStateException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'forEach values, avoid sending caller simply returning null'\nThe code is: 'public V process(Map.Entry<K, V> entry) { action.accept(entry.getKey(), entry.getValue()); <START> return entry.getValue(); <END> \/\/ forEach values, avoid sending caller simply returning null }'","output":"public V process(Map.Entry<K, V> entry) { action.accept(entry.getKey(), entry.getValue()); return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instead, start bot.checkBox(\"SWT.READ_ONLY\").select();'\nThe code is: 'public void typesTextInReadOnly() throws Exception { final SWTBotText text = <START> bot.textInGroup(\"Text\", 1); <END> \/\/ Instead, start bot.checkBox(\"SWT.READ_ONLY\").select(); assertTrue(text.isReadOnly()); try { text.typeText(\"\"); fail(\"Expecting an exception\"); } catch (Exception e) { assertEquals(\"TextBox is read-only\", e.getMessage()); } }'","output":"public void typesTextInReadOnly() throws Exception { bot.checkBox(\"SWT.READ_ONLY\").select(); final SWTBotText text = bot.textInGroup(\"Text\"); assertTrue(text.isReadOnly()); try { text.typeText(\"\"); fail(\"Expecting an exception\"); } catch (Exception e) { assertEquals(\"TextBox is read-only\", e.getMessage()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please, this diamond a couple patterns.toArray(new String[patterns.size()]) in this class. I guess smells Sonar, great fix in this class. Thanks'\nThe code is: 'private void setupStatsEnabledNamePatterns(IntegrationManagementConfigurer configurer) { <START> List<String> patterns = new ArrayList<String>(); <END> \/\/ Please, this diamond a couple patterns.toArray(new String[patterns.size()]) in this class. I guess smells Sonar, great fix in this class. Thanks String[] statsEnabled = this.attributes.getStringArray(\"statsEnabled\"); for (String managedComponent : statsEnabled) { String pattern = this.environment.resolvePlaceholders(managedComponent); patterns.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(pattern))); } configurer.setEnabledStatsPatterns(patterns.toArray(new String[patterns.size()])); }'","output":"private void setupStatsEnabledNamePatterns(IntegrationManagementConfigurer configurer) { List<String> patterns = new ArrayList<>(); String[] statsEnabled = this.attributes.getStringArray(\"statsEnabled\"); for (String managedComponent : statsEnabled) { String pattern = this.environment.resolvePlaceholders(managedComponent); patterns.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(pattern))); } configurer.setEnabledStatsPatterns(patterns.toArray(new String[0])); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is need escape single quote double quotes'\nThe code is: 'public ResourceAlreadyExistsException(String resourceName, String resourceId) { <START> super(format(\"%s resource with id \\'%s\\' already exists.\", resourceName, resourceId)); <END> \/\/ I is need escape single quote double quotes }'","output":"public ResourceAlreadyExistsException(String resourceName, String resourceId) { super(format(\"%s resource with id '%s' already exists.\", resourceName, resourceId)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public static LocalDate deserializeLocalDate(String dateTimeString) throws IOException { return DATE_FORMATTER.parse(dateTimeString, LocalDate::from); }'\nThe code is: 'public static LocalDate deserializeLocalDate(String dateTimeString) throws IOException { return deserializeLocalDateTime(dateTimeString).toLocalDate(); <START> } <END> \/\/ public static LocalDate deserializeLocalDate(String dateTimeString) throws IOException { return DATE_FORMATTER.parse(dateTimeString, LocalDate::from); }'","output":"public static LocalDate deserializeLocalDate(String dateTimeString) throws IOException { return DATE_FORMATTER.parse(dateTimeString, LocalDate::from); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'convinced this is needed free file descriptors... close ByteBuffers, in memory. Anyway, safe, is. However, more simple\/representative fBitBuffer null here'\nThe code is: 'public void close() { <START> fBitBuffer = BitBuffer.EMPTY_BITBUFFER; <END> \/\/ convinced this is needed free file descriptors... close ByteBuffers, in memory. Anyway, safe, is. However, more simple\/representative fBitBuffer null here }'","output":"public void close() { fBitBuffer = null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'bagit folder hidden. .bagit is incubating next version of bagit spec; solves a lot of problems originial spec'\nThe code is: 'public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource(\"bags\/v0_98\/bag\").toURI()); if (System.getProperty(\"os.name\").contains(\"Windows\")){ <START> Path bagitDir = rootDir.resolve(\".bagit\"); <END> \/\/ bagit folder hidden. .bagit is incubating next version of bagit spec; solves a lot of problems originial spec Files.setAttribute(bagitDir, \"dos:hidden\", Boolean.TRUE); } Bag bag = reader.read(rootDir); sut.isValid(bag, true); }'","output":"public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource(\"bags\/v0_98\/bag\").toURI()); Bag bag = reader.read(rootDir); sut.isValid(bag, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If this event is fired a delete operation is **isInodeIndexed** method validating'\nThe code is: 'private void sendDeleteEvent (final Contentlet contentlet) throws DotHibernateException { HibernateUtil.addAsyncCommitListener( () -> { <START> this.isInodeIndexed(contentlet.getInode()); <END> \/\/ If this event is fired a delete operation is **isInodeIndexed** method validating this.contentletSystemEventUtil.pushDeleteEvent(contentlet); }, 1000); }'","output":"private void sendDeleteEvent (final Contentlet contentlet) throws DotHibernateException { HibernateUtil.addAsyncCommitListener( () -> { this.contentletSystemEventUtil.pushDeleteEvent(contentlet); }, 1000); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This works : java String templateName = service.getLabels().getOrDefault(\"template\", \"\"); return templateName.startsWith(\"eap\");'\nThe code is: 'protected boolean supportsJBoss7Markers() { IService service = OpenShiftServerUtils.getService(getServer()); <START> return service.getName().startsWith(\"eap\"); <END> \/\/ This works : java String templateName = service.getLabels().getOrDefault(\"template\", \"\"); return templateName.startsWith(\"eap\"); }'","output":"protected boolean supportsJBoss7Markers() { IService service = OpenShiftServerUtils.getService(getServer()); String templateName = service.getLabels().getOrDefault(\"template\", \"\"); return templateName.startsWith(\"eap\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'TXBegin() calling TXBegin(TransactionType.OPTIMISTIC)? is more intuitive implement default parameters'\nThe code is: 'public void TXBegin() { <START> OptimisticTXBegin(); <END> \/\/ TXBegin() calling TXBegin(TransactionType.OPTIMISTIC)? is more intuitive implement default parameters }'","output":"public void TXBegin() { TXBegin(TransactionType.OPTIMISTIC); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need mock this anymore set string return it'\nThe code is: 'void setup() { MockitoAnnotations.initMocks(this); when(asyncClient.getEntityPath()).thenReturn(ENTITY_PATH); when(asyncClient.getFullyQualifiedNamespace()).thenReturn(NAMESPACE); when(asyncClient.getReceiverOptions()).thenReturn(new ReceiverOptions(ReceiveMode.PEEK_LOCK, 1, maxAutoLockRenewalDuration)); <START> when(messageLockToken).thenReturn(LOCK_TOKEN); <END> \/\/ need mock this anymore set string return it client = new ServiceBusReceiverClient(asyncClient, OPERATION_TIMEOUT); }'","output":"void setup() { MockitoAnnotations.initMocks(this); when(asyncClient.getEntityPath()).thenReturn(ENTITY_PATH); when(asyncClient.getFullyQualifiedNamespace()).thenReturn(NAMESPACE); when(asyncClient.getReceiverOptions()).thenReturn(new ReceiverOptions(ReceiveMode.PEEK_LOCK, 1, maxAutoLockRenewalDuration)); client = new ServiceBusReceiverClient(asyncClient, OPERATION_TIMEOUT); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertNull assertNotNull'\nThe code is: 'public void copyFile_shouldNotCopyTheOutputstreamWhenOutputstreamIsNull() throws Exception { String exampleInputStreamString = \"ExampleInputStream\"; ByteArrayInputStream input = new ByteArrayInputStream(exampleInputStreamString.getBytes()); OutputStream output = null; OpenmrsUtil.copyFile(input, output); <START> assertEquals(null, output); <END> \/\/ assertNull assertNotNull assertNotEquals(null, input); }'","output":"public void copyFile_shouldNotCopyTheOutputstreamWhenOutputstreamIsNull() throws Exception { String exampleInputStreamString = \"ExampleInputStream\"; ByteArrayInputStream input = new ByteArrayInputStream(exampleInputStreamString.getBytes()); OutputStream output = null; OpenmrsUtil.copyFile(input, output); assertNull(output); assertNotNull(input); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'instead of testing assertThat(d.toJavaList(), is(d.run().toJavaList())); (that check toJavaList() is alias of run().toJavaList()) I test assertThat(d.toJavaList(), is(List.range(0, 1000).toJavaList())); (same for methods)'\nThe code is: 'public void testListDList() { DList<Integer> d = listDList(List.range(0, 1000)); <START> assertThat(d.toJavaList(), is(d.run().toJavaList())); <END> \/\/ instead of testing assertThat(d.toJavaList(), is(d.run().toJavaList())); (that check toJavaList() is alias of run().toJavaList()) I test assertThat(d.toJavaList(), is(List.range(0, 1000).toJavaList())); (same for methods) }'","output":"public void testListDList() { DList<Integer> d = listDList(List.range(0, 1000)); assertThat(d.toJavaList(), is(List.range(0, 1000).toJavaList())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@daisuke-yoshimoto @Before @After annotations setUp() tearDown() public method reduce boilerplate code in tests for cleanup. enough rename cleanUp() tearDown() annotate @After'\nThe code is: 'public void testValidResources() { <START> cleanUp(); <END> \/\/ @daisuke-yoshimoto @Before @After annotations setUp() tearDown() public method reduce boilerplate code in tests for cleanup. enough rename cleanUp() tearDown() annotate @After final Resource[] resources = new Resource[]{new ClassPathResource(validName1)}; NeverFailAutoDeploymentStrategy deploymentStrategy = new NeverFailAutoDeploymentStrategy(); deploymentStrategy.deployResources(nameHint, resources, repositoryService); assertEquals(1, repositoryService.createDeploymentQuery().count()); cleanUp(); }'","output":"public void testValidResources() { final Resource[] resources = new Resource[]{new ClassPathResource(validName1)}; NeverFailAutoDeploymentStrategy deploymentStrategy = new NeverFailAutoDeploymentStrategy(); deploymentStrategy.deployResources(nameHint, resources, repositoryService); assertEquals(1, repositoryService.createDeploymentQuery().count()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is a typo here: threashold threshold (and other places)'\nThe code is: 'public boolean checkCell(Cell cell) { boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); <START> if (value.compareTo(column.castValue(threashold)) > 0) <END> \/\/ is a typo here: threashold threshold (and other places) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }'","output":"public boolean checkCell(Cell cell) { boolean valid = true; try { Comparable value = column.castValue(cell.value.toString()); if (value.compareTo(column.castValue(threshold)) > 0) valid = false; } catch (InvalidCastException | ConstraintsException e) { valid = false; } return valid; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this for is equivalent footnoteMacro.getChildren().clear();'\nThe code is: 'private void addFootnoteRef(MacroMarkerBlock footnoteMacro, Block footnoteRef) { <START> for (ListIterator<Block> it = footnoteMacro.getChildren().listIterator(); it.hasNext();) { <END> \/\/ this for is equivalent footnoteMacro.getChildren().clear(); it.next(); it.remove(); } footnoteMacro.addChild(footnoteRef); }'","output":"private void addFootnoteRef(MacroMarkerBlock footnoteMacro, Block footnoteRef) { footnoteMacro.getChildren().clear(); footnoteMacro.addChild(footnoteRef); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '';''\nThe code is: 'public void testLoadSingle() { <START> storage.reloadTemplateMaps();; <END> \/\/ ';' ServerTemplate toSearchFor = getFirstTemplateFromMap(); loadTemplateWithAssertEquals(toSearchFor); }'","output":"public void testLoadSingle() { storage.reloadTemplateMaps(); ServerTemplate toSearchFor = getFirstTemplateFromMap(); loadTemplateWithAssertEquals(toSearchFor); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Map<String,String> params = new HashMap<>();'\nThe code is: 'public History[] filterHistory(String... filters) throws Exception { <START> Map<String,String> params = new HashMap<String,String>(); <END> \/\/ Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (int i = 0; i < filters.length; i++) { params.put(\"source_uri[]\", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }'","output":"public History[] filterHistory(String... filters) throws Exception { final Map<String,String> params = new HashMap<>(); if (filters.length > 0) { for (int i = 0; i < filters.length; i++) { params.put(\"source_uri[]\", filters[i]); } } else { return refreshHistory(); } return constructHistory(params); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove System.out'\nThe code is: '@Override public void preBatchMutate(ObserverContext<RegionCoprocessorEnvironment> c, MiniBatchOperationInProgress<Mutation> miniBatchOp) throws IOException { <START> System.out.println(\"Fail once my coproc \" + this); <END> \/\/ Please remove System.out if (failOnce) { failOnce = false; throw new IOException(); } }'","output":"public void preBatchMutate(ObserverContext<RegionCoprocessorEnvironment> c, MiniBatchOperationInProgress<Mutation> miniBatchOp) throws IOException { if (failOnce) { failOnce = false; throw new IOException(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This ENVIRONMENT_UUID, ID. ID UUID values'\nThe code is: 'protected void setEnvironmentLabel(Map<String, Object> labels, Account account) { <START> labels.put(SystemLabels.LABEL_ENVIRONMENT_ID, account.getUuid()); <END> \/\/ This ENVIRONMENT_UUID, ID. ID UUID values }'","output":"protected void setEnvironmentLabel(Map<String, Object> labels, Account account) { labels.put(SystemLabels.LABEL_ENVIRONMENT_UUID, account.getUuid()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); for readability. This is valid for occurrences'\nThe code is: 'public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); <START> assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); <END> \/\/ This assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); for readability. This is valid for occurrences }'","output":"public void testUnhandledExceptionStoredOnCrashReportEnabled() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'default for bool int need clarify. suggestion'\nThe code is: 'public SpotConfiguration(boolean useBidPrice) { this.useBidPrice = useBidPrice; this.spotMaxBidPrice = \"\"; <START> this.fallbackToOndemand = false; this.spotBlockReservationDuration = 0; <END> \/\/ default for bool int need clarify. suggestion }'","output":"public SpotConfiguration(boolean useBidPrice) { this.useBidPrice = useBidPrice; this.spotMaxBidPrice = \"\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instead of ShellIsActive, ShellIsAvailable - safer'\nThe code is: 'private boolean installationStartedCheck() { try { new WaitUntil(new ShellIsActive(\"Progress Information\"), TimePeriod.LONG); <START> new WaitUntil(new ShellIsActive(\"Install New Software\"), TimePeriod.LONG); <END> \/\/ Instead of ShellIsActive, ShellIsAvailable - safer } catch (RedDeerException e) { return false; } new NoButton().click(); return true; }'","output":"private boolean installationStartedCheck() { try { new WaitUntil(new ShellIsAvailable(\"Progress Information\"), TimePeriod.LONG); new WaitUntil(new ShellIsAvailable(\"Install New Software\"), TimePeriod.LONG); } catch (RedDeerException e) { return false; } new NoButton().click(); return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please chain expression. need create a variable here'\nThe code is: 'private boolean checkBaseDBExist() { <START> File baseFile = mContext.getDatabasePath(\"base.sqlite3\"); <END> \/\/ Please chain expression. need create a variable here return baseFile.isFile(); }'","output":"private boolean checkBaseDBExist() { return mContext.getDatabasePath(\"base.sqlite3\").isFile(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For consistency, declared throw IllegalStateException for null checking. I remove for consistency'\nThe code is: '<START> public void setLevel(LogLevel level) throws IllegalStateException { <END> \/\/ For consistency, declared throw IllegalStateException for null checking. I remove for consistency if(_config == null) { throw new IllegalStateException(\"Cannot set logging level without a configuration\"); } if(level == null) { level = LogLevel.NONE; } if(_level.equals(level)) { return; } _level = level; C4Log.setBinaryFileLevel(level.getValue()); }'","output":"public void setLevel(LogLevel level) { if(_config == null) { throw new IllegalStateException(\"Cannot set logging level without a configuration\"); } if(level == null) { level = LogLevel.NONE; } if(_level.equals(level)) { return; } _level = level; C4Log.setBinaryFileLevel(level.getValue()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logger null. need null check here'\nThe code is: 'private boolean canLogAtLevel(int logLevel, int environmentLoggingLevel) { <START> if (logLevel < environmentLoggingLevel || logger == null) { <END> \/\/ logger null. need null check here return false; } switch (logLevel) { case VERBOSE_LEVEL: return logger.isDebugEnabled(); case INFORMATIONAL_LEVEL: return logger.isInfoEnabled(); case WARNING_LEVEL: return logger.isWarnEnabled(); case ERROR_LEVEL: return logger.isErrorEnabled(); default: return false; } }'","output":"private boolean canLogAtLevel(int logLevel, int environmentLoggingLevel) { if (logLevel < environmentLoggingLevel) { return false; } switch (logLevel) { case VERBOSE_LEVEL: return logger.isDebugEnabled(); case INFORMATIONAL_LEVEL: return logger.isInfoEnabled(); case WARNING_LEVEL: return logger.isWarnEnabled(); case ERROR_LEVEL: return logger.isErrorEnabled(); default: return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need 'this' in waitForElementByElement method. please remove consistency repo if is specific reason for adding this'\nThe code is: 'public LicensedVideoSwapHistoryPageObject navigateToHistoryPage() { <START> this.waitForElementByElement(lvsHistoryBtn); <END> \/\/ need 'this' in waitForElementByElement method. please remove consistency repo if is specific reason for adding this lvsHistoryBtn.click(); this.waitForElementByElement(backLink); PageObjectLogging.log(\"navigateToHistoryPage\", \"lvs history button navigates to right page\", true); return new LicensedVideoSwapHistoryPageObject(driver); }'","output":"public LicensedVideoSwapHistoryPageObject navigateToHistoryPage() { waitForElementByElement(lvsHistoryBtn); lvsHistoryBtn.click(); waitForElementByElement(backLink); PageObjectLogging.log(\"navigateToHistoryPage\", \"lvs history button navigates to right page\", true); return new LicensedVideoSwapHistoryPageObject(driver); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@sureshanaparti, please CollectionUtils.isEmpty? checks if List is empty, returning true in case of null. (<LINK_0> Thanks'\nThe code is: 'public void copyPortGroupsFromHost(HostMO srcHost) throws Exception { if (srcHost == null) { return; } List<HostPortGroupSpec> portGroupSpecs = srcHost.getHostPortGroupSpecs(); <START> if (portGroupSpecs == null || portGroupSpecs.isEmpty()) { <END> \/\/ @sureshanaparti, please CollectionUtils.isEmpty? checks if List is empty, returning true in case of null. (<LINK_0> Thanks s_logger.debug(\"No port groups in the host: \" + srcHost.getName()); return; } for (HostPortGroupSpec spec : portGroupSpecs) { s_logger.debug(\"Creating port group: \" + spec.getName() + \" in the host: \" + getName()); createPortGroup(spec); } }'","output":"public void copyPortGroupsFromHost(HostMO srcHost) throws Exception { if (srcHost == null) { return; } List<HostPortGroupSpec> portGroupSpecs = srcHost.getHostPortGroupSpecs(); if (CollectionUtils.isEmpty(portGroupSpecs)) { s_logger.debug(\"No port groups in the host: \" + srcHost.getName()); return; } for (HostPortGroupSpec spec : portGroupSpecs) { s_logger.debug(\"Creating port group: \" + spec.getName() + \" in the host: \" + getName()); createPortGroup(spec); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Optional: replace System out LOG statements'\nThe code is: 'public void testGetExecutorPoolSize() { <START> System.out.println(\"getExecutorPoolSize\"); <END> \/\/ Optional: replace System out LOG statements int expResult = 100; int result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }'","output":"public void testGetExecutorPoolSize() { int expResult = 100; int result = instance.getExecutorPoolSize(); assertEquals(expResult, result); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is incorrect place for command'\nThe code is: 'public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel(\"Default properties will be used. Exception while properties retrieving: \" + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; <START> updateTagFilter(); <END> \/\/ this is incorrect place for command updatePlace(place); } }); }'","output":"public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel(\"Default properties will be used. Exception while properties retrieving: \" + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; updatePlace(place); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'i this new Object() synchronize object'\nThe code is: 'private RuntimeEnvironment() { configuration = new Configuration(); configLock = new ReentrantReadWriteLock(); <START> authFrameworkLock = new ReentrantLock(); <END> \/\/ i this new Object() synchronize object watchDog = new WatchDogService(); lzIndexerParallelizer = LazilyInstantiate.using(() -> new IndexerParallelizer(this)); lzSearchExecutor = LazilyInstantiate.using(() -> newSearchExecutor()); }'","output":"private RuntimeEnvironment() { configuration = new Configuration(); configLock = new ReentrantReadWriteLock(); watchDog = new WatchDogService(); lzIndexerParallelizer = LazilyInstantiate.using(() -> new IndexerParallelizer(this)); lzSearchExecutor = LazilyInstantiate.using(() -> newSearchExecutor()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This (and others ScanTarget) package visible expose ScanTarget, methods ID of scan enough'\nThe code is: '<START> public BruteForce getBruteForce(ScanTarget target) { <END> \/\/ This (and others ScanTarget) package visible expose ScanTarget, methods ID of scan enough return this.bruteForceMap.get(target); }'","output":"BruteForce getBruteForce(ScanTarget target) { return this.bruteForceMap.get(target); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for null check'\nThe code is: 'public QueryBuilder make(EsHint hint, String fieldName, Object value) { MatchPhraseQueryBuilder matchPhraseQuery = QueryBuilders.matchPhraseQuery(fieldName, value); if (hint.analyzer != null) { <START> matchPhraseQuery.analyzer(hint.analyzer); <END> \/\/ need for null check } return matchPhraseQuery; }'","output":"public QueryBuilder make(EsHint hint, String fieldName, Object value) { return QueryBuilders.matchPhraseQuery(fieldName, value).analyzer(hint.analyzer); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this is WavelengthEditor works. In fact pains admit originally responsible for this SuggestibleString business fact is mutable nullish. I do this days though. rate, a slight improvement add a copy method Focus: java public static final class Focus extends SuggestibleString { public Focus(String value) { super(FocusSuggestion.class); setStringValue(value); } public Focus() { this(FocusSuggestion.DEFAULT.displayValue()); } public Focus copy() { return new Focus(getStringValue()); } } java import edu.gemini.shared.util.immutable.*; public Object getValue() { return ImOption.apply((Focus) super.getValue()).map(f -> f.copy()).getOrNull(); }'\nThe code is: 'public Object getValue() { Focus f = (Focus) super.getValue(); if (f == null) return null; Focus res = new Focus(); res.setStringValue(f.getStringValue()); <START> return res; <END> \/\/ I this is WavelengthEditor works. In fact pains admit originally responsible for this SuggestibleString business fact is mutable nullish. I do this days though. rate, a slight improvement add a copy method Focus: java public static final class Focus extends SuggestibleString { public Focus(String value) { super(FocusSuggestion.class); setStringValue(value); } public Focus() { this(FocusSuggestion.DEFAULT.displayValue()); } public Focus copy() { return new Focus(getStringValue()); } } java import edu.gemini.shared.util.immutable.*; public Object getValue() { return ImOption.apply((Focus) super.getValue()).map(f -> f.copy()).getOrNull(); } }'","output":"public Object getValue() { return ImOption.apply((Focus) super.getValue()).map(f -> f.copy()).getOrNull(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary throws (same for constructor above)'\nThe code is: 'public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) <START> throws Exception <END> \/\/ unnecessary throws (same for constructor above) { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }'","output":"public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove'\nThe code is: 'public void activate() { <START> logger.debug(\"activate\"); <END> \/\/ remove }'","output":"public void activate() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this log, DEBUG level'\nThe code is: 'public SiteRestRepository() { <START> System.out.println(\"Repository initialized by Spring\"); <END> \/\/ this log, DEBUG level }'","output":"public SiteRestRepository() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'try-with-resources need manually close session'\nThe code is: 'public int saveAnnouncement(final Announcement announcement) { LOG.debug(\"save new announcement\"); final SqlSession session = factory.openSession(); int saveId = -1; try { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); session.commit(); } catch (Exception e) { throw new RuntimeException(\"Failed to save announcement\", e); } finally { <START> session.close(); <END> \/\/ try-with-resources need manually close session } return saveId; }'","output":"public int saveAnnouncement(final Announcement announcement) { int saveId = -1; try (final SqlSession session = factory.openSession()) { final AnnouncementsMapper mapper = session.getMapper(AnnouncementsMapper.class); saveId = mapper.saveAnnouncement(announcement); return saveId; } catch (Exception e) { throw new ServiceRuntimeException(\"Failed to save announcements\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Missing <>, this is a raw type'\nThe code is: 'public ScaledNumberIndexFieldTypeContext<?, BigInteger> asBigInteger() { <START> return new StubScaledNumberIndexFieldTypeContext( BigInteger.class, defaultsProvider ); <END> \/\/ Missing <>, this is a raw type }'","output":"public ScaledNumberIndexFieldTypeContext<?, BigInteger> asBigInteger() { return new StubScaledNumberIndexFieldTypeContext<>( BigInteger.class, defaultsProvider ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's.a'\nThe code is: '<START> public Class<MongoCodeListEntry> getEntryType() { <END> \/\/ s.a return MongoCodeListEntry.class; }'","output":"protected Class<MongoCodeListEntry> getEntryType() { return MongoCodeListEntry.class; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertThat(related).isEmpty();'\nThe code is: 'public void getRelatedNoResult() throws Exception { PushOneCommit push = pushFactory.create(db, admin.getIdent()); PatchSet.Id ps = push.to(git, \"refs\/for\/master\").getPatchSetId(); List<ChangeAndCommit> related = getRelated(ps); <START> assertThat(related.size()).isEqualTo(0); <END> \/\/ assertThat(related).isEmpty(); }'","output":"public void getRelatedNoResult() throws Exception { PushOneCommit push = pushFactory.create(db, admin.getIdent()); PatchSet.Id ps = push.to(git, \"refs\/for\/master\").getPatchSetId(); List<ChangeAndCommit> related = getRelated(ps); assertThat(related).isEmpty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This ImmutableList'\nThe code is: 'public void toParamDocs_Test() { <START> final List<ParamDescriptor> pds = Arrays.asList( <END> \/\/ This ImmutableList createParamDescriptor(\"1\"), createParamDescriptor(\"2\")); final ImmutableMap<String, String> result = toParamDocs(pds); assertThat(result.size(), is(2)); assertThat(result.get(\"Name1\"), is(\"Description1\")); assertThat(result.get(\"Name2\"), is(\"Description2\")); }'","output":"public void toParamDocs_Test() { final ImmutableList<ParamDescriptor> pds = ImmutableList.of( createParamDescriptor(\"1\"), createParamDescriptor(\"2\")); final ImmutableMap<String, String> result = toParamDocs(pds); assertThat(result.size(), is(2)); assertThat(result.get(\"Name1\"), is(\"Description1\")); assertThat(result.get(\"Name2\"), is(\"Description2\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add generic'\nThe code is: 'protected Spec[] getSelectedSpecs() { <START> List list <END> \/\/ add generic = fileAssociationViewer.getStructuredSelection().toList(); return (Spec[]) list.toArray(new Spec[list.size()]); }'","output":"protected Spec[] getSelectedSpecs() { List<Spec> list = fileAssociationViewer.getStructuredSelection().toList(); return list.toArray(new Spec[list.size()]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Storing config defaultHistory period enough- a need store'\nThe code is: 'public SegmentMetadataQueryQueryToolChest( SegmentMetadataQueryConfig config ) { <START> this.config = config; <END> \/\/ Storing config defaultHistory period enough- a need store defaultHistory = this.config.getDefaultHistory(); }'","output":"public SegmentMetadataQueryQueryToolChest( SegmentMetadataQueryConfig config ) { this.config = config; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this line. ChangeDetailFactory needed more deleted. files PatchDetailServiceImpl.java, is removed'\nThe code is: 'protected void configureServlets() { install(new FactoryModule() { @Override protected void configure() { <START> factory(ChangeDetailFactory.Factory.class); <END> \/\/ Remove this line. ChangeDetailFactory needed more deleted. files PatchDetailServiceImpl.java, is removed factory(PatchSetDetailFactory.Factory.class); } }); rpc(ChangeDetailServiceImpl.class); }'","output":"protected void configureServlets() { install(new FactoryModule() { @Override protected void configure() { factory(PatchSetDetailFactory.Factory.class); } }); rpc(ChangeDetailServiceImpl.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'methods commands in datadog-agent (stuff datadog-agent jmxfetch list-matching) is expected print stdout always, a debugging command. LOGGER.debug changes, missing something, subject log level, potentially breaking agent commands. If this, info warning - preferable print stdout...'\nThe code is: 'public void displayMatchingAttributeName(JMXAttribute jmxAttribute, int rank, int limit) { <START> LOGGER.debug(\" Matching: \" + rank + \"\/\" + limit + \". \" + jmxAttribute); <END> \/\/ methods commands in datadog-agent (stuff datadog-agent jmxfetch list-matching) is expected print stdout always, a debugging command. LOGGER.debug changes, missing something, subject log level, potentially breaking agent commands. If this, info warning - preferable print stdout... }'","output":"public void displayMatchingAttributeName(JMXAttribute jmxAttribute, int rank, int limit) { LOGGER.info(\" Matching: \" + rank + \"\/\" + limit + \". \" + jmxAttribute); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this \"key id formatting convention\" is applied everywhere. create a static helper randomKey() generate key ids'\nThe code is: 'protected void init() { key = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); <START> value = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); <END> \/\/ this \"key id formatting convention\" is applied everywhere. create a static helper randomKey() generate key ids }'","output":"protected void init() { key = randomString(); value = randomString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Style-nit: Spaces operators +'\nThe code is: 'public void testCreateSchema_DefaultAccess_AnonymousUsers() throws OrmException { db.create(); final SystemConfig config = db.getSystemConfig(); <START> assertDefaultRight(RefRight.REGEX_SYMBOL+\"refs\/*\", config.anonymousGroupId, <END> \/\/ Style-nit: Spaces operators + ApprovalCategory.READ, 1, 1); }'","output":"public void testCreateSchema_DefaultAccess_AnonymousUsers() throws OrmException { db.create(); final SystemConfig config = db.getSystemConfig(); assertDefaultRight(\"refs\/*\", config.anonymousGroupId, ApprovalCategory.READ, 1, 1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java this.client = requireNonNull(client, \"client is null\");'\nThe code is: 'public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, \"client is null\"); <END> \/\/ java this.client = requireNonNull(client, \"client is null\"); this.client = client; }'","output":"public AlluxioHiveMetastore(TableMasterClient client) { this.client = requireNonNull(client, \"client is null\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@lautarobock too, declare throws Exception'\nThe code is: '<START> public void testOneFail() throws IOException { <END> \/\/ @lautarobock too, declare throws Exception final List<Pass> list = new ArrayList<Pass>(1); list.add(new PsFake(false)); final Opt<Identity> identity = new PsAll(list, 0).enter(new RqFake()); MatcherAssert.assertThat( identity.has(), Matchers.is(false) ); }'","output":"public void testOneFail() throws Exception { final List<Pass> list = new ArrayList<Pass>(1); list.add(new PsFake(false)); final Opt<Identity> identity = new PsAll(list, 0).enter(new RqFake()); MatcherAssert.assertThat( identity.has(), Matchers.is(false) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a reason change this info instead of trace'\nThe code is: 'public void stopContainer() throws Exception { deployer.undeploy(APP_CONTEXT); final ModelControllerClient client = TestSuiteEnvironment.getModelControllerClient(); final ManagementClient managementClient = new ManagementClient(client, TestSuiteEnvironment.getServerAddress(), TestSuiteEnvironment.getServerPort(), \"remote+http\"); <START> LOGGER.info(\"*** reseting test configuration\"); <END> \/\/ a reason change this info instead of trace serverTearDown(managementClient); LOGGER.trace(\"*** stopping container\"); containerController.stop(CONTAINER); }'","output":"public void stopContainer() throws Exception { deployer.undeploy(APP_CONTEXT); final ModelControllerClient client = TestSuiteEnvironment.getModelControllerClient(); final ManagementClient managementClient = new ManagementClient(client, TestSuiteEnvironment.getServerAddress(), TestSuiteEnvironment.getServerPort(), \"remote+http\"); LOGGER.trace(\"*** reseting test configuration\"); serverTearDown(managementClient); LOGGER.trace(\"*** stopping container\"); containerController.stop(CONTAINER); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'storageDomain.getDiscardAfterDelete() used'\nThe code is: 'public DestroyImageVDSCommandParameters createDestroyImageParameters() { StorageDomain storageDomain = storageDomainDao.get(getParameters().getStorageDomainId()); return new DestroyImageVDSCommandParameters(getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), Collections.singletonList(getParameters().getImageId()), getDiskImage().isWipeAfterDelete(), <START> storageDomain.getSupportsDiscard(), <END> \/\/ storageDomain.getDiscardAfterDelete() used true); }'","output":"public DestroyImageVDSCommandParameters createDestroyImageParameters() { StorageDomain storageDomain = storageDomainDao.get(getParameters().getStorageDomainId()); return new DestroyImageVDSCommandParameters(getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), Collections.singletonList(getParameters().getImageId()), getDiskImage().isWipeAfterDelete(), storageDomain.getDiscardAfterDelete(), true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method protected instead of public'\nThe code is: '<START> public void execInitClipboardForm(ClipboardForm form) { <END> \/\/ This method protected instead of public }'","output":"protected void execInitClipboardForm(ClipboardForm form) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'condition replaced !TextUtils.isEmpty(assignmentId)'\nThe code is: 'public void trackValuePropLearnMoreTapped(@NonNull String courseId, @Nullable String assignmentId, @NonNull String screenName) { final FirebaseEvent event = new FirebaseEvent(Events.VALUE_PROP_LEARN_MORE_CLICKED, Values.VALUE_PROP_LEARN_MORE_CLICKED); event.putCourseId(courseId); <START> if (assignmentId != null) { <END> \/\/ condition replaced !TextUtils.isEmpty(assignmentId) event.putString(Keys.ASSIGNMENT_ID, assignmentId); } event.putString(Keys.SCREEN_NAME, screenName); logFirebaseEvent(event.getName(), event.getBundle()); }'","output":"public void trackValuePropLearnMoreTapped(@NonNull String courseId, @Nullable String assignmentId, @NonNull String screenName) { final FirebaseEvent event = new FirebaseEvent(Events.VALUE_PROP_LEARN_MORE_CLICKED, Values.VALUE_PROP_LEARN_MORE_CLICKED); event.putCourseId(courseId); if (TextUtils.isEmpty(assignmentId)) { event.putString(Keys.ASSIGNMENT_ID, assignmentId); } event.putString(Keys.SCREEN_NAME, screenName); logFirebaseEvent(event.getName(), event.getBundle()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check is done in verifyVirtIoScsi, repeat it'\nThe code is: 'private ValidationResult isVirtIoScsiValid(VM vm, DiskVmElementValidator diskVmElementValidator) { ValidationResult result = diskVmElementValidator.verifyVirtIoScsi(vm); if (!result.isValid()) { return result; } <START> if (vm != null && diskVmElementValidator.isVirtIoScsi()) { <END> \/\/ check is done in verifyVirtIoScsi, repeat it if (!VmDeviceCommonUtils.isVirtIoScsiDeviceExists(getVm().getManagedVmDeviceMap().values())) { return new ValidationResult(EngineMessage.CANNOT_PERFORM_ACTION_VIRTIO_SCSI_IS_DISABLED); } } return ValidationResult.VALID; }'","output":"private ValidationResult isVirtIoScsiValid(VM vm, DiskVmElementValidator diskVmElementValidator) { ValidationResult result = diskVmElementValidator.verifyVirtIoScsi(vm); if (!result.isValid()) { return result; } return ValidationResult.VALID; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Move setUp(). mCameraId a local variable again'\nThe code is: 'public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { <START> Assume.assumeTrue(mCameraId != null); <END> \/\/ Move setUp(). mCameraId a local variable again mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnClosed(1); }'","output":"public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnClosed(1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'protected? default is package visibility accessible test class. Protected = package + subclasses'\nThe code is: '<START> protected static double average(Double... args) { <END> \/\/ protected? default is package visibility accessible test class. Protected = package + subclasses return average(Arrays.asList(args)); }'","output":"static double average(Double... args) { return average(Arrays.asList(args)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove double a valid test & original exception'\nThe code is: 'public void setObject_unmanagedObjectThrows() { RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll(); realm.beginTransaction(); try { collection.setObject(AllTypes.FIELD_REALMOBJECT, new Dog()); fail(); } catch (IllegalArgumentException e) { <START> assertTrue(\"Wrong error message: \" + e.getMessage(), e.getMessage().contains(\"is not a valid a valid, managed Realm object.\")); <END> \/\/ remove double a valid test & original exception } }'","output":"public void setObject_unmanagedObjectThrows() { RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll(); realm.beginTransaction(); try { collection.setObject(AllTypes.FIELD_REALMOBJECT, new Dog()); fail(); } catch (IllegalArgumentException e) { assertTrue(\"Wrong error message: \" + e.getMessage(), e.getMessage().contains(\"is not a valid, managed Realm object.\")); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getUuid instead of getArtId,'\nThe code is: '<START> private void testUpdateInsertionFeature(String insertion) throws Exception { <END> \/\/ getUuid instead of getArtId, String url = \"\/ats\/program\/\" + getSawProgram().getArtId() + \"\/insertion\/1234567800\/feature\"; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(\"Renamed Insertion Feature\", array); Assert.assertNotNull(\"Did not find value Renamed Insertion Feature\", obj); }'","output":"private void testUpdateInsertionFeature(String insertion) throws Exception { String url = \"\/ats\/program\/\" + getSawProgram().getUuid() + \"\/insertion\/1234567800\/feature\"; JsonArray array = putAndCheck(url, Entity.entity(insertion, MediaType.APPLICATION_JSON_TYPE)); Assert.assertEquals(1, array.size()); JsonObject obj = getObjectNamed(\"Renamed Insertion Feature\", array); Assert.assertNotNull(\"Did not find value Renamed Insertion Feature\", obj); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please consistent other places: <LINK_0> Possibly updating TK103 decoder better'\nThe code is: 'public OsmAndProtocolDecoder(OsmAndProtocol protocol) { super(protocol); <START> speedUnits = Context.getConfig().getString(\"osmand.speedUnits\", \"kn\"); <END> \/\/ Please consistent other places: <LINK_0> Possibly updating TK103 decoder better }'","output":"public OsmAndProtocolDecoder(OsmAndProtocol protocol) { super(protocol); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '1 this. a deal breaker. do in other places, consistently. stands out in file do configMap.containsKey..'\nThe code is: 'public MapConfiguration() { <START> this.configMap = new ConcurrentHashMap<String, String>(); <END> \/\/ 1 this. a deal breaker. do in other places, consistently. stands out in file do configMap.containsKey.. }'","output":"public MapConfiguration() { configMap = new ConcurrentHashMap<String, String>(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null here'\nThe code is: 'public long getFilePointer() { try { return currentPageId * pageSize + currentPageOffset - startPosition; } <START> catch ( NullPointerException npe ) <END> \/\/ null here { throw new AlreadyClosedException( \"Already closed: \" + this ); } }'","output":"public long getFilePointer() { return currentPageId * pageSize + currentPageOffset - startPosition; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I FirebaseListAdapter.this here, (rather FirebaseRecyclerAdapter.this)'\nThe code is: 'public FirebaseListAdapter(Activity activity, Class<T> modelClass, int modelLayout, Query ref) { mModelClass = modelClass; mLayout = modelLayout; mActivity = activity; mSnapshots = new FirebaseArray(ref); mSnapshots.setOnChangedListener(new FirebaseArray.OnChangedListener() { @Override public void onChanged(EventType type, int index, int oldIndex) { notifyDataSetChanged(); } @Override public void onCancelled(DatabaseError databaseError) { <START> FirebaseRecyclerAdapter.this.onCancelled(databaseError); <END> \/\/ I FirebaseListAdapter.this here, (rather FirebaseRecyclerAdapter.this) } }); }'","output":"public FirebaseListAdapter(Activity activity, Class<T> modelClass, int modelLayout, Query ref) { mModelClass = modelClass; mLayout = modelLayout; mActivity = activity; mSnapshots = new FirebaseArray(ref); mSnapshots.setOnChangedListener(new FirebaseArray.OnChangedListener() { @Override public void onChanged(EventType type, int index, int oldIndex) { notifyDataSetChanged(); } @Override public void onCancelled(DatabaseError databaseError) { FirebaseListAdapter.this.onCancelled(databaseError); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simpler call: <code>this(ThingTypeXmlResult.class, \"thing-type\");<\/code> So, do need add new lines constructors'\nThe code is: 'public ThingTypeConverter() { <START> super(ThingTypeXmlResult.class, \"thing-type\"); <END> \/\/ simpler call: <code>this(ThingTypeXmlResult.class, \"thing-type\");<\/code> So, do need add new lines constructors this.attributeMapValidator = new ConverterAttributeMapValidator( new String[][] { { \"id\", \"true\" }, { \"listed\", \"false\" } }); }'","output":"public ThingTypeConverter() { this(ThingTypeXmlResult.class, \"thing-type\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this need public'\nThe code is: '<START> public final ExecutionContext context() { <END> \/\/ this need public return context; }'","output":"final ExecutionContext context() { return context; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove unnecessary brackets: return (RestartVdsReturnValue) super.getReturnValue();'\nThe code is: 'public RestartVdsReturnValue getReturnValue() { <START> return (RestartVdsReturnValue)(super.getReturnValue()); <END> \/\/ Please remove unnecessary brackets: return (RestartVdsReturnValue) super.getReturnValue(); }'","output":"public RestartVdsReturnValue getReturnValue() { return (RestartVdsReturnValue) super.getReturnValue(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This package private :)'\nThe code is: '<START> public Meetup(int monthOfYear, int year) { <END> \/\/ This package private :) startOfMonth = LocalDate.of(year, monthOfYear, 1); }'","output":"Meetup(int monthOfYear, int year) { startOfMonth = LocalDate.of(year, monthOfYear, 1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'follow convention, formatting be: java private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {'\nThe code is: '<START> private static NioClient createClient( Peer peer, int port, int connectionTimeout ) throws IOException { <END> \/\/ follow convention, formatting be: java private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException { InetSocketAddress serverAddress = new InetSocketAddress(InetAddress.getLocalHost(), port); NioClient client = new NioClient(serverAddress, peer, connectionTimeout); return client; }'","output":"private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException { InetSocketAddress serverAddress = new InetSocketAddress(InetAddress.getLocalHost(), port); return new NioClient(serverAddress, peer, connectionTimeout); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this case given? I entry for uuid registrations'\nThe code is: 'protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> \/\/ this case given? I entry for uuid registrations }'","output":"protected boolean isRegistered(final String uuid) { return handlers.containsKey(uuid); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Spare semicolon ;'\nThe code is: '<START> private String getLocalDateTime(Date modificationTime) {; <END> \/\/ Spare semicolon ; SimpleDateFormat dt = new SimpleDateFormat(\"EEE LLL dd yyyy\", Locale.getDefault()); return dt.format(modificationTime); }'","output":"private String getLocalDateTime(Date modificationTime) { SimpleDateFormat dt = new SimpleDateFormat(\"EEE LLL dd yyyy\", Locale.getDefault()); return dt.format(modificationTime); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return Arrays.toString(value);'\nThe code is: 'public String toString() { <START> return String.join(\", \", value); <END> \/\/ suggestion return Arrays.toString(value); }'","output":"public String toString() { return Arrays.toString(value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is a noop, remove this dependency result storage engine. For other storage engines S3, another mechanism remove objects (like auto expiration)'\nThe code is: 'protected void deleteAsyncQuery() { try { Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays); PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\"); FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate); Collection<AsyncQuery> asyncQueryList = asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp); <START> resultStorageEngine.deleteResultsCollection(asyncQueryList); <END> \/\/ this is a noop, remove this dependency result storage engine. For other storage engines S3, another mechanism remove objects (like auto expiration) } catch (Exception e) { log.error(\"Exception in scheduled cleanup: {}\", e); } }'","output":"protected void deleteAsyncQuery() { try { Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays); PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\"); FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate); asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp); } catch (Exception e) { log.error(\"Exception in scheduled cleanup: {}\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'changed mind decided this setter in ctor. I is a justification for a final..'\nThe code is: '<START> public final void setSendTimeoutExpression(Expression sendTimeoutExpression) { <END> \/\/ changed mind decided this setter in ctor. I is a justification for a final.. Assert.notNull(sendTimeoutExpression, \"'sendTimeoutExpression' must not be null\"); this.sendTimeoutExpression = sendTimeoutExpression; }'","output":"public void setSendTimeoutExpression(Expression sendTimeoutExpression) { Assert.notNull(sendTimeoutExpression, \"'sendTimeoutExpression' must not be null\"); this.sendTimeoutExpression = sendTimeoutExpression; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This simply invoke new method'\nThe code is: 'public void removePacketInterceptor(StanzaListener packetInterceptor) { <START> synchronized (interceptors) { <END> \/\/ This simply invoke new method interceptors.remove(packetInterceptor); } }'","output":"public void removePacketInterceptor(StanzaListener packetInterceptor) { removeStanzaInterceptor(packetInterceptor); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fix string concatenation in this file'\nThe code is: 'private ClassLoader createLoaderForJar(URL jarURL) { <START> LOGGER.debug(\"Creating Loader For jar: \" + jarURL); <END> \/\/ fix string concatenation in this file ClassLoader jarLoader = new URLClassLoader(enumerateJar(jarURL), this); if (jarLoader == null) { LOGGER.warn(\"No jar found with url: \" + jarURL); } return jarLoader; }'","output":"private ClassLoader createLoaderForJar(URL jarURL) { LOGGER.debug(\"Creating Loader For jar: {}\", jarURL); ClassLoader jarLoader = new URLClassLoader(enumerateJar(jarURL), this); if (jarLoader == null) { LOGGER.warn(\"No jar found with url: {}\", jarURL); } return jarLoader; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'benefit of Optional instead of returning null? In a caller's life easier? I suspect instead of simply checking for null a caller end Optional.isPresent checks (maybe hidden in ifPresent a lambda thrown in for additional complexity)'\nThe code is: 'public Optional<String> getCommitTemplatePath() { <START> return Optional.ofNullable(commitTemplatePath); <END> \/\/ benefit of Optional instead of returning null? In a caller's life easier? I suspect instead of simply checking for null a caller end Optional.isPresent checks (maybe hidden in ifPresent a lambda thrown in for additional complexity) }'","output":"public String getCommitTemplatePath() { return commitTemplatePath; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need check view type above. table.getTableType() suffice'\nThe code is: 'public TableType tableType() { if (isView()) { <START> return TableType.VIRTUAL_VIEW; <END> \/\/ need check view type above. table.getTableType() suffice } else if (isMaterializedView()) { return TableType.MATERIALIZED_VIEW; } return table.getTableType(); }'","output":"public TableType tableType() { return table.getTableType(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change loadBuildNumber(System.getenv(), properties); loadBuildNumber(properties); BuildServerDataProvider a reference env..'\nThe code is: 'public void loadBuildData(@NotNull Properties properties) { loadBuildVersionAndTimeData(properties); loadBuildHostData(properties); <START> loadBuildNumber(System.getenv(), properties); <END> \/\/ Change loadBuildNumber(System.getenv(), properties); loadBuildNumber(properties); BuildServerDataProvider a reference env.. }'","output":"public void loadBuildData(@NotNull Properties properties) { loadBuildVersionAndTimeData(properties); loadBuildHostData(properties); loadBuildNumber(properties); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is runQueue anywhere'\nThe code is: 'public MaxwellKafkaProducer(MaxwellContext context, Properties kafkaProperties, String kafkaTopic) { super(context); this.queue = new ArrayBlockingQueue<>(100); <START> BlockingQueue<Runnable> runQueue = new ArrayBlockingQueue<>(100); <END> \/\/ Is runQueue anywhere this.worker = new MaxwellKafkaProducerWorker(context, kafkaProperties, kafkaTopic, this.queue); Thread thread = new Thread(this.worker, \"maxwell-kafka-worker\"); thread.setDaemon(true); thread.start(); }'","output":"public MaxwellKafkaProducer(MaxwellContext context, Properties kafkaProperties, String kafkaTopic) { super(context); this.queue = new ArrayBlockingQueue<>(100); this.worker = new MaxwellKafkaProducerWorker(context, kafkaProperties, kafkaTopic, this.queue); Thread thread = new Thread(this.worker, \"maxwell-kafka-worker\"); thread.setDaemon(true); thread.start(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this. here? delete elsewhere'\nThe code is: 'CloseableIterator<RepresentativeReadIndexer> representativeReadIndicesIterator() { <START> return this.representativeReadIndicesForDuplicates.iterator(); <END> \/\/ this. here? delete elsewhere }'","output":"CloseableIterator<RepresentativeReadIndexer> representativeReadIndicesIterator() { return representativeReadIndicesForDuplicates.iterator(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'pushInlineDeployments'\nThe code is: 'public void testContrib() throws Exception { <START> deployContrib(\"org.nuxeo.ecm.core.api.tests\", \"OSGI-INF\/test-pathsegment-contrib.xml\"); <END> \/\/ pushInlineDeployments applyInlineDeployments(); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(\"My Document\"); assertEquals(\"my-document\", service.generatePathSegment(doc)); }'","output":"public void testContrib() throws Exception { pushInlineDeployments(\"org.nuxeo.ecm.core.api.tests:OSGI-INF\/test-pathsegment-contrib.xml\"); PathSegmentService service = Framework.getService(PathSegmentService.class); assertNotNull(service); DocumentModel doc = DocumentModelProxy.newDocumentModel(\"My Document\"); assertEquals(\"my-document\", service.generatePathSegment(doc)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'SEPARATOR constant here'\nThe code is: 'public static String mapToApi(FeedScopedId arg) { if (arg == null) { return null; } <START> return arg.getFeedId() + \":\" + arg.getId(); <END> \/\/ SEPARATOR constant here }'","output":"public static String mapToApi(FeedScopedId arg) { if (arg == null) { return null; } return arg.getFeedId() + SEPARATOR + arg.getId(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'hashCode simpler java @Override public int hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); } OK current well'\nThe code is: '<START> public int hashCode() { <END> \/\/ hashCode simpler java @Override public int hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); } OK current well final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((registry == null) ? 0 : registry.hashCode()); result = prime * result + ((version == null) ? 0 : version.hashCode()); return result; }'","output":"public int hashCode() { return Objects.hash(getRegistry(), getId(), getVersion()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replaced 0L, similarly other casts ommitted'\nThe code is: 'public long getLong() { <START> return (long) 0; <END> \/\/ replaced 0L, similarly other casts ommitted }'","output":"public long getLong() { return 0L; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For curiosity, this method called multiple threads'\nThe code is: '<START> public synchronized ResponseStatus getStatus() { <END> \/\/ For curiosity, this method called multiple threads ResponseStatus status = null; try { if (responseMetadata.has(RESPONSE_STATUS_KEY)) { status = ResponseStatus.valueOf(responseMetadata.getString(RESPONSE_STATUS_KEY)); } } catch (Exception e) { throw new IllegalStateException(e); } return status; }'","output":"public ResponseStatus getStatus() { ResponseStatus status = null; try { if (responseMetadata.has(RESPONSE_STATUS_KEY)) { status = ResponseStatus.valueOf(responseMetadata.getString(RESPONSE_STATUS_KEY)); } } catch (Exception e) { throw new IllegalStateException(e); } return status; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need check for empty'\nThe code is: 'private void processCaches(Document doc, Element parent, Jsr107Configuration configuration) { Map<String, String> cacheMap = configuration.getTemplates(); <START> if (!cacheMap.isEmpty()) { <END> \/\/ need check for empty cacheMap.forEach((k, v) -> { Element cacheElement = doc.createElement(JSR_NAMESPACE_PREFIX + COLON + CACHE_ELEMENT_NAME); cacheElement.setAttribute(CACHE_NAME_ATTRIBUTE, k); cacheElement.setAttribute(TEMPLATE_NAME_ATTRIBUTE, v); parent.appendChild(cacheElement); }); } }'","output":"private void processCaches(Document doc, Element parent, Jsr107Configuration configuration) { Map<String, String> cacheMap = configuration.getTemplates(); cacheMap.forEach((k, v) -> { Element cacheElement = doc.createElement(JSR_NAMESPACE_PREFIX + COLON + CACHE_ELEMENT_NAME); cacheElement.setAttribute(CACHE_NAME_ATTRIBUTE, k); cacheElement.setAttribute(TEMPLATE_NAME_ATTRIBUTE, v); parent.appendChild(cacheElement); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wow'\nThe code is: 'public Iterable<Node> treeIterable(TreeTraversal traversal) { <START> return () -> treeIterator(traversal); <END> \/\/ Wow }'","output":"private Iterable<Node> treeIterable(TreeTraversal traversal) { return () -> treeIterator(traversal); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This return a URL'\nThe code is: '<START> public String getDirectoryUrl() { <END> \/\/ This return a URL return directoryAsyncClient.getDirectoryUrl(); }'","output":"public URL getDirectoryUrl() { return directoryAsyncClient.getDirectoryUrl(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'effective compatibility version is correct well, 'getEffectiveCompatibilityVersion', I'\nThe code is: 'protected void executeVmCommand() { if (shouldAddLease(getVm())) { if <START> (FeatureSupported.isVmLeasesSupported(getVm().getCompatibilityVersion())) <END> \/\/ effective compatibility version is correct well, 'getEffectiveCompatibilityVersion', I { if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) { getVm().setLeaseStorageDomainId(null); } } else { getVm().setLeaseStorageDomainId(null); auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION); } } super.executeVmCommand(); }'","output":"protected void executeVmCommand() { if (shouldAddLease(getVm())) { if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) { if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) { getVm().setLeaseStorageDomainId(null); } } else { getVm().setLeaseStorageDomainId(null); auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION); } } super.executeVmCommand(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'message get (just out of curiosity)'\nThe code is: 'static <T> T build( StructureBuilder<AnyValue,T> builder, MapValue map ) { if ( map.size() == 0 ) { <START> throw new InvalidTemporalArgumentException( \"At least one temporal unit must be specified.\" ); <END> \/\/ message get (just out of curiosity) } return build( builder, map.entrySet() ); }'","output":"static <T> T build( StructureBuilder<AnyValue,T> builder, MapValue map ) { if ( map.size() == 0 ) { throw new InvalidValuesArgumentException( \"At least one temporal unit must be specified.\" ); } return build( builder, map.entrySet() ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please Change externalSearch'\nThe code is: 'public String evaluate( String referer ) { <START> ExternalSearch es_inst = ExternalSearch.getInstance(); <END> \/\/ Please Change externalSearch return es_inst.refererClassify( referer ); }'","output":"public String evaluate( String referer ) { ExternalSearch externalSearch = ExternalSearch.getInstance(); return externalSearch.refererClassify( referer ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return 'true''\nThe code is: 'public boolean isEnabled() { return <START> getActiveTextEditor() != null; <END> \/\/ return 'true' }'","output":"public boolean isEnabled() { return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this package-access instead of public-access? Callers ArchiveRetrievalJobRequest.builder correct'\nThe code is: '<START> public Builder() { <END> \/\/ this package-access instead of public-access? Callers ArchiveRetrievalJobRequest.builder correct }'","output":"protected Builder() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I return \"\"'\nThe code is: 'public String getName() { if(getEcoreClassifier() == null) { <START> return \"null\"; <END> \/\/ I return \"\" } return getEcoreClassifier().getName(); }'","output":"public String getName() { if(getEcoreClassifier() == null) { return \"\"; } return getEcoreClassifier().getName(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion Unit(String symbol) {'\nThe code is: '<START> private Unit(String symbol) { <END> \/\/ suggestion Unit(String symbol) { this.symbol = symbol; }'","output":"Unit(String symbol) { this.symbol = symbol; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Adding this a field is good manner'\nThe code is: 'public String getInstallationID() { <START> return thingIfApi.getInstallationID(); <END> \/\/ Adding this a field is good manner }'","output":"public String getInstallationID() { return this.thingIfApi.getInstallationID(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'able avoid compiler warnings raw types phrasing as: return type instanceof Class<?> && ((Class<?>) type).isPrimitive(); straight-wildcard form of a generic type in instanceof casts issue'\nThe code is: '<START> private static boolean isPrimitiveType(Type type) { <END> \/\/ able avoid compiler warnings raw types phrasing as: return type instanceof Class<?> && ((Class<?>) type).isPrimitive(); straight-wildcard form of a generic type in instanceof casts issue return (type instanceof Class) && ((Class)type).isPrimitive(); }'","output":"private static boolean isPrimitiveType(Type type) { return type instanceof Class<?> && ((Class<?>)type).isPrimitive(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I is move counter handleWebSocketFrame method for BinaryWebSocketFrame'\nThe code is: 'public void channelRead0(ChannelHandlerContext ctx, Object msg) { if (msg instanceof FullHttpRequest) { handleHttpRequest(ctx, (FullHttpRequest) msg); } else if (msg instanceof WebSocketFrame) { handleWebSocketFrame(ctx, (WebSocketFrame) msg); } <START> globalStats.mark(Command.WEB_SOCKETS); <END> \/\/ I is move counter handleWebSocketFrame method for BinaryWebSocketFrame }'","output":"public void channelRead0(ChannelHandlerContext ctx, Object msg) { if (msg instanceof FullHttpRequest) { handleHttpRequest(ctx, (FullHttpRequest) msg); } else if (msg instanceof WebSocketFrame) { handleWebSocketFrame(ctx, (WebSocketFrame) msg); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this right place for this code? this in MainApplication class guarded Config#areFirebasePushNotificationsEnabled check'\nThe code is: 'protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); NotificationUtil.subscribeToTopics(environment, this); <START> NotificationUtil.logFirebaseToken(); <END> \/\/ Is this right place for this code? this in MainApplication class guarded Config#areFirebasePushNotificationsEnabled check initWhatsNew(); addClickListenerOnProfileButton(); }'","output":"protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); initWhatsNew(); addClickListenerOnProfileButton(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please consider adding overridden version of Script(String, int, Logger) constructor accepts Duration encapsulate this type conversion'\nThe code is: 'private Map<String, String> getVersionStrings() { <START> final Script command = new Script(_versionstringpath, _timeout.getMillis(), s_logger); <END> \/\/ Please consider adding overridden version of Script(String, int, Logger) constructor accepts Duration encapsulate this type conversion final KeyValueInterpreter kvi = new KeyValueInterpreter(); final String result = command.execute(kvi); if (result == null) { return kvi.getKeyValues(); } else { return new HashMap<String, String>(1); } }'","output":"private Map<String, String> getVersionStrings() { final Script command = new Script(_versionstringpath, _timeout, s_logger); final KeyValueInterpreter kvi = new KeyValueInterpreter(); final String result = command.execute(kvi); if (result == null) { return kvi.getKeyValues(); } else { return new HashMap<String, String>(1); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'constructors exist for codec \/ jackson protected private. handle warning'\nThe code is: '<START> public CommandTaskNew() { <END> \/\/ constructors exist for codec \/ jackson protected private. handle warning super(); }'","output":"private CommandTaskNew() { super(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'thrown a NotFoundException (if is declared, create it). This exception catch in interceptor response 404 found'\nThe code is: 'public void activate(Object operatorID) { Long count = datastore.entityCount(OperatorEntity.class, Filter.where(\"_id\").is(operatorID)); if (count == 0) { <START> throw new OperatorException(\"Operator is undefined!\"); <END> \/\/ thrown a NotFoundException (if is declared, create it). This exception catch in interceptor response 404 found } datastore.update(OperatorEntity.class, Filter.where(\"_id\").is(operatorID), UpdateStatement.update(\"state\").toBe(OperatorState.ACTIVE.name())); }'","output":"public void activate(Object operatorID) { Long count = datastore.entityCount(OperatorEntity.class, Filter.where(\"_id\").is(operatorID)); if (count == 0) { throw new NotFoundException(\"Operator is undefined!\"); } datastore.update(OperatorEntity.class, Filter.where(\"_id\").is(operatorID), UpdateStatement.update(\"state\").toBe(OperatorState.ACTIVE.name())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtils.EMPTY'\nThe code is: 'public Map<ContainerKeyPrefix, Integer> getKeyPrefixesForContainer( long containerId) throws IOException { <START> return getKeyPrefixesForContainer(containerId, \"\"); <END> \/\/ StringUtils.EMPTY }'","output":"public Map<ContainerKeyPrefix, Integer> getKeyPrefixesForContainer( long containerId) throws IOException { return getKeyPrefixesForContainer(containerId, StringUtils.EMPTY); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'PrimitiveType.stringifier() is for API user. This package protected'\nThe code is: '<START> public PrimitiveStringifier valueStringifier(PrimitiveType primitiveType) { <END> \/\/ PrimitiveType.stringifier() is for API user. This package protected throw new UnsupportedOperationException(\"Stringifier is not supported for the logical type: \" + this); }'","output":"PrimitiveStringifier valueStringifier(PrimitiveType primitiveType) { throw new UnsupportedOperationException(\"Stringifier is not supported for the logical type: \" + this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method is designed read $HOME\/.td\/td.conf, is print warning in case of file found'\nThe code is: 'public static Properties readTDConf() { Properties p = new Properties(); File file = new File(System.getProperty(\"user.home\", \".\/\"), String.format(\".td\/td.conf\")); if (!file.exists()) { <START> logger.debug(String.format(\"config file %s is not found\", file)); <END> \/\/ this method is designed read $HOME\/.td\/td.conf, is print warning in case of file found return p; } return readTDConf(file); }'","output":"public static Properties readTDConf() { Properties p = new Properties(); File file = new File(System.getProperty(\"user.home\", \".\/\"), String.format(\".td\/td.conf\")); if (!file.exists()) { logger.warn(String.format(\"config file %s is not found\", file)); return p; } return readTDConf(file); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Missing closing )'\nThe code is: 'private static String buildMessage(InetSocketAddress address, int queueSize) { <START> return String.format(\"[%s] Pool is busy (no available connection and the queue has reached its max size %d\", <END> \/\/ Missing closing ) address.getAddress(), queueSize); }'","output":"private static String buildMessage(InetSocketAddress address, int queueSize) { return String.format(\"[%s] Pool is busy (no available connection and the queue has reached its max size %d)\", address.getAddress(), queueSize); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'class loader of handlerType'\nThe code is: 'public static <T> AnnotatedHandlerInspector<T> inspectType(Class<? extends T> handlerType, ParameterResolverFactory parameterResolverFactory) { return inspectType(handlerType, parameterResolverFactory, <START> new ClasspathHandlerDefinition(Thread.currentThread().getContextClassLoader())); <END> \/\/ class loader of handlerType }'","output":"public static <T> AnnotatedHandlerInspector<T> inspectType(Class<? extends T> handlerType, ParameterResolverFactory parameterResolverFactory) { return inspectType(handlerType, parameterResolverFactory, ClasspathHandlerDefinition.forClass(handlerType)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'private void setupTestsConfiguration() { <START> System.setProperty(TestConfigurationFactory.TEST_CONFIGURATION_URI_KEY, options.getConfigFile()); <END> \/\/ static import System.setProperty(TestConfigurationFactory.LOCAL_TEST_CONFIGURATION_URI_KEY, options.getConfigFileLocal()); }'","output":"private void setupTestsConfiguration() { System.setProperty(TEST_CONFIGURATION_URI_KEY, options.getConfigFile()); System.setProperty(LOCAL_TEST_CONFIGURATION_URI_KEY, options.getConfigFileLocal()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@darkled too, declare Exception thrown, suggested [here](<LINK_0>'\nThe code is: '<START> public void changesVisibility() throws IOException { <END> \/\/ @darkled too, declare Exception thrown, suggested [here](<LINK_0> final AwsAttributes attr = new AwsAttributes(); attr.show(true); MatcherAssert.assertThat(attr.visible(), Matchers.equalTo(true)); attr.show(false); MatcherAssert.assertThat(attr.visible(), Matchers.equalTo(false)); }'","output":"public void changesVisibility() throws Exception { final AwsAttributes attr = new AwsAttributes(); attr.show(true); MatcherAssert.assertThat(attr.visible(), Matchers.equalTo(true)); attr.show(false); MatcherAssert.assertThat(attr.visible(), Matchers.equalTo(false)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'comfortable throwing IllegalArgumentException for this, lets Utils.validateArg'\nThe code is: 'static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, \"Input matrix cannot be null.\"); Utils.nonNull(targetFactors, \"Target factors cannot be null.\"); <START> if (targetFactors.length != input.getRowDimension()) { <END> \/\/ comfortable throwing IllegalArgumentException for this, lets Utils.validateArg throw new GATKException(\"Number of target factors does not correspond to the number of rows.\"); } input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final int row, final int column, final double value) { return value \/ targetFactors[row]; } }); }'","output":"static void factorNormalize(final RealMatrix input, final double[] targetFactors) { Utils.nonNull(input, \"Input matrix cannot be null.\"); Utils.nonNull(targetFactors, \"Target factors cannot be null.\"); Utils.validateArg(targetFactors.length == input.getRowDimension(), \"Number of target factors does not correspond to the number of rows.\"); input.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(final int row, final int column, final double value) { return value \/ targetFactors[row]; } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This try-catch moved @Test annotation well'\nThe code is: 'public void testParseIntGarbage() throws EvaluationException { <START> try { <END> \/\/ This try-catch moved @Test annotation well PARSE_INTEGER.evaluate(s(\"garbage\")); } catch (EvaluationException e){ assertThat(\"parse_Integer(\\\"garbage\\\") throws\", true, instanceOf(Boolean.class)); } }'","output":"public void testParseIntGarbage() throws EvaluationException { PARSE_INTEGER.evaluate(s(\"garbage\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this package private'\nThe code is: '<START> public CannedAccessControlList getCannedACL() <END> \/\/ this package private { return cannedACL; }'","output":"CannedAccessControlList getCannedACL() { return cannedACL; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> protected byte[][] randomData(String prefix, int count) { <END> \/\/ public byte[][] result = new byte[count][]; for (int i = 0; i < count; ++i) { result[i] = Bytes.toBytes(prefix + RandomStringUtils.randomAlphanumeric(8)); } return result; }'","output":"public byte[][] randomData(String prefix, int count) { byte[][] result = new byte[count][]; for (int i = 0; i < count; ++i) { result[i] = Bytes.toBytes(prefix + RandomStringUtils.randomAlphanumeric(8)); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'closeQuietly again'\nThe code is: 'public static void close(Closeable c) { try { <START> if(c != null) { <END> \/\/ closeQuietly again c.close(); } } catch (Exception e) { } }'","output":"public static void close(Closeable c) { IOUtils.closeQuietly(c); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This \"principalDecoder\", I guess'\nThe code is: 'public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { <START> Assert.checkNotNullParam(\"roleMapper\", roleMapper); <END> \/\/ This \"principalDecoder\", I guess assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }'","output":"public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { Assert.checkNotNullParam(\"principalDecoder\", principalDecoder); assertNotBuilt(); this.principalDecoder = principalDecoder; return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I sanitize this class. This unexpected twist for other callers of this class JSP'\nThe code is: 'public String getName() { <START> return SanitizationHelper.sanitizeForHtml(name); <END> \/\/ I sanitize this class. This unexpected twist for other callers of this class JSP }'","output":"public String getName() { return name; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'point? method is false for DefaultDebugExecutor.EXECUTOR_ID changes'\nThe code is: 'public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) { <START> if(DefaultDebugExecutor.EXECUTOR_ID.equals(executorId)) { <END> \/\/ point? method is false for DefaultDebugExecutor.EXECUTOR_ID changes return false; } return DefaultRunExecutor.EXECUTOR_ID.equals(executorId) && profile instanceof GoRunConfigurationBase; }'","output":"public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) { return DefaultRunExecutor.EXECUTOR_ID.equals(executorId) && profile instanceof GoRunConfigurationBase; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'e.printStackTrace(); prints stdout, for production code. LOG.error(\"Failed open {}: \", path, e) stack trace printed. claiming private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class); in beginning'\nThe code is: 'public int openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { <START> e.printStackTrace(); <END> \/\/ e.printStackTrace(); prints stdout, for production code. LOG.error(\"Failed open {}: \", path, e) stack trace printed. claiming private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class); in beginning return -ErrorCodes.EIO(); } }'","output":"public int openCallback(String path, ByteBuffer buf) { try { return open(path, FuseFileInfo.wrap(buf)); } catch (Exception e) { LOG.error(\"Failed to open {}: \", path, e); return -ErrorCodes.EIO(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return this.count < this.values.count();'\nThe code is: '<START> public boolean hasNext() { <END> \/\/ return this.count < this.values.count(); if (this.count < this.values.count()) { return true; } return false; }'","output":"public boolean hasNext() { return this.count < this.values.count(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Expr.ARG_JOINER'\nThe code is: 'public String stringify() { return StringUtils.format( \"%s(%s)\", name, <START> Joiner.on(\", \").join(args.stream().map(Expr::stringify).iterator()) <END> \/\/ nit: Expr.ARG_JOINER ); }'","output":"public String stringify() { return StringUtils.format( \"%s(%s)\", name, Expr.ARG_JOINER.join(args.stream().map(Expr::stringify).iterator()) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Querying\"'\nThe code is: 'private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { <START> logger.debug(\"Quering projector '{}' state\", deviceId); <END> \/\/ \"Querying\" OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }'","output":"private void updateProjecterState(String deviceId) { long age = System.currentTimeMillis() - lastProjectorStateUpdateTime; boolean needsUpdate = age >= projectorStateUpdateInterval; if (needsUpdate) { logger.debug(\"Querying projector '{}' state\", deviceId); OnOffType newState = (OnOffType) queryDataFromDevice(deviceId, EpsonProjectorCommandType.POWER, SwitchItem.class); updateProjecterStateVariable(newState); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'pretty call withContext needs pass this constant, I helpful if defined in storage.common withTracingContext automatically add this. Otherwise, I Storage folks liable forget mess tracing :)'\nThe code is: 'public Mono<Response<AppendBlobItem>> createWithResponse(BlobHttpHeaders headers, Map<String, String> metadata, BlobRequestConditions requestConditions) { try { return withContext(context -> createWithResponse(headers, metadata, requestConditions, context), <START> STORAGE_TRACING_PROPERTIES); <END> \/\/ pretty call withContext needs pass this constant, I helpful if defined in storage.common withTracingContext automatically add this. Otherwise, I Storage folks liable forget mess tracing :) } catch (RuntimeException ex) { return monoError(logger, ex); } }'","output":"public Mono<Response<AppendBlobItem>> createWithResponse(BlobHttpHeaders headers, Map<String, String> metadata, BlobRequestConditions requestConditions) { try { return withContext(context -> createWithResponse(headers, metadata, requestConditions, context)); } catch (RuntimeException ex) { return monoError(logger, ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catch IOException in index(...)'\nThe code is: 'public Edge addEdge(AddEdgeQuery uniQuery) { UniEdge edge = new UniEdge(uniQuery.getProperties(), uniQuery.getOutVertex(), uniQuery.getInVertex(), graph); try { index(this.edgeSchemas, edge, true); } catch (DocumentAlreadyExistsException ex) { throw Graph.Exceptions.edgeWithIdAlreadyExists(edge.id()); <START> } catch (IOException e) { <END> \/\/ catch IOException in index(...) } return edge; }'","output":"public Edge addEdge(AddEdgeQuery uniQuery) { UniEdge edge = new UniEdge(uniQuery.getProperties(), uniQuery.getOutVertex(), uniQuery.getInVertex(), graph); try { index(this.edgeSchemas, edge, true); } catch (DocumentAlreadyExistsException ex) { throw Graph.Exceptions.edgeWithIdAlreadyExists(edge.id()); } return edge; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Captain-P-Goldfish please define this error message a constant in ResponseCodeConstants class'\nThe code is: 'public BadRequestException() { <START> this(\"invalid request\"); <END> \/\/ @Captain-P-Goldfish please define this error message a constant in ResponseCodeConstants class }'","output":"public BadRequestException() { this(ResponseCodeConstants.INVALID_REQUEST); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'done in line ?'\nThe code is: 'private MutableMetric lookupMetric(String name) { <START> MutableMetric metric = getRegistry().get(name); <END> \/\/ done in line ? return metric; }'","output":"private MutableMetric lookupMetric(String name) { return getRegistry().get(name); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'instead Injector here, pls @Inject annotation, intend GlusterStorageDomainDRSyncJob, declare @Inject Injector.get(GlusterStorageDomainDRSyncJob.class);'\nThe code is: 'public GlusterStorageDomainDRSyncJob() { super(); <START> backend = Injector.get(BackendInternal.class); storageDomainDao = Injector.get(StorageDomainDao.class); geoRepDao = Injector.get(GlusterGeoRepDao.class); <END> \/\/ instead Injector here, pls @Inject annotation, intend GlusterStorageDomainDRSyncJob, declare @Inject Injector.get(GlusterStorageDomainDRSyncJob.class); }'","output":"public GlusterStorageDomainDRSyncJob() { super(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a good methods a higher wider access modifier need to. track here, try [adhere practise](<LINK_0> noted in POLICIES. This (and a more) changed public package-private'\nThe code is: '<START> public Rational add(Rational that) { <END> \/\/ a good methods a higher wider access modifier need to. track here, try [adhere practise](<LINK_0> noted in POLICIES. This (and a more) changed public package-private final int commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }'","output":"Rational add(Rational that) { final int commonDenominator = this.denominator * that.denominator; return new Rational( this.numerator * that.denominator + that.numerator * this.denominator, commonDenominator); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please call super(statusCode); for 3 below'\nThe code is: 'public LockException(int statusCode) { this.statusCode = statusCode; <START> } <END> \/\/ Please call super(statusCode); for 3 below'","output":"public LockException(int statusCode) { super(statusCode); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this: return absoluteUris(PORTS, vxLanPortIds);'\nThe code is: 'public List<URI> getVxLanPorts() { <START> if (vxLanPortIds == null) { return null; } List<URI> uris = new ArrayList<>(vxLanPortIds.size()); for (UUID id : vxLanPortIds) { uris.add(absoluteUri(PORTS, id)); } return uris; <END> \/\/ this: return absoluteUris(PORTS, vxLanPortIds); }'","output":"public List<URI> getVxLanPorts() { return absoluteUris(PORTS, vxLanPortIds); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Objects.requireNonNull(buf)'\nThe code is: 'public SeekableByteArrayInputStream(byte[] buf) { <START> this.buffer = buf; <END> \/\/ Objects.requireNonNull(buf) this.cur = 0; this.max = buf.length; }'","output":"public SeekableByteArrayInputStream(byte[] buf) { Preconditions.checkNotNull(buf, \"bug argument was null\"); this.buffer = buf; this.cur = 0; this.max = buf.length; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'additional loadTypeNameToCategoryMap needed'\nThe code is: 'public Optional<IPageTypeCategoryRole> getTypeCategoryForCatName(String categoryName) { <START> loadTypeNameToCategoryMap(); <END> \/\/ additional loadTypeNameToCategoryMap needed return Optional.fromNullable(getTypeNameToCategoryMapIncludeDeprecated().get(categoryName)); }'","output":"public Optional<IPageTypeCategoryRole> getTypeCategoryForCatName(String categoryName) { return Optional.fromNullable(getTypeNameToCategoryMapIncludeDeprecated().get(categoryName)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'event1 -> event3'\nThe code is: 'public void testNonMatchingStream() throws Exception { RuleProcessorRuntime rpr = new RuleProcessorRuntime(mockBuilder); rpr.process(event3); new Verifications() {{ <START> mockRr1.evaluate(event1); <END> \/\/ event1 -> event3 times=0; mockRr2.evaluate(event1); times=0; }}; }'","output":"public void testNonMatchingStream() throws Exception { RuleProcessorRuntime rpr = new RuleProcessorRuntime(mockBuilder); rpr.process(event3); new Verifications() {{ mockRr1.evaluate(event3); times=0; mockRr2.evaluate(event3); times=0; }}; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'super() call is implicit. harm, needed'\nThe code is: 'public DRepresentationNotificationFilter(DRepresentation dRepresentation) { <START> super(); <END> \/\/ super() call is implicit. harm, needed this.dRepresentation = dRepresentation; }'","output":"public DRepresentationNotificationFilter(DRepresentation dRepresentation) { this.dRepresentation = dRepresentation; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a bad idea checking for exception messages in place'\nThe code is: 'public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(\"should have thrown!\"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains(\"Connection refused\")); <END> \/\/ a bad idea checking for exception messages in place } }'","output":"public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail(\"should have thrown!\"); } catch (IOException e) { } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename fragment'\nThe code is: 'public IProject[] getProjects() { Set<IProject> result= new HashSet<>(); for (IPackageFragment <START> fFragment : <END> \/\/ rename fragment fFragments) { result.add(fFragment.getJavaProject().getProject()); } return result.toArray(new IProject[result.size()]); }'","output":"public IProject[] getProjects() { Set<IProject> result= new HashSet<>(); for (IPackageFragment fragment : fFragments) { result.add(fragment.getJavaProject().getProject()); } return result.toArray(new IProject[result.size()]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This public..'\nThe code is: '<START> public void setParent(IForestryCommand parent) { <END> \/\/ This public.. this.parent = parent; }'","output":"void setParent(IForestryCommand parent) { this.parent = parent; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this (ServerConnectionDetectedEvent) post required? This basically repeats lines finally calls finishServerConnectionDetection(). call finishServerConnectionDetection() method instead of this'\nThe code is: 'public void connectRemote() { this.serverConnection = ApiConnection.REMOTE; if (!isServerRouteLoaded()) { return; } this.serverAddress = serverRoute.getRemoteAddress(); this.serverApi = buildServerApi(); <START> BusProvider.getBus().post(new ServerConnectionDetectedEvent(serverRoute.getRemoteAddress())); <END> \/\/ Is this (ServerConnectionDetectedEvent) post required? This basically repeats lines finally calls finishServerConnectionDetection(). call finishServerConnectionDetection() method instead of this }'","output":"public void connectRemote() { this.serverConnection = ApiConnection.REMOTE; if (!isServerRouteLoaded()) { return; } this.serverAddress = serverRoute.getRemoteAddress(); this.serverApi = buildServerApi(); finishServerConnectionDetection(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ReviewFragmentStrategy is a strategy for ReviewFragment is a strategy for ReviewScreenAdapter, rename ReviewScreenAdapterStrategy'\nThe code is: 'public View getView(final int position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); <START> ReviewFragmentStrategy reviewFragmentStrategy = <END> \/\/ ReviewFragmentStrategy is a strategy for ReviewFragment is a strategy for ReviewScreenAdapter, rename ReviewScreenAdapterStrategy new ReviewFragmentStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }'","output":"public View getView(final int position, View convertView, ViewGroup parent) { Value value = (Value) getItem(position); TableRow rowView = (TableRow) this.lInflater.inflate(getRecordLayout(), parent, false); ReviewScreenAdapterStrategy reviewFragmentStrategy = new ReviewScreenAdapterStrategy(new ReviewScreenAdapter.onClickListener() { @Override public void onClickOnValue(String UId) { onClickListener.onClickOnValue(UId); } }); return reviewFragmentStrategy.createViewRow(rowView, value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assigned'\nThe code is: 'public List<String> getTags() { if (tags == null) { <START> return new ArrayList<>(); <END> \/\/ assigned } return tags; }'","output":"public List<String> getTags() { if (tags == null) { tags = new ArrayList<>(); } return tags; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add this stay consistent other getters here'\nThe code is: 'public long getStartTimestamp() { <START> return startTimestamp; <END> \/\/ Add this stay consistent other getters here }'","output":"public long getStartTimestamp() { return this.startTimestamp; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catch a generic exception here, reason for failure duplicate key. I change this error message I add exception well. like: java logger.info(\"Failed save pushMessageInformation: {}\", e.getMessage()); logger.debug(\"Details:\", e);'\nThe code is: 'public void appendError(final FlatPushMessageInformation pushMessageInformation, final Variant variant, final String errorMessage) { final VariantErrorStatus ves = new VariantErrorStatus(pushMessageInformation, variant, errorMessage); pushMessageInformation.getErrors().add(ves); try { flatPushMessageInformationDao.update(pushMessageInformation); } catch (Exception e) { <START> logger.info(\"A VariantErrorStatus has been already added, for the given Variant in this push job\"); <END> \/\/ catch a generic exception here, reason for failure duplicate key. I change this error message I add exception well. like: java logger.info(\"Failed save pushMessageInformation: {}\", e.getMessage()); logger.debug(\"Details:\", e); } }'","output":"public void appendError(final FlatPushMessageInformation pushMessageInformation, final Variant variant, final String errorMessage) { final VariantErrorStatus ves = new VariantErrorStatus(pushMessageInformation, variant, errorMessage); pushMessageInformation.getErrors().add(ves); try { flatPushMessageInformationDao.update(pushMessageInformation); } catch (Exception e) { logger.info(\"Failed to save pushMessageInformation: {}\", e.getMessage()); logger.debug(\"Details:\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@fanifieiev above'\nThe code is: 'public RsWithHeaders(final Response res, final Iterable<? extends CharSequence> headers) { super( <START> new RsOf( <END> \/\/ @fanifieiev above () -> RsWithHeaders.extend(res, headers), res::body ) ); }'","output":"public RsWithHeaders(final Response res, final Iterable<? extends CharSequence> headers) { super( new ResponseOf( () -> RsWithHeaders.extend(res, headers), res::body ) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line is redundant, request passed in newTokenClient(tokenRequest);'\nThe code is: 'private TokenResponse processTokens(String clientId, String clientSecret, String deviceCode) { TokenRequest tokenRequest = new TokenRequest(GrantType.DEVICE_CODE); tokenRequest.setAuthUsername(clientId); tokenRequest.setAuthPassword(clientSecret);; tokenRequest.setAuthenticationMethod(AuthenticationMethod.CLIENT_SECRET_BASIC); tokenRequest.setDeviceCode(deviceCode); TokenClient tokenClient1 = newTokenClient(tokenRequest); <START> tokenClient1.setRequest(tokenRequest); <END> \/\/ This line is redundant, request passed in newTokenClient(tokenRequest); TokenResponse tokenResponse1 = tokenClient1.exec(); showClient(tokenClient1); return tokenResponse1; }'","output":"private TokenResponse processTokens(String clientId, String clientSecret, String deviceCode) { TokenRequest tokenRequest = new TokenRequest(GrantType.DEVICE_CODE); tokenRequest.setAuthUsername(clientId); tokenRequest.setAuthPassword(clientSecret);; tokenRequest.setAuthenticationMethod(AuthenticationMethod.CLIENT_SECRET_BASIC); tokenRequest.setDeviceCode(deviceCode); TokenClient tokenClient1 = newTokenClient(tokenRequest); TokenResponse tokenResponse1 = tokenClient1.exec(); showClient(tokenClient1); return tokenResponse1; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '#701 asked for this lock removed, if I reading correctly'\nThe code is: 'public void getHTable(String table) throws IOException { final TableName tName = TableName.valueOf(table); <START> synchronized (TABLE_LOCK) { <END> \/\/ #701 asked for this lock removed, if I reading correctly this.currentTable = connection.getTable(tName); if (clientSideBuffering) { final BufferedMutatorParams p = new BufferedMutatorParams(tName); p.writeBufferSize(writeBufferSize); this.bufferedMutator = connection.getBufferedMutator(p); } } }'","output":"public void getHTable(String table) throws IOException { final TableName tName = TableName.valueOf(table); this.currentTable = connection.getTable(tName); if (clientSideBuffering) { final BufferedMutatorParams p = new BufferedMutatorParams(tName); p.writeBufferSize(writeBufferSize); this.bufferedMutator = connection.getBufferedMutator(p); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This check error response is Keycloak (<LINK_0> error code\/description app AIA cancelled login'\nThe code is: 'public void cancelUpdateProfile() { doAIA(); loginPage.login(\"test-user@localhost\", \"password\"); updateProfilePage.assertCurrent(); updateProfilePage.cancel(); <START> assertRedirectSuccess(); <END> \/\/ This check error response is Keycloak (<LINK_0> error code\/description app AIA cancelled login appPage.logout(); loginPage.open(); loginPage.assertCurrent(); loginPage.login(\"test-user@localhost\", \"password\"); updateProfilePage.assertCurrent(); }'","output":"public void cancelUpdateProfile() { doAIA(); loginPage.login(\"test-user@localhost\", \"password\"); updateProfilePage.assertCurrent(); updateProfilePage.cancel(); assertRedirectSuccess(); assertCancelMessage(); appPage.logout(); loginPage.open(); loginPage.assertCurrent(); loginPage.login(\"test-user@localhost\", \"password\"); updateProfilePage.assertCurrent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'alternative implementation of method: java return conceptMap.getOrDefault(targetTable, Collections.emptyMap()).get(targetField);'\nThe code is: 'public List<Concept> get(String targetTable, String targetField) { <START> if (!this.containsKey(targetTable, targetField)) { <END> \/\/ alternative implementation of method: java return conceptMap.getOrDefault(targetTable, Collections.emptyMap()).get(targetField); return null; } return this.conceptMap.get(targetTable).get(targetField); }'","output":"public List<Concept> get(String targetTable, String targetField) { return conceptMap.getOrDefault(targetTable, Collections.emptyMap()).get(targetField); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline this'\nThe code is: 'public ConnectorIndex getIndex( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorIndexHandle indexHandle, List<ColumnHandle> lookupSchema, List<ColumnHandle> outputSchema) { <START> ThriftIndexHandle thriftIndexHandle = (ThriftIndexHandle) indexHandle; <END> \/\/ inline this return new ThriftConnectorIndex(clientProvider, thriftIndexHandle, lookupSchema, outputSchema, maxBytesPerResponse, lookupRequestsConcurrency); }'","output":"public ConnectorIndex getIndex( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorIndexHandle indexHandle, List<ColumnHandle> lookupSchema, List<ColumnHandle> outputSchema) { return new ThriftConnectorIndex(clientProvider, (ThriftIndexHandle) indexHandle, lookupSchema, outputSchema, maxBytesPerResponse, lookupRequestsConcurrency); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove consumedDataType is used'\nThe code is: 'public void applyWritableMetadata(List<String> metadataKeys, DataType consumedDataType) { <START> this.consumedDataType = consumedDataType; <END> \/\/ remove consumedDataType is used this.metadataKeys = metadataKeys; }'","output":"public void applyWritableMetadata(List<String> metadataKeys, DataType consumedDataType) { this.metadataKeys = metadataKeys; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'readAsString(...) instead'\nThe code is: 'public void testGitHubBug207() throws Exception { String c = IOUtils.toString(this.getClass().getResourceAsStream(\"GitHubBug207.java\"), <START> StandardCharsets.UTF_8); <END> \/\/ readAsString(...) instead parseJava18(c); }'","output":"public void testGitHubBug207() { String c = readAsString(\"GitHubBug207.java\"); parseJava18(c); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is INFO level necessary changed DEBUG'\nThe code is: 'public void setBandwidth(long bandwidth) { this.bandwidthLimit = bandwidth; <START> LOG.info(\"Bandwidth limit is set to: \" + bandwidth + \" bytes\/sec\"); <END> \/\/ Is INFO level necessary changed DEBUG }'","output":"public void setBandwidth(long bandwidth) { this.bandwidthLimit = bandwidth; LOG.debug(\"Bandwidth limit is set to: \" + bandwidth + \" bytes\/sec\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (m.find()) { ... }'\nThe code is: 'private static String getPattern (String regex, String hgvs) { Pattern p = Pattern.compile(regex); Matcher m = p.matcher(hgvs); <START> if (m.find()) <END> \/\/ suggestion if (m.find()) { ... } return hgvs.substring(m.start(), m.end()); return null; }'","output":"private static String getPattern(String regex, String hgvs) { Pattern p = Pattern.compile(regex); Matcher m = p.matcher(hgvs); if (m.find()) { return hgvs.substring(m.start(), m.end()); } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add \"this\" qualifier'\nThe code is: 'public List<LogicalNode> getLogicalNodes() { <START> return logicalNodes; <END> \/\/ add \"this\" qualifier }'","output":"public List<LogicalNode> getLogicalNodes() { return this.logicalNodes; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'correct default implementation for getFilters return empty map. Throwing unsupported exception better. Is reason this change instead of add getFilters implementation TRUE instance'\nThe code is: 'default Map<Integer, Filter> getFilters() { <START> return ImmutableMap.of(); <END> \/\/ correct default implementation for getFilters return empty map. Throwing unsupported exception better. Is reason this change instead of add getFilters implementation TRUE instance }'","output":"default Map<Integer, Filter> getFilters() { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Hmm, switch listenerList a set'\nThe code is: 'public void addComponentChangeListener(ComponentChangeListener l) { checkState(); <START> if( ! listenerList.contains(l)) { <END> \/\/ Hmm, switch listenerList a set listenerList.add(l); } log.trace(\"Added ComponentChangeListener \" + l + \", current number of listeners is \" + listenerList.size()); }'","output":"public void addComponentChangeListener(ComponentChangeListener l) { checkState(); listenerList.add(l); log.trace(\"Added ComponentChangeListener \" + l + \", current number of listeners is \" + listenerList.size()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this return true, disks storage domain (Remember check validate method checkDisksInBackupStorage) Change assertTrue'\nThe code is: 'public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertFalse(\"checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain\", <END> \/\/ this return true, disks storage domain (Remember check validate method checkDisksInBackupStorage) Change assertTrue command.checkDisksInBackupStorage()); }'","output":"public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); assertTrue(\"checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain\", command.checkDisksInBackupStorage()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instead of instance here, passed in in event want mock it'\nThe code is: 'public Client( final String packageName, final ImmutableList<Command> commands) { this.packageName = packageName; this.commands = commands; helper = Helper.getInstance(); <START> javaHelper = JavaHelper.getInstance(); <END> \/\/ Instead of instance here, passed in in event want mock it }'","output":"public Client( final String packageName, final ImmutableList<Command> commands) { this.packageName = packageName; this.commands = commands; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"typeName\", type.getInternalName());'\nThe code is: 'public void writeToXml(PrintWriter pw1, int indent) { writeToXmlBegin(pw1, indent); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"equipmentNum\", equipmentNum); <START> MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"typeName\", MekHqXmlUtil.escape(type.getInternalName())); <END> \/\/ suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"typeName\", type.getInternalName()); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"size\", size); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"equipTonnage\", equipTonnage); writeToXmlEnd(pw1, indent); }'","output":"public void writeToXml(PrintWriter pw1, int indent) { writeToXmlBegin(pw1, indent); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"equipmentNum\", equipmentNum); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"typeName\", type.getInternalName()); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"size\", size); MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"equipTonnage\", equipTonnage); writeToXmlEnd(pw1, indent); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '!part.isLocal() instead of part.isLocal()'\nThe code is: 'public boolean isLocal() { for(EnvironmentConfig part : this) { <START> if(part.isLocal()) <END> \/\/ !part.isLocal() instead of part.isLocal() return false; } return true; }'","output":"public boolean isLocal() { for(EnvironmentConfig part : this) { if(!part.isLocal()) return false; } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public @Nullable Iterable... EMPTY_SET is null though, supresswarning instead'\nThe code is: '<START> public Iterable<TmfXmlLocation> getLocations() { <END> \/\/ public @Nullable Iterable... EMPTY_SET is null though, supresswarning instead return Collections.EMPTY_SET; }'","output":"public @Nullable Iterable<TmfXmlLocation> getLocations() { return Collections.EMPTY_SET; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove status variable calling \"return addEndpoint(endpointData);\"'\nThe code is: 'public boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); boolean status = addEndpoint(endpointData); <START> return status; <END> \/\/ remove status variable calling \"return addEndpoint(endpointData);\" } finally { PrivilegedCarbonContext.endTenantFlow(); } }'","output":"public boolean addEndpointForTenant(String endpointData, String tenantDomain) throws EndpointAdminException { try { PrivilegedCarbonContext.startTenantFlow(); PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); return addEndpoint(endpointData); } finally { PrivilegedCarbonContext.endTenantFlow(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'filters method argument passed isMessageInLogFile argument'\nThe code is: '<START> public static boolean hasLogMessage(String logFileName, String logMessage, Predicate<String>... filters) throws Exception { <END> \/\/ filters method argument passed isMessageInLogFile argument Path logPath = LoggingUtil.getInServerLogPath(logFileName); return isMessageInLogFile(logPath, logMessage); }'","output":"public static boolean hasLogMessage(String logFileName, String logMessage, Predicate<String>... filters) throws Exception { Path logPath = LoggingUtil.getInServerLogPath(logFileName); return isMessageInLogFile(logPath, logMessage, filters); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method private other class new HL7Parser201305Utils()'\nThe code is: '<START> HL7Parser201305Utils() { <END> \/\/ this method private other class new HL7Parser201305Utils() }'","output":"private HL7Parser201305Utils() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this ctor package-visible introduce another one, visible everybody, Target argument'\nThe code is: '<START> public TkLogged(final Take take, final Target trget) { <END> \/\/ I this ctor package-visible introduce another one, visible everybody, Target argument this.target = trget; this.origin = take; }'","output":"TkLogged(final Take take, final Target trget) { this.target = trget; this.origin = take; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'removed this HibernateUtil.closeSession(); too'\nThe code is: 'public void execute(JobDelegateDataBean data) { try { executeDelegate(data); } catch (Exception e) { Logger.error(this, \"An error occurred when running the Job Delegate: \" + this.getClass(), e); } finally { try { <START> HibernateUtil.closeSession(); <END> \/\/ removed this HibernateUtil.closeSession(); too } catch (DotHibernateException e) { Logger.warn(this, e.getMessage(), e); } } }'","output":"public void execute(JobDelegateDataBean data) { try { executeDelegate(data); } catch (Exception e) { Logger.error(this, \"An error occurred when running the Job Delegate: \" + this.getClass(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please assertNull instead'\nThe code is: 'public void testAdd() { MockEnabledModelResolver resolver = new MockEnabledModelResolver(); ModelResolverDescriptor oldValue = manager.add(resolver, resolver.getClass().getName(), \"\", \"\"); assertSame(manager.getAllResolver().iterator().next().getModelResolver(), resolver); <START> assertEquals(oldValue, null); <END> \/\/ Please assertNull instead }'","output":"public void testAdd() { MockEnabledModelResolver resolver = new MockEnabledModelResolver(); ModelResolverDescriptor oldValue = manager.add(resolver, resolver.getClass().getName(), \"\", \"\"); assertSame(manager.getAllResolver().iterator().next().getModelResolver(), resolver); assertNull(oldValue); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above, please fix code alignment'\nThe code is: 'public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\") <START> Throwable cause = getRootCause(e); <END> \/\/ above, please fix code alignment assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }'","output":"public void propagate_RuntimeException_when_handler_throws() { ModelTests.clearModel(); FaultyAggregate faultyAggregate = new FaultyAggregate(ID, true, false); Command command = Given.ACommand.createProject(); try { dispatchCommand(faultyAggregate, env(command.getMessage())); failNotThrows(); } catch (RuntimeException e) { Throwable cause = getRootCause(e); assertTrue(cause instanceof IllegalStateException); assertEquals(FaultyAggregate.BROKEN_HANDLER, cause.getMessage()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'requireNonNull(parentMemoryContext, \"parentMemoryContext is null\")'\nThe code is: 'public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { <START> this.parentMemoryContext = requireNonNull(parentMemoryContext); <END> \/\/ requireNonNull(parentMemoryContext, \"parentMemoryContext is null\") }'","output":"public SimpleLocalMemoryContext(AggregatedMemoryContext parentMemoryContext) { this.parentMemoryContext = requireNonNull(parentMemoryContext, \"parentMemoryContext is null\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Nit: else is redundant'\nThe code is: 'private static Comparable<?> encodeDecimal(Type type, BigDecimal value) { BigInteger unscaled = Decimals.rescale(value, (DecimalType) type).unscaledValue(); if (Decimals.isShortDecimal(type)) { return unscaled.longValueExact(); } <START> else { <END> \/\/ Nit: else is redundant return Decimals.encodeUnscaledValue(unscaled); } }'","output":"private static Comparable<?> encodeDecimal(Type type, BigDecimal value) { BigInteger unscaled = Decimals.rescale(value, (DecimalType) type).unscaledValue(); if (Decimals.isShortDecimal(type)) { return unscaled.longValueExact(); } return Decimals.encodeUnscaledValue(unscaled); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fine remove this check test'\nThe code is: 'public TimestampRange incrementBy(long delta) { if (delta <= 0) { <START> throw new IllegalArgumentException(\"Timestamp must be increased by a positive number. Found \" + delta); <END> \/\/ fine remove this check test } long upperBound = value.addAndGet(delta); long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }'","output":"public TimestampRange incrementBy(long delta) { long upperBound = value.addAndGet(delta); long lowerBound = upperBound - delta + 1L; return TimestampRange.createInclusiveRange(lowerBound, upperBound); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Links -> Link'\nThe code is: 'public void allTests() throws Exception { testPersistenceCheck(); testLogin(); testContent(); testAjaxCourseTableLoad(); testShowFeedbackStatsLink(); testHelpLink(); testCourseLinks(); testSearchAction(); testSortAction(); testRemindActions(); <START> testPublishUnpublishResendLinksActions(); <END> \/\/ Links -> Link testArchiveCourseAction(); testCopyToFsAction(); testDeleteCourseAction(); }'","output":"public void allTests() throws Exception { testPersistenceCheck(); testLogin(); testContent(); testAjaxCourseTableLoad(); testShowFeedbackStatsLink(); testHelpLink(); testCourseLinks(); testSearchAction(); testSortAction(); testRemindActions(); testPublishUnpublishResendLinkActions(); testArchiveCourseAction(); testCopyToFsAction(); testDeleteCourseAction(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'blocking calls SDK good. deadlock, perf hit, etc. blocking calls else'\nThe code is: 'public ReplicationPolicy getSystemReplicationPolicy() { <START> DatabaseAccount databaseAccount = this.globalEndpointManager.getDatabaseAccountFromCache(this.serviceEndpoint).block(); <END> \/\/ blocking calls SDK good. deadlock, perf hit, etc. blocking calls else return BridgeInternal.getSystemReplicationPolicy(databaseAccount); }'","output":"public Mono<ReplicationPolicy> getSystemReplicationPolicy() { return this.globalEndpointManager.getDatabaseAccountFromCache(this.serviceEndpoint).map(databaseAccount -> BridgeInternal.getSystemReplicationPolicy(databaseAccount)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@deprecated a DataBoundSetter suggested @KostyaSha'\nThe code is: 'public Maven(String targets,String name, String pom, String properties, String jvmOptions, boolean usePrivateRepository, SettingsProvider settings, GlobalSettingsProvider globalSettings) { <START> this(targets, name, pom, properties, jvmOptions, usePrivateRepository, settings, globalSettings, true); <END> \/\/ @deprecated a DataBoundSetter suggested @KostyaSha }'","output":"public Maven(String targets,String name, String pom, String properties, String jvmOptions, boolean usePrivateRepository, SettingsProvider settings, GlobalSettingsProvider globalSettings) { this(targets, name, pom, properties, jvmOptions, usePrivateRepository, settings, globalSettings, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Variable organizationEntity'\nThe code is: 'public OrganizationEntity create(SchoolDataSource dataSource, String identifier, String name) { <START> OrganizationEntity roleSchoolDataIdentifier = new OrganizationEntity(); <END> \/\/ Variable organizationEntity roleSchoolDataIdentifier.setDataSource(dataSource); roleSchoolDataIdentifier.setIdentifier(identifier); roleSchoolDataIdentifier.setName(name); return persist(roleSchoolDataIdentifier); }'","output":"public OrganizationEntity create(SchoolDataSource dataSource, String identifier, String name) { OrganizationEntity organizationEntity = new OrganizationEntity(); organizationEntity.setDataSource(dataSource); organizationEntity.setIdentifier(identifier); organizationEntity.setName(name); return persist(organizationEntity); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this true here'\nThe code is: 'private void setSync(double defaultDisplayRefreshRate) { <START> if (useDefaultDisplayVsync) { <END> \/\/ this true here vsyncDurationNs = (long) (C.NANOS_PER_SECOND \/ defaultDisplayRefreshRate); vsyncOffsetNs = (vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) \/ 100; } }'","output":"private void setSync(double defaultDisplayRefreshRate) { vsyncDurationNs = (long) (C.NANOS_PER_SECOND \/ defaultDisplayRefreshRate); vsyncOffsetNs = (vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) \/ 100; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is specific this PR in general, consider Throwables.propagate() instead'\nThe code is: 'public String toString(T pojo) { try { ObjectMapper mapper = new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); ObjectWriter writer = mapper.writer(); return writer.writeValueAsString(pojo); } catch (IOException e) { <START> DTThrowable.wrapIfChecked(e); <END> \/\/ This is specific this PR in general, consider Throwables.propagate() instead } return null; }'","output":"public String toString(T pojo) { try { ObjectMapper mapper = new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); ObjectWriter writer = mapper.writer(); return writer.writeValueAsString(pojo); } catch (IOException e) { throw Throwables.propagate(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount);'\nThe code is: 'public void startupShouldNotFailOnRuntimeExceptionOnlineListener() { <START> Assert.assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount); <END> \/\/ suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount); }'","output":"public void startupShouldNotFailOnRuntimeExceptionOnlineListener() { assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Suggest check artifact != null'\nThe code is: '<START> protected Collection<Artifact> setRelationsOfType(AtsArtifactConfigCache cache, Artifact artifact, Collection<? extends IAtsObject> atsObjects, IRelationTypeSide side) throws OseeCoreException { <END> \/\/ Suggest check artifact != null List<Artifact> newArts = new ArrayList<Artifact>(); for (IAtsObject version : atsObjects) { Artifact verArt = cache.getSoleArtifact(version); newArts.add(verArt); } artifact.setRelations(side, newArts); return newArts; }'","output":"protected Collection<Artifact> setRelationsOfType(AtsArtifactConfigCache cache, Artifact artifact, Collection<? extends IAtsObject> atsObjects, IRelationTypeSide side) throws OseeCoreException { Conditions.checkNotNull(artifact, \"artifact\"); List<Artifact> newArts = new ArrayList<Artifact>(); for (IAtsObject version : atsObjects) { Artifact verArt = cache.getSoleArtifact(version); newArts.add(verArt); } artifact.setRelations(side, newArts); return newArts; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fix issue suggestion public void setTopics(ArrayList<String> topics) {'\nThe code is: '<START> void setTopics(ArrayList<String> topics) { <END> \/\/ fix issue suggestion public void setTopics(ArrayList<String> topics) { this.topics = topics; }'","output":"public void setTopics(ArrayList<String> topics) { this.topics = topics; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If wrong, method return void, other mockXYZ methods. return is used'\nThe code is: 'private VM mockVm(VMStatus vmStatus) { vm.setStatus(vmStatus); vm.setId(vmId); vm.setRunOnVds(Guid.newGuid()); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); <START> return vm; <END> \/\/ If wrong, method return void, other mockXYZ methods. return is used }'","output":"private void mockVm(VMStatus vmStatus) { vm.setStatus(vmStatus); vm.setId(vmId); vm.setRunOnVds(Guid.newGuid()); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new byte[]{} -> new byte[0]'\nThe code is: 'public DataBucket(String commandId, long count, byte[] data) { <START> this(commandId, count, data, new byte[]{}, new byte[]{}); <END> \/\/ new byte[]{} -> new byte[0] }'","output":"public DataBucket(String commandId, long count, byte[] data) { this(commandId, count, data, new byte[0], new byte[0]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Fix annotation line placement'\nThe code is: '<START> @Override public void setId(String id) { <END> \/\/ Fix annotation line placement this.id = id; }'","output":"public void setId(String id) { this.id = id; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'including fakeThread'\nThe code is: 'public boolean unlockSimple(SimpleHeldLocksToken token) { Preconditions.checkNotNull(token); LockDescriptor fakeLockDesc = StringLockDescriptor.of(\"unlockSimple\"); SortedLockCollection<LockDescriptor> fakeLockSet = LockCollections.of(ImmutableSortedMap.of(fakeLockDesc, LockMode.READ)); return unlock(new HeldLocksToken( token.getTokenId(), LockClient.ANONYMOUS, token.getCreationDateMs(), 0L, fakeLockSet, maxAllowedLockTimeout, 0L, <START> \"fakeThread-unlockSimple\")); <END> \/\/ including fakeThread }'","output":"public boolean unlockSimple(SimpleHeldLocksToken token) { Preconditions.checkNotNull(token); LockDescriptor fakeLockDesc = StringLockDescriptor.of(\"unlockSimple\"); SortedLockCollection<LockDescriptor> fakeLockSet = LockCollections.of(ImmutableSortedMap.of(fakeLockDesc, LockMode.READ)); return unlock(new HeldLocksToken( token.getTokenId(), LockClient.ANONYMOUS, token.getCreationDateMs(), 0L, fakeLockSet, maxAllowedLockTimeout, 0L, \"UnknownThread-unlockSimple\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please revert if'\nThe code is: '<START> public int getSpinnerId() { <END> \/\/ Please revert if return R.id.hide_variable_spinner; }'","output":"protected int getSpinnerId() { return R.id.hide_variable_spinner; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do call repository method, detect if parameter is wrong. assert in service implementation for catching invalid parameters'\nThe code is: 'public void getStatesByApplicationIdShouldThrowIllegalArgumentExceptionWhenApplicationIdIsNull() { <START> given(applicationsRepository.findOne(null)).willThrow(IllegalArgumentException.class); <END> \/\/ Do call repository method, detect if parameter is wrong. assert in service implementation for catching invalid parameters statesService.getStatesByApplicationId(null); }'","output":"public void getStatesByApplicationIdShouldThrowIllegalArgumentExceptionWhenApplicationIdIsNull() { statesService.getStatesByApplicationId(null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return Objects.hashCode(spec, name, config); auto-generated, I accept verbose version, soon modifying code put in easier-to-read-and-maintain approach'\nThe code is: 'public int hashCode() { <START> int result = spec != null ? spec.hashCode() : 0; <END> \/\/ return Objects.hashCode(spec, name, config); auto-generated, I accept verbose version, soon modifying code put in easier-to-read-and-maintain approach result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (config != null ? config.hashCode() : 0); return result; }'","output":"public int hashCode() { return Objects.hashCode(spec, name, config); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'overridable getOperationTimeout() method instead'\nThe code is: 'protected final Cluster getUpcomingCluster(String host, int port) throws Exception { try (DiagnosticService diagnosticService = DiagnosticServiceFactory.fetch( InetSocketAddress.createUnresolved(host, port), getClass().getSimpleName(), OP_TIMEOUT, <START> OP_TIMEOUT, <END> \/\/ overridable getOperationTimeout() method instead null)) { return diagnosticService.getProxy(TopologyService.class).getUpcomingNodeContext().getCluster(); } }'","output":"protected final Cluster getUpcomingCluster(String host, int port) throws Exception { try (DiagnosticService diagnosticService = DiagnosticServiceFactory.fetch( InetSocketAddress.createUnresolved(host, port), getClass().getSimpleName(), getConnectionTimeout(), getConnectionTimeout(), null)) { return diagnosticService.getProxy(TopologyService.class).getUpcomingNodeContext().getCluster(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'apiDefiinition - I this converted a stand-alone method, please correct variable name'\nThe code is: 'private List<GLJournalEntry> executePostGLJournalEntries(ParamsMap params) throws MambuApiException { <START> ApiDefinition apiDefiinition = new ApiDefinition(APIData.GLJOURNALENTRIES, ContentType.WWW_FORM, Method.POST, <END> \/\/ apiDefiinition - I this converted a stand-alone method, please correct variable name GLJournalEntry.class, ApiReturnFormat.COLLECTION); List<GLJournalEntry> glEntries = serviceExecutor.execute(apiDefiinition, params); return glEntries; }'","output":"private List<GLJournalEntry> executePostGLJournalEntries(ParamsMap params) throws MambuApiException { ApiDefinition apiDefinition = new ApiDefinition(APIData.GLJOURNALENTRIES, ContentType.WWW_FORM, Method.POST, GLJournalEntry.class, ApiReturnFormat.COLLECTION); List<GLJournalEntry> glEntries = serviceExecutor.execute(apiDefinition, params); return glEntries; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'print time? command > server valid'\nThe code is: 'public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> if (help) { <END> \/\/ print time? command > server valid commandInvocation.println(commandInvocation.getHelpInfo()); } return CommandResult.SUCCESS; }'","output":"public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { commandInvocation.println(commandInvocation.getHelpInfo()); return CommandResult.SUCCESS; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove'\nThe code is: 'private BiConsumer<Throwable, Object> completeWithErrorPropagate() { return (error, event) -> { final PrivilegedEvent errorEvent = (PrivilegedEvent) ((MessagingException) error).getEvent(); <START> System.out.println(\"propagating error... \" + errorEvent.getContext().getDepthLevel()); <END> \/\/ Remove errorEvent.getContext().error(error); }; }'","output":"private BiConsumer<Throwable, Object> completeWithErrorPropagate() { return (error, event) -> { final PrivilegedEvent errorEvent = (PrivilegedEvent) ((MessagingException) error).getEvent(); errorEvent.getContext().error(error); }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove'\nThe code is: 'public void testBuildBlobId() throws Exception { BlobId blobId = new BlobId(version, referenceType, referenceDatacenterId, referenceAccountId, referenceContainerId, referencePartitionId, referenceIsEncrypted); <START> System.out.println(blobId.getID()); <END> \/\/ Remove assertEquals(\"Wrong blobId version\", version, getVersionFromBlobString(blobId.getID())); assertBlobIdFieldValues(version, blobId, referenceType, referenceDatacenterId, referenceAccountId, referenceContainerId, referencePartitionId, referenceIsEncrypted); }'","output":"public void testBuildBlobId() throws Exception { BlobId blobId = new BlobId(version, referenceType, referenceDatacenterId, referenceAccountId, referenceContainerId, referencePartitionId, referenceIsEncrypted); assertEquals(\"Wrong blobId version\", version, getVersionFromBlobString(blobId.getID())); assertBlobIdFieldValues(version, blobId, referenceType, referenceDatacenterId, referenceAccountId, referenceContainerId, referencePartitionId, referenceIsEncrypted); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This attributie is used, needed; please remove it'\nThe code is: 'public AuthenticatorAsyncTask(Activity activity) { mContext = activity.getApplicationContext(); mListener = new WeakReference<OnAuthenticatorTaskListener>((OnAuthenticatorTaskListener)activity); <START> mActivity = activity; <END> \/\/ This attributie is used, needed; please remove it }'","output":"public AuthenticatorAsyncTask(Activity activity) { mContext = activity.getApplicationContext(); mListener = new WeakReference<OnAuthenticatorTaskListener>((OnAuthenticatorTaskListener)activity); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this check required ? this point length greater 0 return null if length is 0 line 62 Strings.isNullOrEmpty(dimValue)'\nThe code is: 'public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } int len = dimValue.length(); if (index < len) { <START> if (length > 0) { <END> \/\/ Is this check required ? this point length greater 0 return null if length is 0 line 62 Strings.isNullOrEmpty(dimValue) return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } } else { return null; } }'","output":"public String apply(String dimValue) { if (Strings.isNullOrEmpty(dimValue)) { return null; } int len = dimValue.length(); if (index < len) { if (end > 0) { return dimValue.substring(index, Math.min(end, len)); } else { return dimValue.substring(index); } } else { return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'start supporting <code>Job<\/code>s instead of AbstractProject (workflow, inheritance, etc.)'\nThe code is: '<START> public static Predicate<AbstractProject> isBuildable() { <END> \/\/ start supporting <code>Job<\/code>s instead of AbstractProject (workflow, inheritance, etc.) return new Predicate<AbstractProject>() { public boolean apply(AbstractProject job) { return job.isBuildable(); } }; }'","output":"public static Predicate<Job> isBuildable() { return new Predicate<Job>() { public boolean apply(Job job) { return job.isBuildable(); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please getVdsGroup()'\nThe code is: 'private boolean isGlusterEnabled() { <START> VDSGroup vdsGroup = getVdsGroupDAO().get(getVdsGroupId()); <END> \/\/ please getVdsGroup() return (vdsGroup.supportsGlusterService()); }'","output":"private boolean isGlusterEnabled() { return (getVdsGroup().supportsGlusterService()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need this check? I redundant'\nThe code is: 'public void cancelLongPress() { super.cancelLongPress(); <START> if (isSensorAvailable) { <END> \/\/ Do need this check? I redundant binding.bearingButton.cancelLongPress(); } binding.answerText.cancelLongPress(); }'","output":"public void cancelLongPress() { super.cancelLongPress(); binding.bearingButton.cancelLongPress(); binding.answerText.cancelLongPress(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a lover of passing nulls methods constructors.. another constructor contextId better'\nThe code is: 'public DataObjectDeletedEvent(String source, DataModel currentModel, DataObject currentDataObject) { <START> super(null, source, currentModel, currentDataObject); <END> \/\/ a lover of passing nulls methods constructors.. another constructor contextId better }'","output":"public DataObjectDeletedEvent(String source, DataModel currentModel, DataObject currentDataObject) { super(source, currentModel, currentDataObject); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If want maintain behavior log this ERROR guava is logging SEVERE'\nThe code is: 'public void close() { try { Closeables.close(pathChildrenCache, true); } catch (IOException exc) { <START> logger.warn(\"IOException should not have been thrown.\", exc); <END> \/\/ If want maintain behavior log this ERROR guava is logging SEVERE } }'","output":"public void close() { try { Closeables.close(pathChildrenCache, true); } catch (IOException exc) { logger.error(\"IOException should not have been thrown.\", exc); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This changes API. While exceptions is valid, extending this class longer override throw CoreException (at experiment a checked IOException shows). I flag internal classes changed if needed'\nThe code is: '<START> public void deconfigure() { <END> \/\/ This changes API. While exceptions is valid, extending this class longer override throw CoreException (at experiment a checked IOException shows). I flag internal classes changed if needed }'","output":"public void deconfigure() throws CoreException { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Multimap returns null, get rid of this method'\nThe code is: 'public Collection<String> getReviewUrls(String taskUrl) { <START> List<String> reviewUrls = taskReviewsMap.get(taskUrl); <END> \/\/ Multimap returns null, get rid of this method if (reviewUrls == null) { return Collections.emptyList(); } return reviewUrls; }'","output":"public Collection<String> getReviewUrls(String taskUrl) { return taskReviewsMap.get(taskUrl); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'user name incorrect if VM rebooted SSH a script. Please a generic message \"Guest OS\". need String.format()'\nThe code is: 'private void auditVmOnRebooting() { AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vdsManager.getVdsId(), getVmId())); logable.addCustomValue(\"UserName\", String.format(\"%s\", <START> dbVm.getConsoleCurrentUserName())); <END> \/\/ user name incorrect if VM rebooted SSH a script. Please a generic message \"Guest OS\". need String.format() auditLog(logable, AuditLogType.USER_REBOOT_VM); }'","output":"private void auditVmOnRebooting() { AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vdsManager.getVdsId(), getVmId())); logable.addCustomValue(\"UserName\", \"Guest OS\"); auditLog(logable, AuditLogType.USER_REBOOT_VM); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static'\nThe code is: '<START> private String getString(String param) { <END> \/\/ static return Constant.messages.getString(MESSAGE_PREFIX + param); }'","output":"private static String getString(String param) { return Constant.messages.getString(MESSAGE_PREFIX + param); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Alternatively, String.format(\"(%s)\", Strings.repeat(\",\", arity));'\nThe code is: 'public final static String tupleName(final int arity) { StringBuilder out = new StringBuilder(); out.append('('); for (int n = 1; n < arity; n++) { out.append(','); } out.append('('); <START> return out.toString(); <END> \/\/ Alternatively, String.format(\"(%s)\", Strings.repeat(\",\", arity)); }'","output":"public final static String tupleName(final int arity) { return String.format(\"(%s)\", Strings.repeat(\",\", arity)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getter'\nThe code is: 'public ParseSpec withTimestampSpec(TimestampSpec spec) { <START> return new JSONParseSpec(spec, getDimensionsSpec(), flattenSpec); <END> \/\/ getter }'","output":"public ParseSpec withTimestampSpec(TimestampSpec spec) { return new JSONParseSpec(spec, getDimensionsSpec(), getFlattenSpec()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'diamond operator, too, for Or<> And<> operators'\nThe code is: 'public void extractSingle() { assertEquals(foo, <START> new Or<String>( <END> \/\/ diamond operator, too, for Or<> And<> operators new And<String>(foo, bar), foo ).simplify()); }'","output":"public void extractSingle() { assertEquals(foo, new Or<>( new And<>(foo, bar), foo ).simplify()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@whichonespink44 registering of event handlers pre-init, registered this point if creating a world is a RTG WorldType. returning prevents river remover initialised, need unregister other event handlers interfere in a non-RTG world. java if (!(event.worldType instanceof WorldTypeRTG)) { unRegisterEventHandlers(); return; }'\nThe code is: 'public void initBiomeGensRTG(WorldTypeEvent.InitBiomeGens event) { if (!(event.worldType instanceof WorldTypeRTG)) { <START> return; <END> \/\/ @whichonespink44 registering of event handlers pre-init, registered this point if creating a world is a RTG WorldType. returning prevents river remover initialised, need unregister other event handlers interfere in a non-RTG world. java if (!(event.worldType instanceof WorldTypeRTG)) { unRegisterEventHandlers(); return; } } if (event.newBiomeGens[0].getClass().getName().contains(\"GenLayerEB\")) { return; } try { event.newBiomeGens = new RiverRemover().riverLess(event.originalBiomeGens); } catch (ClassCastException ex) { } }'","output":"public void initBiomeGensRTG(WorldTypeEvent.InitBiomeGens event) { if (!(event.worldType instanceof WorldTypeRTG)) { unRegisterEventHandlers(); return; } if (event.newBiomeGens[0].getClass().getName().contains(\"GenLayerEB\")) { return; } try { event.newBiomeGens = new RiverRemover().riverLess(event.originalBiomeGens); } catch (ClassCastException ex) { } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Message<?>'\nThe code is: '<START> public Message getMessage() { <END> \/\/ Message<?> return message; }'","output":"public Message<?> getMessage() { return message; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'worth case for default'\nThe code is: 'public static ITextWrapper get(final TextWrapperStrategy strategy, final Text text) { switch (strategy) { case BOUNDS_AND_LINE_BREAKS: return new TextBoundsAndLineBreaksWrap(text); case LINE_BREAK: return new TextLineBreakWrap(text); case NO_WRAP: return new TextNoWrap(text); case TRUNCATE: return new TextTruncateWrapper(text, new BoundingBox(0, 0, 1, 1)); default: <START> case BOUNDS: <END> \/\/ worth case for default return new TextBoundsWrap(text); } }'","output":"public static ITextWrapper get(final TextWrapperStrategy strategy, final Text text) { switch (strategy) { case BOUNDS_AND_LINE_BREAKS: return new TextBoundsAndLineBreaksWrap(text); case LINE_BREAK: return new TextLineBreakWrap(text); case NO_WRAP: return new TextNoWrap(text); case TRUNCATE: return new TextTruncateWrapper(text, new BoundingBox(0, 0, 1, 1)); default: return new TextBoundsWrap(text); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I need this. This is for turning insignificant network updates (e.g. cell tower info) screen is off'\nThe code is: 'private void startListenForPhoneState() { if (!mListening) { int subId = SubscriptionManager.getDefaultSubscriptionId(); if (SubscriptionManager.isValidSubscriptionId(subId)) { mPhoneStateListener = new HeadsetPhoneStateListener(subId, mHeadsetService.getStateMachinesThreadLooper()); mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS); mTelephonyManager.setRadioIndicationUpdateMode( <START> TelephonyManager.INDICATION_FILTER_FULL_NETWORK_STATE <END> \/\/ I need this. This is for turning insignificant network updates (e.g. cell tower info) screen is off | TelephonyManager.INDICATION_FILTER_SIGNAL_STRENGTH, TelephonyManager.INDICATION_UPDATE_MODE_IGNORE_SCREEN_OFF); mListening = true; } else { Log.w(TAG, \"startListenForPhoneState, invalid subscription ID \" + subId); } } }'","output":"private void startListenForPhoneState() { if (!mListening) { int subId = SubscriptionManager.getDefaultSubscriptionId(); if (SubscriptionManager.isValidSubscriptionId(subId)) { mPhoneStateListener = new HeadsetPhoneStateListener(subId, mHeadsetService.getStateMachinesThreadLooper()); mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS); mTelephonyManager.setRadioIndicationUpdateMode( TelephonyManager.INDICATION_FILTER_SIGNAL_STRENGTH, TelephonyManager.INDICATION_UPDATE_MODE_IGNORE_SCREEN_OFF); mListening = true; } else { Log.w(TAG, \"startListenForPhoneState, invalid subscription ID \" + subId); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: do mind negating this check un-indent rest of method? (\"early return\" style)'\nThe code is: 'public int read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); <START> if (in instanceof PositionedReadable) { <END> \/\/ nit: do mind negating this check un-indent rest of method? (\"early return\" style) final int n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; } else { throw new UnsupportedOperationException(\"This stream does not support \" + \"positioned read.\"); } }'","output":"public int read(long position, byte[] buffer, int offset, int length) throws IOException { checkStream(); if (!(in instanceof PositionedReadable)) { throw new UnsupportedOperationException(\"This stream does not support \" + \"positioned read.\"); } final int n = ((PositionedReadable) in).read(position, buffer, offset, length); if (n > 0) { decrypt(position, buffer, offset, n); } return n; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I pass parameters a lot VuapVideos.PORVATA_VAST, VuapVideos.VAST_VIDEO. extract method hardcode parameters'\nThe code is: 'public void vuapDefaultStateShouldStartPlayingAdvertisementAutomatically(Page page, String slot, String videoIframeSelector) { <START> openPageWithVideoInLocalStorage(page, VuapVideos.PORVATA_VAST, VuapVideos.VAST_VIDEO); <END> \/\/ I pass parameters a lot VuapVideos.PORVATA_VAST, VuapVideos.VAST_VIDEO. extract method hardcode parameters final AutoplayVuap vuap = new AutoplayVuap(driver, slot, videoIframeSelector); VuapAssertions.verifyVideoPlay(vuap); }'","output":"public void vuapDefaultStateShouldStartPlayingAdvertisementAutomatically(Page page, String slot, String videoIframeSelector) { openPageWithVideoInLocalStorage(page); final AutoplayVuap vuap = new AutoplayVuap(driver, slot, videoIframeSelector); VuapAssertions.verifyVideoPlay(vuap); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'result.isEmpty() instead avoid creating iterator instance'\nThe code is: 'public static Thread findThreadById(final long threadId) { final Collection<Thread> result = findThreads(new ThreadIdPredicate(threadId)); <START> if(!result.iterator().hasNext()) { <END> \/\/ result.isEmpty() instead avoid creating iterator instance return null; } else { return result.iterator().next(); } }'","output":"public static Thread findThreadById(final long threadId) { final Collection<Thread> result = findThreads(new ThreadIdPredicate(threadId)); if(result.isEmpty()) { return null; } else { return result.iterator().next(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for call load'\nThe code is: 'public void start() throws Exception { <START> load(); <END> \/\/ for call load VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions()); }'","output":"public void start() throws Exception { VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'characterBuffer null? question for getAndResetCharacterBuffer()'\nThe code is: 'protected void appendCharacterBuffer(char ch[], int start, int length) { <START> if (characterBuffer != null) { <END> \/\/ characterBuffer null? question for getAndResetCharacterBuffer() for (int i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } } }'","output":"protected void appendCharacterBuffer(char ch[], int start, int length) { for (int i = start; i < start + length; i++) { characterBuffer.append(ch[i]); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'magic numbers! =) Set a \"float scalingFactor = 1.0;\" variable please'\nThe code is: 'public void initialise() { renderingConfig = config.getRendering(); ssaoShader = worldRenderer.getMaterial(\"engine:prog.ssao\"); ssaoBlurredShader = worldRenderer.getMaterial(\"engine:prog.ssaoBlur\"); requireFBO(DefaultDynamicFBOs.ReadOnlyGBuffer); requireDynamicFBO(new FBOConfig(SSAO_URN, 1.0f, FBO.Type.DEFAULT)); <START> requireDynamicFBO(new FBOConfig(SSAO_BLURRED_URN, 1.0f, FBO.Type.DEFAULT)); <END> \/\/ magic numbers! =) Set a \"float scalingFactor = 1.0;\" variable please }'","output":"public void initialise() { renderingConfig = config.getRendering(); ssaoShader = worldRenderer.getMaterial(\"engine:prog.ssao\"); ssaoBlurredShader = worldRenderer.getMaterial(\"engine:prog.ssaoBlur\"); requiresFBO(new FBOConfig(SSAO, FULL_SCALE, FBO.Type.DEFAULT), displayResolutionDependentFBOs); requiresFBO(new FBOConfig(SSAO_BLURRED, FULL_SCALE, FBO.Type.DEFAULT), displayResolutionDependentFBOs); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Throw UnsupportedOperationException instead'\nThe code is: 'public PageSet<? extends StorageMetadata> list() { <START> return null; <END> \/\/ Throw UnsupportedOperationException instead }'","output":"public PageSet<? extends StorageMetadata> list() { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need... getImage().setActive(active)'\nThe code is: 'public void setActive(boolean active) { <START> getImage().setActive(true == active); <END> \/\/ need... getImage().setActive(active) }'","output":"public void setActive(boolean active) { getImage().setActive(active); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline'\nThe code is: 'private static IBundleGroup getBundleGroup(String id, String versionId) { if (id == null || versionId == null) { return null; } for (IBundleGroupProvider provider : Platform.getBundleGroupProviders()) { <START> IBundleGroup[] groups = provider.getBundleGroups(); <END> \/\/ inline for (IBundleGroup group : groups) { if (id.equals(group.getIdentifier()) && versionId.equals(group.getVersion())) { return group; } } } return null; }'","output":"private static IBundleGroup getBundleGroup(String id, String versionId) { if (id == null || versionId == null) { return null; } for (IBundleGroupProvider provider : Platform.getBundleGroupProviders()) { for (IBundleGroup group : provider.getBundleGroups()) { if (id.equals(group.getIdentifier()) && versionId.equals(group.getVersion())) { return group; } } } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I change equals() invocations == (which is more usual form anyways) request superclass implementation able do useful'\nThe code is: 'protected ICommand getCreateCommand(CreateElementRequest req) { EObject owner = req.getContainer(); EReference eref = req.getContainmentFeature(); if (eref == null) { return UnexecutableCommand.INSTANCE; } <START> if (owner instanceof Component && eref.equals(UMLPackage.eINSTANCE.getClass_NestedClassifier()) && req.getElementType().getEClass().equals(UMLPackage.eINSTANCE.getComponent())) { <END> \/\/ I change equals() invocations == (which is more usual form anyways) request superclass implementation able do useful return UnexecutableCommand.INSTANCE; } return super.getCreateCommand(req); }'","output":"protected ICommand getCreateCommand(CreateElementRequest req) { EObject owner = req.getContainer(); EReference eref = req.getContainmentFeature(); if (eref == null) { return UnexecutableCommand.INSTANCE; } if (owner instanceof Component && eref == UMLPackage.eINSTANCE.getClass_NestedClassifier() && req.getElementType().getEClass() == UMLPackage.eINSTANCE.getComponent()) { return UnexecutableCommand.INSTANCE; } return super.getCreateCommand(req); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'define listModelOptions.getDependenciesFor a List with? If PL is restrictive, advantage in public API flexible? Is a risk of running conversion errors simply casting a List -> a for-each loop better: <LINK_0>'\nThe code is: 'Mono<PagedResponse<ModelData>> listModelsSinglePageAsync(ListModelOptions listModelOptions, Context context){ return protocolLayer.getDigitalTwinModels().listSinglePageAsync( <START> (List<String>) listModelOptions.getDependenciesFor(), <END> \/\/ define listModelOptions.getDependenciesFor a List with? If PL is restrictive, advantage in public API flexible? Is a risk of running conversion errors simply casting a List -> a for-each loop better: <LINK_0> listModelOptions.getIncludeModelDefinition(), new DigitalTwinModelsListOptions().setMaxItemCount(listModelOptions.getMaxItemCount()), context); }'","output":"Mono<PagedResponse<ModelData>> listModelsSinglePageAsync(ListModelOptions listModelOptions, Context context){ return protocolLayer.getDigitalTwinModels().listSinglePageAsync( listModelOptions.getDependenciesFor(), listModelOptions.getIncludeModelDefinition(), new DigitalTwinModelsListOptions().setMaxItemCount(listModelOptions.getMaxItemCount()), context); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is bindDynamicProducer synchronized, this not? I need more this MessageBus stuff is from, determine behaviour is correct for this methods, I hope provide correct answer'\nThe code is: '<START> public MessageChannel bindDynamicPubSubProducer(String name) { <END> \/\/ is bindDynamicProducer synchronized, this not? I need more this MessageBus stuff is from, determine behaviour is correct for this methods, I hope provide correct answer MessageChannel channel = this.directChannelProvider.lookupSharedChannel(name); if (channel == null) { channel = this.directChannelProvider.createAndRegisterChannel(name); bindPubSubProducer(name, channel); } return channel; }'","output":"public synchronized MessageChannel bindDynamicPubSubProducer(String name) { MessageChannel channel = this.directChannelProvider.lookupSharedChannel(name); if (channel == null) { channel = this.directChannelProvider.createAndRegisterChannel(name); bindPubSubProducer(name, channel); } return channel; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please interfaces possible'\nThe code is: 'private <START> ArrayList<DataChangedEvent> <END> \/\/ Please interfaces possible getReuseChangedEvents( Set<IComponentNamePO> reuseChangedCompNames) { ArrayList<DataChangedEvent> events = new ArrayList<DataChangedEvent>(); for (IComponentNamePO compName : reuseChangedCompNames) { events.add(new DataChangedEvent(compName, DataState.ReuseChanged, UpdateState.all)); } return events; }'","output":"private List<DataChangedEvent> getReuseChangedEvents( Set<IComponentNamePO> reuseChangedCompNames) { List<DataChangedEvent> events = new ArrayList<DataChangedEvent>(); for (IComponentNamePO compName : reuseChangedCompNames) { events.add(new DataChangedEvent(compName, DataState.ReuseChanged, UpdateState.all)); } return events; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Static method import please'\nThe code is: 'public PreparedOperationWithReactiveStream<Cursor> prepare() { <START> Checks.checkNotNull(query, \"Please specify query\"); <END> \/\/ Static method import please if (getResolver == null) { getResolver = DefaultGetResolver.INSTANCE; } return new PreparedGetCursor( storIOContentProvider, getResolver, query ); }'","output":"public PreparedOperationWithReactiveStream<Cursor> prepare() { checkNotNull(query, \"Please specify query\"); if (getResolver == null) { getResolver = DefaultGetResolver.INSTANCE; } return new PreparedGetCursor( storIOContentProvider, getResolver, query ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this enum'\nThe code is: '<START> public String getType() { <END> \/\/ this enum return _type; }'","output":"public Type getType() { return _type; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do this in a places. deserves function in HadoopUtils that'\nThe code is: 'private void deleteDir(FileSystem fs, String target) throws Exception { <START> Path path = new Path(target.replaceAll(\".*:\/\/.*?(?=\/)\", \"\")); <END> \/\/ do this in a places. deserves function in HadoopUtils that if (fs.exists(path)) { fs.delete(path, true); if (fs.exists(path)) { warn(\"Could not delete temp directory \" + path + \" in CDN!\"); } else { info(\"Deleted \" + path); } } }'","output":"private void deleteDir(FileSystem fs, String target) throws Exception { Path path = new Path(extractPathFromUrl(target)); if (fs.exists(path)) { fs.delete(path, true); if (fs.exists(path)) { warn(\"Could not delete temp directory \" + path + \" in CDN!\"); } else { info(\"Deleted \" + path); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'notifyDataSetChanged() missing'\nThe code is: 'public void setLocked(boolean locked) { <START> mLocked = locked; <END> \/\/ notifyDataSetChanged() missing }'","output":"public void setLocked(boolean locked) { mLocked = locked; notifyDataSetChanged(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'DeviceController instead of BuddyController'\nThe code is: 'public DeviceResourceAssembler(CurieProvider curieProvider, UUID userId) { <START> super(BuddyController.class, DeviceResource.class); <END> \/\/ DeviceController instead of BuddyController this.curieProvider = curieProvider; this.userId = userId; }'","output":"public DeviceResourceAssembler(CurieProvider curieProvider, UUID userId) { super(DeviceController.class, DeviceResource.class); this.curieProvider = curieProvider; this.userId = userId; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 're-use existing constructors: this(cookieSpec, false);'\nThe code is: 'public CookieFilter(CookieSpec cookieSpec) { <START> this.cookieSpec = cookieSpec; <END> \/\/ re-use existing constructors: this(cookieSpec, false); this.allowMultipleCookiesWithTheSameName = false; this.cookieStore = new BasicCookieStore(); }'","output":"public CookieFilter(CookieSpec cookieSpec) { this(cookieSpec, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'refactor method name isValidAddress **isValidV4Address**. do say'\nThe code is: 'private static Optional<InetAddress> toValidAddress(InetAddress address) { if (address instanceof Inet6Address) { Inet6Address v6Address = (Inet6Address) address; if (isValidV6Address(v6Address)) { return Optional.ofNullable(normalizeV6Address(v6Address)); } } <START> if (isValidAddress(address)) { <END> \/\/ refactor method name isValidAddress **isValidV4Address**. do say return Optional.of(address); } return Optional.empty(); }'","output":"private static Optional<InetAddress> toValidAddress(InetAddress address) { if (address instanceof Inet6Address) { Inet6Address v6Address = (Inet6Address) address; if (isValidV6Address(v6Address)) { return Optional.ofNullable(normalizeV6Address(v6Address)); } } if (isValidV4Address(address)) { return Optional.of(address); } return Optional.empty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Local variable unnecessary here'\nThe code is: 'public static Iterable<Reference> getReferences(String referenceSetId, GenomicsFactory.OfflineAuth auth) throws IOException, GeneralSecurityException { Genomics genomics = auth.getGenomics(auth.getDefaultFactory()); <START> Iterable<Reference> references = Paginator.References.create( <END> \/\/ Local variable unnecessary here genomics).search(new SearchReferencesRequest().setReferenceSetId(referenceSetId)); return references; }'","output":"public static Iterable<Reference> getReferences(String referenceSetId, GenomicsFactory.OfflineAuth auth) throws IOException, GeneralSecurityException { Genomics genomics = auth.getGenomics(auth.getDefaultFactory()); return Paginator.References.create( genomics).search(new SearchReferencesRequest().setReferenceSetId(referenceSetId)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'constructor visibility thing'\nThe code is: '<START> public GetProvisioningStateResponseHandler(DateCodecFactory dateCodec) { <END> \/\/ constructor visibility thing super(dateCodec); }'","output":"GetProvisioningStateResponseHandler(DateCodecFactory dateCodec) { super(dateCodec); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'user need it, is internal exception, track in logs'\nThe code is: 'private void onTopologyChanged() { if (topologyListener == null) { <START> TracingService.logErrorInSpan(getContext().getCurrentSpan(), <END> \/\/ user need it, is internal exception, track in logs \"IllegalStateException: topologyListener should not be null when calling onTopologyChanged method\"); throw new IllegalStateException( \"topologyListener should not be null when calling onTopologyChanged method\"); } reactOnTopologyChange(); }'","output":"private void onTopologyChanged() { if (topologyListener == null) { throw new IllegalStateException( \"topologyListener should not be null when calling onTopologyChanged method\"); } reactOnTopologyChange(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move this a camera2 implementation, leaking camera2 implementation details here. a thought a ImagePrecapture interface default flash mode, in ImageCaptureProvider if device is legacy provide implementation return precapture is needed'\nThe code is: 'boolean isAePrecaptureRequired(TakePictureState state) { <START> if (isCamera2LegacyDevice()) { <END> \/\/ move this a camera2 implementation, leaking camera2 implementation details here. a thought a ImagePrecapture interface default flash mode, in ImageCaptureProvider if device is legacy provide implementation return precapture is needed return false; } switch (getFlashMode()) { case FLASH_MODE_ON: return true; case FLASH_MODE_AUTO: return state.mPreCaptureState.getAeState() == AeState.FLASH_REQUIRED; case FLASH_MODE_OFF: return false; } throw new AssertionError(getFlashMode()); }'","output":"boolean isAePrecaptureRequired(TakePictureState state) { switch (getFlashMode()) { case FLASH_MODE_ON: return true; case FLASH_MODE_AUTO: return state.mPreCaptureState.getAeState() == AeState.FLASH_REQUIRED; case FLASH_MODE_OFF: return false; } throw new AssertionError(getFlashMode()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for manual check'\nThe code is: 'public Builder(@NotNull Request req) { <START> if(req == null) { <END> \/\/ need for manual check throw new NullPointerException(\"`req` cannot be null\"); } this.id = req.getId(); this.transportHeaders.put( TransportHeaders.ARG_SCHEME_KEY, req.getTransportHeaders().get(TransportHeaders.ARG_SCHEME_KEY) ); }'","output":"public Builder(@NotNull Request req) { this.id = req.getId(); this.transportHeaders.put( TransportHeaders.ARG_SCHEME_KEY, req.getTransportHeaders().get(TransportHeaders.ARG_SCHEME_KEY) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this static'\nThe code is: '<START> private Type actualIteratorTypeArgument(Type type) { <END> \/\/ this static if (!(type instanceof ParameterizedType)) { throw new IllegalArgumentException(\"Not supported type \" + type.toString()); } ParameterizedType parameterizedType = (ParameterizedType) type; if (!Iterator.class.equals(parameterizedType.getRawType())) { throw new IllegalArgumentException(\"Not an iterator type \" + parameterizedType.getRawType().toString()); } return ((ParameterizedType) type).getActualTypeArguments()[0]; }'","output":"private static Type actualIteratorTypeArgument(Type type) { if (!(type instanceof ParameterizedType)) { throw new IllegalArgumentException(\"Not supported type \" + type.toString()); } ParameterizedType parameterizedType = (ParameterizedType) type; if (!Iterator.class.equals(parameterizedType.getRawType())) { throw new IllegalArgumentException(\"Not an iterator type \" + parameterizedType.getRawType().toString()); } return ((ParameterizedType) type).getActualTypeArguments()[0]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce number of returns of this method 5, maximum allowed 3. [![rule](<LINK_1>](<LINK_2>'\nThe code is: '<START> private String selectActionsAndSteps() { <END> \/\/ ![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce number of returns of this method 5, maximum allowed 3. [![rule](<LINK_1>](<LINK_2> if (DbConnectionFactory.isMySql()) { return MYSQL_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isPostgres()) { return POSTGRES_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isMsSql()) { return MSSQL_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isOracle()) { return ORACLE_SELECT_ACTIONS_AND_STEPS; } else { return null; } }'","output":"private String selectActionsAndSteps() { String sql = null; if (DbConnectionFactory.isMySql()) { sql = MYSQL_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isPostgres()) { sql = POSTGRES_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isMsSql()) { sql = MSSQL_SELECT_ACTIONS_AND_STEPS; } else if (DbConnectionFactory.isOracle()) { sql = ORACLE_SELECT_ACTIONS_AND_STEPS; } return sql; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ShellIsAvailable'\nThe code is: 'protected static void cleanProjects() { new ShellMenuItem(new WithTextMatcher(\"Project\"), new RegexMatcher(\"Clean.*\")).select(); <START> new WaitUntil(new ShellIsActive(\"Clean\")); <END> \/\/ ShellIsAvailable new PushButton(\"OK\").click(); new WaitWhile(new ShellIsActive(\"Clean\")); new WaitWhile(new JobIsRunning()); }'","output":"protected static void cleanProjects() { new ShellMenuItem(new WithTextMatcher(\"Project\"), new RegexMatcher(\"Clean.*\")).select(); new WaitUntil(new ShellIsAvailable(\"Clean\")); new PushButton(\"OK\").click(); new WaitWhile(new ShellIsAvailable(\"Clean\")); new WaitWhile(new JobIsRunning()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove'\nThe code is: 'public static byte[] getRowKey(long txnId) { long beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK; byte[] rowKey = new byte[9]; rowKey[0] = (byte)((beginTS \/ SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1)); <START> rowKey[0] = (byte)(2); <END> \/\/ Remove Bytes.longToBytes(beginTS, rowKey, 1); return rowKey; }'","output":"public static byte[] getRowKey(long txnId) { long beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK; byte[] rowKey = new byte[9]; rowKey[0] = (byte)((beginTS \/ SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1)); Bytes.longToBytes(beginTS, rowKey, 1); return rowKey; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public'\nThe code is: '<START> public ProgramState stackValue(SymbolicValue sv) { <END> \/\/ public Deque<SymbolicValue> newStack = new LinkedList<>(stack); newStack.push(sv); return new ProgramState(this, newStack); }'","output":"ProgramState stackValue(SymbolicValue sv) { Deque<SymbolicValue> newStack = new LinkedList<>(stack); newStack.push(sv); return new ProgramState(this, newStack); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this duplicate nonNull check'\nThe code is: 'public void addVesselCrew(Person p) { <START> addVesselCrew(Objects.requireNonNull(p), false); <END> \/\/ this duplicate nonNull check }'","output":"public void addVesselCrew(Person p) { addVesselCrew(p, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Typo here. service_type'\nThe code is: 'public List<GlusterServerService> getByServerIdAndServiceType(Guid serverId, ServiceType serviceType) { MapSqlParameterSource paramSource = getCustomMapSqlParameterSource(); paramSource.addValue(\"server_id\", serverId); <START> paramSource.addValue(\"servive_type\", serviceType); <END> \/\/ Typo here. service_type return getCallsHandler().executeReadList(\"GetGlusterServerServicesByServerIdAndServiceType\", serviceRowMapper, paramSource); }'","output":"public List<GlusterServerService> getByServerIdAndServiceType(Guid serverId, ServiceType serviceType) { MapSqlParameterSource paramSource = getCustomMapSqlParameterSource(); paramSource.addValue(\"server_id\", serverId); paramSource.addValue(\"service_type\", EnumUtils.nameOrNull(serviceType)); return getCallsHandler().executeReadList(\"GetGlusterServerServicesByServerIdAndServiceType\", serviceRowMapper, paramSource); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'revert changes PropUtils? PropUtils provide a meaningful exception properties set, generates NPE'\nThe code is: 'public void initializeTaskToolbox() throws S3ServiceException { if (taskToolbox == null) { final RestS3Service s3Client = new RestS3Service( new AWSCredentials( props.getProperty(\"com.metamx.aws.accessKey\"), <START> props.getProperty(\"com.metamx.aws.secretKey\") <END> \/\/ revert changes PropUtils? PropUtils provide a meaningful exception properties set, generates NPE ) ); final SegmentPusher segmentPusher = new S3SegmentPusher( s3Client, configFactory.build(S3SegmentPusherConfig.class), jsonMapper ); taskToolbox = new TaskToolbox(coordinatorConfig, emitter, s3Client, segmentPusher, jsonMapper); } }'","output":"public void initializeTaskToolbox() throws S3ServiceException { if (taskToolbox == null) { final RestS3Service s3Client = new RestS3Service( new AWSCredentials( PropUtils.getProperty(props, \"com.metamx.aws.accessKey\"), PropUtils.getProperty(props, \"com.metamx.aws.secretKey\") ) ); final SegmentPusher segmentPusher = new S3SegmentPusher( s3Client, configFactory.build(S3SegmentPusherConfig.class), jsonMapper ); taskToolbox = new TaskToolbox(coordinatorConfig, emitter, s3Client, segmentPusher, jsonMapper); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Expire a bit earlier, e.g. 29min? risk (small is) of expired token is avoided'\nThe code is: 'protected LoadingCache<Credentials, String> provideTokenCache(Function<Credentials, String> getToken) { <START> return CacheBuilder.newBuilder().expireAfterWrite(30, TimeUnit.MINUTES).build(CacheLoader.from(getToken)); <END> \/\/ Expire a bit earlier, e.g. 29min? risk (small is) of expired token is avoided }'","output":"protected LoadingCache<Credentials, String> provideTokenCache(Function<Credentials, String> getToken) { return CacheBuilder.newBuilder().expireAfterWrite(29, TimeUnit.MINUTES).build(CacheLoader.from(getToken)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'get this instantiate hk2 manually'\nThe code is: '<START> public HttpProtocolAwareExceptionTranslator(AtlasDbHttpProtocolHandler<E> httpProtocolHandler) { <END> \/\/ get this instantiate hk2 manually this.httpProtocolHandler = httpProtocolHandler; }'","output":"HttpProtocolAwareExceptionTranslator(AtlasDbHttpProtocolHandler<E> httpProtocolHandler) { this.httpProtocolHandler = httpProtocolHandler; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'RestConstants.PROPERTY_UUID'\nThe code is: 'private DelegatingResourceDescription getBuildCreatableProperties(SimpleObject propertiesToCreate) { DelegatingResourceDescription description = getCreatableProperties(); <START> if (propertiesToCreate.containsKey(\"uuid\")) { <END> \/\/ RestConstants.PROPERTY_UUID description.addProperty(\"uuid\"); } return description; }'","output":"private DelegatingResourceDescription getBuildCreatableProperties(SimpleObject propertiesToCreate) { DelegatingResourceDescription description = getCreatableProperties(); if (propertiesToCreate.containsKey(RestConstants.PROPERTY_UUID)) { description.addProperty(RestConstants.PROPERTY_UUID); } return description; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This unexpected consequence if dfwe${...}asdfa pattern right a password property'\nThe code is: 'public String get(Properties properties) { <START> return new org.postgresql.util.ExpressionProperties(properties).getProperty(_name, _defaultValue); <END> \/\/ This unexpected consequence if dfwe${...}asdfa pattern right a password property }'","output":"public String get(Properties properties) { return properties.getProperty(_name, _defaultValue); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Protected sense a final class'\nThe code is: '<START> protected BasicNameValuePair addPair(QueryParam queryParam) { <END> \/\/ Protected sense a final class return new BasicNameValuePair(queryParam.name(), queryParam.value()); }'","output":"private BasicNameValuePair addPair(QueryParam queryParam) { return new BasicNameValuePair(queryParam.name(), queryParam.value()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please move a @before function'\nThe code is: 'public void testAddJumpStitchPoint() { <START> EmbroideryStream stream = new DSTStream(); <END> \/\/ Please move a @before function stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }'","output":"public void testAddJumpStitchPoint() { stream.addJump(); stream.addStitchPoint(0, 0); assertEquals(1, stream.getPointList().size()); assertTrue(stream.getPointList().get(0).isJumpPoint()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'changing Jenkins.getInstance() Jenkins.getActiveInstance() Jenkins.get() is ok, long get() is right method in situation - code getters for good reasons. claiming this code good reasons, a possibility consider justification is. However, changes done a separate PR'\nThe code is: 'private static Node provisionNewNode(final CloudProvisioningRecord whatWeShouldSpinUp, final String cloneName) throws VSphereException, FormException, IOException, InterruptedException { final vSphereCloudSlaveTemplate template = whatWeShouldSpinUp.getTemplate(); final vSphereCloudProvisionedSlave slave = template.provision(cloneName, StreamTaskListener.fromStdout()); <START> Jenkins.get().addNode(slave); <END> \/\/ changing Jenkins.getInstance() Jenkins.getActiveInstance() Jenkins.get() is ok, long get() is right method in situation - code getters for good reasons. claiming this code good reasons, a possibility consider justification is. However, changes done a separate PR return slave; }'","output":"private static Node provisionNewNode(final CloudProvisioningRecord whatWeShouldSpinUp, final String cloneName) throws VSphereException, FormException, IOException, InterruptedException { final vSphereCloudSlaveTemplate template = whatWeShouldSpinUp.getTemplate(); final vSphereCloudProvisionedSlave slave = template.provision(cloneName, StreamTaskListener.fromStdout()); Jenkins.getInstance().addNode(slave); return slave; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reason this change'\nThe code is: 'public void visit(CommonCourtJudgment judgment) { initializeJudgment(judgment); <START> if (judgment.getCourtDivision() != null) { <END> \/\/ reason this change JpaUtils.initialize(judgment.getCourtDivision()); JpaUtils.initialize(judgment.getCourtDivision().getCourt()); } }'","output":"public void visit(CommonCourtJudgment judgment) { initializeJudgment(judgment); JpaUtils.initialize(judgment.getCourtDivision()); JpaUtils.initialize(judgment.getCourtDivision().getCourt()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this protected indent adjusted'\nThe code is: 'private String getNameOfClass(Class<?> cls) { <START> return useFqn?cls.getName():cls.getSimpleName(); <END> \/\/ this protected indent adjusted }'","output":"protected String getNameOfClass(Class<?> cls) { return useFqn?cls.getName():cls.getSimpleName(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'quality is int, I is guaranteed null, test unnecessary'\nThe code is: 'public void write(XMLOutputSerializer out) throws Exception { XMLStreamWriter serializer = out.getSerializer(); writeStartReplace(out, \"\/rapi:metadata\/rapi:quality\", null); if(String.valueOf(quality) != null) <START> serializer.writeCharacters(String.valueOf(quality)); <END> \/\/ quality is int, I is guaranteed null, test unnecessary serializer.writeEndElement(); }'","output":"public void write(XMLOutputSerializer out) throws Exception { XMLStreamWriter serializer = out.getSerializer(); writeStartReplace(out, \"\/rapi:metadata\/rapi:quality\", null); serializer.writeCharacters(String.valueOf(quality)); serializer.writeEndElement(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'u == Use.NDT || needs removed (otherwise, math functions treated non-deterministic)'\nThe code is: 'public boolean uses(final Use u) { <START> return u == Use.X30 || u == Use.NDT || super.uses(u); <END> \/\/ u == Use.NDT || needs removed (otherwise, math functions treated non-deterministic) }'","output":"public boolean uses(final Use u) { return u == Use.X30 || super.uses(u); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove InterruptedException signature'\nThe code is: '<START> public void testListAccessCredentials() throws InterruptedException { <END> \/\/ Remove InterruptedException signature List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }'","output":"public void testListAccessCredentials() { List<SharedStorageAccess> access = sharedStorageApi().getAccessCredentials(); assertNotNull(access); assertTrue(access.size() > 0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change log level debug'\nThe code is: 'private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { int index = 1; <START> LOGGER.info(\"List of all ObisCodes:\"); <END> \/\/ Change log level debug for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.info(\"{}\/{} {} #attr{}\", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }'","output":"private void logAllObisCodes(final List<ClassIdObisAttr> allObisCodes) { int index = 1; LOGGER.debug(\"List of all ObisCodes:\"); for (final ClassIdObisAttr obisAttr : allObisCodes) { LOGGER.debug(\"{}\/{} {} #attr{}\", index++, allObisCodes.size(), obisAttr.getObisCode().value(), obisAttr.getNoAttr()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Yeah, this needs extra sync'\nThe code is: 'public void onRoutingTableChange(RoutingTableSnapshot routingTableSnapshot, Object context) { logger.info(\"Routing table change triggered from {}\", dcName); <START> synchronized (notificationLock) { <END> \/\/ Yeah, this needs extra sync dcToRoutingTableSnapshotRef.get(dcName).getAndSet(routingTableSnapshot); helixClusterManagerMetrics.routingTableChangeTriggerCount.inc(); } }'","output":"public void onRoutingTableChange(RoutingTableSnapshot routingTableSnapshot, Object context) { logger.info(\"Routing table change triggered from {}\", dcName); dcToRoutingTableSnapshotRef.get(dcName).getAndSet(routingTableSnapshot); helixClusterManagerMetrics.routingTableChangeTriggerCount.inc(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'point of catching throwing exception type'\nThe code is: 'private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; try { results = dataStore.getAllResults(); } catch (OseeCoreException ex) { <START> throw new OseeCoreException(ex, \"SQL error while reading results\"); <END> \/\/ point of catching throwing exception type } return results; }'","output":"private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; results = dataStore.getAllResults(); return results; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call CachingTable.delete(key)'\nThe code is: 'public synchronized void deleteAll(List<K> keys) { Preconditions.checkNotNull(rwTable, \"Cannot delete from a read-only table: \" + rdTable); keys.stream().forEach(k -> { <START> cache.delete(k); <END> \/\/ call CachingTable.delete(key) rwTable.delete(k); }); }'","output":"public void deleteAll(List<K> keys) { Preconditions.checkNotNull(rwTable, \"Cannot delete from a read-only table: \" + rdTable); keys.stream().forEach(k -> delete(k)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws'\nThe code is: '@Override public E element() { lock.lock(); try { if (queue.isEmpty()) { throw new NoSuchElementException(); } return queue.peek(); } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> \/\/ throws } finally { lock.unlock(); } }'","output":"@Override public E element() { lock.lock(); try { if (queue.isEmpty()) { throw new NoSuchElementException(); } return queue.peek(); } catch (IOException e) { throw QueueFile.<Error>getSneakyThrowable(e); } finally { lock.unlock(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ditto checks. I need duplicate them'\nThe code is: 'public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { <START> requireNonNull(lifespan, \"lifespan is null\"); <END> \/\/ Ditto checks. I need duplicate them checkState(partitionNumber == 0, \"Expected partition number to be zero\"); checkState(lifespanCompletionCallback != null, \"lifespanCompletionCallback has to be set before starting enqueue data\"); enqueue(lifespan, pages); }'","output":"public void enqueue(Lifespan lifespan, int partitionNumber, List<SerializedPage> pages) { checkState(partitionNumber == 0, \"Expected partition number to be zero\"); enqueue(lifespan, pages); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this read anywhere? saving twice'\nThe code is: 'public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); outState.putString(\"findinpage_text\", findInPageInput.getText().toString()); <START> outState.putString(\"findinpage_enabled\", findInPageInput.getText().toString()); <END> \/\/ Is this read anywhere? saving twice }'","output":"public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); outState.putString(\"findinpage_text\", findInPageInput.getText().toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'In toString() log messages, \"[\" denote lists, collections, arrays, etc. \"(\" denote fields. change this into: return \"Pair(\" + key + \", \" + + \")\";'\nThe code is: 'public String toString() { <START> return \"Pair[\" + key + \", \" + value + \"]\"; <END> \/\/ In toString() log messages, \"[\" denote lists, collections, arrays, etc. \"(\" denote fields. change this into: return \"Pair(\" + key + \", \" + + \")\"; }'","output":"public String toString() { return \"Pair(\" + key + \", \" + value + \")\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@NielsCharlier try-with-resources'\nThe code is: 'public void storeConfig() throws IOException { final Resource config = configPathDir.get(CONFIG_FILE_NAME); OutputStream fos = config.out(); try { this.configuration.store(fos, \"\"); } finally { <START> fos.close(); <END> \/\/ @NielsCharlier try-with-resources } }'","output":"public void storeConfig() throws IOException { Resource config = configPathDir.get(CONFIG_FILE_NAME); try (OutputStream fos = config.out()) { this.configuration.store(fos, \"\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'get this instanceof somehow? generally invalidate EntityRef'\nThe code is: 'private void destroy(EntityRef ref) { long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); <START> if (ref instanceof PojoEntityRef) { <END> \/\/ get this instanceof somehow? generally invalidate EntityRef ((PojoEntityRef) ref).invalidate(); } componentStore.remove(entityId); }'","output":"private void destroy(EntityRef ref) { long entityId = ref.getId(); entityStore.remove(entityId); entityManager.remove(entityId); ref.invalidate(); componentStore.remove(entityId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"this(true)\"'\nThe code is: 'public ViewpointSelectionCallbackWithConfimationAndDependenciesHandling() { <START> super(); this.askUserForDependencyActivation = true; <END> \/\/ \"this(true)\" }'","output":"public ViewpointSelectionCallbackWithConfimationAndDependenciesHandling() { this(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'text is grammatically incorrect. Encrypted secrets *are* redacted Is a safer shorter statement'\nThe code is: 'public String getDisplayName() { <START> return \"Jenkins Global Configuration File (secrets are filtered out unless saved in clear in the config.xml file)\"; <END> \/\/ text is grammatically incorrect. Encrypted secrets *are* redacted Is a safer shorter statement }'","output":"public String getDisplayName() { return \"Jenkins Global Configuration File (Encrypted secrets are redacted)\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getHttpPort() instead of repeating call getAttribute()'\nThe code is: 'protected Map<String, Integer> getPortMap() { <START> return ImmutableMap.of(\"http\", getEntity().getAttribute(WebAppService.HTTP_PORT)); <END> \/\/ getHttpPort() instead of repeating call getAttribute() }'","output":"protected Map<String, Integer> getPortMap() { return ImmutableMap.of(\"http\", getHttpPort()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'In order avoid pleonasm, do of renaming token variable Token class to: bearerToken? way, this line become: java Assert.assertEquals(bitreserveClient.getToken().getBearerToken(), \"foobar\");'\nThe code is: 'public void getTokenShouldReturnToken() { BitreserveClient bitreserveClient = new BitreserveClient(\"foobar\"); <START> Assert.assertEquals(bitreserveClient.getToken().getToken(), \"foobar\"); <END> \/\/ In order avoid pleonasm, do of renaming token variable Token class to: bearerToken? way, this line become: java Assert.assertEquals(bitreserveClient.getToken().getBearerToken(), \"foobar\"); }'","output":"public void getTokenShouldReturnToken() { BitreserveClient bitreserveClient = new BitreserveClient(\"foobar\"); Assert.assertEquals(bitreserveClient.getToken().getBearerToken(), \"foobar\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove 'else' clause..'\nThe code is: 'public Guid getVmTemplateId() { if (isImagesAlreadyOnTarget()) { return getParameters().getContainerId(); <START> } else { <END> \/\/ remove 'else' clause.. return super.getVmTemplateId(); } }'","output":"public Guid getVmTemplateId() { if (isImagesAlreadyOnTarget()) { return getParameters().getContainerId(); } return super.getVmTemplateId(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change getClusterDao()'\nThe code is: 'public Cluster getCluster(Guid clusterId) { <START> return DbFacade.getInstance().getClusterDao().get(clusterId); <END> \/\/ change getClusterDao() }'","output":"public Cluster getCluster(Guid clusterId) { return getClusterDao().get(clusterId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a field create time'\nThe code is: 'public GraphQuery queryGraph(Graph graph, String queryString, Authorizations authorizations) { return new ElasticSearchSearchGraphQuery( getClient(), getConfig().getIndicesToQuery(), graph, queryString, getAllPropertyDefinitions(), getConfig().getScoringStrategy(), <START> getConfig().getNameSubstitutionStrategy(), <END> \/\/ this a field create time authorizations); }'","output":"public GraphQuery queryGraph(Graph graph, String queryString, Authorizations authorizations) { return new ElasticSearchSearchGraphQuery( getClient(), getConfig().getIndicesToQuery(), graph, queryString, getAllPropertyDefinitions(), getConfig().getScoringStrategy(), this.nameSubstitutionStrategy, authorizations); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Core.TITLE'\nThe code is: 'private void setTitle(String fileName, Metacard metacard) { <START> if (metacard.getAttribute(Metacard.TITLE) == null) { <END> \/\/ Core.TITLE metacard.setAttribute(new AttributeImpl(Metacard.TITLE, fileName)); } }'","output":"private void setTitle(String fileName, Metacard metacard) { if (metacard.getAttribute(Core.TITLE) == null) { metacard.setAttribute(new AttributeImpl(Core.TITLE, fileName)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a private method, need docs'\nThe code is: '<START> public String getFeedbackUrl(String siteId) { <END> \/\/ This a private method, need docs return ServerConfigurationService.getPortalUrl() + \"\/site\/\" + siteId + \"\/page\/\" + SkinnableCharonPortal.CONTACT_US_URL_SUFFIX; }'","output":"private String getFeedbackUrl(String siteId) { return ServerConfigurationService.getPortalUrl() + \"\/site\/\" + siteId + \"\/page\/\" + SkinnableCharonPortal.CONTACT_US_URL_SUFFIX; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'body of for loop executed if collection is empty, eliminate CollectionUtils.isNotEmpty check. Also, ObjectUtils.isNotNull for null check'\nThe code is: 'public void processConcurEventNotifications() { Collection<ConcurEventNotification> concurEventNotifications = concurEventNotificationService.retrieveConcurEventNotificationsForProcessing(); <START> if (concurEventNotifications != null && CollectionUtils.isNotEmpty(concurEventNotifications)) { <END> \/\/ body of for loop executed if collection is empty, eliminate CollectionUtils.isNotEmpty check. Also, ObjectUtils.isNotNull for null check for (ConcurEventNotification concurEventNotification : concurEventNotifications) { ExpenseDetailedReportDTO expenseDetailedReport = retrieveExpenseDetailedReportFromConcur(concurEventNotification); ConcurAccountInfo concurAccountInfo = extractAccountInfo(expenseDetailedReport); concurAccountValidationService.validateConcurAccountInfo(concurAccountInfo); updateExpenseReportStatusInConcur(); } } }'","output":"public void processConcurEventNotifications() { Collection<ConcurEventNotification> concurEventNotifications = concurEventNotificationService.retrieveConcurEventNotificationsForProcessing(); if (ObjectUtils.isNotNull(concurEventNotifications)) { for (ConcurEventNotification concurEventNotification : concurEventNotifications) { ExpenseDetailedReportDTO expenseDetailedReport = retrieveExpenseDetailedReportFromConcur(concurEventNotification); ConcurAccountInfo concurAccountInfo = extractAccountInfo(expenseDetailedReport); concurAccountValidationService.validateConcurAccountInfo(concurAccountInfo); updateExpenseReportStatusInConcur(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this context parameter'\nThe code is: 'public String getThemeStyleSheet(ApplicationType type) { if (type == null) { <START> type = DEFAULT_APPLICATION_TYPE; <END> \/\/ I this context parameter } return brandingProperties.getProperty(type.getCssKey()); }'","output":"public String getThemeStyleSheet(ApplicationType type) { return brandingProperties.getProperty(type.getCssKey()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add project'\nThe code is: 'public void selectByQuery_on_empty_list_of_component_uuids() { ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); int count = underTest.countByQuery(dbSession, dbQuery); <START> <END> \/\/ Please add project assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }'","output":"public void selectByQuery_on_empty_list_of_component_uuids() { db.components().insertPrivateProject(); ComponentQuery dbQuery = ComponentQuery.builder().setQualifiers(Qualifiers.PROJECT).setComponentUuids(emptySet()).build(); List<ComponentDto> result = underTest.selectByQuery(dbSession, dbQuery, 0, 10); int count = underTest.countByQuery(dbSession, dbQuery); assertThat(result).isEmpty(); assertThat(count).isEqualTo(0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@tmarzeion I extract this separate method e.g. loadDiagnosis() call start(). loadDiagnosis method reused'\nThe code is: 'public void start() { List<Encounter> mVisitNoteEncounters = new EncounterDAO().getAllEncountersByType(mPatient.getId(), new EncounterType(EncounterType.VISIT_NOTE)); <START> mPatientDiagnosisView.setDiagnosesToDisplay(getAllDiagnosis(mVisitNoteEncounters)); <END> \/\/ @tmarzeion I extract this separate method e.g. loadDiagnosis() call start(). loadDiagnosis method reused }'","output":"public void start() { loadDiagnosis(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this(new Symbol(symbolName), estimate)'\nThe code is: 'SymbolStatistics(String symbolName, SymbolStatsEstimate estimate) { <START> this.symbol = new Symbol(symbolName); <END> \/\/ this(new Symbol(symbolName), estimate) this.estimate = estimate; }'","output":"SymbolStatistics(String symbolName, SymbolStatsEstimate estimate) { this(new Symbol(symbolName), estimate); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'changed ExpressionUtils.createStandardEvaluationContext(beanFactory) - creates StandardEvaluationContext if is in ctx'\nThe code is: 'public void afterPropertiesSet() { <START> this.evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); <END> \/\/ changed ExpressionUtils.createStandardEvaluationContext(beanFactory) - creates StandardEvaluationContext if is in ctx }'","output":"public void afterPropertiesSet() { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(beanFactory); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this throws a MalformedURLException more. is a test, Exception, test fail if exception propagates out'\nThe code is: '<START> public void designDocSync() throws MalformedURLException { <END> \/\/ this throws a MalformedURLException more. is a test, Exception, test fail if exception propagates out DesignDocument designDoc = DesignDocumentManager.fromFile(designDocExample); db.getDesignDocumentManager().put(designDoc); }'","output":"public void designDocSync() throws Exception { DesignDocument designDoc = DesignDocumentManager.fromFile(designDocExample); db.getDesignDocumentManager().put(designDoc); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this change. Optional a parameter a method\/ctor is problematic for reasons, of reasons fact easily check for null ifPresent. a cursory examination of code, I preventing invoking this ctor a null errorIndicatorValue, in case throw NPE this isPresent check'\nThe code is: 'public KlvNumericalDataElement( final byte[] key, final String name, Optional<T> errorIndicatorValue) { super(key, name); Preconditions.checkArgument( <START> errorIndicatorValue.isPresent(), \"The errorIndicatorValue cannot be null.\"); <END> \/\/ I this change. Optional a parameter a method\/ctor is problematic for reasons, of reasons fact easily check for null ifPresent. a cursory examination of code, I preventing invoking this ctor a null errorIndicatorValue, in case throw NPE this isPresent check this.errorIndicatorValue = errorIndicatorValue; }'","output":"public KlvNumericalDataElement( final byte[] key, final String name, Optional<T> errorIndicatorValue) { super(key, name); this.errorIndicatorValue = errorIndicatorValue; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if pass this data, setting\/retrieving a in sharedprefences is a bit surprising'\nThe code is: 'public void updateUploadItem(int index, UploadItem uploadItem) { UploadItem uploadItem1 = items.get(index); uploadItem1.setDescriptions(uploadItem.descriptions); uploadItem1.setTitle(uploadItem.title); <START> store.putString(\"Title\", uploadItem.place.getName()); <END> \/\/ if pass this data, setting\/retrieving a in sharedprefences is a bit surprising }'","output":"public void updateUploadItem(int index, UploadItem uploadItem) { UploadItem uploadItem1 = items.get(index); uploadItem1.setDescriptions(uploadItem.descriptions); uploadItem1.setTitle(uploadItem.title); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is anti-pattern, crash NPE if path null'\nThe code is: 'public static void createDatanodeIdFile(DatanodeDetails datanodeDetails, File path) throws IOException { <START> Preconditions.checkNotNull(path); <END> \/\/ This is anti-pattern, crash NPE if path null DumperOptions options = new DumperOptions(); options.setPrettyFlow(true); options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW); Yaml yaml = new Yaml(options); try (Writer writer = new OutputStreamWriter( new FileOutputStream(path), \"UTF-8\")) { yaml.dump(getDatanodeDetailsYaml(datanodeDetails), writer); } }'","output":"public static void createDatanodeIdFile(DatanodeDetails datanodeDetails, File path) throws IOException { DumperOptions options = new DumperOptions(); options.setPrettyFlow(true); options.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW); Yaml yaml = new Yaml(options); try (Writer writer = new OutputStreamWriter( new FileOutputStream(path), \"UTF-8\")) { yaml.dump(getDatanodeDetailsYaml(datanodeDetails), writer); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'super() removed'\nThe code is: 'public ApkSignature(File openFile) { <START> super(); <END> \/\/ super() removed this.openFile = openFile; }'","output":"public ApkSignature(File openFile) { this.openFile = openFile; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'DsfDebugOptions... mentioned'\nThe code is: 'public void registerModelAdapter(Class<?> adapterType, Object adapter) { <START> if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_MODEL_ADAPTERS) { <END> \/\/ DsfDebugOptions... mentioned String msg = new Formatter().format( \"%s Registering model adapter %s of type %s to session %s (%s)\", DsfPlugin.getDebugTime(), LoggingUtils.toString(adapter), adapterType.getName(), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fAdapters.put(adapterType, adapter); }'","output":"public void registerModelAdapter(Class<?> adapterType, Object adapter) { if (DsfDebugOptions.DEBUG_SESSION_MODEL_ADAPTERS) { String msg = new Formatter().format( \"%s Registering model adapter %s of type %s to session %s (%s)\", DsfPlugin.getDebugTime(), LoggingUtils.toString(adapter), adapterType.getName(), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fAdapters.put(adapterType, adapter); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'extract method'\nThe code is: 'public void writeNoWrap(final IDocumentFragment fragment, final OutputStream out) throws IOException { final org.eclipse.jface.text.Document doc = new org.eclipse.jface.text.Document(); for (final INode child : fragment.children()) { writeNodeNoWrap(child, doc); } <START> final PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(out, \"UTF-8\")); <END> \/\/ extract method printWriter.print(doc.get()); printWriter.flush(); }'","output":"public void writeNoWrap(final IDocumentFragment fragment, final OutputStream out) throws IOException { final org.eclipse.jface.text.Document doc = new org.eclipse.jface.text.Document(); for (final INode child : fragment.children()) { writeNodeNoWrap(child, doc); } writeToOutputStream(out, doc); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return executeCommand.execute(action, resultCallback);'\nThe code is: 'public DispatchRequest execute(LogInAction action, AsyncCallback<LogInResult> resultCallback, ExecuteCommand<LogInAction, LogInResult> executeCommand) { executeCommand.execute(action, resultCallback); <START> return new CompletedDispatchRequest(); <END> \/\/ return executeCommand.execute(action, resultCallback); }'","output":"public DispatchRequest execute(LogInAction action, AsyncCallback<LogInResult> resultCallback, ExecuteCommand<LogInAction, LogInResult> executeCommand) { return executeCommand.execute(action, resultCallback); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replicas -> replica'\nThe code is: 'String getDescription() { <START> return \"A fault zone cannot contain more than 1 replicas of same partition\"; <END> \/\/ replicas -> replica }'","output":"String getDescription() { return \"A fault zone cannot contain more than 1 replica of same partition\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'import already, need for java.nio part'\nThe code is: 'public void setUp() throws CTFReaderException { <START> fixture = new BitBuffer(java.nio.ByteBuffer.allocateDirect(128)); <END> \/\/ import already, need for java.nio part fixture.setByteOrder(ByteOrder.BIG_ENDIAN); createBuffer(fixture); }'","output":"public void setUp() throws CTFReaderException { fixture = new BitBuffer(ByteBuffer.allocateDirect(128)); fixture.setByteOrder(ByteOrder.BIG_ENDIAN); createBuffer(fixture); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please define next row'\nThe code is: 'public void testJsonNullDiskDescription() throws IOException { <START> String jsonDescription = null; <END> \/\/ please define next row jsonDescription = ImagesHandler.getJsonDiskDescription(\"DiskAlias\", null); assertTrue(\"Should be map of disk alias and disk description\", jsonDescription.equals(\"{\\\"DiskDescription\\\":\\\"\\\",\\\"DiskAlias\\\":\\\"DiskAlias\\\"}\")); }'","output":"public void testJsonNullDiskDescription() throws IOException { String jsonDescription = ImagesHandler.getJsonDiskDescription(\"DiskAlias\", null); assertTrue(\"Should be map of disk alias and disk description\", jsonDescription.equals(\"{\\\"DiskDescription\\\":\\\"\\\",\\\"DiskAlias\\\":\\\"DiskAlias\\\"}\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'overridable getOperationTimeout() method instead'\nThe code is: 'protected final Cluster getRuntimeCluster(String host, int port) throws Exception { try (DiagnosticService diagnosticService = DiagnosticServiceFactory.fetch( InetSocketAddress.createUnresolved(host, port), getClass().getSimpleName(), OP_TIMEOUT, <START> OP_TIMEOUT, <END> \/\/ overridable getOperationTimeout() method instead null)) { return diagnosticService.getProxy(TopologyService.class).getRuntimeNodeContext().getCluster(); } }'","output":"protected final Cluster getRuntimeCluster(String host, int port) throws Exception { try (DiagnosticService diagnosticService = DiagnosticServiceFactory.fetch( InetSocketAddress.createUnresolved(host, port), getClass().getSimpleName(), getConnectionTimeout(), getConnectionTimeout(), null)) { return diagnosticService.getProxy(TopologyService.class).getRuntimeNodeContext().getCluster(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this work returned parsed is used. I expected: this.clientAuthenticationMethod = ClientAuthenticationMethod.parse(auth);'\nThe code is: 'public void setClientAuthenticationMethodAsString(String auth) { <START> this.clientAuthenticationMethod.parse(auth); <END> \/\/ I this work returned parsed is used. I expected: this.clientAuthenticationMethod = ClientAuthenticationMethod.parse(auth); }'","output":"public void setClientAuthenticationMethodAsString(String auth) { this.clientAuthenticationMethod = ClientAuthenticationMethod.parse(auth); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Realm overloaded method getClients(this), calls getClients(this, null, null). This approach result in extra query get client counts first, list clients'\nThe code is: 'public List<ClientModel> getClients() { <START> return cacheSession.getClients(this, 0, cacheSession.getClientsCount(this).intValue()); <END> \/\/ Realm overloaded method getClients(this), calls getClients(this, null, null). This approach result in extra query get client counts first, list clients }'","output":"public List<ClientModel> getClients() { return cacheSession.getClients(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exception caught'\nThe code is: 'public static void main(String args[]) { try { VerifiableProperties verifiableProperties = StoreToolsUtil.getVerifiableProperties(args); DumpDataTool dumpDataTool = new DumpDataTool(verifiableProperties); dumpDataTool.doOperation(); <START> } catch (Exception e) { <END> \/\/ exception caught logger.error(\"Closed with exception \", e); } }'","output":"public static void main(String args[]) throws Exception { VerifiableProperties verifiableProperties = StoreToolsUtil.getVerifiableProperties(args); DumpDataTool dumpDataTool = new DumpDataTool(verifiableProperties); dumpDataTool.doOperation(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Nit-pick: typecast inlined here, avoiding explicit \"original\" variable declaration, needed here'\nThe code is: 'public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) { super.restoreStateFromViewItem(originalViewItem); if (originalViewItem instanceof HostNetworkInterfaceBondedListViewItem) { HostNetworkInterfaceBondedListViewItem original = (HostNetworkInterfaceBondedListViewItem) originalViewItem; <START> setSlavesExpanded(original.getSlavesState()); <END> \/\/ Nit-pick: typecast inlined here, avoiding explicit \"original\" variable declaration, needed here } }'","output":"public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) { super.restoreStateFromViewItem(originalViewItem); if (originalViewItem instanceof HostNetworkInterfaceBondedListViewItem) { setSlavesExpanded(((HostNetworkInterfaceBondedListViewItem) originalViewItem).getSlavesState()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Deprecate setConnectionId instead of setAsString call super.setId method avoid duplication'\nThe code is: '<START> public void setConnectionId(String connectionId) { <END> \/\/ Deprecate setConnectionId instead of setAsString call super.setId method avoid duplication setAsString(AtomXPath.id, connectionId); }'","output":"public void setConnectionId(String connectionId) { super.setId(connectionId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'returning wrong type - return CreateEcKeyOptions'\nThe code is: '<START> public CreateKeyOptions setEnabled(Boolean enabled) { <END> \/\/ returning wrong type - return CreateEcKeyOptions super.setEnabled(enabled); return this; }'","output":"public CreateEcKeyOptions setEnabled(Boolean enabled) { super.setEnabled(enabled); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I rewrite this java import javax.ws.rs.core.Response.Status; ... chain.doFilter(request, resp); Status status = Status.fromStatusCode(resp.getStatus()); if (status.getFamily() == Status.Family.SUCCESSFUL) { eventSinkProvider.get().sendEvents(); } else { log.debug(\"Request failed, skipping event sending, status={}\", status); } (It's do == Enums equals() if desired) if want stick integers, store status integer if isDebugEnabled() block'\nThe code is: 'public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { TeeHttpServletResponse resp = new TeeHttpServletResponse( (HttpServletResponse) response); chain.doFilter(request, resp); if (resp.getStatus() >= 200 && resp.getStatus() < 300) { eventSinkProvider.get().sendEvents(); } else { if (log.isDebugEnabled()) { log.debug(\"Request failed, skipping event sending, status=\" + resp.getStatus()); <START> } <END> \/\/ I rewrite this java import javax.ws.rs.core.Response.Status; ... chain.doFilter(request, resp); Status status = Status.fromStatusCode(resp.getStatus()); if (status.getFamily() == Status.Family.SUCCESSFUL) { eventSinkProvider.get().sendEvents(); } else { log.debug(\"Request failed, skipping event sending, status={}\", status); } (It's do == Enums equals() if desired) if want stick integers, store status integer if isDebugEnabled() block } }'","output":"public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { TeeHttpServletResponse resp = new TeeHttpServletResponse( (HttpServletResponse) response); chain.doFilter(request, resp); Status status = Status.fromStatusCode(resp.getStatus()); if (status.getFamily() == Status.Family.SUCCESSFUL) { eventSinkProvider.get().sendEvents(); } else { log.debug(\"Request failed, skipping event sending, status={}\", status); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I assume behavior ExportVmCommand. Do need this'\nThe code is: 'protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) { for (DiskImage disk : disks) { ActionReturnValue vdcRetValue = runInternalActionWithTasksContext( ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID)); if (!vdcRetValue.getSucceeded()) { throw new EngineException(vdcRetValue.getFault().getError(), \"Failed to copy disk!\"); } <START> getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList()); <END> \/\/ I assume behavior ExportVmCommand. Do need this } }'","output":"protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) { for (DiskImage disk : disks) { ActionReturnValue vdcRetValue = runInternalActionWithTasksContext( ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID)); if (!vdcRetValue.getSucceeded()) { throw new EngineException(vdcRetValue.getFault().getError(), \"Failed to copy disk!\"); } getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is a thread safe implement a singleton. explain point: <LINK_0>'\nThe code is: 'public static IntegrationTestInitService getInstance() { if (service == null) { service = new IntegrationTestInitService(); <START> } <END> \/\/ is a thread safe implement a singleton. explain point: <LINK_0> return service; }'","output":"public static IntegrationTestInitService getInstance() { return service; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This in update()? is simplified put inline update() then, remove this method'\nThe code is: 'private FBO getFbo() { <START> return frameBuffersManager.get(fboName); <END> \/\/ This in update()? is simplified put inline update() then, remove this method }'","output":"private FBO getFbo() { return fboManager.get(fboName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor typo : normalized instead of normilized'\nThe code is: 'public static String getNormalizedString(String input) { int end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); <START> String normilizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); <END> \/\/ minor typo : normalized instead of normilized return normilizedString; }'","output":"public static String getNormalizedString(String input) { int end = Math.min(input.length(), MAX_CHARS - 1); String stringLessThan63chars = input.substring(0, end); String normalizedString = removeSpecialCharactersInTheEnd(stringLessThan63chars); return normalizedString; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If is specific reason, constructor private'\nThe code is: '<START> SQLiteLimits(int id) { <END> \/\/ If is specific reason, constructor private this.id = id; }'","output":"private SQLiteLimits(int id) { this.id = id; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'optional: this more readable \"import static\"'\nThe code is: 'FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = <START> Objects.requireNonNull(wantIds); <END> \/\/ optional: this more readable \"import static\" this.depth = depth; this.clientShallowCommits = Objects .requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = Objects.requireNonNull(clientCapabilities); }'","output":"FetchRequest(@NonNull Set<ObjectId> wantIds, int depth, @NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit, @NonNull Set<String> clientCapabilities) { this.wantIds = requireNonNull(wantIds); this.depth = depth; this.clientShallowCommits = requireNonNull(clientShallowCommits); this.filterBlobLimit = filterBlobLimit; this.clientCapabilities = requireNonNull(clientCapabilities); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'needed'\nThe code is: 'public SecurityConfig(String[] authIdsForHooks, String[] authIdsForRoots) { <START> super(); <END> \/\/ needed this.authIdsForHookExecution = authIdsForHooks; this.authIdsForRootInstallation = authIdsForRoots; }'","output":"public SecurityConfig(String[] authIdsForHooks, String[] authIdsForRoots) { this.authIdsForHookExecution = authIdsForHooks; this.authIdsForRootInstallation = authIdsForRoots; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'close'\nThe code is: 'private Slice toSlice(Object object) { kryo.writeClassAndObject(serializationBuffer, object); <START> serializationBuffer.close(); <END> \/\/ close return serializationBuffer.toSlice(); }'","output":"private Slice toSlice(Object object) { kryo.writeClassAndObject(serializationBuffer, object); return serializationBuffer.toSlice(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'normalized.toString().isEmpty() working'\nThe code is: 'public static boolean isEmpty(Path path) { Objects.requireNonNull(path, \"The given path must not be null\"); Path normalized = path.normalize(); <START> return normalized.getNameCount() == 1 && normalized.toString().equals(\"\"); <END> \/\/ normalized.toString().isEmpty() working }'","output":"public static boolean isEmpty(Path path) { Objects.requireNonNull(path, \"The given path must not be null\"); Path normalized = path.normalize(); return normalized.getNameCount() == 1 && normalized.toString().isEmpty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this consistent line 40 (getInt getLong)'\nThe code is: 'public Collection<ArtifactToken> getArtifactsFromQuery(String query, Object... data) { List<ArtifactId> ids = new LinkedList<>(); <START> jdbcService.getClient().runQuery(stmt -> ids.add(ArtifactId.valueOf(stmt.getInt(\"art_id\"))), query, data); <END> \/\/ this consistent line 40 (getInt getLong) return services.getQueryService().getArtifacts(ids, services.getAtsBranch()); }'","output":"public Collection<ArtifactToken> getArtifactsFromQuery(String query, Object... data) { List<ArtifactId> ids = new LinkedList<>(); jdbcService.getClient().runQuery(stmt -> ids.add(ArtifactId.valueOf(stmt.getLong(\"art_id\"))), query, data); return services.getQueryService().getArtifacts(ids, services.getAtsBranch()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this protected well'\nThe code is: '<START> public EditingDomain <END> \/\/ this protected well getEditingDomainForContainment() { return actionContext.getEditingDomain(); }'","output":"protected EditingDomain getEditingDomainForContainment() { return actionContext.getEditingDomain(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: call eligibleForLoad(currInterval, interval) for easier code maintenance'\nThe code is: 'public static boolean eligibleForLoad(Period period, Interval interval, DateTime referenceTimestamp) { final Interval currInterval = new Interval(period, referenceTimestamp); <START> return currInterval.overlaps(interval); <END> \/\/ nit: call eligibleForLoad(currInterval, interval) for easier code maintenance }'","output":"public static boolean eligibleForLoad(Period period, Interval interval, DateTime referenceTimestamp) { final Interval currInterval = new Interval(period, referenceTimestamp); return eligibleForLoad(currInterval, interval); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'passing this superclass constructor, a superclass manage lifecycle of this variable? CryptographyAsyncClient a protected method getKeyId() get this key id'\nThe code is: 'KeyEncryptionKeyAsyncClient(String keyId, HttpPipeline pipeline, CryptographyServiceVersion version) { super(keyId, pipeline, version); <START> this.keyId = keyId; <END> \/\/ passing this superclass constructor, a superclass manage lifecycle of this variable? CryptographyAsyncClient a protected method getKeyId() get this key id }'","output":"KeyEncryptionKeyAsyncClient(String keyId, HttpPipeline pipeline, CryptographyServiceVersion version) { super(keyId, pipeline, version); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is wrong, entry.getValue()'\nThe code is: 'public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (operations.get(entry.getKey()).contains(name)) { <END> \/\/ This is wrong, entry.getValue() return true; } } } return false; }'","output":"public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { if (entry.getValue().contains(name)) { return true; } } } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'extra careful hurt is need check for null this point. For simplicity's sake, recommend removing check is semantic in it. I step remove null-check line 136 (radioButton.setChecked(mSelectedRole.equalsIgnoreCase(role)) reversing equals role.equalsIgnoreCase(mSelectedRole) role is expected null. Cheers'\nThe code is: 'public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); String role = mRoleListAdapter.getSelectedRole(); <START> if (role != null) { <END> \/\/ extra careful hurt is need check for null this point. For simplicity's sake, recommend removing check is semantic in it. I step remove null-check line 136 (radioButton.setChecked(mSelectedRole.equalsIgnoreCase(role)) reversing equals role.equalsIgnoreCase(mSelectedRole) role is expected null. Cheers outState.putString(ROLE_TAG, role); } }'","output":"public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); String role = mRoleListAdapter.getSelectedRole(); outState.putString(ROLE_TAG, role); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please delegate other constructor this(name, false); in constructor body'\nThe code is: 'public AccessContext(IASTName name) { this.name = name; <START> this.isPrefixLookup = false; <END> \/\/ Please delegate other constructor this(name, false); in constructor body }'","output":"public AccessContext(IASTName name) { this(name, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fail(); in onSuccess()'\nThe code is: 'public void getInstanceAsync_nonLooperThreadShouldThrow() { DynamicRealm.getInstanceAsync(defaultConfig, new DynamicRealm.Callback() { @Override public void onSuccess(DynamicRealm realm) { <START> } <END> \/\/ fail(); in onSuccess() }); }'","output":"public void getInstanceAsync_nonLooperThreadShouldThrow() { DynamicRealm.getInstanceAsync(defaultConfig, new DynamicRealm.Callback() { @Override public void onSuccess(DynamicRealm realm) { fail(); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Missing super() call'\nThe code is: 'public <START> CommonTargetToModelUpdateStrategy(VElement <END> \/\/ Missing super() call vElement, EStructuralFeature eStructuralFeature) { this.vElement = vElement; this.eStructuralFeature = eStructuralFeature; }'","output":"public CommonTargetToModelUpdateStrategy(VElement vElement, EStructuralFeature eStructuralFeature) { super(POLICY_UPDATE); this.vElement = vElement; this.eStructuralFeature = eStructuralFeature; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need creating new instance of validatorLocator for new sub-resource\/subcollection, reuse instance defined in BackendApplication adding [resource.setValidatorLocator(X);] in AbstractBackendResource.inject(). - inject context ('backend', etc.) in sub-resource\/subcollection,'\nThe code is: 'protected ValidatorLocator getValidatorLocator() { if (validatorLocator == null) { validatorLocator = new ValidatorLocator(); <START> validatorLocator.populate(); <END> \/\/ do need creating new instance of validatorLocator for new sub-resource\/subcollection, reuse instance defined in BackendApplication adding [resource.setValidatorLocator(X);] in AbstractBackendResource.inject(). - inject context ('backend', etc.) in sub-resource\/subcollection, } return validatorLocator; }'","output":"protected ValidatorLocator getValidatorLocator() { return validatorLocator; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is java participantStatus.name() overridden toString() can'\nThe code is: 'public void writeTo(ParticipantStatus participantStatus, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException { <START> entityStream.write(participantStatus.toString().getBytes()); <END> \/\/ is java participantStatus.name() overridden toString() can }'","output":"public void writeTo(ParticipantStatus participantStatus, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException { entityStream.write(participantStatus.name().getBytes()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this super call needed here'\nThe code is: 'public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final int port) { <START> super(); <END> \/\/ Is this super call needed here this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }'","output":"public Iec61850MockServerMarkerWadden(final String serverName, final String icdFilename, final int port) { this.serverName = serverName; this.icdFilename = icdFilename; this.port = port; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'visibility increased public'\nThe code is: '<START> public static int getTransactionId(long operationId) { <END> \/\/ visibility increased public return (int) (operationId >>> LOG_ID_BITS); }'","output":"static int getTransactionId(long operationId) { return (int) (operationId >>> LOG_ID_BITS); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is a specific reason for naming fields variables in Configuration class snake case, i.e., _'s instead of camel case? If not, please rename camel case.'\nThe code is: 'public static ImmutableStorageProvider getStorageProvider(ImmutableStorageProviderFactory.AvailableImmutableStorages desiredProvider, AccountabilityConfigurationObject configuration) { if (Objects.isNull(storageProvider)) { switch (desiredProvider) { case SWARM: <START> storageProvider = new SwarmProvider(configuration.getSwarm_gateway_url()); <END> \/\/ Is a specific reason for naming fields variables in Configuration class snake case, i.e., _'s instead of camel case? If not, please rename camel case. break; case TEST: default: storageProvider = new SwarmProvider(\"<LINK_0>\"); break; } } return storageProvider; }'","output":"public static ImmutableStorageProvider getStorageProvider(ImmutableStorageProviderFactory.AvailableImmutableStorages desiredProvider, AccountabilityConfigurationObject configuration) { if (Objects.isNull(storageProvider)) { switch (desiredProvider) { case SWARM: storageProvider = new SwarmProvider(configuration.getSwarmGatewayUrl()); break; case TEST: default: storageProvider = new SwarmProvider(\"<LINK_0>\"); break; } } return storageProvider; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IllegalStateException is unchecked exception, is required define method throwing this type of exception'\nThe code is: '<START> protected void checkInitialized() throws IllegalStateException { <END> \/\/ IllegalStateException is unchecked exception, is required define method throwing this type of exception if (terminated) { throw new IllegalStateException(\"This SmartProxy instance has been terminated and cannot be used any more.\"); } if (!initialized) { throw new IllegalStateException(\"This SmartProxy instance has not been initialized.\"); } }'","output":"protected void checkInitialized() { if (terminated) { throw new IllegalStateException(\"This SmartProxy instance has been terminated and cannot be used any more.\"); } if (!initialized) { throw new IllegalStateException(\"This SmartProxy instance has not been initialized.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this throw a ParseException, throw (no pokemon catching)'\nThe code is: '<START> private AbstractBackupPath getAbstractBackupPath(final File file, final BackupFileType type) throws Exception { <END> \/\/ I this throw a ParseException, throw (no pokemon catching) final AbstractBackupPath bp = pathFactory.get(); bp.parseLocal(file, type); return bp; }'","output":"private AbstractBackupPath getAbstractBackupPath(final File file, final BackupFileType type) throws ParseException { final AbstractBackupPath bp = pathFactory.get(); bp.parseLocal(file, type); return bp; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is needed if handles exception in other method'\nThe code is: 'public static <T> Class<? extends T> defineClass(ClassDefinition classDefinition, Class<T> superType, Map<Long, MethodHandle> callSiteBindings, ClassLoader parentClassLoader) { <START> try { <END> \/\/ This is needed if handles exception in other method return defineClass(classDefinition, superType, new DynamicClassLoader(parentClassLoader, callSiteBindings)); } catch (ByteCodeTooLargeException byteCodeTooLargeException) { throw new PrestoException(GENERATED_BYTECODE_TOO_LARGE, ERROR_LARGE_BYTECODE); } }'","output":"public static <T> Class<? extends T> defineClass(ClassDefinition classDefinition, Class<T> superType, Map<Long, MethodHandle> callSiteBindings, ClassLoader parentClassLoader) { return defineClass(classDefinition, superType, new DynamicClassLoader(parentClassLoader, callSiteBindings)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reference variable **USER_DIRECTORY** a String of \"USER_DIRECTORY\"'\nThe code is: 'public void testNullPathWithRoot() { AbsolutePathResolver apr = new AbsolutePathResolver(null); <START> assertThat(apr.getPath(\"USER_DIRECTORY\"), nullValue()); <END> \/\/ reference variable **USER_DIRECTORY** a String of \"USER_DIRECTORY\" }'","output":"public void testNullPathWithRoot() { AbsolutePathResolver apr = new AbsolutePathResolver(null); assertThat(apr.getPath(USER_DIRECTORY), nullValue()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion this.gatewayMap.values().forEach(MethodInvocationGateway::destroy); do live this before? consider back-port a bug? is a consequence this destroy()'\nThe code is: 'public void destroy() { <START> this.gatewayMap.values().forEach(gw -> gw.destroy()); <END> \/\/ suggestion this.gatewayMap.values().forEach(MethodInvocationGateway::destroy); do live this before? consider back-port a bug? is a consequence this destroy() }'","output":"public void destroy() { this.gatewayMap.values().forEach(MethodInvocationGateway::destroy); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: of methods package-private class is package-private well. This ensures expose mistake some point'\nThe code is: '<START> public static UnixResolverOptions.Builder newBuilder() { <END> \/\/ nit: of methods package-private class is package-private well. This ensures expose mistake some point return new UnixResolverOptions.Builder(); }'","output":"static UnixResolverOptions.Builder newBuilder() { return new UnixResolverOptions.Builder(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: space if ('\nThe code is: 'private QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) { this.id = id; this.addr = addr; this.electionAddr = electionAddr; this.type = type; String checkIPReachableValue = System.getProperty(\"zookeeper.checkIPTimeout\"); <START> if(checkIPReachableValue != null){ <END> \/\/ nit: space if ( this.checkIPReachableTO = Integer.parseInt(checkIPReachableValue); } }'","output":"private QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) { this.id = id; this.addr = addr; this.electionAddr = electionAddr; this.type = type; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Objects.equal(f.testTagFilter, testTagFilter) (it handles null)'\nThe code is: 'public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof TestFilter)) { return false; } TestFilter f = (TestFilter) o; return f.testSizeFilterSet.equals(testSizeFilterSet) && f.testTimeoutFilterSet.equals(testTimeoutFilterSet) <START> && (f.testTagFilter == null && testTagFilter == null <END> \/\/ Objects.equal(f.testTagFilter, testTagFilter) (it handles null) || f.testTagFilter != null && f.testTagFilter.equals(testTagFilter)) && f.testLangFilterList.equals(testLangFilterList); }'","output":"public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof TestFilter)) { return false; } TestFilter f = (TestFilter) o; return f.testSizeFilterSet.equals(testSizeFilterSet) && f.testTimeoutFilterSet.equals(testTimeoutFilterSet) && Objects.equals(f.testTagFilter, testTagFilter) && f.testLangFilterList.equals(testLangFilterList); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this'\nThe code is: 'public void setTimestamp(long timestamp) { <START> this.fTimestamp = timestamp; <END> \/\/ this }'","output":"public void setTimestamp(long timestamp) { fTimestamp = timestamp; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this necessary? If I remove update line work'\nThe code is: 'private void setNotFoundBackgroundColor() { patternField.setData(CCS_CLASS_KEY, NO_RESULTS_CLASS); patternField.reskin(SWT.ALL); <START> patternField.update(); <END> \/\/ Is this necessary? If I remove update line work noResults = true; }'","output":"private void setNotFoundBackgroundColor() { patternField.setData(CCS_CLASS_KEY, NO_RESULTS_CLASS); patternField.reskin(SWT.ALL); noResults = true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'be: java public int hashCode() { return this.delegate.hashCode(); }'\nThe code is: '<START> public int hashCode() { <END> \/\/ be: java public int hashCode() { return this.delegate.hashCode(); } int hash = 1; final int prime = 31; hash = hash * prime + (int) (delegate.hashCode()); return hash; }'","output":"public int hashCode() { return this.delegate.hashCode(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove MiddlewareQueryException'\nThe code is: '<START> List<GermplasmList> retrieveAndValidateIfHasGermplasmList(Integer studyId) throws MiddlewareQueryException, <END> \/\/ Remove MiddlewareQueryException CrossingTemplateExportException { List<GermplasmList> crossesList = this.fieldbookMiddlewareService.getGermplasmListsByProjectId(studyId, GermplasmListType.NURSERY); if (crossesList.isEmpty()) { throw new CrossingTemplateExportException(\"study.export.crosses.no.germplasm.list.available\"); } return crossesList; }'","output":"List<GermplasmList> retrieveAndValidateIfHasGermplasmList(Integer studyId) throws CrossingTemplateExportException { List<GermplasmList> crossesList = this.fieldbookMiddlewareService.getGermplasmListsByProjectId(studyId, GermplasmListType.NURSERY); if (crossesList.isEmpty()) { throw new CrossingTemplateExportException(\"study.export.crosses.no.germplasm.list.available\"); } return crossesList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wondering if return \"true\" here. Wdyt'\nThe code is: 'private void checkIfUsernameCanBeChanged() { AccountModel account = mAccountStore.getAccount(); mUsernamePreference.setEnabled(account.getUsernameCanBeChanged()); mUsernamePreference.setOnPreferenceClickListener(preference -> { showUsernameChangerFragment(); <START> return false; <END> \/\/ wondering if return \"true\" here. Wdyt }); }'","output":"private void checkIfUsernameCanBeChanged() { AccountModel account = mAccountStore.getAccount(); mUsernamePreference.setEnabled(account.getUsernameCanBeChanged()); mUsernamePreference.setOnPreferenceClickListener(preference -> { showUsernameChangerFragment(); return true; }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'i this is existing pattern feels weird this returns null empty list, especially provider.senders() method logic return empty list is enabled'\nThe code is: 'public List<String> getPubsubPrefixes() { final List<String> pubsubPrefixes = options.getList(pubsubTopicPrefixArg.getDest()); <START> return pubsubPrefixes.isEmpty() ? null : pubsubPrefixes; <END> \/\/ i this is existing pattern feels weird this returns null empty list, especially provider.senders() method logic return empty list is enabled }'","output":"public List<String> getPubsubPrefixes() { return options.getList(pubsubTopicPrefixArg.getDest()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I of UncheckedIOException earlier. here'\nThe code is: 'public void close() { try { reader.close(); } catch (IOException e) { <START> throw new RuntimeException(e); <END> \/\/ I of UncheckedIOException earlier. here } }'","output":"public void close() { try { reader.close(); } catch (IOException e) { throw new UncheckedIOException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: cacheManager is null'\nThe code is: 'public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, \"inputStream is null\"); <START> this.cacheManager = requireNonNull(cacheManager, \"cachingFileSystem is null\"); <END> \/\/ nit: cacheManager is null this.path = requireNonNull(path, \"path is null\"); this.cacheValidationEnabled = cacheValidationEnabled; }'","output":"public CachingInputStream( FSDataInputStream inputStream, CacheManager cacheManager, Path path, boolean cacheValidationEnabled) { super(inputStream); this.inputStream = requireNonNull(inputStream, \"inputStream is null\"); this.cacheManager = requireNonNull(cacheManager, \"cacheManager is null\"); this.path = requireNonNull(path, \"path is null\"); this.cacheValidationEnabled = cacheValidationEnabled; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '1ms=10^6ns'\nThe code is: 'public synchronized boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { long now = System.nanoTime(); long end = now + unit.toNanos(timeout); while (!isTerminated() && (end - now) > 0L) { <START> wait((end - now) \/ 1000L); <END> \/\/ 1ms=10^6ns now = System.nanoTime(); } return isTerminated(); }'","output":"public synchronized boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { long now = System.nanoTime(); long end = now + unit.toNanos(timeout); while (!isTerminated() && (end - now) > 0L) { wait(TimeUnit.NANOSECONDS.toMillis(end - now)); now = System.nanoTime(); } return isTerminated(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reduce debug'\nThe code is: 'public void handleCommand(ChannelUID channelUID, Command command) { if (command instanceof RefreshType) { logger.debug(\"Refreshing channel {}\", channelUID); coapClient.asyncGet(this); return; } <START> logger.warn(\"The controller is a read-only device and cannot handle commands.\"); <END> \/\/ reduce debug }'","output":"public void handleCommand(ChannelUID channelUID, Command command) { if (command instanceof RefreshType) { logger.debug(\"Refreshing channel {}\", channelUID); coapClient.asyncGet(this); return; } logger.debug(\"The controller is a read-only device and cannot handle commands.\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Extract this a setUp method in a test _originalProperties_ a field'\nThe code is: 'public void resolvePropertiesNotSetAndOverrideTrue() { <START> Map<String, String> originalProperties = new HashMap<>(); <END> \/\/ Extract this a setUp method in a test _originalProperties_ a field originalProperties.put(\"foo\", \"bar\"); Map<String, String> resolvedProperties = cloudHubArtifactDeployer.resolveProperties(originalProperties, null, true); assertThat(\"originalProperties should have the same size\", resolvedProperties.size(), equalTo(1)); assertThat(\"resolvedProperties should contains the (foo,bar) entry\", resolvedProperties, hasEntry(\"foo\", \"bar\")); }'","output":"public void resolvePropertiesNotSetAndOverrideTrue() { Map<String, String> resolvedProperties = cloudHubArtifactDeployer.resolveProperties(originalProperties, null, true); assertThat(\"originalProperties should have the same size\", resolvedProperties.size(), equalTo(1)); assertThat(\"resolvedProperties should contains the (foo,bar) entry\", resolvedProperties, hasEntry(\"foo\", \"bar\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is problem of keeping throws XmlPullParserException'\nThe code is: '<START> public Iterable<Result<Upload>> listIncompleteUploads(String bucketName, String prefix) { <END> \/\/ is problem of keeping throws XmlPullParserException return listIncompleteUploads(bucketName, prefix, true, true); }'","output":"public Iterable<Result<Upload>> listIncompleteUploads(String bucketName, String prefix) throws XmlPullParserException { return listIncompleteUploads(bucketName, prefix, true, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check for null is needed instanceof operator: \"When instanceof operator, in mind null is instance of anything.\" (<LINK_0>'\nThe code is: 'public boolean equals(Object obj) { <START> if (obj == null) <END> \/\/ check for null is needed instanceof operator: \"When instanceof operator, in mind null is instance of anything.\" (<LINK_0> return false; if (!(obj instanceof XBee64BitAddress)) return false; XBee64BitAddress addr = (XBee64BitAddress)obj; return Arrays.equals(addr.getValue(), getValue()); }'","output":"public boolean equals(Object obj) { if (!(obj instanceof XBee64BitAddress)) return false; XBee64BitAddress addr = (XBee64BitAddress)obj; return Arrays.equals(addr.getValue(), getValue()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I tell, this removed. I missing something'\nThe code is: 'public void setUp() throws Exception { activityActivityTestRule.getActivity() <START> .getSupportFragmentManager().beginTransaction(); <END> \/\/ I tell, this removed. I missing something context = getInstrumentation().getTargetContext(); }'","output":"public void setUp() throws Exception { context = getInstrumentation().getTargetContext(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instead of printing system output stream, a proper logger'\nThe code is: 'public void handleTask(Task task) throws InterruptedException { var time = task.getTime(); Thread.sleep(time); <START> System.out.println(\"It takes \" + time + \" milliseconds to finish the task\"); <END> \/\/ Instead of printing system output stream, a proper logger task.setFinished(); }'","output":"public void handleTask(Task task) throws InterruptedException { var time = task.getTime(); Thread.sleep(time); LOGGER.info(\"It takes \" + time + \" milliseconds to finish the task\"); task.setFinished(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion Table<?> table = (Table<?>) visit(context.alterTableDefinition()); return new DropCheckConstraint<>(table, getIdentText(context.ident()));'\nThe code is: 'public Node visitDropCheckConstraint(SqlBaseParser.DropCheckConstraintContext context) { <START> Table table = (Table) visit(context.alterTableDefinition()); StringLiteral ident = (StringLiteral) visit(context.ident()); return new DropCheckConstraint<>(table, ident.getValue()); <END> \/\/ suggestion Table<?> table = (Table<?>) visit(context.alterTableDefinition()); return new DropCheckConstraint<>(table, getIdentText(context.ident())); }'","output":"public Node visitDropCheckConstraint(SqlBaseParser.DropCheckConstraintContext context) { Table<?> table = (Table<?>) visit(context.alterTableDefinition()); return new DropCheckConstraint<>(table, getIdentText(context.ident())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Override this line'\nThe code is: '<START> public String mimeType() { <END> \/\/ @Override this line return \"multipart\/form-data; boundary=\" + boundary; }'","output":"@Override public String mimeType() { return \"multipart\/form-data; boundary=\" + boundary; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'moved Java 7, a single catch block IOException | RuntimeException'\nThe code is: 'public void skip() { try { in.skipFully(length); <START> } catch (IOException e) { <END> \/\/ moved Java 7, a single catch block IOException | RuntimeException throw new ParquetDecodingException(\"could not skip bytes at offset \" + in.position(), e); } catch (RuntimeException e) { throw new ParquetDecodingException(\"could not skip bytes at offset \" + in.position(), e); } }'","output":"public void skip() { try { in.skipFully(length); } catch (IOException | RuntimeException e) { throw new ParquetDecodingException(\"could not skip bytes at offset \" + in.position(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: drop else this if (..) { ...} throw new .'\nThe code is: 'public NavigableMap<byte[], List<Cell>> getFamilyCellMap() { if (action instanceof Mutation) { return ((Mutation) action).getFamilyCellMap(); <START> } else { <END> \/\/ nit: drop else this if (..) { ...} throw new . throw new UnsupportedOperationException(); } }'","output":"public NavigableMap<byte[], List<Cell>> getFamilyCellMap() { if (action instanceof Mutation) { return ((Mutation) action).getFamilyCellMap(); } throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need \"== true\", a boolean :-)'\nThe code is: 'private boolean validateHostsConnectionResults(List<Pair<Guid, Boolean>> hostsConnectionResults) { for (Pair<Guid, Boolean> hostsConnectionResult : hostsConnectionResults) { <START> if (hostsConnectionResult.getSecond() == true) { <END> \/\/ need \"== true\", a boolean :-) return true; } } return false; }'","output":"private boolean validateHostsConnectionResults(List<Pair<Guid, Boolean>> hostsConnectionResults) { for (Pair<Guid, Boolean> hostsConnectionResult : hostsConnectionResults) { if (hostsConnectionResult.getSecond()) { return true; } } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java closer.register(directReader::close); closer.register(dictionaryReader::close);'\nThe code is: 'public void close() { try (Closer closer = Closer.create()) { <START> closer.register(() -> directReader.close()); <END> \/\/ java closer.register(directReader::close); closer.register(dictionaryReader::close); closer.register(() -> dictionaryReader.close()); } catch (IOException e) { throw new UncheckedIOException(e); } }'","output":"public void close() { try (Closer closer = Closer.create()) { closer.register(directReader::close); closer.register(dictionaryReader::close); } catch (IOException e) { throw new UncheckedIOException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is reason for appending 1 variable name'\nThe code is: 'public void getOrderGroupsByPatient_shouldGetOrderGroupsGivenPatient() { Patient existingPatient1 = Context.getPatientService().getPatient(8); <START> List<OrderGroup> ordergroups1 = Context.getOrderService().getOrderGroupsByPatient(existingPatient1); <END> \/\/ is reason for appending 1 variable name assertEquals(1, ordergroups1.size()); }'","output":"public void getOrderGroupsByPatient_shouldGetOrderGroupsGivenPatient() { Patient existingPatient = Context.getPatientService().getPatient(8); List<OrderGroup> ordergroups = Context.getOrderService().getOrderGroupsByPatient(existingPatient); assertEquals(1, ordergroups.size()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Check for equality of error code'\nThe code is: 'public void testSaveNullId() throws Exception { Document expectedDocument = new Document(); expectedDocument.setId(null); expectedDocument.setTimestamp(System.currentTimeMillis()); JsonNode data = mapper.valueToTree(Collections.singletonMap(\"TEST_NAME\", \"SINGLE_SAVE_TEST\")); expectedDocument.setData(data); <START> queryStore.save(TestUtils.TEST_TABLE_NAME, expectedDocument); <END> \/\/ Check for equality of error code }'","output":"public void testSaveNullId() throws Exception { Document expectedDocument = new Document(); expectedDocument.setId(null); expectedDocument.setTimestamp(System.currentTimeMillis()); JsonNode data = mapper.valueToTree(Collections.singletonMap(\"TEST_NAME\", \"SINGLE_SAVE_TEST\")); expectedDocument.setData(data); try { queryStore.save(TestUtils.TEST_TABLE_NAME, expectedDocument); } catch (QueryStoreException e) { assertEquals(QueryStoreException.ErrorCode.INVALID_REQUEST, e.getErrorCode()); throw e; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return Integer.toString(index); is more idiomatic'\nThe code is: 'public static String getContainerId(int index) { <START> return \"\" + index; <END> \/\/ return Integer.toString(index); is more idiomatic }'","output":"public static String getContainerId(int index) { return Integer.toString(index); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'LinkedHashSet predictable debugging easier'\nThe code is: 'public MergedSelectionSet collectFields(FieldCollectorParameters parameters, MergedField mergedField) { Map<String, MergedField> subFields = new LinkedHashMap<>(); <START> Set<String> visitedFragments = new HashSet<>(); <END> \/\/ LinkedHashSet predictable debugging easier for (Field field : mergedField.getFields()) { if (field.getSelectionSet() == null) { continue; } this.collectFields(parameters, field.getSelectionSet(), visitedFragments, subFields); } return newMergedSelectionSet().subFields(subFields).build(); }'","output":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, MergedField mergedField) { Map<String, MergedField> subFields = new LinkedHashMap<>(); Set<String> visitedFragments = new LinkedHashSet<>(); for (Field field : mergedField.getFields()) { if (field.getSelectionSet() == null) { continue; } this.collectFields(parameters, field.getSelectionSet(), visitedFragments, subFields); } return newMergedSelectionSet().subFields(subFields).build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above: LinkedHashSet predictable debugging easier'\nThe code is: 'public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedField> subFields = new LinkedHashMap<>(); <START> Set<String> visitedFragments = new HashSet<>(); <END> \/\/ above: LinkedHashSet predictable debugging easier this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }'","output":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedField> subFields = new LinkedHashMap<>(); Set<String> visitedFragments = new LinkedHashSet<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java.util.Objects.hashcode instead of checking for null'\nThe code is: 'public int hashCode() { final int prime = 31; int result = super.hashCode(); <START> result = prime * result + ((this.helper == null) ? 0 : this.helper.hashCode()); <END> \/\/ java.util.Objects.hashcode instead of checking for null return result; }'","output":"public int hashCode() { return super.hashCode() + Objects.hash(this.helper); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please create a new list call of getDifferences(), create list once, e.g., call, return instance. want UnmodifiableEList instead, fail early, if modify it'\nThe code is: 'public EList<Diff> getDifferences() { <START> return new BasicEList<Diff>(this.diffs); <END> \/\/ Please create a new list call of getDifferences(), create list once, e.g., call, return instance. want UnmodifiableEList instead, fail early, if modify it }'","output":"public EList<Diff> getDifferences() { return this.diffs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I guess Arrays.equals is choice'\nThe code is: 'public boolean equals(Object o) { if (!(o instanceof OSCoreCtx)) { return false; } OSCoreCtx other = (OSCoreCtx) o; <START> return other.sender_id.equals(sender_id) && other.recipient_id.equals(recipient_id); <END> \/\/ I guess Arrays.equals is choice }'","output":"public boolean equals(Object o) { if (!(o instanceof OSCoreCtx)) { return false; } OSCoreCtx other = (OSCoreCtx) o; return Arrays.equals(other.sender_id, sender_id) && Arrays.equals(other.recipient_id, recipient_id); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this set in ui binder file need do in localize (we do this due DynamicMessages)'\nThe code is: 'void localize() { applicationTitle.setText(dynamicMessages.applicationTitle()); copyrightNotice.setText(dynamicMessages.copyRightNotice()); versionLabel.setText(dynamicMessages.ovirtVersionAbout()); <START> userNameLabel.setText(constants.userNameAboutLabel()); <END> \/\/ this set in ui binder file need do in localize (we do this due DynamicMessages) }'","output":"void localize() { applicationTitle.setText(dynamicMessages.applicationTitle()); copyrightNotice.setText(dynamicMessages.copyRightNotice()); versionLabel.setText(dynamicMessages.ovirtVersionAbout()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertThat(conf).isNotEmpty(); is shorter error messages. 7x in this PR: CTRL + f \"isEmpty()).isFalse()\"'\nThe code is: 'public void loadEnvironmentConfig() { ConfigurationStrategy strategy = new ConfigurationEnvironmentStrategy(); Map<ConfigurationKey, String> conf = strategy.loadConfiguration(); assertThat(conf).isEmpty(); strategy = new ConfigurationEnvironmentStrategy(getMapForEnv()); conf = strategy.loadConfiguration(); <START> assertThat(conf.isEmpty()).isFalse(); <END> \/\/ assertThat(conf).isNotEmpty(); is shorter error messages. 7x in this PR: CTRL + f \"isEmpty()).isFalse()\" assertThat(strategy.isValid()).isTrue(); assertThat(conf.keySet()).hasSize(14); }'","output":"public void loadEnvironmentConfig() { ConfigurationStrategy strategy = new ConfigurationEnvironmentStrategy(); Map<ConfigurationKey, String> conf = strategy.loadConfiguration(); assertThat(conf).isEmpty(); strategy = new ConfigurationEnvironmentStrategy(getMapForEnv()); conf = strategy.loadConfiguration(); assertThat(conf).isNotEmpty(); assertThat(strategy.isValid()).isTrue(); assertThat(conf.keySet()).hasSize(14); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This private required other class package'\nThe code is: '<START> AmqpMessageBody() { <END> \/\/ This private required other class package }'","output":"private AmqpMessageBody() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'boolean'\nThe code is: '<START> protected Boolean getInvalidConfiguration() { <END> \/\/ boolean return invalidConfiguration; }'","output":"protected boolean getInvalidConfiguration() { return invalidConfiguration; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Objects.equals too, more trend models'\nThe code is: 'public boolean equals(Object o) { if (o instanceof MITrigger) { MITrigger other = (MITrigger) o; <START> return (null != value) ? value.equals(other.value) : null == other.value; <END> \/\/ Objects.equals too, more trend models } return false; }'","output":"public boolean equals(Object o) { if (o instanceof MITrigger) { MITrigger other = (MITrigger) o; return Objects.equals(value, other.value); } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '== tests for reference equality, error-prone -- .equals() method..'\nThe code is: 'private static boolean checkForValidityOfAttributes(ArrayList<String> attributeList) { for (String str : attributeList) { <START> if (str == \"-1\") { <END> \/\/ == tests for reference equality, error-prone -- .equals() method.. return false; } } return true; }'","output":"private static boolean checkForValidityOfAttributes(ArrayList<String> attributeList) { for (String str : attributeList) { if (str.equals(\"-1\")) { return false; } } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change logic answer is true'\nThe code is: 'public boolean hasNext() { <START> if (this.peek != null) { <END> \/\/ change logic answer is true return true; } if (!this.iterator.hasNext()) { this.iterator = this.iterable.iterator(); } return this.iterator.hasNext(); }'","output":"public boolean hasNext() { return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is synchronized this lead race conditions a listener registration get lost. If simply instantiate is declared above, this happen anymore'\nThe code is: 'public void addTriggerChangeListener(TriggerChangeListener listener) { if (listeners == null) { <START> listeners = new CopyOnWriteArraySet<TriggerChangeListener>(); <END> \/\/ is synchronized this lead race conditions a listener registration get lost. If simply instantiate is declared above, this happen anymore } listeners.add(listener); }'","output":"public void addTriggerChangeListener(TriggerChangeListener listener) { listeners.add(listener); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'negative logic'\nThe code is: 'public ExtendedQueryResult<T> orderAsc(String attribute, boolean appendEntityName) { lastPaginatedQuery = null; <START> if (!context.getRepositoryMethod().isQuery()) { <END> \/\/ negative logic context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.ASC)); } else { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } return this; }'","output":"public ExtendedQueryResult<T> orderAsc(String attribute, boolean appendEntityName) { lastPaginatedQuery = null; if (context.getRepositoryMethod().isQuery()) { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } else { context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.ASC)); } return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need public (same other functions)'\nThe code is: '<START> public long getSegmentsNeeded() { <END> \/\/ need public (same other functions) return segmentsNeeded; }'","output":"long getSegmentsNeeded() { return segmentsNeeded; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'put Y acceleration (-0.03) in a named constant in class? e.g. VERTICAL_GRAVITY_ACCEL'\nThe code is: 'public GlowEnderPearl(Location location, float speed) { super(location); setDrag(0.99, false); setDrag(0.99, true); setHorizontalAirDrag(1); <START> setGravityAccel(new Vector(0, -0.03, 0)); <END> \/\/ put Y acceleration (-0.03) in a named constant in class? e.g. VERTICAL_GRAVITY_ACCEL setVelocity(location.getDirection().multiply(speed)); setBoundingBox(0.25, 0.25); }'","output":"public GlowEnderPearl(Location location, float speed) { super(location); setDrag(0.99, false); setDrag(0.99, true); setHorizontalAirDrag(1); setGravityAccel(new Vector(0, VERTICAL_GRAVITY_ACCEL, 0)); setVelocity(location.getDirection().multiply(speed)); setBoundingBox(0.25, 0.25); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'isEmpty() instead'\nThe code is: 'public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> \/\/ isEmpty() instead }'","output":"public void testGetAllInterfacesForVdsWithPermissionsForUnpriviligedUser() { List<VdsNetworkInterface> result = dao.getAllInterfacesForVds(VDS_ID, UNPRIVILEGED_USER_ID, true); assertNotNull(result); assertTrue(result.isEmpty()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'true'\nThe code is: 'private void normalizeAndCalculateStatistics() { <START> if (allNormalizationIds != null) { <END> \/\/ true normalizeIntensities(); } calculateStatistics(); }'","output":"private void normalizeAndCalculateStatistics() { normalizeIntensities(); calculateStatistics(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method written java public static void clearVisitDate(String[] selected) { setVisitDate(Arrays.asList(selected), 0); }'\nThe code is: 'public static void clearVisitDate(String[] selected) { ArrayList<String> geocodes = new ArrayList<String>(); for (int i = 0; i < selected.length; i++) { geocodes.add(selected[i]); } setVisitDate(geocodes, 0); <START> } <END> \/\/ This method written java public static void clearVisitDate(String[] selected) { setVisitDate(Arrays.asList(selected), 0); }'","output":"public static void clearVisitDate(String[] selected) { setVisitDate(Arrays.asList(selected), 0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I more understandable do following: \/\/ Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam(\"sha\", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, \"projects\", projectId, \"repository\", \"archive\", \".\", format);'\nThe code is: 'public InputStream getRepositoryArchive(Integer projectId, String sha, String format) throws GitLabApiException { Form formData = new GitLabApiForm().withParam(\"sha\", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, <START> \"projects\", projectId, \"repository\", \"archive\".concat(checkFormat(format))); <END> \/\/ I more understandable do following: \/\/ Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam(\"sha\", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, \"projects\", projectId, \"repository\", \"archive\", \".\", format); return (response.readEntity(InputStream.class)); }'","output":"public InputStream getRepositoryArchive(Integer projectId, String sha, String format) throws GitLabApiException { format = checkFormat(format); Form formData = new GitLabApiForm().withParam(\"sha\", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, \"projects\", projectId, \"repository\", \"archive\", \".\", format); return (response.readEntity(InputStream.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.uri'\nThe code is: 'public URI getUri() { <START> return uri; <END> \/\/ this.uri }'","output":"public URI getUri() { return this.uri; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need properties exist apply'\nThe code is: 'public DelegatingResourceDescription getRepresentationDescription(Representation rep) { DelegatingResourceDescription delegatingResourceDescription = new DelegatingResourceDescription(); delegatingResourceDescription.addProperty(\"fulfillerStatus\"); delegatingResourceDescription.addProperty(\"fulfillerComment\"); <START> delegatingResourceDescription.addProperty(\"uuid\"); <END> \/\/ need properties exist apply delegatingResourceDescription.addLink(\"full\", \".?v=\" + RestConstants.REPRESENTATION_FULL); delegatingResourceDescription.addSelfLink(); return delegatingResourceDescription; }'","output":"public DelegatingResourceDescription getRepresentationDescription(Representation rep) { DelegatingResourceDescription delegatingResourceDescription = new DelegatingResourceDescription(); delegatingResourceDescription.addProperty(\"fulfillerStatus\"); delegatingResourceDescription.addProperty(\"fulfillerComment\"); return delegatingResourceDescription; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(k) -> suggestion return locks.computeIfAbsent(key, -> new ReentrantLock());'\nThe code is: 'private ReentrantLock getLockForKey(Object key) { <START> return locks.computeIfAbsent(key, (k) -> new ReentrantLock()); <END> \/\/ (k) -> suggestion return locks.computeIfAbsent(key, -> new ReentrantLock()); }'","output":"private ReentrantLock getLockForKey(Object key) { return locks.computeIfAbsent(key, k -> new ReentrantLock()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Unnecessary parenthesis'\nThe code is: 'protected PreparedStatement getPreparedStatement(String query) throws SQLException { <START> return (connection.prepareStatement(query)); <END> \/\/ Unnecessary parenthesis }'","output":"protected PreparedStatement getPreparedStatement(String query) throws SQLException { return connection.prepareStatement(query); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline: java return hash.addPage(page);'\nThe code is: 'public Work<?> addPage(Page page) { <START> Work<?> work = hash.addPage(page); <END> \/\/ inline: java return hash.addPage(page); return work; }'","output":"public Work<?> addPage(Page page) { return hash.addPage(page); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return getName() nicer'\nThe code is: 'public String getDisplayName() { <START> return this.name; <END> \/\/ return getName() nicer }'","output":"public String getDisplayName() { return getName(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion initColumns.add(COL_ID_ACTIONS);'\nThe code is: 'public List<String> getExpectedInitialColumns() { List<String> initColumns = new ArrayList<String>(); initColumns.add(COL_ID_PROCESSNAME); initColumns.add(COL_ID_PROCESSVERSION); initColumns.add(COL_ID_PROJECT); <START> initColumns.add(\"Actions\"); <END> \/\/ suggestion initColumns.add(COL_ID_ACTIONS); return initColumns; }'","output":"public List<String> getExpectedInitialColumns() { List<String> initColumns = new ArrayList<String>(); initColumns.add(COL_ID_PROCESSNAME); initColumns.add(COL_ID_PROCESSVERSION); initColumns.add(COL_ID_PROJECT); initColumns.add(COL_ID_ACTIONS); return initColumns; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for avoiding putting synchronized stating in docs. another sync'd variant created builder'\nThe code is: '<START> public synchronized void setValue(int index, Object value) { <END> \/\/ for avoiding putting synchronized stating in docs. another sync'd variant created builder if (index < 0 || index >= size()) { throw new IndexOutOfBoundsException(); } values.set(index, value); }'","output":"public void setValue(int index, Object value) { if (index < 0 || index >= size()) { throw new IndexOutOfBoundsException(); } values.set(index, value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'singular is good here, IMHO'\nThe code is: 'public CloudBigtableTableConfiguration build() { return new CloudBigtableTableConfiguration(projectId, zoneId, clusterId, tableId, <START> additionalConfigurations); <END> \/\/ singular is good here, IMHO }'","output":"public CloudBigtableTableConfiguration build() { return new CloudBigtableTableConfiguration(projectId, zoneId, clusterId, tableId, additionalConfiguration); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wait, this is worse previous version. happened assertEquals()'\nThe code is: 'private void assertGetResult(VM result) { assertNotNull(result); <START> assertTrue(\"Vm db generation wasn't loaded as expected\", result.getDbGeneration() == 1); <END> \/\/ Wait, this is worse previous version. happened assertEquals() assertEquals(result, existingVm); }'","output":"private void assertGetResult(VM result) { assertNotNull(result); assertEquals(\"Vm db generation wasn't loaded as expected\", 1, result.getDbGeneration()); assertEquals(result, existingVm); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This return repository.hashCode()'\nThe code is: 'public int hashCode() { final int prime = 31; int result = 1; <START> result = prime * result + ((repository == null) ? 0 : repository.hashCode()); <END> \/\/ This return repository.hashCode() return result; }'","output":"public int hashCode() { return repository.hashCode(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Move this validation PluginProfileService'\nThe code is: 'public void create(Username currentUser, SecurityAuthConfig securityAuthConfig, LocalizedOperationResult result) { <START> SecurityAuthConfigCreateCommand command = new SecurityAuthConfigCreateCommand(goConfigService, securityAuthConfig, authorizationExtension, currentUser, result); <END> \/\/ Move this validation PluginProfileService validatePluginProperties(command, securityAuthConfig); update(currentUser, securityAuthConfig, result, command); }'","output":"public void create(Username currentUser, SecurityAuthConfig securityAuthConfig, LocalizedOperationResult result) { SecurityAuthConfigCreateCommand command = new SecurityAuthConfigCreateCommand(goConfigService, securityAuthConfig, authorizationExtension, currentUser, result); update(currentUser, securityAuthConfig, result, command); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Is this meant private? users create(...)'\nThe code is: '<START> public AutobatchingLeadershipObserverFactory( <END> \/\/ nit: Is this meant private? users create(...) DisruptorAutobatcher<Map.Entry<Client, LeadershipEvent>, Void> leadershipEventProcessor) { this.leadershipEventProcessor = leadershipEventProcessor; }'","output":"private AutobatchingLeadershipObserverFactory( DisruptorAutobatcher<Map.Entry<Client, LeadershipEvent>, Void> leadershipEventProcessor) { this.leadershipEventProcessor = leadershipEventProcessor; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Extra ;'\nThe code is: 'public static QueryType sqlQueryType(String sqlQuery) { String query = sqlQuery.substring(0, sqlQuery.indexOf(\" \")).toUpperCase(); <START> ; <END> \/\/ Extra ; switch (query) { case \"UPDATE\": sqlQueryType = QueryType.UPDATE; break; case \"SELECT\": sqlQueryType = QueryType.SELECT; break; case \"DELETE\": sqlQueryType = QueryType.DELETE; break; case \"INSERT\": sqlQueryType = QueryType.INSERT; break; } return sqlQueryType; }'","output":"public static QueryType sqlQueryType(String sqlQuery) { String query = sqlQuery.substring(0, sqlQuery.indexOf(\" \")).toUpperCase(); switch (query) { case \"UPDATE\": sqlQueryType = QueryType.UPDATE; break; case \"SELECT\": sqlQueryType = QueryType.SELECT; break; case \"DELETE\": sqlQueryType = QueryType.DELETE; break; case \"INSERT\": sqlQueryType = QueryType.INSERT; break; } return sqlQueryType; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If AtomicBoolean (and dont do else), longer need synchronized keyword here'\nThe code is: '<START> @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { <END> \/\/ If AtomicBoolean (and dont do else), longer need synchronized keyword here return canceled.compareAndSet( false, true ); }'","output":"@Override public boolean cancel( final boolean mayInterruptIfRunning ) { return canceled.compareAndSet( false, true ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'theoretically, order matters, test orders-of-operations'\nThe code is: 'public void <START> testCreateInvalidConfigAeadWithAuth() <END> \/\/ theoretically, order matters, test orders-of-operations throws Exception { IpSecConfig ipSecConfig = buildBasicIpSecConfig(); for (int direction : directions) { ipSecConfig.setAuthentication(direction, authAlgo); try { ipSecConfig.setAuthenticatedEncryption(direction, aeadAlgo); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( \"IpSecService should have thrown an error on authentication being\" + \" enabled with authenticated encryption\"); } catch (IllegalArgumentException expected) { } }'","output":"public void testCreateInvalidConfigAeadWithAuth() throws Exception { IpSecConfig ipSecConfig = new IpSecConfig(); addDefaultSpisAndRemoteAddrToIpSecConfig(ipSecConfig); for (int direction : DIRECTIONS) { ipSecConfig.setAuthentication(direction, AUTH_ALGO); try { ipSecConfig.setAuthenticatedEncryption(direction, AEAD_ALGO); } catch (IllegalArgumentException expected) { } } try { mIpSecService.createTransportModeTransform(ipSecConfig, new Binder()); fail( \"IpSecService should have thrown an error on authentication being\" + \" enabled with authenticated encryption\"); } catch (IllegalArgumentException expected) { } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do if (Objects.equals(channel.get(), key)) { null checking for you. Objects.nonNull is useful a function is required (e.g. stream.filter) is add extra method call jit decide inline (as compared obj != null')'\nThe code is: 'public Maybe<Channel> fromKey(String key) { for (Channel channel : channels.get()) { <START> if (Objects.nonNull(channel.getKey()) && channel.getKey().equals(key)) { <END> \/\/ do if (Objects.equals(channel.get(), key)) { null checking for you. Objects.nonNull is useful a function is required (e.g. stream.filter) is add extra method call jit decide inline (as compared obj != null') return Maybe.just(channel); } } return Maybe.nothing(); }'","output":"public Maybe<Channel> fromKey(String key) { for (Channel channel : channels.get()) { if (Objects.equals(channel.getKey(), key)) { return Maybe.just(channel); } } return Maybe.nothing(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtils.isBlank(), want avoid NPEs'\nThe code is: 'public FormValidation doCheckUrl(@QueryParameter String value) { <START> if (value.isEmpty()) { <END> \/\/ StringUtils.isBlank(), want avoid NPEs return FormValidation.warning(Messages.Jenkins_EmptyRootUrl()); } if(value.startsWith(\"http:\/\/localhost\")) return FormValidation.warning(Messages.Mailer_Localhost_Error()); return FormValidation.ok(); }'","output":"public FormValidation doCheckUrl(@QueryParameter String value) { if (StringUtils.isBlank(value)) { return FormValidation.warning(Messages.Jenkins_EmptyRootUrl()); } if(value.startsWith(\"http:\/\/localhost\")) return FormValidation.warning(Messages.Mailer_Localhost_Error()); return FormValidation.ok(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.emptySet() returns a singleton is preferred here'\nThe code is: 'public Set<String> getDependentFields() { <START> return Sets.newHashSet(); <END> \/\/ Collections.emptySet() returns a singleton is preferred here }'","output":"public Set<String> getDependentFields() { return Collections.emptySet(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need synchronized (YEAR_FORMAT) { here. block .setTimeZone() calls above'\nThe code is: 'public int draw(GC gc, long nanosec, Rectangle rect) { String stime; <START> synchronized (formats) { <END> \/\/ need synchronized (YEAR_FORMAT) { here. block .setTimeZone() calls above stime = YEAR_FORMAT.format(new Date(nanosec \/ MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }'","output":"public int draw(GC gc, long nanosec, Rectangle rect) { String stime; synchronized (YEAR_FORMAT) { stime = YEAR_FORMAT.format(new Date(nanosec \/ MILLISEC_IN_NS)); } return Utils.drawText(gc, stime, rect, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: jut call super.setForceCloseTimeoutMillis(...) this ensure do correct if change super method content allow forceCloseTimeMillis private'\nThe code is: 'public WebSocketClientHandshaker13 setForceCloseTimeoutMillis(long forceCloseTimeoutMillis) { <START> this.forceCloseTimeoutMillis = forceCloseTimeoutMillis; <END> \/\/ nit: jut call super.setForceCloseTimeoutMillis(...) this ensure do correct if change super method content allow forceCloseTimeMillis private return this; }'","output":"public WebSocketClientHandshaker13 setForceCloseTimeoutMillis(long forceCloseTimeoutMillis) { super.setForceCloseTimeoutMillis(forceCloseTimeoutMillis); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'SearchView's visibility dependent of discovery fragments, visibility controlled MainDiscoveryFragment''\nThe code is: 'public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); <START> searchView.setVisibility(isVisibleToUser ? View.VISIBLE : View.GONE); <END> \/\/ SearchView's visibility dependent of discovery fragments, visibility controlled MainDiscoveryFragment' onFragmentVisibilityChange(isVisibleToUser); }'","output":"public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); onFragmentVisibilityChange(isVisibleToUser); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return false better'\nThe code is: 'private boolean validateHostPort(String string) { try { URI uri = new URI(\"my:\/\/\" + string); if (uri.getHost() == null || uri.getPort() == -1) { <START> throw new URISyntaxException(uri.toString(), \"URI must have host and port parts\"); <END> \/\/ return false better } } catch (URISyntaxException ex) { return false; } return true; }'","output":"private boolean validateHostPort(String string) { try { URI uri = new URI(\"my:\/\/\" + string); if (uri.getHost() == null || uri.getPort() == -1) { return false; } } catch (URISyntaxException ex) { return false; } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please do start threads implementation items for Tellstick binding (see providesBindingFor() a hook). Please stop this Thread deactivate() called'\nThe code is: 'public void activate() { logger.info(\"Activate \" + Thread.currentThread()); <START> controllerThread.start(); <END> \/\/ please do start threads implementation items for Tellstick binding (see providesBindingFor() a hook). Please stop this Thread deactivate() called }'","output":"public void activate() { logger.info(\"Activate \" + Thread.currentThread()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'in run method call collector.getOrThrowException. In configurePipeline method, data pipeline app throw in exception if validation failure carries failures. however, this apply other methods'\nThe code is: 'public void run(BatchActionContext batchContext) throws Exception { <START> config.validate(batchContext.getFailureCollector()); <END> \/\/ in run method call collector.getOrThrowException. In configurePipeline method, data pipeline app throw in exception if validation failure carries failures. however, this apply other methods if (!config.shouldRun(batchContext)) { return; } Class<? extends Driver> driverClass = batchContext.loadPluginClass(JDBC_PLUGIN_ID); DBRun executeQuery = new DBRun(config, driverClass); executeQuery.run(); }'","output":"public void run(BatchActionContext batchContext) throws Exception { FailureCollector collector = batchContext.getFailureCollector(); config.validate(collector); collector.getOrThrowException(); if (!config.shouldRun(batchContext)) { return; } Class<? extends Driver> driverClass = batchContext.loadPluginClass(JDBC_PLUGIN_ID); DBRun executeQuery = new DBRun(config, driverClass); executeQuery.run(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Unsupported operation POST\"'\nThe code is: 'public void handlePost(RestRequestInfo restRequestInfo) throws RestServiceException { if (restRequestInfo.isFirstPart()) { adminMetrics.postOperationRate.mark(); } <START> logger.debug(\"While trying to perform POST: Unsupported operation - POST\"); <END> \/\/ \"Unsupported operation POST\" adminMetrics.unsupportedPostOperation.inc(); throw new RestServiceException(\"Unsupported operation for Admin service - POST\", RestServiceErrorCode.UnsupportedOperation); }'","output":"public void handlePost(RestRequestInfo restRequestInfo) throws RestServiceException { if (restRequestInfo.isFirstPart()) { adminMetrics.postOperationRate.mark(); } adminMetrics.unsupportedPostOperationError.inc(); throw new RestServiceException(\"Unsupported operation for Admin service - POST\", RestServiceErrorCode.UnsupportedOperation); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor nit, move \"as max\" capacity string a line own' merge a single string,'\nThe code is: 'public void testGetLocalPathForWriteForLessSpace() throws Exception { String dir0 = buildBufferDir(ROOT, 0); String dir1 = buildBufferDir(ROOT, 1); conf.set(CONTEXT, dir0 + \",\" + dir1); <START> LambdaTestUtils.intercept(DiskErrorException.class, \"as the max capacity\" + <END> \/\/ minor nit, move \"as max\" capacity string a line own' merge a single string, \" in any directory is\", \"Expect a DiskErrorException.\", () -> dirAllocator.getLocalPathForWrite(\"p1\/x\", Long.MAX_VALUE-1, conf)); }'","output":"public void testGetLocalPathForWriteForLessSpace() throws Exception { String dir0 = buildBufferDir(ROOT, 0); String dir1 = buildBufferDir(ROOT, 1); conf.set(CONTEXT, dir0 + \",\" + dir1); LambdaTestUtils.intercept(DiskErrorException.class, \"as the max capacity in any directory is\", \"Expect a DiskErrorException.\", () -> dirAllocator.getLocalPathForWrite(\"p1\/x\", Long.MAX_VALUE-1, conf)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is server mode set OPEN in teardown'\nThe code is: 'public void tearDown() throws Exception { <START> GrillServices.get().setServiceMode(GrillServices.SERVICE_MODE.OPEN); <END> \/\/ is server mode set OPEN in teardown super.tearDown(); }'","output":"public void tearDown() throws Exception { super.tearDown(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Annotations line'\nThe code is: '<START> @Override public void setPickupStatus(PickupStatus pickupStatus) { <END> \/\/ Annotations line customPickupStatus = pickupStatus; }'","output":"public void setPickupStatus(PickupStatus pickupStatus) { customPickupStatus = pickupStatus; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Count need explicitly initialized is 0 default'\nThe code is: 'private SkipRevFilter(int skip) { <START> this.count = 0; <END> \/\/ Count need explicitly initialized is 0 default this.skip = skip; }'","output":"private SkipRevFilter(int skip) { this.skip = skip; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'adding this this error message only'\nThe code is: 'public static Node createInvalidType(Node node, NodeType type) { StringBuilder message = new StringBuilder(\"Invalid type \" + node.getType() + \", expected \" + type); if (node.getParent() != null && node.getParent() instanceof KeyValueNode) { <START> message.append(\" (key: \\\"\" + ((KeyValueNode) node.getParent()).getKey() + \"\\\")\"); <END> \/\/ adding this this error message only } return new ErrorNode(message.toString()); }'","output":"public static Node createInvalidType(Node node, NodeType type) { return new ErrorNode(\"Invalid type \" + node.getType() + \", expected \" + type); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Alias null'\nThe code is: 'public String getDeleteDescription() { <START> return getName() + (getAlias() == null ? \"\" : \" (\" + getAlias() + \")\"); <END> \/\/ Alias null }'","output":"public String getDeleteDescription() { return getName() + \" (\" + getAlias() + \")\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List.of'\nThe code is: 'public List<String> getScopes() { <START> return Arrays.asList(\"openid\", \"email\", \"profile\", groupsNameParameter, alfioGroupsNameParameter); <END> \/\/ List.of }'","output":"public List<String> getScopes() { return List.of(\"openid\", \"email\", \"profile\", groupsNameParameter, alfioGroupsNameParameter); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws IOException required? If this worked before, include it'\nThe code is: '<START> public static String getFileName(final Path rootDir, final Path filePath) throws IOException{ <END> \/\/ throws IOException required? If this worked before, include it return rootDir.relativize(filePath).toString().replace(\"\\\\\", \"\/\"); }'","output":"public static String getFileName(final Path rootDir, final Path filePath) { return rootDir.relativize(filePath).toString().replace(\"\\\\\", \"\/\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need call 'frontendFailureEventListener.hide()' here, 'CurrentUser.logout()' invoke 'BaseApplicationInit.onLogout()' default'\nThe code is: 'void initFrontend() { Frontend.initEventsHandler(frontendEventsHandler); Frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener); Frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() { @Override public void eventRaised(Event ev, Object sender, EventArgs args) { user.logout(); <START> frontendFailureEventListener.hide(); <END> \/\/ need call 'frontendFailureEventListener.hide()' here, 'CurrentUser.logout()' invoke 'BaseApplicationInit.onLogout()' default } }); Frontend.setFilterQueries(filterFrontendQueries()); }'","output":"void initFrontend() { Frontend.initEventsHandler(frontendEventsHandler); Frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener); Frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() { @Override public void eventRaised(Event ev, Object sender, EventArgs args) { user.logout(); } }); Frontend.setFilterQueries(filterFrontendQueries()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reset lock'\nThe code is: 'private CommandContext createCommandContext(GlusterVolumeEntity volume, GlusterVolumeOptionEntity option) { Step setOptionStep = addSubStep(StepEnum.EXECUTING, StepEnum.SETTING_GLUSTER_OPTION, getOptionValues(volume, option)); ExecutionContext setOptionCtx = new ExecutionContext(); setOptionCtx.setMonitored(true); setOptionCtx.setStep(setOptionStep); <START> return dupContext().setExecutionContext(setOptionCtx); <END> \/\/ reset lock }'","output":"private CommandContext createCommandContext(GlusterVolumeEntity volume, GlusterVolumeOptionEntity option) { Step setOptionStep = addSubStep(StepEnum.EXECUTING, StepEnum.SETTING_GLUSTER_OPTION, getOptionValues(volume, option)); ExecutionContext setOptionCtx = new ExecutionContext(); setOptionCtx.setMonitored(true); setOptionCtx.setStep(setOptionStep); return dupContext().withExecutionContext(setOptionCtx); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This break Windows. portableString \"\/\" platforms. Please org.eclipse.core.runtime.IPath.SEPARATOR'\nThe code is: 'static boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + <START> File.separator + <END> \/\/ This break Windows. portableString \"\/\" platforms. Please org.eclipse.core.runtime.IPath.SEPARATOR JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }'","output":"static boolean isJdtCoreSettingsResource(IResource resource) { IPath resourcePath = resource.getProjectRelativePath(); String prefs = JavaProject.DEFAULT_PREFERENCES_DIRNAME + IPath.SEPARATOR + JavaProject.JAVA_CORE_PREFS_FILE; IPath expectedPath = Path.fromPortableString(prefs); boolean isJdtCoreSettingsResource = expectedPath.equals(resourcePath); return isJdtCoreSettingsResource; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Assert.notNull()'\nThe code is: 'public static void setSerializationStrategy(SerializationStrategy serializationStrategy) { <START> if (serializationStrategy == null) { <END> \/\/ Assert.notNull() throw new IllegalArgumentException(\"Serialization strategy can't be null\"); } strategy = serializationStrategy; }'","output":"public static void setSerializationStrategy(SerializationStrategy serializationStrategy) { Assert.notNull(serializationStrategy, \"Serialization strategy can't be null\"); strategy = serializationStrategy; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do public methods'\nThe code is: '<START> public QueryWithParams(Query query, Object[] params) { <END> \/\/ Do public methods this(query, params, null); }'","output":"QueryWithParams(Query query, Object[] params) { this(query, params, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this changed super.selectedItemsChanged()'\nThe code is: 'protected void selectedItemsChanged() { <START> super.onSelectedItemChanged(); <END> \/\/ this changed super.selectedItemsChanged() updateActionAvailability(); }'","output":"protected void selectedItemsChanged() { super.selectedItemsChanged(); updateActionAvailability(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is a bit weird, is calling toString method right do'\nThe code is: 'public SegmentRef toRef() { <START> return new SegmentRef(checkNotNull(this.getId().toString(), <END> \/\/ this is a bit weird, is calling toString method right do \"Can't create reference for segment without ID\")); }'","output":"public SegmentRef toRef() { return new SegmentRef(checkNotNull(this.getId(), \"Can't create reference for segment without ID\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this static, I feel plugin is static'\nThe code is: '<START> public static Economy getEconomy() { <END> \/\/ I this static, I feel plugin is static return econ; }'","output":"public Economy getEconomy() { return econ; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this done in Nodes.updateNode() - route setNodes() addNodes() removeNodes()'\nThe code is: 'public boolean updateNode(Node n) throws IOException { <START> if ( nodes.updateNode(n) ){ <END> \/\/ this done in Nodes.updateNode() - route setNodes() addNodes() removeNodes() getQueue().scheduleMaintenance(); return true; }; return false; }'","output":"public boolean updateNode(Node n) throws IOException { return nodes.updateNode(n); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'raw types - new Pair<>(vm, vmDevice)'\nThe code is: 'public void testValidationFailsDiskConnectedToRunningVm() { VM vm = new VM(); vm.setStatus(VMStatus.Up); VmDevice vmDevice = new VmDevice(); vmDevice.setPlugged(true); List<Pair<VM, VmDevice>> vms = <START> Collections.singletonList(new Pair(vm, <END> \/\/ raw types - new Pair<>(vm, vmDevice) vmDevice)); doReturn(vms).when(vmDao).getVmsWithPlugInfo(diskId); ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN); }'","output":"public void testValidationFailsDiskConnectedToRunningVm() { VM vm = new VM(); vm.setStatus(VMStatus.Up); VmDevice vmDevice = new VmDevice(); vmDevice.setPlugged(true); List<Pair<VM, VmDevice>> vms = Collections.singletonList(new Pair<>(vm, vmDevice)); doReturn(vms).when(vmDao).getVmsWithPlugInfo(diskId); ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this doing'\nThe code is: 'public boolean isUnifiable(Index index) { return index instanceof TopIndex || equals(index) || (index instanceof TokenIndex && <START> kLabel.sorts().contains(((TokenIndex) index).sort())); <END> \/\/ is this doing }'","output":"public boolean isUnifiable(Index index) { return index instanceof TopIndex || equals(index); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this throws exception file writer get closed, consider a try resources'\nThe code is: 'static void writeModel(NaiveBayesModel model) throws IOException { ensureTextClassifierFolderExists(); <START> FileWriter fw = new FileWriter(new File(MODEL_PATH)); <END> \/\/ this throws exception file writer get closed, consider a try resources PlainTextNaiveBayesModelWriter modelWriter; modelWriter = new PlainTextNaiveBayesModelWriter(model, new BufferedWriter(fw)); modelWriter.persist(); fw.close(); }'","output":"static void writeModel(NaiveBayesModel model) throws IOException { ensureTextClassifierFolderExists(); try (FileWriter fw = new FileWriter(new File(MODEL_PATH))) { PlainTextNaiveBayesModelWriter modelWriter; modelWriter = new PlainTextNaiveBayesModelWriter(model, new BufferedWriter(fw)); modelWriter.persist(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw'\nThe code is: 'public void execute(Tuple input, BasicOutputCollector collector) { try { Thread.sleep(1000); } catch (InterruptedException e) { <START> Throwables.propagate(e); <END> \/\/ throw } }'","output":"public void execute(Tuple input, BasicOutputCollector collector) { try { Thread.sleep(1000); } catch (InterruptedException e) { throw Throwables.propagate(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method changed private'\nThe code is: '<START> public HashMap<String, <END> \/\/ this method changed private ArrayList<Order>> getBuyOrders() { return buyOrders; }'","output":"private HashMap<String, ArrayList<Order>> getBuyOrders() { return buyOrders; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this protected. I assume ListModel is'\nThe code is: '<START> public void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> \/\/ this protected. I assume ListModel is getStorageDevices().setSelectedItems(selectedDevices); }'","output":"protected void setSelectedDevices(List<StorageDevice> selectedDevices) { getStorageDevices().setSelectedItems(selectedDevices); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplified AccountLinkingStatus.ENABLED.equals(getStatus())'\nThe code is: 'public boolean isAccountLinkingEnabled () { <START> return AccountLinkingStatus.ENABLED.equals(getStatus()) ? true : false; <END> \/\/ simplified AccountLinkingStatus.ENABLED.equals(getStatus()) }'","output":"public boolean isAccountLinkingEnabled () { return AccountLinkingStatus.ENABLED.equals(getStatus()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null -> UnsupportedOperationException'\nThe code is: 'public List<Span> getChildren(String tenant, String id) { <START> return null; <END> \/\/ null -> UnsupportedOperationException }'","output":"public List<Span> getChildren(String tenant, String id) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'lines combined one'\nThe code is: 'public Map<String, String> getOrcSchemaMapping() { <START> String prefix = \"secor.orc.schema.mapfile.topic\"; <END> \/\/ lines combined one return getKeyValueFromPrefix(prefix); }'","output":"public Map<String, String> getOrcSchemaMapping() { return getKeyValueFromPrefix(\"secor.orc.schema.mapfile.topic\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This if list removed completely'\nThe code is: 'void processAnnotatedType(@Observes ProcessAnnotatedType<NoAnnotationBean> bean) { <START> if(classToProcess.contains(bean.getAnnotatedType().getJavaClass())) { <END> \/\/ This if list removed completely AnnotatedTypeWrapper<NoAnnotationBean> wrapper = new AnnotatedTypeWrapper<NoAnnotationBean>(bean); wrapper.addAnnotation(new TransactionalLiteral()); bean.setAnnotatedType(wrapper); } }'","output":"void processAnnotatedType(@Observes ProcessAnnotatedType<NoAnnotationBean> bean) { AnnotatedTypeWrapper<NoAnnotationBean> wrapper = new AnnotatedTypeWrapper<NoAnnotationBean>(bean); wrapper.addAnnotation(new TransactionalLiteral()); bean.setAnnotatedType(wrapper); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need lock this code? ExecutorService.execute is thread safe,'\nThe code is: 'protected void demandUnload(SynchronizedResourceSet resourceSet, Resource resource, IProgressMonitor monitor) { <START> lock.lock(); <END> \/\/ do need lock this code? ExecutorService.execute is thread safe, try { unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor)); } finally { lock.unlock(); } }'","output":"protected void demandUnload(SynchronizedResourceSet resourceSet, Resource resource, IProgressMonitor monitor) { unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion EMPTY_VALUE);'\nThe code is: 'public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateConditionalEvent emptySubprocessEvent = getCatchingIntermediateNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_NO_OUTGOING_EDGE); assertGeneralSet(emptySubprocessEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertConditionalEventExecutionSet(emptySubprocessEvent.getExecutionSet(), CONDITION_EXPRESSION_SCRIPT_DEFAULT_VALUE, CONDITION_EXPRESSION_LANGUAGE, CONDITION_ERPRESSION_TYPE, NON_CANCELLING, <START> \"\"); <END> \/\/ suggestion EMPTY_VALUE); }'","output":"public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_CATCHING_INTERMEDIATE_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); IntermediateConditionalEvent emptySubprocessEvent = getCatchingIntermediateNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, HAS_NO_INCOME_EDGE, HAS_NO_OUTGOING_EDGE); assertGeneralSet(emptySubprocessEvent.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertConditionalEventExecutionSet(emptySubprocessEvent.getExecutionSet(), CONDITION_EXPRESSION_SCRIPT_DEFAULT_VALUE, CONDITION_EXPRESSION_LANGUAGE, CONDITION_ERPRESSION_TYPE, NON_CANCELLING, EMPTY_VALUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this Noncompliant'\nThe code is: 'boolean boxedEqual3(Boolean B, Boolean V) { <START> return B == V; END> }'","output":"void boxedEqual3(Boolean B, Boolean V) { if (B == V) { foo(); } else { bar(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this import instead of a fully qualified reference'\nThe code is: 'public ModListScreen(Screen mainMenu) { super(new TranslationTextComponent(\"fml.menu.mods.title\")); this.mainMenu = mainMenu; <START> this.mods = Collections.unmodifiableList(net.minecraftforge.fml.ModList.get().getMods()); <END> \/\/ this import instead of a fully qualified reference this.unsortedMods = Collections.unmodifiableList(this.mods); }'","output":"public ModListScreen(Screen mainMenu) { super(new TranslationTextComponent(\"fml.menu.mods.title\")); this.mainMenu = mainMenu; this.mods = Collections.unmodifiableList(ModList.get().getMods()); this.unsortedMods = Collections.unmodifiableList(this.mods); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for a test this (I run locally): suggestion final GHRepository repo = gitHub.getRepository(\"hub4j-test-org\/GHContentIntegrationTest\"); final GHContent fileContent = repo.getFileContent(\"ghcontent-ro\/a-file-with-\\u00F6\"); assertThat(IOUtils.readLines(fileContent.read(), StandardCharsets.UTF_8), hasItems(\"test\")); final GHContent fileContent2 = repo.getFileContent(fileContent.getPath()); assertThat(IOUtils.readLines(fileContent2.read(), StandardCharsets.UTF_8), hasItems(\"test\"));'\nThe code is: 'public void testGetFileContentWithNonAsciiPath() throws Exception { <START> final GHContent fileContent = gitHub.getRepository(\"hub4j-test-org\/GHContentIntegrationTest\") .getFileContent(\"ghcontent-ro\/a-file-with-\\u00F6\"); assertThat(IOUtils.readLines(fileContent.read(), StandardCharsets.UTF_8), hasItems(\"test\")); <END> \/\/ for a test this (I run locally): suggestion final GHRepository repo = gitHub.getRepository(\"hub4j-test-org\/GHContentIntegrationTest\"); final GHContent fileContent = repo.getFileContent(\"ghcontent-ro\/a-file-with-\\u00F6\"); assertThat(IOUtils.readLines(fileContent.read(), StandardCharsets.UTF_8), hasItems(\"test\")); final GHContent fileContent2 = repo.getFileContent(fileContent.getPath()); assertThat(IOUtils.readLines(fileContent2.read(), StandardCharsets.UTF_8), hasItems(\"test\")); }'","output":"public void testGetFileContentWithNonAsciiPath() throws Exception { final GHRepository repo = gitHub.getRepository(\"hub4j-test-org\/GHContentIntegrationTest\"); final GHContent fileContent = repo.getFileContent(\"ghcontent-ro\/a-file-with-\\u00F6\"); assertThat(IOUtils.readLines(fileContent.read(), StandardCharsets.UTF_8), hasItems(\"test\")); final GHContent fileContent2 = repo.getFileContent(fileContent.getPath()); assertThat(IOUtils.readLines(fileContent2.read(), StandardCharsets.UTF_8), hasItems(\"test\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this change please, necessary'\nThe code is: 'public ExpressionProjector(String name, String tableName, Expression expression, boolean isCaseSensitive) { this.name = name; this.expression = expression; this.tableName = tableName; this.isCaseSensitive = isCaseSensitive; <START> this.arrayIndex = -1; <END> \/\/ Remove this change please, necessary }'","output":"public ExpressionProjector(String name, String tableName, Expression expression, boolean isCaseSensitive) { this.name = name; this.expression = expression; this.tableName = tableName; this.isCaseSensitive = isCaseSensitive; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tableScanPlanNodeId'\nThe code is: 'public int getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { int count = 0; <START> for (PlanNodeId partitionedSource : fragment.getTableScanSchedulingOrder()) { <END> \/\/ tableScanPlanNodeId Collection<Split> partitionedSplits = splits.get(partitionedSource); count += partitionedSplits.size(); } return count; } }'","output":"public int getPartitionedSplitCount() { if (taskStateMachine.getState().isDone()) { return 0; } synchronized (this) { int count = 0; for (PlanNodeId tableScanPlanNodeId : fragment.getTableScanSchedulingOrder()) { Collection<Split> partitionedSplits = splits.get(tableScanPlanNodeId); count += partitionedSplits.size(); } return count; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion super(\"Unable send a notification slack:\" + e.getMessage());'\nThe code is: 'public SlackNotificationException(IOException e) { <START> super(\"Unable to send a notification to slack error:\" + e.getMessage()); <END> \/\/ suggestion super(\"Unable send a notification slack:\" + e.getMessage()); }'","output":"public SlackNotificationException(IOException e) { super(\"Unable to send a notification to slack:\" + e.getMessage()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Lets return of apapter.createDirectory'\nThe code is: 'private boolean mkdir(Path path) throws IOException { String key = pathToKey(path); <START> adapter.createDirectory(key); <END> \/\/ Lets return of apapter.createDirectory return true; }'","output":"private boolean mkdir(Path path) throws IOException { String key = pathToKey(path); return adapter.createDirectory(key); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please do create useless variables, is more readable if use: java return ECApi.postLog(cache, logType, date, log);'\nThe code is: 'public final LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final List<TrackableLog> trackableLogs) { <START> final LogResult result = ECApi.postLog(cache, logType, date, log); <END> \/\/ Please do create useless variables, is more readable if use: java return ECApi.postLog(cache, logType, date, log); return result; }'","output":"public final LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final List<TrackableLog> trackableLogs) { return ECApi.postLog(cache, logType, date, log); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Invalid output schema'\nThe code is: 'public void configurePipeline(PipelineConfigurer pipelineConfigurer) { Preconditions.checkArgument(!Strings.isNullOrEmpty(config.schema), \"Schema must be specified.\"); try { Schema schema = Schema.parseJson(config.schema); pipelineConfigurer.getStageConfigurer().setOutputSchema(schema); } catch (Exception e) { <START> throw new IllegalArgumentException(\"Invalid input schema: \" + e.getMessage(), e); <END> \/\/ Invalid output schema } }'","output":"public void configurePipeline(PipelineConfigurer pipelineConfigurer) { Preconditions.checkArgument(!Strings.isNullOrEmpty(config.schema), \"Schema must be specified.\"); try { Schema schema = Schema.parseJson(config.schema); pipelineConfigurer.getStageConfigurer().setOutputSchema(schema); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid output schema: \" + e.getMessage(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'visibility of this method private'\nThe code is: '<START> void enqueuePendingNativeReports() { <END> \/\/ visibility of this method private setChanged(); notifyObservers(new Message( NativeInterface.MessageType.DELIVER_PENDING, null)); }'","output":"private void enqueuePendingNativeReports() { setChanged(); notifyObservers(new Message( NativeInterface.MessageType.DELIVER_PENDING, null)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (!validatePort(targetTraceCollectionPort) && collectBuildTraces) {'\nThe code is: 'public FormValidation doCheckTargetTraceCollectionPort(@QueryParameter(\"targetTraceCollectionPort\") final String targetTraceCollectionPort) { <START> if (!validatePort(targetTraceCollectionPort) && collectBuildLogs) { <END> \/\/ suggestion if (!validatePort(targetTraceCollectionPort) && collectBuildTraces) { return FormValidation.error(\"Invalid Trace Collection Port\"); } return FormValidation.ok(\"Valid Trace Collection Port\"); }'","output":"public FormValidation doCheckTargetTraceCollectionPort(@QueryParameter(\"targetTraceCollectionPort\") final String targetTraceCollectionPort) { if (!validatePort(targetTraceCollectionPort) && collectBuildTraces) { return FormValidation.error(\"Invalid Trace Collection Port\"); } return FormValidation.ok(\"Valid Trace Collection Port\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'final'\nThe code is: 'public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, \"sessionId\"); <START> WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); <END> \/\/ final Assert.requireNonNull(mutexReference, \"mutexReference\"); return mutexReference.get(); }'","output":"public Mutex getMutexForHttpSession(final String sessionId) { Assert.requireNonBlank(sessionId, \"sessionId\"); final WeakReference<Mutex> mutexReference = sessionMutexMap.get(sessionId); Assert.requireNonNull(mutexReference, \"mutexReference\"); return mutexReference.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'processFuture.isDone() instead of negation'\nThe code is: 'public boolean finished() { <START> return !processFuture.isCancelled() && !processFuture.isDone(); <END> \/\/ processFuture.isDone() instead of negation }'","output":"public boolean finished() { return processFuture.isDone(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Argument name is wrong in call arg checker'\nThe code is: 'public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { <START> ArgChecker.notNull(index, \"currency\"); <END> \/\/ Argument name is wrong in call arg checker ArgChecker.notNull(forwardCurve, \"forwardCurve\"); this.indexCurves.put(index, forwardCurve); return this; }'","output":"public ImmutableRatesProviderBuilder iborIndexCurve(IborIndex index, Curve forwardCurve) { ArgChecker.notNull(index, \"index\"); ArgChecker.notNull(forwardCurve, \"forwardCurve\"); this.indexCurves.put(index, forwardCurve); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if login is deferred, code run soon'\nThe code is: 'public SalesforceDroidGapActivity() { super(); delegate = new SalesforceActivityDelegate(this); <START> authConfig = AuthConfigUtil.getMyDomainAuthConfig(SalesforceHybridSDKManager.getInstance().getLoginServerManager().getSelectedLoginServer().url); <END> \/\/ if login is deferred, code run soon }'","output":"public SalesforceDroidGapActivity() { super(); delegate = new SalesforceActivityDelegate(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '0'\nThe code is: 'private static long extractValue(@Nullable Object val) { if (val instanceof Number) { return ((Number) val).longValue(); } <START> return -1; <END> \/\/ 0 }'","output":"private static long extractValue(@Nullable Object val) { if (val instanceof Number) { return ((Number) val).longValue(); } return 0; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Consider CollectionUtils.isEmpty(this.applicationDefinitions) instead'\nThe code is: 'public void initialize() { <START> if (this.applicationDefinitions == null || this.applicationDefinitions.isEmpty()) { <END> \/\/ Consider CollectionUtils.isEmpty(this.applicationDefinitions) instead this.applicationDefinitions = getAppDefinitions(this.name, this.dslText); } }'","output":"public void initialize() { if (CollectionUtils.isEmpty(this.applicationDefinitions)) { this.applicationDefinitions = getAppDefinitions(this.name, this.dslText); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If this hit often, I vote for making this info'\nThe code is: 'public void removeAllPrivateWorkerKeys(String topologyId) { for (WorkerTokenServiceType type : WorkerTokenServiceType.values()) { String path = ClusterUtils.secretKeysPath(type, topologyId); try { <START> LOG.debug(\"Removing worker keys under {}\", path); <END> \/\/ If this hit often, I vote for making this info stateStorage.delete_node(path); } catch (RuntimeException e) { if (!Utils.exceptionCauseIsInstanceOf(KeeperException.NoNodeException.class, e)) { throw e; } } } }'","output":"public void removeAllPrivateWorkerKeys(String topologyId) { for (WorkerTokenServiceType type : WorkerTokenServiceType.values()) { String path = ClusterUtils.secretKeysPath(type, topologyId); try { LOG.info(\"Removing worker keys under {}\", path); stateStorage.delete_node(path); } catch (RuntimeException e) { if (!Utils.exceptionCauseIsInstanceOf(KeeperException.NoNodeException.class, e)) { throw e; } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'name dependency'\nThe code is: 'private void addPrerequisites(BundleDescription bundle, Set<BundleDescription> reachable) { if (reachable.contains(bundle)) return; reachable.add(bundle); List<BundleDescription> depList = ((BundleDescriptionImpl) bundle).getBundleDependencies(); BundleDescription[] dependencies = depList.toArray(new BundleDescription[depList.size()]); for (BundleDescription <START> dependencie : <END> \/\/ name dependency dependencies) { addPrerequisites(dependencie, reachable); } }'","output":"private void addPrerequisites(BundleDescription bundle, Set<BundleDescription> reachable) { if (reachable.contains(bundle)) return; reachable.add(bundle); List<BundleDescription> depList = ((BundleDescriptionImpl) bundle).getBundleDependencies(); BundleDescription[] dependencies = depList.toArray(new BundleDescription[depList.size()]); for (BundleDescription dependency : dependencies) { addPrerequisites(dependency, reachable); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'yeah needed'\nThe code is: 'public int get(int index) { <START> return this.data[index] & 0xFFFF; <END> \/\/ yeah needed }'","output":"public int get(int index) { return this.data[index]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method need static'\nThe code is: '<START> private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId, <END> \/\/ This method need static boolean isLastEventInTransaction, Region region) { GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class); when(event.getTransactionId()).thenReturn(new TXId(null, transactionId)); when(event.makeHeapCopyIfOffHeap()).thenReturn(event); when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction); when(event.getRegion()).thenReturn(region); return event; }'","output":"private GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId, boolean isLastEventInTransaction, Region region) { GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class); when(event.getTransactionId()).thenReturn(new TXId(null, transactionId)); when(event.makeHeapCopyIfOffHeap()).thenReturn(event); when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction); when(event.getRegion()).thenReturn(region); return event; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'lambda'\nThe code is: 'private static Integer getSelectionIndex(SWTBotView viewBot) { final TimeGraphControl timegraph = viewBot.bot().widget(WidgetOfType.widgetOfType(TimeGraphControl.class)); <START> return UIThreadRunnable.syncExec(new IntResult() { <END> \/\/ lambda @Override public Integer run() { return timegraph.getSelectedIndex(); } }); }'","output":"private static Integer getSelectionIndex(SWTBotView viewBot) { final TimeGraphControl timegraph = viewBot.bot().widget(WidgetOfType.widgetOfType(TimeGraphControl.class)); return UIThreadRunnable.syncExec(() -> { return timegraph.getSelectedIndex(); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'invalidNamesor invalidFieldNames is fieldNames'\nThe code is: 'public void createWithPrimaryKeyField_invalidFieldNameThrows() { <START> String[] fieldNames = new String[] { null, \"\", \"foo.bar\", TestHelper.getRandomString(65) }; <END> \/\/ invalidNamesor invalidFieldNames is fieldNames for (String fieldName : fieldNames) { try { realmSchema.createWithPrimaryKeyField(\"Foo\", fieldName, int.class); fail(); } catch (IllegalArgumentException ignored) { } } }'","output":"public void createWithPrimaryKeyField_invalidFieldNameThrows() { String[] invalidFieldNames = new String[] { null, \"\", \"foo.bar\", TestHelper.getRandomString(65) }; for (String fieldName : invalidFieldNames) { try { realmSchema.createWithPrimaryKeyField(\"Foo\", fieldName, int.class); fail(); } catch (IllegalArgumentException ignored) { } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Static import'\nThe code is: 'public UpdateQuery build() { <START> Checks.checkNotNull(uri, \"Please specify uri\"); <END> \/\/ Static import return new UpdateQuery( uri, where, whereArgs ); }'","output":"public UpdateQuery build() { checkNotNull(uri, \"Please specify uri\"); return new UpdateQuery( uri, where, whereArgs ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'default access'\nThe code is: '<START> public IsMergeablePredicate(Provider<ReviewDb> <END> \/\/ default access dbProvider) { super(ChangeField.MERGEABLE, \"1\"); this.dbProvider = dbProvider; }'","output":"IsMergeablePredicate(Provider<ReviewDb> dbProvider) { super(ChangeField.MERGEABLE, \"1\"); this.dbProvider = dbProvider; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new Double() is redundant'\nThe code is: 'public Object getResult(VarianceData data) { <START> return new Double(data.squaredSum \/ data.count); <END> \/\/ new Double() is redundant }'","output":"public Double getResult(VarianceData data) { return data.squaredSum \/ data.count; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.contributor'\nThe code is: 'public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> \/\/ this.contributor }'","output":"public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = EEFTabbedPropertyRegistry.getDefault(this.contributor); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need WaitUtils.sleepQuietly(1) here'\nThe code is: 'public void clickOnAllStacksButton() { seleniumWebDriverHelper.waitAndClick(By.xpath(Locators.ALL_STACKS_BUTTON_XPATH)); <START> WaitUtils.sleepQuietly(1); <END> \/\/ Do need WaitUtils.sleepQuietly(1) here }'","output":"public void clickOnAllStacksButton() { seleniumWebDriverHelper.waitAndClick(By.xpath(Locators.ALL_STACKS_BUTTON_XPATH)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"test\/testGrid2.json\". is grid1.json is reserved for tests'\nThe code is: 'public void runAll(){ for(TestCase test: testcases){ <START> server.newGame(GridLoader.loadGrid(\"grid1.json\")); <END> \/\/ \"test\/testGrid2.json\". is grid1.json is reserved for tests test.run(); } }'","output":"public void runAll(){ for(TestCase test: testcases){ server.newGame(GridLoader.loadGrid(\"test\/testGrid2.json\")); test.run(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'masquerade instructor'\nThe code is: 'protected void testAccessControl() throws Exception { String[] submissionParams = new String[] {}; verifyAccessibleForStudents(submissionParams); <START> verifyAccessibleForAdminToMasqueradeAsInstructor(submissionParams); <END> \/\/ masquerade instructor }'","output":"protected void testAccessControl() throws Exception { String[] submissionParams = new String[] {}; verifyAccessibleForStudents(submissionParams); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove public modifier class is package-private'\nThe code is: '<START> public SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { <END> \/\/ remove public modifier class is package-private Assert.notNull(expectedJwsAlgorithm, \"expectedJwsAlgorithm cannot be null\"); Assert.notNull(key, \"key cannot be null\"); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }'","output":"SingleKeyJWSKeySelector(JWSAlgorithm expectedJwsAlgorithm, Key key) { Assert.notNull(expectedJwsAlgorithm, \"expectedJwsAlgorithm cannot be null\"); Assert.notNull(key, \"key cannot be null\"); this.keySet = Arrays.asList(key); this.expectedJwsAlgorithm = expectedJwsAlgorithm; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change method return type String void'\nThe code is: '<START> public String setClearAlarmRegister(final DlmsConnectionHolder conn, final DlmsDevice device, <END> \/\/ Change method return type String void final ClearAlarmRegisterRequestDto clearAlarmRegisterRequestDto) throws ProtocolAdapterException { this.clearAlarmRegisterCommandExecutor.execute(conn, device, clearAlarmRegisterRequestDto); return \"Clear alarm register result is OK for device: \" + device.getDeviceIdentification(); }'","output":"public void setClearAlarmRegister(final DlmsConnectionHolder conn, final DlmsDevice device, final ClearAlarmRegisterRequestDto clearAlarmRegisterRequestDto) throws ProtocolAdapterException { this.clearAlarmRegisterCommandExecutor.execute(conn, device, clearAlarmRegisterRequestDto); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this'\nThe code is: 'public EventDefinition(IEventDeclaration declaration, StreamInputReader streamInputReader) { <START> this.fDeclaration = declaration; <END> \/\/ Remove this this.fStreamInputReader = streamInputReader; }'","output":"public EventDefinition(IEventDeclaration declaration, StreamInputReader streamInputReader) { fDeclaration = declaration; fStreamInputReader = streamInputReader; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Adding this a field is good manner'\nThe code is: 'public Target getTarget() { <START> return thingIfApi.getTarget(); <END> \/\/ Adding this a field is good manner }'","output":"public Target getTarget() { return this.thingIfApi.getTarget(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List<FeedRange> feedRanges = new ArrayList<FeedRange>(feedRanges.size());'\nThe code is: 'private static List<FeedRange> toFeedRanges( Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) { final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v; if (partitionKeyRangeList == null) { throw new IllegalStateException(\"PartitionKeyRange list cannot be null\"); } <START> List<FeedRange> feedRanges = new ArrayList<FeedRange>(); <END> \/\/ List<FeedRange> feedRanges = new ArrayList<FeedRange>(feedRanges.size()); partitionKeyRangeList.forEach(pkRange -> { feedRanges.add(toFeedRange(pkRange)); }); return feedRanges; }'","output":"private static List<FeedRange> toFeedRanges( Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) { final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v; if (partitionKeyRangeList == null) { throw new IllegalStateException(\"PartitionKeyRange list cannot be null\"); } List<FeedRange> feedRanges = new ArrayList<FeedRange>(partitionKeyRangeList.size()); partitionKeyRangeList.forEach(pkRange -> { feedRanges.add(toFeedRange(pkRange)); }); return feedRanges; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If swallowing exception need addSuppressed'\nThe code is: 'private void performRecoveredIndexDropActions() { indexesToDropAfterCompletedRecovery.values().forEach( index -> { try { index.drop(); } catch ( Exception e ) { try { index.close(); } catch ( IOException closeException ) { <START> e.addSuppressed( closeException ); <END> \/\/ If swallowing exception need addSuppressed } } } ); indexesToDropAfterCompletedRecovery.clear(); }'","output":"private void performRecoveredIndexDropActions() { indexesToDropAfterCompletedRecovery.values().forEach( index -> { try { index.drop(); } catch ( Exception e ) { try { index.close(); } catch ( IOException closeException ) { } } } ); indexesToDropAfterCompletedRecovery.clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new Boolean skips constant pool -- placing unnecessary pressure garbage collector. Please Boolean.valueOf instead'\nThe code is: 'private boolean canCloneVolume() { <START> return new Boolean(getDriver().getCapabilities().get(DataStoreCapabilities.CAN_CREATE_VOLUME_FROM_VOLUME.toString())); <END> \/\/ new Boolean skips constant pool -- placing unnecessary pressure garbage collector. Please Boolean.valueOf instead }'","output":"private boolean canCloneVolume() { return Boolean.valueOf(getDriver().getCapabilities().get(DataStoreCapabilities.CAN_CREATE_VOLUME_FROM_VOLUME.toString())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this public'\nThe code is: '<START> public static String indexFile(final String filename, final String extension) { <END> \/\/ is this public return ParsingUtils.appendToPath(filename, extension); }'","output":"private static String indexFile(final String filename, final String extension) { return ParsingUtils.appendToPath(filename, extension); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ImmutableSet.of(this.resultStream)'\nThe code is: 'public Set<Stream> getResultStreams() { <START> Set<Stream> streams = new HashSet<Stream>(); <END> \/\/ ImmutableSet.of(this.resultStream) streams.add(this.resultStream); return streams; }'","output":"public Set<Stream> getResultStreams() { Set<Stream> streams = ImmutableSet.of(this.resultStream); return streams; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertFalse(...);'\nThe code is: 'public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); <START> assertTrue(!sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); <END> \/\/ assertFalse(...); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); }'","output":"public void testSharedPreferencesClearedAfterLoggingException() { CrashReporter.storeUnhandledException(exception); assertFalse(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); CrashReporter.sendUnhandledCaughtException(); assertTrue(sharedPreferences.getString(CrashReporter.EXCEPTION_FOR_REPORT, \"\").isEmpty()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Multiple ';''\nThe code is: 'private void removeFromMap(View child) { <START> this.map.get(child).child = null;; <END> \/\/ Multiple ';' this.map.remove(child); }'","output":"private void removeFromMap(View child) { this.map.get(child).child = null; this.map.remove(child); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do return System.getProperty(this.port, getPort(getProtocol()); here'\nThe code is: 'public String getPort() { <START> String port = System.getProperty(this.port); <END> \/\/ do return System.getProperty(this.port, getPort(getProtocol()); here if (port == null) { port = getPort(getProtocol()); } return port; }'","output":"public String getPort() { return System.getProperty(this.port, getPort(getProtocol())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This replaced this.color = color.getRGB()'\nThe code is: 'public Fluid setColor(Color color) { <START> this.color = (color.getAlpha()<<24) + (color.getRed()<<16) + (color.getGreen()<<8) + color.getBlue(); <END> \/\/ This replaced this.color = color.getRGB() return this; }'","output":"public Fluid setColor(Color color) { this.color = color.getRGB(); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'block replaced with: return Collections.singletonList(Constants.REMOTE_TYPE);'\nThe code is: 'public List<String> getSupportedTypes() { final List<String> types = new ArrayList<>(); types.add(Constants.REMOTE_TYPE); <START> return types; <END> \/\/ block replaced with: return Collections.singletonList(Constants.REMOTE_TYPE); }'","output":"public List<String> getSupportedTypes() { return Collections.singletonList(Constants.REMOTE_TYPE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@antonini please name user, initialize Opt.Empty'\nThe code is: 'public Opt<Identity> enter(final Request req) throws IOException { <START> Opt<Identity> retValue = null; <END> \/\/ @antonini please name user, initialize Opt.Empty for (final Pass pass : this.passes) { retValue = pass.enter(req); if (retValue.has()) { break; } } if (retValue == null) { retValue = new Opt.Empty<Identity>(); } return retValue; }'","output":"public Opt<Identity> enter(final Request req) throws IOException { Opt<Identity> user = new Opt.Empty<Identity>(); for (final Pass pass : this.passes) { user = pass.enter(req); if (user.has()) { break; } } return user; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'offHeapEntryFactory.getSize() include size of LRU pointers'\nThe code is: 'public BoundedOffHeapDataContainer(int desiredSize, long maxSize, EvictionType type) { super(desiredSize); this.maxSize = maxSize; if (type == EvictionType.COUNT) { sizeCalculator = i -> 1; } else { <START> sizeCalculator = i -> offHeapEntryFactory.getSize(i) + OffHeapLruNode.getSize(); <END> \/\/ offHeapEntryFactory.getSize() include size of LRU pointers } this.lruLock = new ReentrantLock(); firstAddress = 0; }'","output":"public BoundedOffHeapDataContainer(int desiredSize, long maxSize, EvictionType type) { super(desiredSize); this.maxSize = maxSize; if (type == EvictionType.COUNT) { sizeCalculator = i -> 1; } else { sizeCalculator = i -> offHeapEntryFactory.getSize(i); } this.lruLock = new ReentrantLock(); firstAddress = 0; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call 'super()' is implicit. need state explicitly'\nThe code is: 'public UserPortalNewTemplateVmModelBehavior() { <START> super(); <END> \/\/ call 'super()' is implicit. need state explicitly }'","output":"public UserPortalNewTemplateVmModelBehavior() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'o: StringUtils.isBlank() here'\nThe code is: 'public static ConditionEvaluationResult disabled(String reason, String customReason) { <START> if (customReason.isEmpty()) { <END> \/\/ o: StringUtils.isBlank() here return disabled(reason); } return disabled(String.format(\"%s ==> %s\", reason, customReason)); }'","output":"public static ConditionEvaluationResult disabled(String reason, String customReason) { if (StringUtils.isBlank(customReason)) { return disabled(reason); } return disabled(String.format(\"%s ==> %s\", reason, customReason)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for intermediate blob variable'\nThe code is: 'public static MultipartInput buildMultipartInput(Object input, String content) throws IOException { MultipartInput mpinput = new MultipartInput(); mpinput.setRequest(content); if (input instanceof Blob) { Blob blob = (Blob) input; <START> mpinput.setBlob(blob); <END> \/\/ need for intermediate blob variable } else if (input instanceof Blobs) { mpinput.setBlobs((Blobs) input); } else { throw new IllegalArgumentException(\"Unsupported binary input object: \" + input); } return mpinput; }'","output":"public static MultipartInput buildMultipartInput(Object input, String content) throws IOException { MultipartInput mpinput = new MultipartInput(); mpinput.setRequest(content); if (input instanceof Blob) { mpinput.setBlob((Blob) input); } else if (input instanceof Blobs) { mpinput.setBlobs((Blobs) input); } else { throw new IllegalArgumentException(\"Unsupported binary input object: \" + input); } return mpinput; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This private. Is a reason protected'\nThe code is: '<START> protected InterProcessMutex(CuratorFramework client, String path, LockInternalsDriver driver) <END> \/\/ This private. Is a reason protected { this(client, path, LOCK_NAME, 1, driver); }'","output":"public InterProcessMutex(CuratorFramework client, String path, LockInternalsDriver driver) { this(client, path, LOCK_NAME, 1, driver); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '[Broken Double-checked locking](<LINK_0> pattern'\nThe code is: 'public PrometheusMetricsTrackerFactory(CollectorRegistry registry) { if (globalCollector == null) { synchronized (PrometheusMetricsTrackerFactory.class) { if (globalCollector == null) { globalCollector = new HikariCPCollector(); } } <START> } <END> \/\/ [Broken Double-checked locking](<LINK_0> pattern this.registry = registry; this.collector = globalCollector.register(registry); }'","output":"public PrometheusMetricsTrackerFactory(CollectorRegistry registry) { checkGlobalCollector(); this.registry = registry; this.collector = globalCollector.register(registry); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this RevWalk used? ObjectReader released r.close(), I this try { } finally block is needed'\nThe code is: 'private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException { Repository r = repoManager.openRepository(project); try { <START> RevWalk rw = new RevWalk(r); <END> \/\/ Is this RevWalk used? ObjectReader released r.close(), I this try { } finally block is needed try { ObjectId headCommit = r.getRef(branch).getObjectId(); ObjectId taggedCommit = r.getRef(tagName).getObjectId(); assertEquals(headCommit, taggedCommit); } finally { rw.release(); } } finally { r.close(); } }'","output":"private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException { Repository r = repoManager.openRepository(project); try { ObjectId headCommit = r.getRef(branch).getObjectId(); ObjectId taggedCommit = r.getRef(tagName).getObjectId(); assertEquals(headCommit, taggedCommit); } finally { r.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ID is longer required, need non-null'\nThe code is: 'void addListener(final Session session) { Preconditions.checkNotNull(session); <START> Preconditions.checkNotNull(session.getId()); <END> \/\/ ID is longer required, need non-null sessionSet.put(session); }'","output":"void addListener(final Session session) { sessionSet.put(session); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'negative logic'\nThe code is: 'public ExtendedQueryResult<T> orderDesc(String attribute, boolean appendEntityName) { lastPaginatedQuery = null; <START> if (!context.getRepositoryMethod().isQuery()) { <END> \/\/ negative logic context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.DESC)); } else { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } return this; }'","output":"public ExtendedQueryResult<T> orderDesc(String attribute, boolean appendEntityName) { lastPaginatedQuery = null; if (context.getRepositoryMethod().isQuery()) { context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC, appendEntityName)); } else { context.addCriteriaBuilderPostProcessor(new OrderByCriteriaBuilderPostProcessor(attribute, OrderDirection.DESC)); } return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'HttpServletResponse.SC_NOT_FOUND'\nThe code is: 'public Publication getPublicationById(Long id) { <START> return publicationRepository.findById(id).orElseThrow(() -> new RestException(\"Not found\", 404)); <END> \/\/ HttpServletResponse.SC_NOT_FOUND }'","output":"public Publication getPublicationById(Long id) { return publicationRepository.findById(id).orElseThrow(() -> new RestException(\"Not found\", HttpServletResponse.SC_NOT_FOUND)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: assertThrows. a of in this PR'\nThe code is: 'private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); try { int size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); <START> message.write(byteBufferAccessor, cache, version); <END> \/\/ nit: assertThrows. a of in this PR fail(\"Expected to see a NullPointerException when writing \" + message + \" at version \" + version); } catch (NullPointerException e) { } }'","output":"private void verifyWriteRaisesNpe(short version, Message message) throws Exception { ObjectSerializationCache cache = new ObjectSerializationCache(); assertThrows(NullPointerException.class, () -> { int size = message.size(cache, version); ByteBuffer buf = ByteBuffer.allocate(size); ByteBufferAccessor byteBufferAccessor = new ByteBufferAccessor(buf); message.write(byteBufferAccessor, cache, version); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nice this private call of HomeActivityUIController constructor'\nThe code is: '<START> public void setupUI() { <END> \/\/ nice this private call of HomeActivityUIController constructor setMainView(); adapter = new HomeScreenAdapter(activity); mTopBanner = View.inflate(activity, R.layout.grid_header_top_banner, null); setupGridView(); }'","output":"private void setupUI() { setMainView(); adapter = new HomeScreenAdapter(activity); mTopBanner = View.inflate(activity, R.layout.grid_header_top_banner, null); setupGridView(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need this public. client of Iterator<Note> blob is attached note'\nThe code is: '<START> ObjectId getData() { <END> \/\/ need this public. client of Iterator<Note> blob is attached note return data; }'","output":"public ObjectId getData() { return data; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplified java return itemMaterial == null ? 0 : itemMaterial.getMaxStackSize();'\nThe code is: 'public int getMaxStackSize() { if (itemMaterial == null) { return 0; } else { <START> return itemMaterial.getMaxStackSize(); <END> \/\/ simplified java return itemMaterial == null ? 0 : itemMaterial.getMaxStackSize(); } }'","output":"public int getMaxStackSize() { return itemMaterial.getMaxStackSize(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'super(); is unnecessary automatically called'\nThe code is: 'public ByteArrayLenCodec(final CRAMCodec<Integer> lenCodec, final CRAMCodec<byte[]> byteCodec) { <START> super(); <END> \/\/ super(); is unnecessary automatically called this.lenCodec = lenCodec; this.byteCodec = byteCodec; }'","output":"public ByteArrayLenCodec(final CRAMCodec<Integer> lenCodec, final CRAMCodec<byte[]> byteCodec) { this.lenCodec = lenCodec; this.byteCodec = byteCodec; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this exposed public setter'\nThe code is: '<START> public void setInBatchMode(boolean inBatchMode) <END> \/\/ this exposed public setter { this.inBatchMode = inBatchMode; }'","output":"protected void setInBatchMode(boolean inBatchMode) { this.inBatchMode = inBatchMode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is number null'\nThe code is: 'protected void setData(String key, Number value) { if (data == null) { data = new HashMap<>(); } if (value == null) { data.remove(key); } else if (value instanceof Number) { data.put(key, value); <START> } else { <END> \/\/ is number null throw new RuntimeException(\"unexpected value\"); } }'","output":"protected void setData(String key, Number value) { if (data == null) { data = new HashMap<>(); } data.put(key, value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This need public, private'\nThe code is: '<START> public int getMode(File file) { <END> \/\/ This need public, private return 0664; }'","output":"private int getMode(File file) { return 0664; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'isEmpty'\nThe code is: 'public void sendEventBundle(EventBundle events) { <START> if (events.size() == 0) { <END> \/\/ isEmpty return; } for (EventBundlePipe pipe : pipes) { pipe.sendEventBundle(events); } }'","output":"public void sendEventBundle(EventBundle events) { if (events.isEmpty()) { return; } for (EventBundlePipe pipe : pipes) { pipe.sendEventBundle(events); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fix position? call validateCursorForNulls, call KafkaCursor.fromNakadiCursor, basically checks. other side is clear call KafkaCursor.fromNakadiCursor do work KafkaCursor'\nThe code is: '<START> public void validateCommitCursor(final NakadiCursor position) throws InvalidCursorException { <END> \/\/ fix position? call validateCursorForNulls, call KafkaCursor.fromNakadiCursor, basically checks. other side is clear call KafkaCursor.fromNakadiCursor do work KafkaCursor validateCursorForNulls(position); KafkaCursor.fromNakadiCursor(position); }'","output":"public void validateCommitCursor(final NakadiCursor position) throws InvalidCursorException { KafkaCursor.fromNakadiCursor(position); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this'\nThe code is: 'public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> this.fChartViewer <END> \/\/ remove this = chartViewer; }'","output":"public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); fChartViewer = chartViewer; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'method protected (private if isolated in tests)'\nThe code is: '<START> public boolean execute(BindContext context) { <END> \/\/ method protected (private if isolated in tests) for (BindOperation operation : operations) { log.debug(\"Starting execute of {}\", operation.getClass().getSimpleName()); if (operation.execute(context)) { log.debug(\"Finished execute of {}\", operation.getClass().getSimpleName()); } else { log.error(\"Skipped chain execute in operation {}\", operation.getClass().getSimpleName()); return false; } } return true; }'","output":"private boolean execute(BindContext context) { for (BindOperation operation : operations) { log.debug(\"Starting execute of {}\", operation.getClass().getSimpleName()); if (operation.execute(context)) { log.debug(\"Finished execute of {}\", operation.getClass().getSimpleName()); } else { log.error(\"Skipped chain execute in operation {}\", operation.getClass().getSimpleName()); return false; } } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'CosemDateTime appears immutable, is need return a new object protect internal state'\nThe code is: 'public CosemDateTime getDaylightSavingsBegin() { <START> return new CosemDateTime(this.daylightSavingsBegin); <END> \/\/ CosemDateTime appears immutable, is need return a new object protect internal state }'","output":"public CosemDateTime getDaylightSavingsBegin() { return this.daylightSavingsBegin; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'In case changing code change to: updateGridSize(calculateGridHeight(values.size()));'\nThe code is: 'public void setRowData(int start, final List<? extends T> values) { if (values.size() == 1) { addStyleName(HIDE_ONE_ROW_SCROLL); } else { removeStyleName(HIDE_ONE_ROW_SCROLL); } super.setRowData(start, values); <START> updateGridSize(calculateGridHeightOnlyRows(values.size())); <END> \/\/ In case changing code change to: updateGridSize(calculateGridHeight(values.size())); }'","output":"public void setRowData(int start, final List<? extends T> values) { if (values.size() == 1) { addStyleName(HIDE_ONE_ROW_SCROLL); } else { removeStyleName(HIDE_ONE_ROW_SCROLL); } super.setRowData(start, values); updateGridSize(calculateGridHeight(values.size())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion + \" 'getDataView()' data type.\",'\nThe code is: 'protected final void verifyDataProviderType(Class<?> dataProviderType) { Class<?> supportedDataProviderType = getSupportedDataProviderType(); if (!supportedDataProviderType.isAssignableFrom(dataProviderType)) { final String message = String.format( \"%s only supports '%s' or it's subclasses, but was given a '%s'.\" + \"%nUse either 'getLazyDataView()', 'getListDataView()'\" <START> + \" or getDataView() according to the used data type.\", <END> \/\/ suggestion + \" 'getDataView()' data type.\", this.getClass().getSimpleName(), supportedDataProviderType.getSimpleName(), dataProviderType.getSuperclass().getSimpleName()); throw new IllegalStateException(message); } }'","output":"protected final void verifyDataProviderType(Class<?> dataProviderType) { Class<?> supportedDataProviderType = getSupportedDataProviderType(); if (!supportedDataProviderType.isAssignableFrom(dataProviderType)) { final String message = String.format( \"%s only supports '%s' or it's subclasses, but was given a '%s'.\" + \"%nUse either 'getLazyDataView()', 'getListDataView()'\" + \" or 'getDataView()' according to the used data type.\", this.getClass().getSimpleName(), supportedDataProviderType.getSimpleName(), dataProviderType.getSuperclass().getSimpleName()); throw new IllegalStateException(message); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@garydgregory Please Args.notNull for consistency rest of code base'\nThe code is: 'public static Method normalizedValueOf(final String method) { <START> return valueOf(Objects.requireNonNull(method, \"method\").toUpperCase(Locale.ROOT)); <END> \/\/ @garydgregory Please Args.notNull for consistency rest of code base }'","output":"public static Method normalizedValueOf(final String method) { return valueOf(Args.notNull(method, \"method\").toUpperCase(Locale.ROOT)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove: declare-response, useless-assign return object method-call'\nThe code is: 'private AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest request, AssertionType assertion, NhinTargetCommunitiesType targets) { AdhocQueryResponse response = null; if (targets == null) { targets = new ObjectFactory().createNhinTargetCommunitiesType(); } if (StringUtils.isBlank(targets.getUseSpecVersion())) { targets.setUseSpecVersion(\"3.0\"); } response = outboundDocQuery.respondingGatewayCrossGatewayQuery(request, assertion, targets); <START> return response; <END> \/\/ remove: declare-response, useless-assign return object method-call }'","output":"private AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest request, AssertionType assertion, NhinTargetCommunitiesType targets) { if (targets == null) { targets = new ObjectFactory().createNhinTargetCommunitiesType(); } if (StringUtils.isBlank(targets.getUseSpecVersion())) { targets.setUseSpecVersion(\"3.0\"); } return outboundDocQuery.respondingGatewayCrossGatewayQuery(request, assertion, targets); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename method'\nThe code is: 'private Set<IType> getRelatedTypes() { Set<IMethod> methods= getMethodsToRename(); Set<IType> result= new HashSet<>(methods.size()); for (IMethod <START> iMethod : <END> \/\/ rename method methods) { result.add(iMethod.getDeclaringType()); } return result; }'","output":"private Set<IType> getRelatedTypes() { Set<IMethod> methods= getMethodsToRename(); Set<IType> result= new HashSet<>(methods.size()); for (IMethod method : methods) { result.add(method.getDeclaringType()); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Separate file for test. Rename avoid misunderstanding. File name short information purpose'\nThe code is: 'public void testComma() throws Exception { checkConfig.addAttribute(\"option\", \"EOL\"); checkConfig.addAttribute(\"tokens\", \"COMMA\"); final String[] expected = { \"39:17: \" + getCheckMessage(MSG_LINE_PREVIOUS, \",\"), }; <START> verify(checkConfig, getPath(\"InputSeparatorWrapAfter3904.java\"), expected); <END> \/\/ Separate file for test. Rename avoid misunderstanding. File name short information purpose }'","output":"public void testComma() throws Exception { checkConfig.addAttribute(\"option\", \"EOL\"); checkConfig.addAttribute(\"tokens\", \"COMMA\"); final String[] expected = { \"39:17: \" + getCheckMessage(MSG_LINE_PREVIOUS, \",\"), }; verify(checkConfig, getPath(\"InputSeparatorWrapForTestComma.java\"), expected); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if result, break out of loop'\nThe code is: 'private boolean hasAnyImportInCurrentGroup(String currentGroup) { boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { <START> result = true; <END> \/\/ if result, break out of loop } } return result; }'","output":"private boolean hasAnyImportInCurrentGroup(String currentGroup) { boolean result = false; for (ImportDetails currentImport : importToGroupList) { if (currentGroup.equals(currentImport.getImportGroup())) { result = true; break; } } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This necessary'\nThe code is: 'public void onStart() throws Exception { try { startDispatcherServices(); } catch (Throwable t) { <START> getTerminationFuture().completeExceptionally(t); <END> \/\/ This necessary final DispatcherException exception = new DispatcherException(String.format(\"Could not start the Dispatcher %s\", getAddress()), t); onFatalError(exception); throw exception; } dispatcherBootstrap.initialize(this, this.getRpcService().getScheduledExecutor()); }'","output":"public void onStart() throws Exception { try { startDispatcherServices(); } catch (Throwable t) { final DispatcherException exception = new DispatcherException(String.format(\"Could not start the Dispatcher %s\", getAddress()), t); onFatalError(exception); throw exception; } dispatcherBootstrap.initialize(this, this.getRpcService().getScheduledExecutor()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'FmsGroups suffer issue FmsUsers. need calculate group mapping line 71 add UmsUsersState line 78'\nThe code is: 'private FmsGroup umsGroupToGroup(Group umsGroup) { FmsGroup fmsGroup = new FmsGroup(); fmsGroup.withName(umsGroup.getGroupName()); <START> fmsGroup.withAzureObjectId(getOptionalAzureObjectId(umsGroup.getCloudIdentitiesList())); <END> \/\/ FmsGroups suffer issue FmsUsers. need calculate group mapping line 71 add UmsUsersState line 78 return fmsGroup; }'","output":"private FmsGroup umsGroupToGroup(Group umsGroup) { FmsGroup fmsGroup = new FmsGroup(); fmsGroup.withName(umsGroup.getGroupName()); return fmsGroup; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I want this be... suggestion return appUrl; \"\/medic\/_design\/medic\/_rewrite\/\" bit is format longer need'\nThe code is: 'private String getRootUrl() { <START> return appUrl.concat(\"\/medic\/_design\/medic\/_rewrite\/\"); <END> \/\/ I want this be... suggestion return appUrl; \"\/medic\/_design\/medic\/_rewrite\/\" bit is format longer need }'","output":"private String getRootUrl() { return appUrl; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Comparing [TestExecutionResult](<LINK_0> this Getter return Optional'\nThe code is: '<START> public Throwable getThrowable() { <END> \/\/ Comparing [TestExecutionResult](<LINK_0> this Getter return Optional return throwable; }'","output":"public Optional<Throwable> getThrowable() { return Optional.ofNullable(throwable); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"rigion\" \"region\"'\nThe code is: 'public void addRegion(Region region) { if (!regions.contains(region)) { if (serviceConnected) { try { beaconManager.startMonitoringBeaconsInRegion(region); } catch (RemoteException e) { LogManager.e(e, TAG, \"Can't add bootstrap region\"); } }else{ <START> LogManager.w(TAG, \"Adding a rigion: service not yet Connected\"); <END> \/\/ \"rigion\" \"region\" } regions.add(region); } }'","output":"public void addRegion(Region region) { if (!regions.contains(region)) { if (serviceConnected) { try { beaconManager.startMonitoringBeaconsInRegion(region); } catch (RemoteException e) { LogManager.e(e, TAG, \"Can't add bootstrap region\"); } }else{ LogManager.w(TAG, \"Adding a region: service not yet Connected\"); } regions.add(region); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'in save digest uppercase for sha'\nThe code is: 'private void updateDigest(PipelineTemplate pipelineTemplate) { <START> String digestId = String.format(\"%s@sha256%s\", pipelineTemplate.getId(), computeSHA256Digest(pipelineTemplate)); <END> \/\/ in save digest uppercase for sha getPipelineTemplateDAO().update(digestId, pipelineTemplate); }'","output":"private void updateDigest(PipelineTemplate pipelineTemplate) { String digestId = String.format(\"%s@sha256:%s\", pipelineTemplate.getId(), computeSHA256Digest(pipelineTemplate)); getPipelineTemplateDAO().update(digestId, pipelineTemplate); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static'\nThe code is: '<START> public IPath buildPath(IPath <END> \/\/ static sourcePath, IPath targetPath, int count) { sourcePath = sourcePath.removeFirstSegments(count); return targetPath.append(sourcePath); }'","output":"public static IPath buildPath(IPath sourcePath, IPath targetPath, int count) { sourcePath = sourcePath.removeFirstSegments(count); return targetPath.append(sourcePath); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'position parameter is in NatTable coordinates out of range in scrollableLayer. Ideally scrollableColumn row underlying scrollable layer row is NatTable position, change scrolling. Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException(\"No viewport layer position \" + position); } int scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row);'\nThe code is: 'public Position scrollToColumnHeader(Position position, int headerRow, int scrollableColumn) { int column = scrollViewport(position, <START> position.row, scrollableColumn).column; <END> \/\/ position parameter is in NatTable coordinates out of range in scrollableLayer. Ideally scrollableColumn row underlying scrollable layer row is NatTable position, change scrolling. Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException(\"No viewport layer position \" + position); } int scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row); return new Position(headerRow, column); }'","output":"public Position scrollToColumnHeader(Position position, int headerRow, int scrollableColumn) { Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException(\"No viewport layer found at position \" + position); } int scrollableRow = viewportLayer.localToUnderlyingRowPosition(viewportPosition.row); int column = scrollViewport(position, scrollableRow, scrollableColumn).column; return new Position(headerRow, column); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer people providing default properties file, want default more explicit. provide default in secor.common.properties'\nThe code is: 'public String getGsCredentialsPath() { <START> return getString(\"secor.gs.credentials.path\", null); <END> \/\/ prefer people providing default properties file, want default more explicit. provide default in secor.common.properties }'","output":"public String getGsCredentialsPath() { return getString(\"secor.gs.credentials.path\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'fileInfo map immutable'\nThe code is: 'public static Entry create(String accountId, String bucketId, String contentType, String fileId, Map<String, String> fileInfo, String fileName, long uploadTimestamp) { <START> return new AutoValue_ListUnfinishedLargeFilesResponse_Entry(accountId, bucketId, contentType, fileId, fileInfo, fileName, new Date(uploadTimestamp)); <END> \/\/ fileInfo map immutable }'","output":"public static Entry create(String accountId, String bucketId, String contentType, String fileId, Map<String, String> fileInfo, String fileName, long uploadTimestamp) { return new AutoValue_ListUnfinishedLargeFilesResponse_Entry(accountId, bucketId, contentType, fileId, ImmutableMap.copyOf(fileInfo), fileName, new Date(uploadTimestamp)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'A number of tests throw HttpMediaTypeNotAcceptableException. please remove throws signature is unnecessary? This way, expectations of test clearer'\nThe code is: '<START> public void useEqualsWhenTrueThenCustomMediaTypeIsMatched() throws HttpMediaTypeNotAcceptableException { <END> \/\/ A number of tests throw HttpMediaTypeNotAcceptableException. please remove throws signature is unnecessary? This way, expectations of test clearer request.addHeader(\"Accept\", \"text\/unique\"); matcher = new MediaTypeRequestMatcher(new MediaType(\"text\", \"unique\")); matcher.setUseEquals(true); assertThat(matcher.matches(request)).isTrue(); }'","output":"public void useEqualsWhenTrueThenCustomMediaTypeIsMatched() { request.addHeader(\"Accept\", \"text\/unique\"); matcher = new MediaTypeRequestMatcher(new MediaType(\"text\", \"unique\")); matcher.setUseEquals(true); assertThat(matcher.matches(request)).isTrue(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary new suggestion {\"NA12891.over.fingerprints.r1.sam\", true},'\nThe code is: 'Object[][] samFilesforFingerprinting() { return new Object[][]{ <START> new Object[]{\"NA12891.over.fingerprints.r1.sam\", true}, <END> \/\/ unnecessary new suggestion {\"NA12891.over.fingerprints.r1.sam\", true}, new Object[]{\"aligned_queryname_sorted.sam\", false}, new Object[]{\"aligned_unsorted.sam\", false}, }; }'","output":"Object[][] samFilesforFingerprinting() { return new Object[][]{ {\"NA12891.over.fingerprints.r1.sam\", true}, {\"aligned_queryname_sorted.sam\", false}, {\"aligned_unsorted.sam\", false}, }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'muss dies public sein oder recht package private'\nThe code is: '<START> public void countActiveUsers() { <END> \/\/ muss dies public sein oder recht package private Metrics.gauge(METRIC_USERS_ACTIVE, this.personService.getActivePersons().size()); }'","output":"void countActiveUsers() { Metrics.gauge(METRIC_USERS_ACTIVE, this.personService.getActivePersons().size()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call reflow() instead'\nThe code is: 'private void reflowAsync() { Display.getDefault().asyncExec(new Runnable() { @Override public void run() { <START> getParentSection().getTaskEditorPage().reflow(); <END> \/\/ call reflow() instead } }); }'","output":"private void reflowAsync() { Display.getDefault().asyncExec(new Runnable() { @Override public void run() { reflow(); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I Collections.unmodifyableList(...) here. I apache-commons variant is for JDK4 users'\nThe code is: 'public List<RemoteServerData> getServerList() { <START> return UnmodifiableList.decorate(remoteServerDataList); <END> \/\/ I Collections.unmodifyableList(...) here. I apache-commons variant is for JDK4 users }'","output":"public List<RemoteServerData> getServerList() { return Collections.unmodifiableList(remoteServerDataList); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'set in xml'\nThe code is: 'public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); mContext = getActivity().getApplicationContext(); mDataBaseAdapter = new DataBaseAdapter(getActivity()); mDataBaseAdapter.createDatabase(); mDataBaseAdapter.open(); mItemAdapter = new ATMItemListAdapter(mContext, ((MainActivity) getActivity()).getLocationTracker()); setListAdapter(mItemAdapter); getLoaderManager().initLoader(0, null, this); <START> getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE); <END> \/\/ set in xml }'","output":"public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); mContext = getActivity().getApplicationContext(); mDataBaseAdapter = new DataBaseAdapter(getActivity()); mDataBaseAdapter.createDatabase(); mDataBaseAdapter.open(); mItemAdapter = new ATMItemListAdapter(mContext, ((MainActivity) getActivity()).getLocationTracker()); setListAdapter(mItemAdapter); getLoaderManager().initLoader(0, null, this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'so, changing expected behavior for some weird cases. I prefer a separate method createAccountWithHashedPassword if goal is for CasC. In current approach impacting users desires a real password starting #jbcrypt:. I understand impact is small behavior potentially malicious users achieve things'\nThe code is: 'public User createAccount(String userName, String password) throws IOException { User user = User.getById(userName, true); <START> if (password.startsWith(JBCRYPT_HEADER)) { <END> \/\/ so, changing expected behavior for some weird cases. I prefer a separate method createAccountWithHashedPassword if goal is for CasC. In current approach impacting users desires a real password starting #jbcrypt:. I understand impact is small behavior potentially malicious users achieve things user.addProperty(Details.fromHashedPassword(password)); } else { user.addProperty(Details.fromPlainPassword(password)); } return user; }'","output":"public User createAccount(String userName, String password) throws IOException { User user = User.getById(userName, true); user.addProperty(Details.fromPlainPassword(password)); return user; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'concatening strings +, needed do .toString(). This result: return singleBenchmarkResult + \"_\" + problemStatisticType; Furthermore, avoids a nullpointerexception if for example problemStatisticType is null (which is in this case)'\nThe code is: 'public String toString() { <START> return singleBenchmarkResult.toString() + \"_\" + problemStatisticType.toString(); <END> \/\/ concatening strings +, needed do .toString(). This result: return singleBenchmarkResult + \"_\" + problemStatisticType; Furthermore, avoids a nullpointerexception if for example problemStatisticType is null (which is in this case) }'","output":"public String toString() { return singleBenchmarkResult + \"_\" + problemStatisticType; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'beautiful'\nThe code is: 'public SimpleDialogPanel() { infoIconStyle = RESOURCES.iconStyle(); infoIconStyle.ensureInjected(); setWidget(WidgetUiBinder.uiBinder.createAndBindUi(this)); infoAnchor.addStyleName(infoIconStyle.infoIconColor()); <START> addAttachHandler(event -> { <END> \/\/ beautiful setDraggable(isAttached()); }); }'","output":"public SimpleDialogPanel() { infoIconStyle = RESOURCES.iconStyle(); infoIconStyle.ensureInjected(); setWidget(WidgetUiBinder.uiBinder.createAndBindUi(this)); infoAnchor.addStyleName(infoIconStyle.infoIconColor()); addAttachHandler(event -> setDraggable(isAttached())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For non-public methods checkWidget() is required'\nThe code is: 'void showTooltip (int x, int y) { <START> checkWidget (); <END> \/\/ For non-public methods checkWidget() is required if (itemToolTip == null) return; itemToolTip.setLocation (x, y); itemToolTip.setVisible (true); }'","output":"void showTooltip (int x, int y) { if (itemToolTip == null) return; itemToolTip.setLocation (x, y); itemToolTip.setVisible (true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please rename _ret variables ? remaining request I merge this PR. thanks'\nThe code is: 'private RequestController suspendedRCWithQueuedTasks(int i, Runnable whenExecuted) { RequestController _ret = new RequestController(false); <START> _ret.suspended(() -> { <END> \/\/ please rename _ret variables ? remaining request I merge this PR. thanks }); for (int taskNo = 0; taskNo < TASKS_QTY; taskNo++) { _ret.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return _ret; }'","output":"private RequestController suspendedRCWithQueuedTasks(int i, Runnable whenExecuted) { RequestController requestController = new RequestController(false); requestController.suspended(() -> { }); for (int taskNo = 0; taskNo < TASKS_QTY; taskNo++) { requestController.queueTask(null, null, task -> whenExecuted.run(), 0, null, false, false); } return requestController; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'preferable create a new method error propagation'\nThe code is: 'public COL get() { if (parsed==null) { synchronized (this) { if (parsed==null) { try { load(); } catch (IOException e) { <START> throw new RuntimeException(e); <END> \/\/ preferable create a new method error propagation } } } } return parsed; }'","output":"public COL get() { if (parsed==null) { synchronized (this) { if (parsed==null) { load(); } } } return parsed; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is benefit compared Collections.unmodifiableMap'\nThe code is: 'public Map<String, Object> getProperties() { <START> return UnmodifiableMap.decorate(properties); <END> \/\/ is benefit compared Collections.unmodifiableMap }'","output":"public Map<String, Object> getProperties() { return Collections.unmodifiableMap(properties); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'default (i.e., false) in place replacing this constructor implementation this(ErrorProneFlags.empty());'\nThe code is: 'public MissingOverride() { <START> this.ignoreInterfaceOverrides = false; <END> \/\/ default (i.e., false) in place replacing this constructor implementation this(ErrorProneFlags.empty()); }'","output":"public MissingOverride() { this(ErrorProneFlags.empty()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exiting, STDERR'\nThe code is: 'static BufferedReader openReader(File inputFile) { BufferedReader in = null; <START> try { <END> \/\/ exiting, STDERR in = new BufferedReader(new FileReader(inputFile)); } catch (Exception e) { logger.error(\"Can't open '\" + inputFile + \"' for input: \" + e); System.exit(1); } return in; }'","output":"static BufferedReader openReader(File inputFile) { BufferedReader in = null; try { in = new BufferedReader(new FileReader(inputFile)); } catch (Exception e) { System.err.println(\"Can't open '\" + inputFile + \"' for input: \" + e); System.exit(1); } return in; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: redundant casting'\nThe code is: 'public Object randomValue() { <START> return (boolean) ThreadLocalRandom.current().nextBoolean(); <END> \/\/ nit: redundant casting }'","output":"public Object randomValue() { return ThreadLocalRandom.current().nextBoolean(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this function private'\nThe code is: '<START> boolean deregisterIndexGauges(String storeId) { <END> \/\/ this function private String prefix = storeId + SEPERATOR; return registry.remove(MetricRegistry.name(Log.class, prefix + \"CurrentCapacityUsed\")) && registry.remove( MetricRegistry.name(Log.class, prefix + \"PercentageUsedCapacity\")) && registry.remove( MetricRegistry.name(Log.class, prefix + \"CurrentSegmentCount\")); }'","output":"private boolean deregisterIndexGauges(String storeId) { String prefix = storeId + SEPERATOR; return registry.remove(MetricRegistry.name(Log.class, prefix + \"CurrentCapacityUsed\")) && registry.remove( MetricRegistry.name(Log.class, prefix + \"PercentageUsedCapacity\")) && registry.remove( MetricRegistry.name(Log.class, prefix + \"CurrentSegmentCount\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(\"I_S_D_A\")) { str = \"ORIGINAL_ISDA\"; } return valueOf(str)'\nThe code is: 'public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, \"uniqueName\"); <START> return valueOf(uniqueName.replace('-', '_').toUpperCase(Locale.ENGLISH)); <END> \/\/ Code String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(\"I_S_D_A\")) { str = \"ORIGINAL_ISDA\"; } return valueOf(str) }'","output":"public static AccrualOnDefaultFormula of(String uniqueName) { ArgChecker.notNull(uniqueName, \"uniqueName\"); String str = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, uniqueName); if (str.endsWith(\"I_S_D_A\")) { str = \"ORIGINAL_ISDA\"; } return valueOf(str); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This swallow interrupts etc? Exceptions.propagateIfFatal() first'\nThe code is: 'public static String getFirstReachableAddress(ComputeServiceContext context, NodeMetadata node) { SshClient client; try { client = context.utils().sshForNode().apply(node); } catch (Exception e) { <START> throw new IllegalStateException(\"Unable to connect SshClient to \"+node+\"; check that the node is accessible and that the SSH key exists and is correctly configured, including any passphrase defined\", e); <END> \/\/ This swallow interrupts etc? Exceptions.propagateIfFatal() first } return client.getHostAddress(); }'","output":"public static String getFirstReachableAddress(ComputeServiceContext context, NodeMetadata node) { SshClient client; try { client = context.utils().sshForNode().apply(node); } catch (Exception e) { Exceptions.propagateIfFatal(e); throw new IllegalStateException(\"Unable to connect SshClient to \"+node+\"; check that the node is accessible and that the SSH key exists and is correctly configured, including any passphrase defined\", e); } return client.getHostAddress(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return (expression instanceof CallExpression) && functionManager.getFunctionMetadata(..'\nThe code is: 'private static boolean isSTDistance(RowExpression expression, FunctionManager functionManager) { <START> if (expression instanceof CallExpression) { <END> \/\/ return (expression instanceof CallExpression) && functionManager.getFunctionMetadata(.. return functionManager.getFunctionMetadata(((CallExpression) expression).getFunctionHandle()).getName().equals(ST_DISTANCE); } return false; }'","output":"private static boolean isSTDistance(RowExpression expression, FunctionManager functionManager) { return expression instanceof CallExpression && functionManager.getFunctionMetadata(((CallExpression) expression).getFunctionHandle()).getName().equals(ST_DISTANCE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'public Collection<OperatorSpec>'\nThe code is: '<START> public Set<OperatorSpec> getAllOperatorSpecs() { <END> \/\/ public Collection<OperatorSpec> Collection<InputStreamInternal> inputStreams = inStreams.values(); Set<OperatorSpec> operatorSpecs = new HashSet<>(); for (InputStreamInternal stream : inputStreams) { doGetOperatorSpecs((MessageStreamImpl) stream, operatorSpecs); } return operatorSpecs; }'","output":"public Collection<OperatorSpec> getAllOperatorSpecs() { Collection<InputStreamInternal> inputStreams = inStreams.values(); Set<OperatorSpec> operatorSpecs = new HashSet<>(); for (InputStreamInternal stream : inputStreams) { doGetOperatorSpecs((MessageStreamImpl) stream, operatorSpecs); } return operatorSpecs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws QueueFile.<Error>getSneakyThrowable(e);'\nThe code is: '@Override public E remove() { lock.lock(); try { if (queue.isEmpty()) { throw new NoSuchElementException(); } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> \/\/ throws QueueFile.<Error>getSneakyThrowable(e); } finally { lock.unlock(); } }'","output":"@Override public E remove() { lock.lock(); try { if (queue.isEmpty()) { throw new NoSuchElementException(); } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { throw QueueFile.<Error>getSneakyThrowable(e); } finally { lock.unlock(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'configure this @Mock annotation: @Mock(answer = RETURNS_DEEP_STUBS)'\nThe code is: 'public void setup() { <START> filterBuilder = mock(FilterBuilder.class, RETURNS_DEEP_STUBS); <END> \/\/ configure this @Mock annotation: @Mock(answer = RETURNS_DEEP_STUBS) when(workspaceMetacardFilter.filter(any())).thenReturn(true); workspaceServiceImpl = new WorkspaceServiceImpl( catalogFramework, workspaceTransformer, workspaceQueryBuilder, securityService, persistentStore, filterBuilder); workspaceServiceImpl.setMaxSubscriptions(100); }'","output":"public void setup() { when(workspaceMetacardFilter.filter(any())).thenReturn(true); workspaceServiceImpl = new WorkspaceServiceImpl( catalogFramework, workspaceTransformer, workspaceQueryBuilder, securityService, persistentStore, filterBuilder); workspaceServiceImpl.setMaxSubscriptions(100); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Revert this line'\nThe code is: 'protected String[] addUserIdToParams(String userId, String[] params) { <START> List<String> list = new ArrayList<String>(); <END> \/\/ Revert this line list.add(Const.ParamsNames.USER_ID); list.add(userId); for (String s : params) { list.add(s); } return list.toArray(new String[list.size()]); }'","output":"protected String[] addUserIdToParams(String userId, String[] params) { List<String> list = new ArrayList<>(); list.add(Const.ParamsNames.USER_ID); list.add(userId); for (String s : params) { list.add(s); } return list.toArray(new String[list.size()]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Huh? point is a cast necessary'\nThe code is: 'public void arrayType() { Type type = parseType(\"int[]\"); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; <START> type.ifArrayType(t -> s[0] = (ArrayType)t); <END> \/\/ Huh? point is a cast necessary assertNotNull(s[0]); }'","output":"public void arrayType() { Type type = parseType(\"int[]\"); assertTrue(type.isArrayType()); ArrayType arrayType = type.asArrayType(); final ArrayType[] s = new ArrayType[1]; type.ifArrayType(t -> s[0] = t); assertNotNull(s[0]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'protected access modifier instead of default (all-over)'\nThe code is: '<START> boolean isGlusterSupportEnabled() { <END> \/\/ protected access modifier instead of default (all-over) return getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded(); }'","output":"protected boolean isGlusterSupportEnabled() { return getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'FQN needed here, instead simple name suffice returning required import getImports()'\nThe code is: 'protected String getToExpression(ConversionContext conversionContext) { <START> return \"new java.sql.Timestamp( <SOURCE>.getTime() )\"; <END> \/\/ FQN needed here, instead simple name suffice returning required import getImports() }'","output":"protected String getToExpression(ConversionContext conversionContext) { return \"new Timestamp( <SOURCE>.getTime() )\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggest private'\nThe code is: '<START> long consumerLag() { <END> \/\/ suggest private return consumerLag; }'","output":"private long consumerLag() { return consumerLag; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'TargetCardInYourGraveyard'\nThe code is: 'public SoulStrings(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.SORCERY}, \"{X}{B}\"); Effect effect = new DoUnlessAnyPlayerPaysEffect( new ReturnFromGraveyardToHandTargetEffect(), new VariableManaCost() ); this.getSpellAbility().addEffect(effect); <START> this.getSpellAbility().addTarget(new TargetCardInGraveyard(2, new FilterCreatureCard(\"creature cards from your graveyard\"))); <END> \/\/ TargetCardInYourGraveyard }'","output":"public SoulStrings(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.SORCERY}, \"{X}{B}\"); Effect effect = new DoUnlessAnyPlayerPaysEffect( new ReturnFromGraveyardToHandTargetEffect(), new VariableManaCost() ); this.getSpellAbility().addEffect(effect); this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(2, new FilterCreatureCard(\"creature cards from your graveyard\"))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This ParameterService method accepts a Boolean object, need unbox Boolean.TRUE here'\nThe code is: 'protected boolean shouldValidateOnBudgetTotal() { Boolean validateOnBudgetTotal = parameterService.getParameterValueAsBoolean(ArConstants.AR_NAMESPACE_CODE, ArConstants.CONTRACTS_GRANTS_INVOICE_COMPONENT, <START> CuArConstants.CG_INVOICE_AMT_BILLED_SUSPENSION_BY_BUDGET_TOTAL, Boolean.TRUE.booleanValue()); <END> \/\/ This ParameterService method accepts a Boolean object, need unbox Boolean.TRUE here if (LOG.isDebugEnabled()) { LOG.debug(\"shouldValidateOnBudgetTotal, the value of \" + CuArConstants.CG_INVOICE_AMT_BILLED_SUSPENSION_BY_BUDGET_TOTAL + \" is \" + validateOnBudgetTotal.booleanValue()); } return validateOnBudgetTotal.booleanValue(); }'","output":"protected boolean shouldValidateOnBudgetTotal() { Boolean validateOnBudgetTotal = parameterService.getParameterValueAsBoolean(ArConstants.AR_NAMESPACE_CODE, ArConstants.CONTRACTS_GRANTS_INVOICE_COMPONENT, CuArConstants.CG_INVOICE_AMT_BILLED_SUSPENSION_BY_BUDGET_TOTAL, Boolean.TRUE); if (LOG.isDebugEnabled()) { LOG.debug(\"shouldValidateOnBudgetTotal, the value of \" + CuArConstants.CG_INVOICE_AMT_BILLED_SUSPENSION_BY_BUDGET_TOTAL + \" is \" + validateOnBudgetTotal.booleanValue()); } return validateOnBudgetTotal.booleanValue(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'more lenient comparison window always, get rid of OS detection? intending test system clock all, OS-specific behavior avoided possible'\nThe code is: 'private TemporalUnitOffset getAllowableOffset() { if (SystemUtils.IS_OS_WINDOWS) { <START> return within(0, ChronoUnit.MICROS); <END> \/\/ more lenient comparison window always, get rid of OS detection? intending test system clock all, OS-specific behavior avoided possible } else { return within(0, ChronoUnit.NANOS); } }'","output":"private TemporalUnitOffset getAllowableOffset() { return within(0, ChronoUnit.MICROS); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'overloaded constructor in ReleaseHelper do this(cClient, false, null, null). false, null, null part code readable this place, parameters mean. usage in ComponentExporter'\nThe code is: 'public ProjectExporter(ComponentService.Iface componentClient, ProjectService.Iface projectClient, User user, List<Project> projects, boolean extendedByReleases) throws SW360Exception { super(new ProjectHelper(projectClient, user, extendedByReleases, <START> new ReleaseHelper(componentClient, false, null, null))); <END> \/\/ overloaded constructor in ReleaseHelper do this(cClient, false, null, null). false, null, null part code readable this place, parameters mean. usage in ComponentExporter preloadRelatedDataFor(projects, extendedByReleases, user); }'","output":"public ProjectExporter(ComponentService.Iface componentClient, ProjectService.Iface projectClient, User user, List<Project> projects, boolean extendedByReleases) throws SW360Exception { super(new ProjectHelper(projectClient, user, extendedByReleases, new ReleaseHelper(componentClient))); preloadRelatedDataFor(projects, extendedByReleases, user); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'type ChargeDTO in return responseEntity instead of'\nThe code is: '<START> public ResponseEntity<?> charge(@RequestBody @Valid ChargeDTO chargeDTO) { <END> \/\/ type ChargeDTO in return responseEntity instead of LOG.info(\" Charge controller new chargeDTO: \" + chargeDTO.getDescription()); ChargeDTO resultDTO; try { resultDTO = paymentService.charge(chargeDTO, PaymentType.USER_LICENSE); } catch (ServiceException e) { LOG.log(Level.SEVERE, e.getMessage()); throw new BadRequestException(e.getMessage()); } return new ResponseEntity<>(resultDTO, HttpStatus.OK); }'","output":"public ResponseEntity<ChargeDTO> charge(@RequestBody @Valid ChargeDTO chargeDTO) { LOG.info(\" Charge controller new chargeDTO: \" + chargeDTO.getDescription()); ChargeDTO resultDTO; try { resultDTO = paymentService.charge(chargeDTO, PaymentType.USER_LICENSE); } catch (ServiceException e) { LOG.log(Level.SEVERE, e.getMessage()); throw new BadRequestException(e.getMessage()); } return new ResponseEntity<>(resultDTO, HttpStatus.OK); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this instead? return getNonNullRequestParamValues(paramName)[0]'\nThe code is: 'protected String getNonNullRequestParamValue(String paramName) { String value = getRequestParamValue(paramName); Assumption.assertPostParamNotNull(paramName, value); <START> return value; <END> \/\/ this instead? return getNonNullRequestParamValues(paramName)[0] }'","output":"protected String getNonNullRequestParamValue(String paramName) { return getNonNullRequestParamValues(paramName)[0]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'final :D'\nThe code is: 'private Map getViews(){ <START> Map allViews = new HashMap<>(); <END> \/\/ final :D allViews.put( ViewType.CLI, getCliViews() ); allViews.put( ViewType.JSON, getJsonViews() ); return allViews; }'","output":"private Map getViews(){ final Map allViews = new HashMap<>(); allViews.put( ViewType.CLI, getCliViews() ); allViews.put( ViewType.JSON, getJsonViews() ); return allViews; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getInstance().logError() instead of printStackTrace'\nThe code is: 'protected void startActions() { try { fServer = new LSPServer(); } catch (IOException e) { <START> e.printStackTrace(); <END> \/\/ getInstance().logError() instead of printStackTrace } }'","output":"protected void startActions() { try { fServer = new LSPServer(); } catch (IOException e) { getInstance().logError(e.getMessage()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rewrite: this.apolloEnabled = \"true\".equalsIgnoreCase(apolloFlag)'\nThe code is: 'public void registerApollo(String apolloFlag) { <START> if (apolloFlag != null && apolloFlag.equalsIgnoreCase(\"true\")) { <END> \/\/ rewrite: this.apolloEnabled = \"true\".equalsIgnoreCase(apolloFlag) this.apolloEnabled = true; } else { this.apolloEnabled = false; } }'","output":"public void registerApollo(String apolloFlag) { this.apolloEnabled = \"true\".equalsIgnoreCase(apolloFlag); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'registerOn'\nThe code is: 'public void onServiceConnected(ComponentName componentName, IBinder iBinder) { super.onServiceConnected(componentName, iBinder); getService().registeronServiceStateChangeListener(this); getService().registeronServiceStateChangeListener(mFolderListFragment); <START> getService().registeronServiceStateChangeListener(mDeviceListFragment); <END> \/\/ registerOn }'","output":"public void onServiceConnected(ComponentName componentName, IBinder iBinder) { super.onServiceConnected(componentName, iBinder); getService().registerOnServiceStateChangeListener(this); getService().registerOnServiceStateChangeListener(mFolderListFragment); getService().registerOnServiceStateChangeListener(mDeviceListFragment); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call super(conf, store, smallestReadPoint) instead'\nThe code is: 'public SpliceDefaultCompactor(final Configuration conf, final Store store, long smallestReadPoint) { <START> super(conf, store); <END> \/\/ call super(conf, store, smallestReadPoint) instead }'","output":"public SpliceDefaultCompactor(final Configuration conf, final Store store, long smallestReadPoint) { super(conf, store, smallestReadPoint); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'activeScope, wrong..'\nThe code is: 'private void closeScope() { if (openTracingService == null) { return; } Tracer tracer = openTracingService.getTracer(PAYARA_CORBA_RMI_TRACER_NAME); if (tracer == null) { return; } <START> try (Scope activeScope = tracer.scopeManager().active()) { <END> \/\/ activeScope, wrong.. } }'","output":"private void closeScope() { if (!tracerAvailable()) { return; } try (Scope activeScope = tracer.scopeManager().active()) { } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'it, please change this long primitive type? :)'\nThe code is: 'public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> Long id = Long.parseLong(issueId + \"0\" + newCommentId); <END> \/\/ it, please change this long primitive type? :) URI selfUri = URI.create(TEST_JIRA_URL + \"\/rest\/api\/latest\/issue\/\" + issueId + \"\/comment\"); return new Comment(selfUri, comment, null, null, now, null, null, id); }'","output":"public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); long id = Long.parseLong(issueId + \"0\" + newCommentId); URI selfUri = URI.create(TEST_JIRA_URL + \"\/rest\/api\/latest\/issue\/\" + issueId + \"\/comment\"); return new Comment(selfUri, comment, null, null, now, null, null, id); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is a code smell. path super. Instead, call this(storagePoolId, null)'\nThe code is: 'public SyncLunsParameters(Guid storagePoolId) { <START> super(storagePoolId); <END> \/\/ This is a code smell. path super. Instead, call this(storagePoolId, null) }'","output":"public SyncLunsParameters(Guid storagePoolId) { this(storagePoolId, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This breaks MySql in theory ... DefaultBeanLoader line 224'\nThe code is: 'public SpiTransaction createQueryTransaction(Object tenantId) { SpiTransaction t = transactionManager.createQueryTransaction(tenantId); try { <START> transactionScopeManager.set(t); <END> \/\/ This breaks MySql in theory ... DefaultBeanLoader line 224 } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; }'","output":"public SpiTransaction createQueryTransaction(Object tenantId) { SpiTransaction t = transactionManager.createQueryTransaction(tenantId); return t; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Return type changed Iterator'\nThe code is: '<START> public TreasureChestItemIterator iterator(ItemType itemType) { <END> \/\/ Return type changed Iterator return new TreasureChestItemIterator(this, itemType); }'","output":"public Iterator<Item> iterator(ItemType itemType) { return new TreasureChestItemIterator(this, itemType); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this synchronized'\nThe code is: '<START> public void clear() { <END> \/\/ this synchronized this.domainsVisibility.clear(); }'","output":"public synchronized void clear() { this.domainsVisibility.clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrong method name in error message'\nThe code is: 'default CompletionStage<Void> commit(Transaction transaction) { <START> throw new UnsupportedOperationException(\"Store characteristic included \" + Characteristic.TRANSACTIONAL + \", but it does not implement rollback\"); <END> \/\/ Wrong method name in error message }'","output":"default CompletionStage<Void> commit(Transaction transaction) { throw new UnsupportedOperationException(\"Store characteristic included \" + Characteristic.TRANSACTIONAL + \", but it does not implement commit\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Style inconsistency: space if'\nThe code is: 'private void onAddExpenseResult(Intent data) { ExpenseClaim claim = (ExpenseClaim)data.getSerializableExtra(ExpenseClaimAddActivity.EXTRA_EXPENSE_CLAIM); listModel.add(claim); <START> if(checkFilteredTags()) { <END> \/\/ Style inconsistency: space if setListAdapter(new ExpenseClaimArrayAdapter(this, filteredListModel.getItems())); } }'","output":"private void onAddExpenseResult(Intent data) { ExpenseClaim claim = (ExpenseClaim)data.getSerializableExtra(ExpenseClaimAddActivity.EXTRA_EXPENSE_CLAIM); listModel.add(claim); if (!filteredTagsList.isEmpty()) { setListAdapter(new ExpenseClaimArrayAdapter(this, filteredListModel.getItems())); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this stay in warn'\nThe code is: 'public void init(FMLInitializationEvent evt) { try { Natura.logger.debug(\"[MFR] Registering Natura trees\/plants\/crops with MFR Farming Registry.\"); MRFRegistering.registerWithMFR(); } catch (Throwable t) { <START> Natura.logger.debug(\"Something went wrong in Natura plugin MineFactoryReloaded.\", t); <END> \/\/ this stay in warn } }'","output":"public void init(FMLInitializationEvent evt) { try { Natura.logger.debug(\"[MFR] Registering Natura trees\/plants\/crops with MFR Farming Registry.\"); MRFRegistering.registerWithMFR(); } catch (Throwable t) { Natura.logger.warn(\"Something went wrong in Natura plugin MineFactoryReloaded.\", t); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion annotation.maxCharsPerColumn(), annotation.ignoreTrailingAndLeadingWhitespace());'\nThe code is: 'static CsvParser createParserFor(CsvFileSource annotation) { String delimiter = selectDelimiter(annotation, annotation.delimiter(), annotation.delimiterString()); return createParser(delimiter, annotation.lineSeparator(), DOUBLE_QUOTE, annotation.emptyValue(), <START> annotation.maxCharsPerColumn(), false); <END> \/\/ suggestion annotation.maxCharsPerColumn(), annotation.ignoreTrailingAndLeadingWhitespace()); }'","output":"static CsvParser createParserFor(CsvFileSource annotation) { String delimiter = selectDelimiter(annotation, annotation.delimiter(), annotation.delimiterString()); return createParser(delimiter, annotation.lineSeparator(), DOUBLE_QUOTE, annotation.emptyValue(), annotation.maxCharsPerColumn(), annotation.ignoreTrailingAndLeadingWhitespace()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change breaks equals contract, equality account subclass names this new hashCode does. avoid that, Objects.hash(AnchorVariableDemand.class.getName(), ...)'\nThe code is: 'public int hashCode() { <START> return Objects.hash(this.getClass().getName(), sourceVariableDescriptor); <END> \/\/ Change breaks equals contract, equality account subclass names this new hashCode does. avoid that, Objects.hash(AnchorVariableDemand.class.getName(), ...) }'","output":"public int hashCode() { return Objects.hash(AnchorVariableDemand.class.getName(), sourceVariableDescriptor); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace return this == other;'\nThe code is: 'public boolean equals( Object other ) { <START> return false; <END> \/\/ replace return this == other; }'","output":"public boolean equals( Object other ) { return this == other; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null check'\nThe code is: 'public DefaultLeaderRetrievalService(LeaderRetrievalDriverFactory leaderRetrievalDriverFactory) { <START> this.leaderRetrievalDriverFactory = leaderRetrievalDriverFactory; <END> \/\/ null check this.lastLeaderAddress = null; this.lastLeaderSessionID = null; running = false; }'","output":"public DefaultLeaderRetrievalService(LeaderRetrievalDriverFactory leaderRetrievalDriverFactory) { this.leaderRetrievalDriverFactory = checkNotNull(leaderRetrievalDriverFactory); this.lastLeaderAddress = null; this.lastLeaderSessionID = null; running = false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is null a valid input all'\nThe code is: 'public static NetworkType fromValue(String value) { <START> if (value == null) return null; <END> \/\/ Is null a valid input all return NetworkType.valueOf(value.toUpperCase()); }'","output":"public static NetworkType fromValue(String value) { return NetworkType.valueOf(value.toUpperCase()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'empty string a collection items in (which is returned before). Is this correct? account for JSON files breaking'\nThe code is: 'public String getLabelFilter() { <START> return labelFilter == null ? \"\" : labelFilter; <END> \/\/ empty string a collection items in (which is returned before). Is this correct? account for JSON files breaking }'","output":"public String getLabelFilter() { return labelFilter; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'parameter needs 1 backup model node is level cache'\nThe code is: 'public BackupGetSendingSiteCommand() { <START> super(0); <END> \/\/ parameter needs 1 backup model node is level cache }'","output":"public BackupGetSendingSiteCommand() { super(1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else branch is needed'\nThe code is: 'private static IActivityListener createForwarder(final IActivityConsumer target) { return new IActivityListener() { @Override public void created(IActivity activity) { if (activity instanceof GitRequestActivity) { target.exec(rewriteGitRequestActivity((GitRequestActivity) activity)); } else if (activity instanceof GitCollectActivity) { target.exec(rewriteGitCollectActivity((GitCollectActivity) activity)); } else if (activity instanceof GitSendBundleActivity) { target.exec(rewriteGitSendBundleActivity((GitSendBundleActivity) activity)); } else { <START> return; <END> \/\/ else branch is needed } } }; }'","output":"private static IActivityListener createForwarder(final IActivityConsumer target) { return new IActivityListener() { @Override public void created(IActivity activity) { if (activity instanceof GitRequestActivity) { target.exec(rewriteGitRequestActivity((GitRequestActivity) activity)); } else if (activity instanceof GitCollectActivity) { target.exec(rewriteGitCollectActivity((GitCollectActivity) activity)); } else if (activity instanceof GitSendBundleActivity) { target.exec(rewriteGitSendBundleActivity((GitSendBundleActivity) activity)); } } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this == 0'\nThe code is: 'public static boolean sameAnnotationValue(AnnotationValue av1, AnnotationValue av2) { <START> return compareAnnotationValue(av1, av2) != 0; <END> \/\/ this == 0 }'","output":"public static boolean sameAnnotationValue(AnnotationValue av1, AnnotationValue av2) { return compareAnnotationValue(av1, av2) == 0; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'log excepion'\nThe code is: 'public void start() { try { server.setHandler(new Dhis2RequestsHandler()); server.start(); } catch (Exception e) { <START> LOGGER.error(\"Failed to start the Jetty server\"); <END> \/\/ log excepion } }'","output":"public void start() { try { server.setHandler(new Dhis2RequestsHandler()); server.start(); } catch (Exception e) { LOGGER.error(\"Failed to start the Jetty server.\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Empty return needed'\nThe code is: 'public void execute(T t) { <START> return; <END> \/\/ Empty return needed }'","output":"public void execute(T t) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtils.isNotBlank compare for null'\nThe code is: 'private boolean matchNamePattern(String value, String namePattern) { boolean match = true; <START> if (value != null && StringUtils.isNotBlank(value)) { <END> \/\/ StringUtils.isNotBlank compare for null match = value.matches(namePattern); } return match; }'","output":"private boolean matchNamePattern(String value, String namePattern) { boolean match = true; if (StringUtils.isNotBlank(value)) { match = value.matches(namePattern); } return match; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wondering...is worth putting rc == FMT check for a short-circuiting efficiency improvement'\nThe code is: 'public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); <START> return isRTPFBPacket(baf) && rc == FMT; <END> \/\/ wondering...is worth putting rc == FMT check for a short-circuiting efficiency improvement }'","output":"public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); return rc == FMT && isRTPFBPacket(baf); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Suggest retaining untranslated strings translating rendering'\nThe code is: 'private void prepare(ControlWidget screen) { InjectionHelper.inject(screen); <START> translator.updateWidget(screen); <END> \/\/ Suggest retaining untranslated strings translating rendering screen.onOpened(); }'","output":"private void prepare(ControlWidget screen) { InjectionHelper.inject(screen); screen.onOpened(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Selectors fetched database'\nThe code is: 'public List<ResourceGroupSelector> getSelectors() { if (lastRefresh.get() == 0) { <START> throw new PrestoException(CONFIGURATION_UNAVAILABLE, \"Selectors could not be fetched from database\"); <END> \/\/ Selectors fetched database } if (this.selectors.get().isEmpty()) { throw new PrestoException(CONFIGURATION_INVALID, \"No selectors are configured\"); } return this.selectors.get(); }'","output":"public List<ResourceGroupSelector> getSelectors() { if (lastRefresh.get() == 0) { throw new PrestoException(CONFIGURATION_UNAVAILABLE, \"Selectors cannot be fetched from database\"); } if (this.selectors.get().isEmpty()) { throw new PrestoException(CONFIGURATION_INVALID, \"No selectors are configured\"); } return this.selectors.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'useless cast long double'\nThe code is: 'public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(\"The value of the scale denominator must be equal or greater than 1\"),pce); } <START> mapControl.getMapTransform().setScaleDenominator((double)newScale); <END> \/\/ useless cast long double }'","output":"public void onUserSetScaleDenominator(PropertyChangeEvent pce) throws PropertyVetoException { long newScale = (Long)pce.getNewValue(); if(newScale<1) { throw new PropertyVetoException(I18N.tr(\"The value of the scale denominator must be equal or greater than 1\"),pce); } mapControl.getMapTransform().setScaleDenominator(newScale); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I assume this function called if service is activated. EventPublisher is a mandatory reference, need check for nullness'\nThe code is: 'private void postInstalledEvent(String extensionId) { <START> if (eventPublisher != null) { <END> \/\/ I assume this function called if service is activated. EventPublisher is a mandatory reference, need check for nullness Event event = ExtensionEventFactory.createExtensionInstalledEvent(extensionId); eventPublisher.post(event); } }'","output":"private void postInstalledEvent(String extensionId) { Event event = ExtensionEventFactory.createExtensionInstalledEvent(extensionId); eventPublisher.post(event); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I LOGGER legitimate in this case, is related slave logs'\nThe code is: 'private OutputStream decorate(OutputStream os) { for (ConsoleLogFilter f : ConsoleLogFilter.all()) { try { os = f.decorateLogger(this,os); } catch (IOException|InterruptedException e) { <START> logger.log(Level.WARNING, \"Failed to filter log with \"+f, e); <END> \/\/ I LOGGER legitimate in this case, is related slave logs } } return os; }'","output":"private OutputStream decorate(OutputStream os) { for (ConsoleLogFilter f : ConsoleLogFilter.all()) { try { os = f.decorateLogger(this,os); } catch (IOException|InterruptedException e) { LOGGER.log(Level.WARNING, \"Failed to filter log with \"+f, e); } } return os; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change this TypeConstants.JAVA_LANG_RECORD'\nThe code is: 'public boolean isRecord() throws JavaModelException { IBinaryType info = (IBinaryType) getElementInfo(); if( TypeDeclaration.kind(info.getModifiers()) == TypeDeclaration.CLASS_DECL) { <START> return CharOperation.equals(info.getSuperclassName(), RecordDeclaration.super_class); <END> \/\/ change this TypeConstants.JAVA_LANG_RECORD } return false; }'","output":"public boolean isRecord() throws JavaModelException { IBinaryType info = (IBinaryType) getElementInfo(); if( TypeDeclaration.kind(info.getModifiers()) == TypeDeclaration.CLASS_DECL) { return CharOperation.equals(info.getSuperclassName(), TypeConstants.CharArray_JAVA_LANG_RECORD); } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: liner: this.features = Objects.requireNonNull(features, \"Provided features null.\");'\nThe code is: 'private Features(Map<String, VersionRangeType> features) { <START> if (features == null) { <END> \/\/ nit: liner: this.features = Objects.requireNonNull(features, \"Provided features null.\"); throw new IllegalArgumentException(\"Provided features can not be null.\"); } this.features = features; }'","output":"private Features(Map<String, VersionRangeType> features) { Objects.requireNonNull(features, \"Provided features can not be null.\"); this.features = features; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a simple setter (notice setWaterLevelIncrementRatio this side effect) AcceptorConfig set default value, similar sets 400 for Late Acceptance'\nThe code is: 'public void setWaterLevelIncrementScore(Score waterLevelIncrementScore) { this.waterLevelIncrementScore = waterLevelIncrementScore; <START> this.waterLevelIncrementRatio = null; <END> \/\/ a simple setter (notice setWaterLevelIncrementRatio this side effect) AcceptorConfig set default value, similar sets 400 for Late Acceptance }'","output":"public void setWaterLevelIncrementScore(Score waterLevelIncrementScore) { this.waterLevelIncrementScore = waterLevelIncrementScore; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call super() is superfluous removed. compiler care of this'\nThe code is: 'public SetDataRequestDto(final List<SetDataSystemIdentifierDto> setDataSystemIdentifiers) { <START> super(); <END> \/\/ call super() is superfluous removed. compiler care of this this.setDataSystemIdentifiers = setDataSystemIdentifiers; }'","output":"public SetDataRequestDto(final List<SetDataSystemIdentifierDto> setDataSystemIdentifiers) { this.setDataSystemIdentifiers = new ArrayList<>(setDataSystemIdentifiers); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this line'\nThe code is: 'public MobileSpecialUserLogin(WebDriver driver) { super(driver); <START> PageFactory.initElements(driver, this); <END> \/\/ remove this line }'","output":"public MobileSpecialUserLogin(WebDriver driver) { super(driver); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reorder this if-then-else? To: if (StringUtils.isBlank(consoleProxyUrlDomain) { \/\/ Blank config, proxy IP sb.append(proxyIpAddress); } else if (consoleProxyUrlDomain.startsWith(\"*\")) { sb.append(proxyIpAddress.replaceAll(\"\\\\.\", \"-\")); sb.append(consoleProxyUrlDomain.substring(1)); \/\/ skip * } else { \/\/ assume a valid domain if config blank sb.append(consoleProxyUrlDomain); }'\nThe code is: 'private String formatProxyAddress(String consoleProxyUrlDomain, String proxyIpAddress) { StringBuffer sb = new StringBuffer(); <START> if (consoleProxyUrlDomain != null && consoleProxyUrlDomain.startsWith(\"*\")) { <END> \/\/ reorder this if-then-else? To: if (StringUtils.isBlank(consoleProxyUrlDomain) { \/\/ Blank config, proxy IP sb.append(proxyIpAddress); } else if (consoleProxyUrlDomain.startsWith(\"*\")) { sb.append(proxyIpAddress.replaceAll(\"\\\\.\", \"-\")); sb.append(consoleProxyUrlDomain.substring(1)); \/\/ skip * } else { \/\/ assume a valid domain if config blank sb.append(consoleProxyUrlDomain); } sb.append(proxyIpAddress.replaceAll(\"\\\\.\", \"-\")); sb.append(consoleProxyUrlDomain.substring(1)); } else if (StringUtils.isNotBlank(consoleProxyUrlDomain)) { sb.append(consoleProxyUrlDomain); } else { sb.append(proxyIpAddress); } return sb.toString(); }'","output":"private String formatProxyAddress(String consoleProxyUrlDomain, String proxyIpAddress) { StringBuffer sb = new StringBuffer(); if (StringUtils.isBlank(consoleProxyUrlDomain)) { sb.append(proxyIpAddress); } else if (consoleProxyUrlDomain.startsWith(\"*\")) { sb.append(proxyIpAddress.replaceAll(\"\\\\.\", \"-\")); sb.append(consoleProxyUrlDomain.substring(1)); } else { sb.append(consoleProxyUrlDomain); } return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this necessary'\nThe code is: 'private JsonNode parseRequestResponse (Response response) throws IOException { <START> response.bufferEntity(); <END> \/\/ is this necessary String body = response.readEntity(String.class); ObjectMapper objectMapper = new ObjectMapper(); return objectMapper.readTree(body); }'","output":"private JsonNode parseRequestResponse (Response response) throws IOException { String body = response.readEntity(String.class); ObjectMapper objectMapper = new ObjectMapper(); return objectMapper.readTree(body); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'returning boolean type is useless return **true**, throw timeout exception'\nThe code is: '<START> public boolean waitInvisibility(By elementLocator) { <END> \/\/ returning boolean type is useless return **true**, throw timeout exception return waitInvisibility(elementLocator, DEFAULT_TIMEOUT); }'","output":"public void waitInvisibility(By elementLocator) { waitInvisibility(elementLocator, DEFAULT_TIMEOUT); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'require ?test param'\nThe code is: 'public void setup() { try { <START> this.espConn = new Connection(\"http:\/\/\" + testClusterIp + \":8010?test\"); <END> \/\/ require ?test param espConn.setUserName(\"\"); espConn.setPassword(\"\"); } catch (Exception e) {} }'","output":"public void setup() { try { this.espConn = new Connection(\"http:\/\/\" + testClusterIp + \":8010\"); espConn.setUserName(\"\"); espConn.setPassword(\"\"); } catch (Exception e) {} }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this public'\nThe code is: '<START> public void addControl(String id, Control control) { <END> \/\/ is this public if (controls.containsKey(id)) { throw new IllegalArgumentException( MessageFormat.format(\"A control with id {0} already exists\", id)); } controls.put(id, control); }'","output":"protected void addControl(String id, Control control) { if (controls.containsKey(id)) { throw new IllegalArgumentException( MessageFormat.format(\"A control with id {0} already exists\", id)); } controls.put(id, control); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Thanks. change it'\nThe code is: 'public CompletableFuture<org.apache.bookkeeper.client.api.LedgerEntries> readUnconfirmed(long firstEntry, <START> long lastEntry) { END> if (firstEntry < 0 || firstEntry > lastEntry) { LOG.error(\"IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}\", new Object[] { ledgerId, firstEntry, lastEntry }); return FutureUtils.exception(new BKIncorrectParameterException()); } return readEntriesInternalAsync(firstEntry, lastEntry); }'","output":"public CompletableFuture<LedgerEntries> readUnconfirmed(long firstEntry, long lastEntry) { if (firstEntry < 0 || firstEntry > lastEntry) { LOG.error(\"IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}\", new Object[] { ledgerId, firstEntry, lastEntry }); return FutureUtils.exception(new BKIncorrectParameterException()); } return readEntriesInternalAsync(firstEntry, lastEntry); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This public. default package access thee cache impl in this package it'\nThe code is: '<START> public SshKeyCacheEntryIterable(Iterable<SshKeyCacheEntry> sshKeyIter) { <END> \/\/ This public. default package access thee cache impl in this package it this.sshKeyIter = sshKeyIter; }'","output":"SshKeyCacheEntryIterable(Iterable<SshKeyCacheEntry> sshKeyIter) { this.sshKeyIter = sshKeyIter; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this returns expression, combine this line next'\nThe code is: 'public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); <START> requireNonNull(expression, \"expression can't be null\"); <END> \/\/ this returns expression, combine this line next this.expression = expression; }'","output":"public ProcessorExpressionRoute(String expression, Processor processor) { super(processor); this.expression = requireNonNull(expression, \"expression can't be null\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![INFO](<LINK_0> 'Severity: INFO') Do forget remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>'\nThe code is: '<START> public QualityProfileDto selectByNameAndLanguage(String name, String language, DbSession session) { <END> \/\/ ![INFO](<LINK_0> 'Severity: INFO') Do forget remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2> return mapper(session).selectByNameAndLanguage(name, language); }'","output":"public QualityProfileDto selectByNameAndLanguage(String name, String language, DbSession session) { return mapper(session).selectByNameAndLanguage(null, name, language); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this private method'\nThe code is: '<START> StopModel getReverseStopID(String stopId, String routeShortName) { <END> \/\/ this private method List<Criteria> criteria = new ArrayList<>(2); criteria.add(new Criteria(\"route_short_name\", Criteria.Operation.EQ, routeShortName)); criteria.add(new Criteria(\"stop_id\", Criteria.Operation.EQ, stopId)); Cursor cursor = reverseStopCursorAdapterSupplier.getCursor(context, criteria); if (cursor.moveToFirst()) { return reverseStopCursorAdapterSupplier.getCurrentItemFromCursor(cursor); } else { return null; } }'","output":"private StopModel getReverseStopID(String stopId, String routeShortName) { List<Criteria> criteria = new ArrayList<>(2); criteria.add(new Criteria(\"route_short_name\", Criteria.Operation.EQ, routeShortName)); criteria.add(new Criteria(\"stop_id\", Criteria.Operation.EQ, stopId)); Cursor cursor = reverseStopCursorAdapterSupplier.getCursor(context, criteria); if (cursor.moveToFirst()) { return reverseStopCursorAdapterSupplier.getCurrentItemFromCursor(cursor); } else { return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Similarly static enum thing, I subjectively enum constructors explicitly private practical difference. rationale for this change'\nThe code is: '<START> HtmlElementTransformation(String tagName, String attributeName) { <END> \/\/ Similarly static enum thing, I subjectively enum constructors explicitly private practical difference. rationale for this change this.matchingTagName = tagName; this.matchingAttributeName = attributeName; }'","output":"private HtmlElementTransformation(String tagName, String attributeName) { this.matchingTagName = tagName; this.matchingAttributeName = attributeName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Boolean, boolean'\nThe code is: '<START> public static Boolean isString(Schema.Type type) { <END> \/\/ Boolean, boolean return Schema.Type.STRING.equals(type); }'","output":"public static boolean isString(Schema.Type type) { return Schema.Type.STRING.equals(type); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove \"this.\"'\nThe code is: 'public void tearDown() throws Exception { <START> this.mTranslateSpecialChar = null; <END> \/\/ remove \"this.\" this.mTestStr.clear(); this.mVerifyStr.clear(); }'","output":"public void tearDown() throws Exception { mTranslateSpecialChar = null; mTestStr.clear(); mVerifyStr.clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.emptyList(); need create new instance'\nThe code is: 'public static List<String> getTags(JSONObject jo) throws JSONException { if (jo.has(FIELD_TAGS)) { return getStringsFromJSONArray(jo.getJSONArray(FIELD_TAGS)); } else { <START> return Lists.newArrayList(); <END> \/\/ Collections.emptyList(); need create new instance } }'","output":"public static List<String> getTags(JSONObject jo) throws JSONException { if (jo.has(FIELD_TAGS)) { return getStringsFromJSONArray(jo.getJSONArray(FIELD_TAGS)); } else { return Collections.emptyList(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove'\nThe code is: 'public TestingService(ProjectManager projectManager, TestFrameworkRegistry frameworkRegistry, TestClasspathRegistry classpathRegistry) { this.projectManager = projectManager; this.frameworkRegistry = frameworkRegistry; this.classpathRegistry = classpathRegistry; <START> System.out.println(\"inititilaized TestingService\"); <END> \/\/ remove }'","output":"public TestingService(ProjectManager projectManager, TestFrameworkRegistry frameworkRegistry, TestClasspathRegistry classpathRegistry) { this.projectManager = projectManager; this.frameworkRegistry = frameworkRegistry; this.classpathRegistry = classpathRegistry; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This more readable return isGenotypeInTransition(g, transition) || is GenotypeInTransition(g, transition.complement())'\nThe code is: 'public static boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, \"Genotype cannot be null\"); Utils.nonNull(transition, \"Transition cannot be null\"); <START> final boolean isInTransition = isGenotypeInTransition(g, transition); <END> \/\/ This more readable return isGenotypeInTransition(g, transition) || is GenotypeInTransition(g, transition.complement()) if (isInTransition) { return true; } final Transition transitionComplement = transition.complement(); return isGenotypeInTransition(g, transitionComplement); }'","output":"public static boolean isGenotypeInTransitionWithComplement(final Genotype g, final Transition transition) { Utils.nonNull(g, \"Genotype cannot be null\"); Utils.nonNull(transition, \"Transition cannot be null\"); return isGenotypeInTransition(g, transition) || isGenotypeInTransition(g, transition.complement()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'happen null is returned current scene = null project = null? this a problem'\nThe code is: 'public Scene getCurrentScene() { if (currentScene == null && project != null) { currentScene = project.getDefaultScene(); } <START> return currentScene; <END> \/\/ happen null is returned current scene = null project = null? this a problem }'","output":"public Scene getCurrentScene() { if (currentScene == null) { currentScene = project.getDefaultScene(); } return currentScene; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I a try-with-resources better, in case raise exception for instance'\nThe code is: 'public <T> List<T> queryList(String sql) throws Exception { List<T> resultList = Lists.newArrayList(); ResultSet rs = executeQuery(sql); while (rs.next()) { resultList.add((T) rs.getObject(1)); } <START> rs.close(); <END> \/\/ I a try-with-resources better, in case raise exception for instance return resultList; }'","output":"public <T> List<T> queryList(String sql) throws Exception { List<T> resultList = Lists.newArrayList(); try (ResultSet rs = executeQuery(sql)) { while (rs.next()) { resultList.add((T) rs.getObject(1)); } } return resultList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new ArrayList<>(numTrainingDataInstance);'\nThe code is: 'public List<Integer> parse() { <START> final List<Integer> list = new LinkedList<>(); <END> \/\/ new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }'","output":"public List<Integer> parse() { final List<Integer> list = new ArrayList<>(numTrainingDataInstance); for (int i = 0; i < numTrainingDataInstance; i++) { list.add(RAND.nextInt()); } return list; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Windup\/Discover\/Java'\nThe code is: 'public void enhanceMetadata(Context context) { super.enhanceMetadata(context); <START> context.put(RuleMetadata.CATEGORY, \"Core\"); <END> \/\/ Windup\/Discover\/Java }'","output":"public void enhanceMetadata(Context context) { super.enhanceMetadata(context); context.put(RuleMetadata.CATEGORY, \"Java\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else statement removed'\nThe code is: 'private String socketToStr(Socket socket) { if (socket == null) { return \"\"; <START> } else { <END> \/\/ else statement removed return socket.getLocalAddress().toString() + \":\" + socket.getPort(); } }'","output":"private String socketToStr(Socket socket) { if (socket == null) { return \"\"; } return socket.getLocalAddress().toString() + \":\" + socket.getPort(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I assertEquals parameters inversed'\nThe code is: '@Test public void testInsertSourceRelTypeWithNullValues() throws Exception { Planner planner = getPlanner(null, Programs.standard()); SqlNode parse = planner.parse( \"insert into \\\"emps\\\" values(1, 1, null, 1, 1)\"); SqlNode validate = planner.validate(parse); RelNode convert = planner.rel(validate).rel; RelDataType insertSourceType = convert.getInput(0).getRowType(); String typeString = SqlTests.getTypeString(insertSourceType); <START> assertEquals(typeString, <END> \/\/ I assertEquals parameters inversed \"RecordType(INTEGER NOT NULL empid, INTEGER NOT NULL deptno, VARCHAR name, \" + \"REAL NOT NULL salary, INTEGER commission) NOT NULL\"); }'","output":"@Test public void testInsertSourceRelTypeWithNullValues() throws Exception { Planner planner = getPlanner(null, Programs.standard()); SqlNode parse = planner.parse( \"insert into \\\"emps\\\" values(1, 1, null, 1, 1)\"); SqlNode validate = planner.validate(parse); RelNode convert = planner.rel(validate).rel; RelDataType insertSourceType = convert.getInput(0).getRowType(); String typeString = SqlTests.getTypeString(insertSourceType); assertEquals(\"RecordType(INTEGER NOT NULL empid, INTEGER NOT NULL deptno, VARCHAR name, \" + \"REAL NOT NULL salary, INTEGER commission) NOT NULL\", typeString); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please replace this return getUrlForWiki(wikiName) + wikiPath'\nThe code is: 'public String getUrlForPathWithoutWiki(String wikiName, String wikiPath) { String url = getUrlForWiki(wikiName); url = url + wikiPath; <START> return url; <END> \/\/ please replace this return getUrlForWiki(wikiName) + wikiPath }'","output":"public String getUrlForPathWithoutWiki(String wikiName, String wikiPath) { return getUrlForWiki(wikiName) + wikiPath; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return checkNotNull(Collections.EMPTY_LIST); EMPTY_* static definitions do some sort of type inference, older .empty*() methods don't'\nThe code is: 'public List<IBaseEventInfo> getKernelProvider(IProgressMonitor monitor) throws ExecutionException { <START> return checkNotNull(new ArrayList<IBaseEventInfo>()); <END> \/\/ return checkNotNull(Collections.EMPTY_LIST); EMPTY_* static definitions do some sort of type inference, older .empty*() methods don't }'","output":"public List<IBaseEventInfo> getKernelProvider(IProgressMonitor monitor) throws ExecutionException { return checkNotNull(Collections.EMPTY_LIST); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This instead \"[abc, bcd, cde]\" changes I suggested'\nThe code is: 'public void toStringTest() { final NodeList<Name> list = nodeList(new Name(\"abc\"), new Name(\"bcd\"), new Name(\"cde\")); <START> assertEquals(\"abcbcdcde\", list.toString()); <END> \/\/ This instead \"[abc, bcd, cde]\" changes I suggested }'","output":"public void toStringTest() { final NodeList<Name> list = nodeList(new Name(\"abc\"), new Name(\"bcd\"), new Name(\"cde\")); assertEquals(\"[abc, bcd, cde]\", list.toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add some message info'\nThe code is: 'private Response processMessage(final MessageHandler handler, final Message message) { Response response; try { response = handler.handle(message); } catch (MessageHandler.HandleException e) { response = Response.of(e.getMessage()); <START> LOGGER.log(Level.WARNING, \"Exception while processing message\", e); <END> \/\/ add some message info } return response; }'","output":"private Response processMessage(final MessageHandler handler, final Message message) { Response response; try { response = handler.handle(message); } catch (MessageHandler.HandleException e) { response = Response.of(e.getMessage()); LOGGER.log(Level.WARNING, \"Exception while processing message \" + message, e); } return response; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I filter part of TmfTraceContext. Please move there'\nThe code is: 'private TmfTraceManager() { fTraces = new LinkedHashMap<ITmfTrace, TmfTraceContext>(); <START> fFilters = new LinkedHashMap<ITmfTrace, ITmfFilter>(); <END> \/\/ I filter part of TmfTraceContext. Please move there TmfSignalManager.registerVIP(this); }'","output":"private TmfTraceManager() { fTraces = new LinkedHashMap<ITmfTrace, TmfTraceContext>(); TmfSignalManager.registerVIP(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please implement as: java return IOUtils.readLines(in, StandardCharsets.UTF_8).stream().collect(Collectors.joining(System.lineSeparator())); I apply this for: org.drools.workbench.services.verifier.plugin.client.testutil.TestUtil#loadResource'\nThe code is: 'public static String loadResource(final InputStream in) throws Exception { <START> final Reader reader = new InputStreamReader(in); <END> \/\/ Please implement as: java return IOUtils.readLines(in, StandardCharsets.UTF_8).stream().collect(Collectors.joining(System.lineSeparator())); I apply this for: org.drools.workbench.services.verifier.plugin.client.testutil.TestUtil#loadResource final StringBuilder text = new StringBuilder(); final char[] buf = new char[1024]; int len = 0; while ((len = reader.read(buf)) >= 0) { text.append(buf, 0, len); } return text.toString(); }'","output":"public static String loadResource(final InputStream in) throws Exception { return IOUtils.readLines(in, StandardCharsets.UTF_8).stream().collect(Collectors.joining(System.lineSeparator())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'UnsupportedOperationException is a fit'\nThe code is: 'protected BinaryConverter<M> getConverterFor(Class<M> clazz) { <START> throw new RuntimeException(\"Unsupported\"); <END> \/\/ UnsupportedOperationException is a fit }'","output":"protected BinaryConverter<M> getConverterFor(Class<M> clazz) { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)'\nThe code is: 'public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); <START> assertTrue(allDves.stream().filter(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID)).collect( Collectors.toList()).isEmpty()); <END> \/\/ need collect it: assertTrue(allDevs.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID) }'","output":"public void testNUllVmElementForFloatingDisk() { List<DiskVmElement> allDves = dao.getAll(); assertTrue(allDves.stream().noneMatch(dve -> dve.getDiskId().equals(FixturesTool.FLOATING_DISK_ID))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add synchronized this method'\nThe code is: '<START> public TmfTimeRange getCurrentRange() { <END> \/\/ Add synchronized this method return getCurrentTraceContext().getTimerange(); }'","output":"public synchronized TmfTimeRange getCurrentRange() { return getCurrentTraceContext().getTimerange(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws RestApiException necessary'\nThe code is: '<START> public List<EditInfo> parseEditInfos(JsonElement result) throws RestApiException { <END> \/\/ throws RestApiException necessary if (!result.isJsonArray()) { return Collections.singletonList(gson.fromJson(result, EditInfo.class)); } return gson.fromJson(result, TYPE); }'","output":"public List<EditInfo> parseEditInfos(JsonElement result) { if (!result.isJsonArray()) { return Collections.singletonList(gson.fromJson(result, EditInfo.class)); } return gson.fromJson(result, TYPE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please change es_inst externalSerach. I some \"_\" in code camelCase is a more common java convention'\nThe code is: 'public String evaluate( String referer ) { <START> ExternalSearch es_inst = ExternalSearch.getInstance(); <END> \/\/ Please change es_inst externalSerach. I some \"_\" in code camelCase is a more common java convention return es_inst.identifySearchEngine( referer ); }'","output":"public String evaluate( String referer ) { ExternalSearch externalSearch = ExternalSearch.getInstance(); return externalSearch.identifySearchEngine( referer ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want verify executeSQL is called all. parameter I told wrong Please replace verify(adminDAO, never()).executeSQL(anyString(), anyBoolean()); this ensure method is called matter parameters'\nThe code is: 'public void executeSQL_shouldReturnNullGivenNull() { adminService.executeSQL(null, true); <START> verify(adminDAO, never()).executeSQL(\"was never called\", true); <END> \/\/ want verify executeSQL is called all. parameter I told wrong Please replace verify(adminDAO, never()).executeSQL(anyString(), anyBoolean()); this ensure method is called matter parameters }'","output":"public void executeSQL_shouldReturnNullGivenNull() { adminService.executeSQL(null, true); verify(adminDAO, never()).executeSQL(anyString(), anyBoolean()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if (bytesAvailable >= count) simpler'\nThe code is: 'private void reportBytesRead(int count) { <START> if (bytesAvailable - count >= 0) { <END> \/\/ if (bytesAvailable >= count) simpler bytesAvailable -= count; } }'","output":"private void reportBytesRead(int count) { if (bytesAvailable >= count) { bytesAvailable -= count; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Renamed segments -> segmentStore in next patch'\nThe code is: 'protected abstract Object[] readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException; <START> protected abstract boolean buildAnalysisSegments(ISegmentStore<ISegment> segments, IProgressMonitor monitor) throws TmfAnalysisException; <END> \/\/ Renamed segments -> segmentStore in next patch @Override public @Nullable ISegmentStore<ISegment> getSegmentStore() { return fSegmentStore; }'","output":"protected abstract Object[] readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException; protected abstract boolean buildAnalysisSegments(ISegmentStore<ISegment> segmentStore, IProgressMonitor monitor) throws TmfAnalysisException; @Override public @Nullable ISegmentStore<ISegment> getSegmentStore() { return fSegmentStore; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant, class is @NNBD'\nThe code is: '<START> public Iterable<@NonNull IEventDeclaration> getEventDeclarations() { <END> \/\/ redundant, class is @NNBD return checkNotNull(ImmutableList.copyOf(fStreamInput.getStream().getEventDeclarations())); }'","output":"public Iterable<IEventDeclaration> getEventDeclarations() { return checkNotNull(ImmutableList.copyOf(fStreamInput.getStream().getEventDeclarations())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catching a generic Exception'\nThe code is: 'public Response getAPIRevisions(String apiId, MessageContext messageContext) { try { APIProvider apiProvider = RestApiCommonUtil.getLoggedInUserProvider(); List<APIRevision> apiRevisions = apiProvider.getAPIRevisions(apiId); APIRevisionListDTO apiRevisionListDTO = APIMappingUtil.fromListAPIRevisiontoDTO(apiRevisions); return Response.ok().entity(apiRevisionListDTO).build(); <START> } catch (Exception e) { <END> \/\/ catching a generic Exception String errorMessage = \"Error while adding retrieving API Revision for api id : \" + apiId + \" - \" + e.getMessage(); RestApiUtil.handleInternalServerError(errorMessage, e, log); } return null; }'","output":"public Response getAPIRevisions(String apiId, MessageContext messageContext) { try { APIProvider apiProvider = RestApiCommonUtil.getLoggedInUserProvider(); List<APIRevision> apiRevisions = apiProvider.getAPIRevisions(apiId); APIRevisionListDTO apiRevisionListDTO = APIMappingUtil.fromListAPIRevisiontoDTO(apiRevisions); return Response.ok().entity(apiRevisionListDTO).build(); } catch (APIManagementException e) { String errorMessage = \"Error while adding retrieving API Revision for api id : \" + apiId + \" - \" + e.getMessage(); RestApiUtil.handleInternalServerError(errorMessage, e, log); } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add a getDriver() override returns a cast of super.getDriver() this neater'\nThe code is: 'public void pillowfight(String targetHostnameAndPort, String bucket, String username, String password, Integer iterations, Integer numItems, String keyPrefix, Integer numThreads, Integer numInstances, Integer randomSeed, Integer ratio, Integer minSize, Integer maxSize) { <START> ((CouchbaseLoadGeneratorDriver)getDriver()).pillowfight(targetHostnameAndPort, bucket, username, password, <END> \/\/ add a getDriver() override returns a cast of super.getDriver() this neater iterations, numItems, keyPrefix, numThreads, numInstances, randomSeed, ratio, minSize, maxSize); }'","output":"public void pillowfight(String targetHostnameAndPort, String bucket, String username, String password, Integer iterations, Integer numItems, String keyPrefix, Integer numThreads, Integer numInstances, Integer randomSeed, Integer ratio, Integer minSize, Integer maxSize) { getDriver().pillowfight(targetHostnameAndPort, bucket, username, password, iterations, numItems, keyPrefix, numThreads, numInstances, randomSeed, ratio, minSize, maxSize); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: this final'\nThe code is: 'public Attribute createAttribute(HttpRequest request, String name) { <START> Attribute attribute; <END> \/\/ nit: this final if (useDisk) { attribute = new DiskAttribute(name, charset); } else if (checkSize) { attribute = new MixedAttribute(name, minSize, charset); } else { attribute = new MemoryAttribute(name); } attribute.setMaxSize(maxSize); List<HttpData> list = getList(request); list.add(attribute); return attribute; }'","output":"public Attribute createAttribute(HttpRequest request, String name) { final Attribute attribute; if (useDisk) { attribute = new DiskAttribute(name, charset); } else if (checkSize) { attribute = new MixedAttribute(name, minSize, charset); } else { attribute = new MemoryAttribute(name); } attribute.setMaxSize(maxSize); List<HttpData> list = getList(request); list.add(attribute); return attribute; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@paulodamaso braces return needed'\nThe code is: 'public FbStatus(final int code, final Fallback fallback) { this( new Filtered<Integer>( <START> (status) -> { <END> \/\/ @paulodamaso braces return needed return code == status.intValue(); }, code ), fallback ); }'","output":"public FbStatus(final int code, final Fallback fallback) { this( new Filtered<Integer>( (status) -> code == status.intValue(), code ), fallback ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I FINE enough'\nThe code is: 'public void onNext(final CompletedEvaluator completedEvaluator) { <START> LOG.log(Level.INFO, \"CompletedEvaluator: {0}\", completedEvaluator); <END> \/\/ I FINE enough }'","output":"public void onNext(final CompletedEvaluator completedEvaluator) { LOG.log(Level.FINE, \"CompletedEvaluator: {0}\", completedEvaluator); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reason do: this(replication, NULL_ID)'\nThe code is: 'public BasicReplicator(Replication replication) { this.replication = replication; <START> this.state = State.PENDING; <END> \/\/ reason do: this(replication, NULL_ID) }'","output":"public BasicReplicator(Replication replication) { this(replication, NULL_ID); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'readFully[2] read[1] ensure read length bytes. [1] <LINK_0>[], int, int) [2] <LINK_1>[], int, int)'\nThe code is: 'public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { int length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; <START> input.read(data, 0, length); <END> \/\/ readFully[2] read[1] ensure read length bytes. [1] <LINK_0>[], int, int) [2] <LINK_1>[], int, int) return new ByteBufferImpl(data, 0, length); }'","output":"public ByteBufferImpl readObject(ObjectInput input) throws IOException, ClassNotFoundException { int length = UnsignedNumeric.readUnsignedInt(input); byte[] data = new byte[length]; input.readFully(data, 0, length); return new ByteBufferImpl(data, 0, length); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor: Optional<Integer>'\nThe code is: '<START> public Integer getRefundAmountAvailable() { <END> \/\/ minor: Optional<Integer> return refundAmountAvailable; }'","output":"public Optional<Integer> getRefundAmountAvailable() { return Optional.ofNullable(refundAmountAvailable); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This log statement I is relevant if connection client a server is established. is useful, I leave INFO DEBUG'\nThe code is: 'public void channelActive(final ChannelHandlerContext ctx) throws Exception { <START> log.trace(\"channelActive: Incoming connection established from: {} Start Read Timeout.\", <END> \/\/ This log statement I is relevant if connection client a server is established. is useful, I leave INFO DEBUG ctx.channel().remoteAddress()); ctx.pipeline().addBefore(ctx.name(), READ_TIMEOUT_HANDLER, new ReadTimeoutHandler(this.timeoutInSeconds)); }'","output":"public void channelActive(final ChannelHandlerContext ctx) throws Exception { log.info(\"channelActive: Incoming connection established from: {} Start Read Timeout.\", ctx.channel().remoteAddress()); ctx.pipeline().addBefore(ctx.name(), READ_TIMEOUT_HANDLER, new ReadTimeoutHandler(this.timeoutInSeconds)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'calling this(context, Type.LOADING_NON_CACHED); here, making taskType final, centralizing initialization logic in constructor'\nThe code is: 'public Task(Context context) { <START> super(context); <END> \/\/ calling this(context, Type.LOADING_NON_CACHED); here, making taskType final, centralizing initialization logic in constructor if (context instanceof TaskProcessCallback) { setTaskProcessCallback((TaskProcessCallback) context); } }'","output":"public Task(Context context) { this(context, Type.LOADING_NON_CACHED); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return \"entitlement\"; default SP translate attribute eduPersonEntitlement entitlement name match perun attribute friendly name'\nThe code is: 'public String getSourceAttributeFriendlyName() { <START> return \"eduPersonEntitlement\"; <END> \/\/ suggestion return \"entitlement\"; default SP translate attribute eduPersonEntitlement entitlement name match perun attribute friendly name }'","output":"public String getSourceAttributeFriendlyName() { return \"entitlement\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return List<GarbageCollectionStatus>'\nThe code is: '<START> default GarbageCollectionStatus getGarbageCollectionStatus() { <END> \/\/ return List<GarbageCollectionStatus> return null; }'","output":"default List<GarbageCollectionStatus> getGarbageCollectionStatus() { return Collections.emptyList(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'in places above, if (zone == null) { return null; } return createSecurityGroup(name, zone);'\nThe code is: 'public SecurityGroup createSecurityGroup(String name, Location location) { String zone = location.getId(); if (zone != null) { return createSecurityGroup(name, zone); } else { return null; <START> } <END> \/\/ in places above, if (zone == null) { return null; } return createSecurityGroup(name, zone); }'","output":"public SecurityGroup createSecurityGroup(String name, Location location) { String zone = location.getId(); if (zone == null) { return null; } return createSecurityGroup(name, zone); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IllegalArgumentException'\nThe code is: 'public StreamProperties visitSpatialJoin(SpatialJoinNode node, List<StreamProperties> inputProperties) { StreamProperties leftProperties = inputProperties.get(0); switch (node.getType()) { case INNER: case LEFT: return leftProperties.translate(column -> PropertyDerivations.filterIfMissing(node.getOutputSymbols(), column)); default: <START> throw new UnsupportedOperationException(\"Unsupported spatial join type: \" + node.getType()); <END> \/\/ IllegalArgumentException } }'","output":"public StreamProperties visitSpatialJoin(SpatialJoinNode node, List<StreamProperties> inputProperties) { StreamProperties leftProperties = inputProperties.get(0); switch (node.getType()) { case INNER: case LEFT: return leftProperties.translate(column -> PropertyDerivations.filterIfMissing(node.getOutputSymbols(), column)); default: throw new IllegalArgumentException(\"Unsupported spatial join type: \" + node.getType()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename access_type token_type match code'\nThe code is: 'public String toString() { return String.format( <START> \"access_token=%s; access_type=%s; expires_in=%d; scope=%s; refresh_token=%s\", <END> \/\/ rename access_type token_type match code access_token, token_type, expires_in, scope, refresh_token); }'","output":"public String toString() { return String.format( \"access_token=%s; token_type=%s; expires_in=%d; scope=%s; refresh_token=%s\", access_token, token_type, expires_in, scope, refresh_token); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'more brief: java return Sponge.getRegistry().createBuilder(Builder.class);'\nThe code is: 'static Builder builder() { <START> return Sponge.getRegistry().createBuilder(SoundType.Builder.class); <END> \/\/ more brief: java return Sponge.getRegistry().createBuilder(Builder.class); }'","output":"static Builder builder() { return Sponge.getRegistry().createBuilder(Builder.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'log.trace'\nThe code is: 'public void afterBegin() throws EJBException, RemoteException { <START> log.info(\"afterBegin called\"); <END> \/\/ log.trace checker.setSynchronizedBegin(); }'","output":"public void afterBegin() throws EJBException, RemoteException { log.trace(\"afterBegin called\"); checker.setSynchronizedBegin(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please Objects.equals'\nThe code is: 'private ModelField getModelField(String factName, String fieldName) { ModelField toReturn = null; if (modelFieldsMap.containsKey(factName)) { final ModelField[] modelFields = modelFieldsMap.get(factName); for (ModelField modelField : modelFields) { <START> if (modelField.getName().equals(fieldName)) { <END> \/\/ please Objects.equals toReturn = modelField; break; } } } return toReturn; }'","output":"private ModelField getModelField(String factName, String fieldName) { ModelField toReturn = null; if (modelFieldsMap.containsKey(factName)) { final ModelField[] modelFields = modelFieldsMap.get(factName); for (ModelField modelField : modelFields) { if (Objects.equals(modelField.getName(), fieldName)) { toReturn = modelField; break; } } } return toReturn; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change suggested above, this simplified throw ControllerLogger.ROOT_LOGGER.unsupportedCharset..'\nThe code is: 'public void validateParameter(String parameterName, ModelNode value) throws OperationFailedException { super.validateParameter(parameterName, value); if (value.isDefined()) { try { Charset hashCharset = Charset.forName(value.asString()); } catch (IllegalCharsetNameException e) { throw ControllerLogger.ROOT_LOGGER.illegalCharsetName(value.asString()); } catch (UnsupportedCharsetException e) { <START> throw new OperationFailedException(ControllerLogger.ROOT_LOGGER.unsupportedCharset(value.asString())); <END> \/\/ change suggested above, this simplified throw ControllerLogger.ROOT_LOGGER.unsupportedCharset.. } } }'","output":"public void validateParameter(String parameterName, ModelNode value) throws OperationFailedException { super.validateParameter(parameterName, value); if (value.isDefined()) { try { Charset hashCharset = Charset.forName(value.asString()); } catch (IllegalCharsetNameException e) { throw ControllerLogger.ROOT_LOGGER.illegalCharsetName(value.asString()); } catch (UnsupportedCharsetException e) { throw ControllerLogger.ROOT_LOGGER.unsupportedCharset(value.asString()); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.game..'\nThe code is: 'public SpongeMod() { super(new ModMetadata()); ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class), SpongePluginContainer.class); this.getMetadata().name = \"SpongeAPIMod\"; this.getMetadata().modId = \"SpongeAPIMod\"; SpongeMod.instance = this; <START> this.game = new SpongeGame(); <END> \/\/ this.game.. }'","output":"public SpongeMod() { super(new ModMetadata()); ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class), SpongePluginContainer.class); this.getMetadata().name = \"SpongeAPIMod\"; this.getMetadata().modId = \"SpongeAPIMod\"; SpongeMod.instance = this; game = new SpongeGame(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'questionType is shown here, in test files, show questiontype. I data-questiontype instead, consistent test files'\nThe code is: 'public String getQuestionTypeChoiceOption() { <START> return \"<li data-questionType = \\\"CONTRIB\\\"><a>\" + Const.FeedbackQuestionTypeNames.CONTRIB + \"<\/a><\/li>\"; <END> \/\/ questionType is shown here, in test files, show questiontype. I data-questiontype instead, consistent test files }'","output":"public String getQuestionTypeChoiceOption() { return \"<li data-questiontype = \\\"CONTRIB\\\"><a>\" + Const.FeedbackQuestionTypeNames.CONTRIB + \"<\/a><\/li>\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);'\nThe code is: 'public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartMessageEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartMessageEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, \"\"); <END> \/\/ suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE); assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }'","output":"public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartMessageEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartMessageEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE); assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'UnsupportedOperationException reasonable here'\nThe code is: 'public Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> getUpsertRuntime(IDataSource<String> dataSource, IOperatorSchema inputSchema, IVariableTypeEnvironment typeEnv, List<LogicalVariable> keys, LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec) throws AlgebricksException { <START> return null; <END> \/\/ UnsupportedOperationException reasonable here }'","output":"public Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> getUpsertRuntime(IDataSource<String> dataSource, IOperatorSchema inputSchema, IVariableTypeEnvironment typeEnv, List<LogicalVariable> keys, LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec) throws AlgebricksException { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this((e, ctx) -> fn.apply(e)); instead'\nThe code is: 'EventFnRoute(Function<E, I> fn) { <START> checkNotNull(fn); this.fn = (e, ctx) -> fn.apply(e); <END> \/\/ this((e, ctx) -> fn.apply(e)); instead }'","output":"EventFnRoute(Function<E, I> fn) { this((e, ctx) -> fn.apply(e)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I get IDE warning suggesting this: suggestion return Collections.unmodifiableList(Collections.singletonList(\"<unistd.h>\"));'\nThe code is: 'public List<String> getHeaderFiles() { <START> return Collections.unmodifiableList(Arrays.asList(\"<unistd.h>\")); <END> \/\/ I get IDE warning suggesting this: suggestion return Collections.unmodifiableList(Collections.singletonList(\"<unistd.h>\")); }'","output":"public List<String> getHeaderFiles() { return Collections.unmodifiableList(Collections.singletonList(\"<unistd.h>\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I eliminate eventType variable, add readability'\nThe code is: 'public void serviceChanged(ServiceEvent event) { ServiceReference serviceRef = event.getServiceReference(); Object service = context.getService(serviceRef); if (service instanceof InjectableAttribute) { <START> int eventType = event.getType(); <END> \/\/ I eliminate eventType variable, add readability if (eventType == ServiceEvent.REGISTERED) { registerAttribute(((InjectableAttribute) service).attribute()); } } }'","output":"public void serviceChanged(ServiceEvent event) { ServiceReference serviceRef = event.getServiceReference(); Object service = context.getService(serviceRef); if (service instanceof InjectableAttribute) { if (event.getType() == ServiceEvent.REGISTERED) { registerAttribute(((InjectableAttribute) service).attribute()); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this anywhere'\nThe code is: 'public RemoteTableDescriptor<K, V> withWriteFunction(TableWriteFunction<K, V> writeFn) { Preconditions.checkNotNull(writeFn, \"null write function\"); this.writeFn = writeFn; <START> this.writeFn.setTableId(String.format(\"%s.%s\", tableId, WRITE_FN)); <END> \/\/ Is this anywhere return this; }'","output":"public RemoteTableDescriptor<K, V> withWriteFunction(TableWriteFunction<K, V> writeFn) { Preconditions.checkNotNull(writeFn, \"null write function\"); this.writeFn = writeFn; return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instance'\nThe code is: 'public CommandCallback getCallback() { <START> return Injector.injectMembers(new ConcurrentChildCommandsExecutionCallback()); <END> \/\/ Instance }'","output":"public CommandCallback getCallback() { return callbackProvider.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is null correct here? weird..'\nThe code is: 'public boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { boolean rc; PublicKey key; try { if (publicKey == null) { <START> key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias(null)).getPublicKey(); <END> \/\/ Is null correct here? weird.. } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(\"Cannot verify token.\", e); } return rc; }'","output":"public boolean verifyToken(JWT token, RSAPublicKey publicKey) throws TokenServiceException { boolean rc; PublicKey key; try { if (publicKey == null) { key = ks.getSigningKeystore().getCertificate(getSigningKeyAlias()).getPublicKey(); } else { key = publicKey; } JWSVerifier verifier = new RSASSAVerifier((RSAPublicKey) key); rc = token.verify(verifier); } catch (KeyStoreException | KeystoreServiceException e) { throw new TokenServiceException(\"Cannot verify token.\", e); } return rc; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a double-decrement'\nThe code is: 'public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); <START> numConnections.decrementAndGet(); <END> \/\/ this a double-decrement log.info(\"Accepted connection above limit ({}). Dropping.\", maxConnections); } } super.channelOpen(ctx, e); }'","output":"public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); log.info(\"Accepted connection above limit ({}). Dropping.\", maxConnections); } } super.channelOpen(ctx, e); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'expected parameter, actual second, e.g. assertEquals(\"<p>_foo bar_<\/p>\\n\",html)'\nThe code is: 'public void escapedEmphasis() { String html = parseToHtml(\"\\\\_foo bar_\"); <START> assertEquals(html,\"<p>_foo bar_<\/p>\\n\"); <END> \/\/ expected parameter, actual second, e.g. assertEquals(\"<p>_foo bar_<\/p>\\n\",html) }'","output":"public void escapedEmphasis() { String html = parseToHtml(\"\\\\_foo bar_\"); assertEquals(\"<p>_foo bar_<\/p>\\n\", html); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This breaks compatibility'\nThe code is: '<START> ParameterMap getQueryParams(MuleEvent event) <END> \/\/ This breaks compatibility { return resolveParams(event, HttpParamType.QUERY_PARAM); }'","output":"public ParameterMap getQueryParams(MuleEvent event) { return resolveParams(event, HttpParamType.QUERY_PARAM); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please do *not* leave authorization turned test methods. This result in unexpected behavior. temporarily turned create (or delete) test content'\nThe code is: 'public void setup() { context.turnOffAuthorisationSystem(); parentCommunity = CommunityBuilder.createCommunity(context).withName(\"test\").build(); <START> collection = CollectionBuilder.createCollection(context, parentCommunity).withName(\"Collection 1\").build(); <END> \/\/ Please do *not* leave authorization turned test methods. This result in unexpected behavior. temporarily turned create (or delete) test content }'","output":"public void setup() { context.turnOffAuthorisationSystem(); parentCommunity = CommunityBuilder.createCommunity(context).withName(\"test\").build(); collection = CollectionBuilder.createCollection(context, parentCommunity).withName(\"Collection 1\").build(); context.restoreAuthSystemState(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I turn this in a one-liner'\nThe code is: 'public boolean hasAnyTicket(String username) { <START> Collection<Ticket> tickets = ticketRepository.findAllByOwnerUsername(username); <END> \/\/ I turn this in a one-liner return tickets.stream().anyMatch(Ticket::isValid); }'","output":"public boolean hasAnyTicket(String username) { return ticketRepository.findAllByOwnerUsername(username).stream().anyMatch(Ticket::isValid); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's\/getInstance()\/instance\/'\nThe code is: 'public String getIdLabel() { Instance instance = getInstance(); if (instance == null) { return \"\"; } return String.format(\"%s (0x%x)\", ValueDescriptorImpl.getIdLabel(myObjectReference), <START> getInstance().getUniqueId()); <END> \/\/ s\/getInstance()\/instance\/ }'","output":"public String getIdLabel() { Instance instance = getInstance(); if (instance == null) { return \"\"; } return String.format(\"%s (0x%x)\", ValueDescriptorImpl.getIdLabel(myObjectReference), instance.getUniqueId()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo'\nThe code is: 'public TestFactory fromUrl(String url) throws Exception { HttpJsonRequest httpJsonRequest = requestFactory.fromUrl(apiEndpointProvider.get() + \"factory\/resolver\"); httpJsonRequest.setBody(singletonMap(\"url\", url)); <START> HttpJsonResponse respoTestCheDefaultUserHttpJsonRequestFactorynse = httpJsonRequest.request(); <END> \/\/ typo FactoryDto factoryDto = response.asDto(FactoryDto.class); String factoryUrl = ideUrlProvider.get() + \"f?url=\" + URLEncoder.encode(url, \"UTF8\"); return new TestFactory( factoryUrl, defaultUser, factoryDto, dashboardUrlProvider, testFactoryServiceClient, workspaceServiceClient, loginPage); }'","output":"public TestFactory fromUrl(String url) throws Exception { HttpJsonRequest httpJsonRequest = requestFactory.fromUrl(apiEndpointProvider.get() + \"factory\/resolver\"); httpJsonRequest.setBody(singletonMap(\"url\", url)); HttpJsonResponse response = httpJsonRequest.request(); FactoryDto factoryDto = response.asDto(FactoryDto.class); String factoryUrl = ideUrlProvider.get() + \"f?url=\" + URLEncoder.encode(url, \"UTF8\"); return new TestFactory( factoryUrl, defaultUser, factoryDto, dashboardUrlProvider, testFactoryServiceClient, workspaceServiceClient, loginPage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw exception instead. try do I difficult current classes hierarchy > Change meaning of a plain user name ID (opaque user), in a location is in places (even in RuntimeDto). sense. I username is a mistake done of docs lack. @gazarenkov right person is supposed there. If user id I try change run QA tests. I guess clients OK :wink:'\nThe code is: 'public String getOwner() { try { <START> User user = userDao.getById(context.getIdentity().getOwnerId()); <END> \/\/ throw exception instead. try do I difficult current classes hierarchy > Change meaning of a plain user name ID (opaque user), in a location is in places (even in RuntimeDto). sense. I username is a mistake done of docs lack. @gazarenkov right person is supposed there. If user id I try change run QA tests. I guess clients OK :wink: return user == null ? context.getIdentity().getOwnerId() : user.getName(); } catch (NotFoundException | ServerException e) { return context.getIdentity().getOwnerId(); } }'","output":"public String getOwner() { return context.getIdentity().getOwnerId(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Assertion missing'\nThe code is: 'public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException { SyncUser user = createTestUser(); Realm realm = Realm.getInstance(configuration); try { <START> SyncManager.getSession(configuration).downloadAllServerChanges(); <END> \/\/ Assertion missing } catch (IllegalStateException ignored) { } finally { realm.close(); } }'","output":"public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException { Realm realm = Realm.getInstance(configuration); try { SyncManager.getSession(configuration).downloadAllServerChanges(); fail(\"Should throw an IllegalStateException on Ui Thread\"); } catch (IllegalStateException ignored) { } finally { realm.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw error atleast log this info\/error level'\nThe code is: 'public LoginContext login() throws LoginException { String jaasConfigFile = System.getProperty(JAAS_CONFIG_SYSTEM_PROPERTY); if (jaasConfigFile == null) { <START> log.debug(\"System property \" + JAAS_CONFIG_SYSTEM_PROPERTY + \" for jaas config file is not set, using default JAAS configuration.\"); <END> \/\/ throw error atleast log this info\/error level } loginContext = new LoginContext(loginContextName, new LoginCallbackHandler()); loginContext.login(); log.info(\"Successfully logged in.\"); return loginContext; }'","output":"public LoginContext login() throws LoginException { String jaasConfigFile = System.getProperty(JAAS_CONFIG_SYSTEM_PROPERTY); if (jaasConfigFile == null) { log.error(\"System property \" + JAAS_CONFIG_SYSTEM_PROPERTY + \" for jaas config file is not set, using default JAAS configuration.\"); } loginContext = new LoginContext(loginContextName, new LoginCallbackHandler()); loginContext.login(); log.info(\"Successfully logged in.\"); return loginContext; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertOpenBlock(); here, a test fails'\nThe code is: '<START> public void lineBreak() { <END> \/\/ assertOpenBlock(); here, a test fails delegate.lineBreak(); }'","output":"public void lineBreak() { assertOpenBlock(); delegate.lineBreak(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'mark of ThreadBound methods final, long else is overriding them. point of deriving this class is allow base class handle them, derived classes accidentally override :)'\nThe code is: '<START> public boolean checkThreadAccess() { <END> \/\/ mark of ThreadBound methods final, long else is overriding them. point of deriving this class is allow base class handle them, derived classes accidentally override :) return mEnforcer.checkThreadAccess(); }'","output":"public final boolean checkThreadAccess() { return mEnforcer.checkThreadAccess(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Delete elements\"'\nThe code is: 'public String getFamilyName() { <START> return \"Delete range\"; <END> \/\/ \"Delete elements\" }'","output":"public String getFamilyName() { return \"Delete elements\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Sorry, null better: List<VDS> result = dao.getAllOfType(null);'\nThe code is: 'public void testGetAllOfTypeWithUnrepresentedType() { <START> List<VDS> result = dao.getAllOfType(VDSType.forValue(-1)); <END> \/\/ Sorry, null better: List<VDS> result = dao.getAllOfType(null); assertIncorrectGetResult(result); }'","output":"public void testGetAllOfTypeWithUnrepresentedType() { List<VDS> result = dao.getAllOfType(null); assertIncorrectGetResult(result); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is a solution this? throw a new NoOpNameFoundException? auto skips in place do that'\nThe code is: 'public String tensorflowName() { <START> return \"MergeZZZ\"; <END> \/\/ Is a solution this? throw a new NoOpNameFoundException? auto skips in place do that }'","output":"public String tensorflowName() { throw new NoOpNameFoundException(\"This operation has no TF counterpart\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If mistaken, visibility of this method restricted package private'\nThe code is: '<START> public void flushToFileWriter(ColumnDescriptor path, ParquetFileWriter writer) throws IOException { <END> \/\/ If mistaken, visibility of this method restricted package private ColumnChunkPageWriter pageWriter = writers.get(path); pageWriter.writeToFileWriter(writer); }'","output":"void flushToFileWriter(ColumnDescriptor path, ParquetFileWriter writer) throws IOException { ColumnChunkPageWriter pageWriter = writers.get(path); pageWriter.writeToFileWriter(writer); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'JobRegistry internal component - direction this functionality blog post this Jira issue sense a class citizen'\nThe code is: 'public void setJobRegistry(JobRegistry jobRegistry) { this.jobRegistry = jobRegistry; if (stepRegistry == null && jobRegistry instanceof StepRegistry) { setStepRegistry((StepRegistry) jobRegistry); <START> } <END> \/\/ JobRegistry internal component - direction this functionality blog post this Jira issue sense a class citizen }'","output":"public void setJobRegistry(JobRegistry jobRegistry) { this.jobRegistry = jobRegistry; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'time a constructor method is private called a nested enclosing class, compiler produce a \"fake\" member package-private access calls private member. this process awry. members package-private in place instead of private'\nThe code is: '<START> private PasswordBasedEncryptionUtil(Cipher cipher, AlgorithmParameters algorithmParameters, Alphabet alphabet) { <END> \/\/ time a constructor method is private called a nested enclosing class, compiler produce a \"fake\" member package-private access calls private member. this process awry. members package-private in place instead of private this.cipher = cipher; this.alphabet = alphabet; this.algorithmParameters = algorithmParameters; }'","output":"PasswordBasedEncryptionUtil(Cipher cipher, AlgorithmParameters algorithmParameters, Alphabet alphabet) { this.cipher = cipher; this.alphabet = alphabet; this.algorithmParameters = algorithmParameters; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@guiseco Bundle args for here, arguments is added it'\nThe code is: 'public static UVCDialog newInstance() { final UVCDialog dialog = new UVCDialog(); final Bundle args = new Bundle(); <START> dialog.setArguments(args); <END> \/\/ @guiseco Bundle args for here, arguments is added it return dialog; }'","output":"public static UVCDialog newInstance() { final UVCDialog dialog = new UVCDialog(); return dialog; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'calling validate runtime. containsMacro(\"port\") true check port if negative not'\nThe code is: 'public void validate() { <START> if (!containsMacro(\"port\") && port < 0) { <END> \/\/ calling validate runtime. containsMacro(\"port\") true check port if negative not throw new IllegalArgumentException(\"Port cannot be negative\"); } }'","output":"public void validate() { if (port < 0) { throw new IllegalArgumentException(\"Port cannot be negative\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.emptyList() creating a new list'\nThe code is: 'private Catalog replayFailedCatalogRebuildUnderDebug( VoltCompiler autoGenCompiler, List<VoltCompilerReader> autogenReaderList, InMemoryJarfile autoGenJarOutput) { Catalog autoGenCatalog = autoGenCompiler.compileCatalogInternal(null, null, <START> autogenReaderList, new ArrayList<>(), autoGenJarOutput); <END> \/\/ Collections.emptyList() creating a new list return autoGenCatalog; }'","output":"private Catalog replayFailedCatalogRebuildUnderDebug( VoltCompiler autoGenCompiler, List<VoltCompilerReader> autogenReaderList, InMemoryJarfile autoGenJarOutput) { Catalog autoGenCatalog = autoGenCompiler.compileCatalogInternal(null, null, autogenReaderList, Collections.emptyList(), autoGenJarOutput); return autoGenCatalog; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above. getAndSet(boolean)'\nThe code is: 'public void unlock() { boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(\"Unlocked successfully.\"); <START> hasLock.set(false); <END> \/\/ above. getAndSet(boolean) leaseId.getAndSet(null); } else { LOG.info(\"Unable to unlock.\"); } }'","output":"public void unlock() { boolean status = leaseBlobManager.releaseLease(leaseId.get()); if (status) { LOG.info(\"Unlocked successfully.\"); hasLock.getAndSet(false); leaseId.getAndSet(null); } else { LOG.info(\"Unable to unlock.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'requireNonNull'\nThe code is: 'public ScriptResultConversionException(Object value) { super(ERROR_CODE); <START> this.value = value; <END> \/\/ requireNonNull }'","output":"public ScriptResultConversionException(Object value) { super(ERROR_CODE); this.value = requireNonNull(value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this get called time of deserialization. jackson properties call this time of deserialization. CertificateProperties examples'\nThe code is: 'public String getVaultUrl() { <START> unpackId(this.id); <END> \/\/ this get called time of deserialization. jackson properties call this time of deserialization. CertificateProperties examples return this.vaultUrl; }'","output":"public String getVaultUrl() { return this.vaultUrl; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'license'\nThe code is: 'public boolean shouldThrottle() { return shouldThrotle; <START> } <END> \/\/ license'","output":"public boolean shouldThrottle() { return shouldThrottle; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Exception is thrown'\nThe code is: '<START> public void convert_skip_null_abstract() throws IOException { <END> \/\/ Exception is thrown Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, \"null\"); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }'","output":"public void convert_skip_null_abstract() { Result sourceDataset = minimalEntityBuilder(ID, InfoSpaceConstants.SEMANTIC_CLASS_INSTANCE_TYPE_DATASET); addDescription(sourceDataset, \"null\"); addDescription(sourceDataset, ABSTRACT); DataSetReference metadata = converter.convert(sourceDataset); assertNotNull(metadata); assertEquals(ABSTRACT, metadata.getDescription()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This protected (more internal detail for external consumption.)'\nThe code is: '<START> public boolean isEnabledForMultipleContexts() { <END> \/\/ This protected (more internal detail for external consumption.) return enabledForMultipleContexts; }'","output":"protected boolean isEnabledForMultipleContexts() { return enabledForMultipleContexts; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'debug statements changed trace removed'\nThe code is: 'public void registerHandlers() { SessionFactory session = gov.hhs.fha.nhinc.event.persistence.HibernateUtil.getSessionFactory(); session = gov.hhs.fha.nhinc.direct.messagemonitoring.persistence.HibernateUtil.getSessionFactory(); LOG.debug(\"Registering event Loggers\"); EventLoggerFactory.getInstance().registerLoggers(); <START> LOG.debug(\"Registering handlers...\"); <END> \/\/ debug statements changed trace removed getDirectReceiver(); }'","output":"public void registerHandlers() { SessionFactory session = gov.hhs.fha.nhinc.event.persistence.HibernateUtil.getSessionFactory(); session = gov.hhs.fha.nhinc.direct.messagemonitoring.persistence.HibernateUtil.getSessionFactory(); LOG.trace(\"Registering event Loggers\"); EventLoggerFactory.getInstance().registerLoggers(); LOG.trace(\"Registering handlers...\"); getDirectReceiver(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'kick review then. protected, templates report support forShare'\nThe code is: '<START> public void setForShareSupported(boolean forShareSupported) { <END> \/\/ kick review then. protected, templates report support forShare this.forShareSupported = forShareSupported; }'","output":"protected void setForShareSupported(boolean forShareSupported) { this.forShareSupported = forShareSupported; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call node.dispose() here'\nThe code is: 'public void dispose() { <START> for (Node node : nodeMap.values()) { <END> \/\/ call node.dispose() here graph.removeNode(node); } nodeMap.clear(); }'","output":"public void dispose() { for (Node node : nodeMap.values()) { graph.removeNode(node); node.dispose(); } nodeMap.clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Is a reason change this null? I find null more intuitive (in java) represent string, a present string is empty'\nThe code is: 'public Factory(Connection conn) { <START> this(conn, \"\"); <END> \/\/ nit: Is a reason change this null? I find null more intuitive (in java) represent string, a present string is empty }'","output":"public Factory(Connection conn) { this(conn, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'variable is required'\nThe code is: 'private ValidationResult validateWithHostSetupNetworksValidator(VDS host) { NetworkAttachment <START> networkAttachment = <END> \/\/ variable is required selectNetworkAttachmentForValidatation(); HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), networkAttachment, getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator, backend); return validator.validate(); }'","output":"private ValidationResult validateWithHostSetupNetworksValidator(VDS host) { HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), selectNetworkAttachmentForValidatation(), getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator, backend); return validator.validate(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Permission.\" -> \"Permission denied.\"'\nThe code is: 'private void requestForbidden(HttpServerExchange exchange, String messageId, String qualifiedTopicName) { messageErrorProcessor.sendQuietly( exchange, <START> error(\"Permission.\", AUTH_ERROR), <END> \/\/ \"Permission.\" -> \"Permission denied.\" messageId, qualifiedTopicName); }'","output":"private void requestForbidden(HttpServerExchange exchange, String messageId, String qualifiedTopicName) { messageErrorProcessor.sendQuietly( exchange, error(\"Permission denied.\", AUTH_ERROR), messageId, qualifiedTopicName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'builders want external code create new entries, content, constructor private protected'\nThe code is: '<START> public AttributeEntryModel(long id, long parentId, String name, long start, long end, int quark) { <END> \/\/ builders want external code create new entries, content, constructor private protected super(id, parentId, name, start, end, true); fQuark = quark; }'","output":"protected AttributeEntryModel(long id, long parentId, String name, long start, long end, int quark) { super(id, parentId, name, start, end, true); fQuark = quark; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'set this this.urn = \"java:\" + clazz.getName() dont need transient java type'\nThe code is: '<START> public void setJavaClass(Class<?> clazz) { <END> \/\/ set this this.urn = \"java:\" + clazz.getName() dont need transient java type this.clazz = clazz; }'","output":"public void setJavaClass(Class<?> clazz) { this.urn = \"java:\" + clazz.getName(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I return Array here'\nThe code is: '<START> public ArrayInterface setNumber(int index, Number value) { <END> \/\/ I return Array here return setObject(index, value); }'","output":"public Array setNumber(int index, Number value) { return setObject(index, value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'empty() instead of EMPTY for consistency'\nThe code is: 'public CalculationRequirements requirements() { <START> return CalculationRequirements.EMPTY; <END> \/\/ empty() instead of EMPTY for consistency }'","output":"public CalculationRequirements requirements() { return CalculationRequirements.empty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Redundant, call this(vdsId, bondName, network, nics) handles'\nThe code is: 'public AddBondParameters(Guid vdsId, String bondName, Network network, String[] nics, int vladId) { this(vdsId, bondName, network, nics); setVlanId(vladId); <START> privateBootProtocol = NetworkBootProtocol.NONE; <END> \/\/ Redundant, call this(vdsId, bondName, network, nics) handles }'","output":"public AddBondParameters(Guid vdsId, String bondName, Network network, String[] nics, int vladId) { this(vdsId, bondName, network, nics); setVlanId(vladId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'of coding styles try adhere is braces for conditional bodies. more verbose easier add else statements is consistent rest of codebase'\nThe code is: 'public Object eval(Object[] args, EvaluationContext ec) { if(!locationUpdatesRequested) requestLocationUpdates(); <START> if(location == null) return \"\"; <END> \/\/ of coding styles try adhere is braces for conditional bodies. more verbose easier add else statements is consistent rest of codebase return location.getDisplayText(); }'","output":"public Object eval(Object[] args, EvaluationContext ec) { if (!locationUpdatesRequested) { requestLocationUpdates(); } if (location == null) { return \"\"; } return location.getDisplayText(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please limit visibility of constructor'\nThe code is: '<START> public ChainFilter() { <END> \/\/ please limit visibility of constructor this(RowFilter.Chain.newBuilder()); }'","output":"private ChainFilter() { this(RowFilter.Chain.newBuilder()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.gender = student.gender'\nThe code is: 'public StudentProfile(String fullName, StudentProfileAttributes student, String pictureUrl) { this.pictureUrl = pictureUrl; this.name = fullName; this.shortName = student.shortName; <START> this.gender = Gender.valueOf(student.gender.name()); <END> \/\/ this.gender = student.gender this.email = student.email; this.institute = student.institute; this.nationality = student.nationality; this.moreInfo = student.moreInfo; }'","output":"public StudentProfile(String fullName, StudentProfileAttributes student, String pictureUrl) { this.pictureUrl = pictureUrl; this.name = fullName; this.shortName = student.shortName; this.gender = student.gender; this.email = student.email; this.institute = student.institute; this.nationality = student.nationality; this.moreInfo = student.moreInfo; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a lot of calls this method, resulting in errors reference BPMN element. a quick look, of do element id reference'\nThe code is: '<START> public void addError(String errorMessage, Element element) { <END> \/\/ a lot of calls this method, resulting in errors reference BPMN element. a quick look, of do element id reference errors.add(new ProblemImpl(errorMessage, name, element)); }'","output":"public void addError(String errorMessage, Element element) { errors.add(new ProblemImpl(errorMessage, element)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'log errors'\nThe code is: 'private void dropConglomerate(long CID, Activation activation) { TransactionController tc = activation.getTransactionController(); LOG.trace(format(\"Dropping temporary conglomerate splice:%d\", CID)); try { tc.dropConglomerate(CID); } <START> catch (StandardException e) { <END> \/\/ log errors } try { dropTable(CID); } catch (StandardException e) { } }'","output":"private void dropConglomerate(long CID, Activation activation) { TransactionController tc = activation.getTransactionController(); LOG.trace(format(\"Dropping temporary conglomerate splice:%d\", CID)); try { tc.dropConglomerate(CID); } catch (StandardException e) { LOG.warn(format(\"Unable to drop temporary trigger conglomerate %d. Cleanup may have been called twice.\", CID), e); } try { dropTable(CID); } catch (StandardException e) { LOG.warn(format(\"Unable to drop HBase table for temporary trigger conglomerate %d. Cleanup may have been called twice.\", CID), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'call ignoreFailure(true) for consistency'\nThe code is: 'public StandardBuilder ignoreFailure() { <START> ignoreFailure = true; <END> \/\/ call ignoreFailure(true) for consistency return this; }'","output":"public StandardBuilder ignoreFailure() { return ignoreFailure(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do lambda approach'\nThe code is: 'public void addKerberosAuthentication(UserEntity userEntity, String principalName, boolean persist) throws AmbariException { addAuthentication(userEntity, UserAuthenticationType.KERBEROS, principalName, new Validator() { <START> @Override <END> \/\/ do lambda approach public void validate(UserEntity userEntity, String key) throws AmbariException { if (!CollectionUtils.isEmpty(userAuthenticationDAO.findByTypeAndKey(UserAuthenticationType.KERBEROS, key))) { throw new AmbariException(\"The authentication type already exists for this principal\"); } } }, persist); }'","output":"public void addKerberosAuthentication(UserEntity userEntity, String principalName, boolean persist) throws AmbariException { addAuthentication(userEntity, UserAuthenticationType.KERBEROS, principalName, (user, key) -> { if (!CollectionUtils.isEmpty(userAuthenticationDAO.findByTypeAndKey(UserAuthenticationType.KERBEROS, key))) { throw new AmbariException(\"The authentication type already exists for this principal\"); } }, persist); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'leave List<String> return type ? other methods in RunImageConfiguration return a List for collections, is generic type here, I uniform'\nThe code is: '<START> public Iterable<String> getLinks() { <END> \/\/ leave List<String> return type ? other methods in RunImageConfiguration return a List for collections, is generic type here, I uniform return EnvUtil.splitAtCommasAndTrim(links); }'","output":"public List<String> getLinks() { return EnvUtil.splitAtCommasAndTrim(links); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please replace StringUtils.isNotBlank()'\nThe code is: 'private StringBuilder buildMainFileName(Artifact artifact) { StringBuilder mainName = new StringBuilder(); String versionString = \"-\" + getNormalizedVersion(artifact); String classifierString = StringUtils.EMPTY; <START> if (artifact.getClassifier() != null && !artifact.getClassifier().isEmpty()) { <END> \/\/ please replace StringUtils.isNotBlank() classifierString = \"-\" + artifact.getClassifier(); } mainName.append(artifact.getArtifactId()).append(versionString); mainName.append(classifierString).append(\".\"); return mainName; }'","output":"private StringBuilder buildMainFileName(Artifact artifact) { StringBuilder mainName = new StringBuilder(); String versionString = \"-\" + getNormalizedVersion(artifact); String classifierString = StringUtils.EMPTY; if (StringUtils.isNotBlank(artifact.getClassifier())) { classifierString = \"-\" + artifact.getClassifier(); } mainName.append(artifact.getArtifactId()).append(versionString); mainName.append(classifierString).append(\".\"); return mainName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this IF block. do need it? store fboName get fbo need it'\nThe code is: 'public SetViewportSizeOf(String fboName) { this.fboName = fboName; if (!fboName.equals(DEFAULT_FBO)) { fbo = frameBuffersManager.getFBO(fboName); <START> } <END> \/\/ this IF block. do need it? store fboName get fbo need it }'","output":"public SetViewportSizeOf(String fboName) { this.fboName = fboName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is a bit double negativey if (cryptoEnablePgpInline) { ComposeCryptoStatus .... } else { return false; } more readable'\nThe code is: 'public boolean isForceTextMessageFormat() { if (!cryptoEnablePgpInline) { return false; <START> } <END> \/\/ This is a bit double negativey if (cryptoEnablePgpInline) { ComposeCryptoStatus .... } else { return false; } more readable ComposeCryptoStatus cryptoStatus = getCurrentCryptoStatus(); return cryptoStatus.isEncryptionEnabled() || cryptoStatus.isSigningEnabled(); }'","output":"public boolean isForceTextMessageFormat() { if (cryptoEnablePgpInline) { ComposeCryptoStatus cryptoStatus = getCurrentCryptoStatus(); return cryptoStatus.isEncryptionEnabled() || cryptoStatus.isSigningEnabled(); } else { return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new constant here'\nThe code is: 'public Version() { major = minor = build = revision = <START> -1; <END> \/\/ new constant here }'","output":"public Version() { major = minor = build = revision = VERSION_NOT_SET; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This needs return a completable future, null'\nThe code is: 'public CompletableFuture<Void> hideMapVersion(MapBean map) { String id = map.getId(); MapVersion mapVersion = new MapVersion(); mapVersion.setHidden(true); mapVersion.setId(map.getId()); fafApiAccessor.updateMapVersion(id, mapVersion); <START> return null; <END> \/\/ This needs return a completable future, null }'","output":"public CompletableFuture<Void> hideMapVersion(MapBean map) { String id = map.getId(); MapVersion mapVersion = new MapVersion(); mapVersion.setHidden(true); mapVersion.setId(map.getId()); fafApiAccessor.updateMapVersion(id, mapVersion); return CompletableFuture.completedFuture(null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need explicitly open transaction, save DB, transaction open automaticly'\nThe code is: '<START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> \/\/ need explicitly open transaction, save DB, transaction open automaticly TransactionSupport.executeInNewTransaction( new TransactionMethod<Void>() { @Override public Void runInTransaction() { createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); return null; } }); }'","output":"private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reason get exception here. reword this \"Failed read time zone id file.\"'\nThe code is: 'catch ( IOException e ) { <START> throw new RuntimeException( \"Time zone id file is missing.\" ); <END> \/\/ reason get exception here. reword this \"Failed read time zone id file.\" }'","output":"catch ( IOException e ) { throw new RuntimeException( \"Failed to read time zone id file.\" ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint'\nThe code is: 'public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\"); Assert.assertTrue(rs.next()); <START> Assert.assertEquals(Math.round(val),rs.getDouble(1),0.0); <END> \/\/ Assert.assertEquals(Math.round(val),rs.getLong(1)); instead here, Math.round() ROUND() 1 parameter returns bigint } }'","output":"public void testRound() throws Exception { ResultSet rs; for(double val : roundVals){ rs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\"); Assert.assertTrue(rs.next()); Assert.assertEquals(Math.round(val),rs.getLong(1)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'extraneous line me'\nThe code is: 'private WebElement getSessionLinkInRow(String elementClassNamePrefix, int rowId){ waitForElementPresence(By.id(\"session\" + rowId)); <START> By.id(\"session\" + rowId); <END> \/\/ extraneous line me waitForElementPresence(By.className(elementClassNamePrefix)); return browser.driver.findElement(By.id(\"session\" + rowId)).findElement(By.className(elementClassNamePrefix)); }'","output":"private WebElement getSessionLinkInRow(String elementClassNamePrefix, int rowId){ waitForElementPresence(By.id(\"session\" + rowId)); waitForElementPresence(By.className(elementClassNamePrefix)); return browser.driver.findElement(By.id(\"session\" + rowId)).findElement(By.className(elementClassNamePrefix)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this move AbstractControllerService? nice if clear() method public'\nThe code is: 'public void stop(final StopContext context) { synchronized (serverInventoryLock) { try { serverInventory = null; serverInventoryLock.set(false); } finally { serverInventoryLock.notifyAll(); } } extensionRegistry.clear(); <START> capabilityRegistry.clear(); <END> \/\/ this move AbstractControllerService? nice if clear() method public super.stop(context); }'","output":"public void stop(final StopContext context) { synchronized (serverInventoryLock) { try { serverInventory = null; serverInventoryLock.set(false); } finally { serverInventoryLock.notifyAll(); } } extensionRegistry.clear(); super.stop(context); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'onTracksChanged called twice. L1187 of MediaControllerImplBase (in patch set) enough'\nThe code is: 'public void onTrackInfoChanged(@NonNull MediaController controller, @NonNull List<TrackInfo> trackInfos) { <START> onTracksChanged(controller, trackInfos); <END> \/\/ onTracksChanged called twice. L1187 of MediaControllerImplBase (in patch set) enough }'","output":"public void onTrackInfoChanged(@NonNull MediaController controller, @NonNull List<TrackInfo> trackInfos) { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'size of referenced mappers initial size of list'\nThe code is: 'private AnnotatedConstructor buildAnnotatedConstructorForMapper(Mapper mapper) { <START> List<AnnotationMapperReference> mapperReferencesForConstructor = new ArrayList<AnnotationMapperReference>(); <END> \/\/ size of referenced mappers initial size of list for ( MapperReference mapperReference : mapper.getReferencedMappers() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ); } List<Annotation> mapperReferenceAnnotations = getMapperReferenceAnnotations(); removeReferenceAnnotations( mapperReferencesForConstructor, mapperReferenceAnnotations ); return new AnnotatedConstructor( mapper.getName(), mapperReferencesForConstructor, mapperReferenceAnnotations, additionalPublicEmptyConstructor() ); }'","output":"private AnnotatedConstructor buildAnnotatedConstructorForMapper(Mapper mapper) { List<AnnotationMapperReference> mapperReferencesForConstructor = new ArrayList<AnnotationMapperReference>( mapper.getReferencedMappers().size() ); for ( MapperReference mapperReference : mapper.getReferencedMappers() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ); } List<Annotation> mapperReferenceAnnotations = getMapperReferenceAnnotations(); removeDuplicateAnnotations( mapperReferencesForConstructor, mapperReferenceAnnotations ); return new AnnotatedConstructor( mapper.getName(), mapperReferencesForConstructor, mapperReferenceAnnotations, additionalPublicEmptyConstructor() ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'class final'\nThe code is: '<START> public final void setValue(byte[] value) { <END> \/\/ class final if (value == null) throw new NullPointerException(); this.value = value; }'","output":"public void setValue(byte[] value) { if (value == null) throw new NullPointerException(); this.value = value; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename variable _mesosStormScheduler _stormScheduler'\nThe code is: 'public MesosNimbus() { <START> this._mesosStormScheduler = new StormSchedulerImpl(); <END> \/\/ rename variable _mesosStormScheduler _stormScheduler }'","output":"public MesosNimbus() { this._stormScheduler = new StormSchedulerImpl(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'import static Assert.assertEquals()'\nThe code is: 'public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> Assert.assertEquals(\"<LINK_0>\", extractedGenericImage.getImage()); <END> \/\/ import static Assert.assertEquals() Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }'","output":"public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); assertEquals(\"<LINK_0>\", extractedGenericImage.getImage()); assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method static static methods typically bottom of class'\nThe code is: '<START> private String surfaceRotationToString(int surfaceRotation) { <END> \/\/ This method static static methods typically bottom of class switch (surfaceRotation) { case Surface.ROTATION_0: return \"0\"; case Surface.ROTATION_90: return \"90\"; case Surface.ROTATION_180: return \"180\"; case Surface.ROTATION_270: return \"270\"; } throw new IllegalArgumentException(\"Unsupported surface rotation value\" + surfaceRotation); }'","output":"private static String surfaceRotationToString(int surfaceRotation) { switch (surfaceRotation) { case Surface.ROTATION_0: return \"0\"; case Surface.ROTATION_90: return \"90\"; case Surface.ROTATION_180: return \"180\"; case Surface.ROTATION_270: return \"270\"; } throw new IllegalArgumentException(\"Unsupported surface rotation value\" + surfaceRotation); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.m_'\nThe code is: 'public boolean hasParent() { <START> return this.m_elements.size()>1; <END> \/\/ this.m_ }'","output":"public boolean hasParent() { return this.elements.size()>1; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this projected, call of this class. remain private'\nThe code is: '<START> protected static void checkBindingsSubsetOfVarOrder(final BindingSet bindingSet, final VariableOrder varOrder) throws IllegalArgumentException { <END> \/\/ this projected, call of this class. remain private checkNotNull(bindingSet); checkNotNull(varOrder); final Set<String> bindingNames = bindingSet.getBindingNames(); final List<String> varNames = varOrder.getVariableOrders(); checkArgument(varNames.containsAll(bindingNames), \"The BindingSet contains a Binding whose name is not part of the VariableOrder.\"); }'","output":"private static void checkBindingsSubsetOfVarOrder(final BindingSet bindingSet, final VariableOrder varOrder) throws IllegalArgumentException { checkNotNull(bindingSet); checkNotNull(varOrder); final Set<String> bindingNames = bindingSet.getBindingNames(); final List<String> varNames = varOrder.getVariableOrders(); checkArgument(varNames.containsAll(bindingNames), \"The BindingSet contains a Binding whose name is not part of the VariableOrder.\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '?grant_type=authorization_code redundant standard OAuth2 param, added <LINK_0>'\nThe code is: 'public String getAccessTokenEndpoint() { <START> return \"<LINK_1>?grant_type=authorization_code\"; <END> \/\/ ?grant_type=authorization_code redundant standard OAuth2 param, added <LINK_0> }'","output":"public String getAccessTokenEndpoint() { return \"<LINK_1>\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this m_'\nThe code is: 'public void setTTL(Long ttl) { <START> this.m_ttl = m_ttl; <END> \/\/ this m_ }'","output":"public void setTTL(Long ttl) { m_ttl = ttl; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion assertThat(got).contains(\"Description\");'\nThe code is: 'public void testLogoDetectGcs() throws Exception { LogoDetectionGcs.detectLogoGcs(\"gs:\/\/cloud-samples-data\/video\/googlework_tiny.mp4\"); String got = bout.toString(); <START> assertThat(got).contains(\"Description : Google Maps\"); <END> \/\/ suggestion assertThat(got).contains(\"Description\"); assertThat(got).contains(\"Confidence\"); assertThat(got).contains(\"Start Time Offset\"); assertThat(got).contains(\"End Time Offset\"); }'","output":"public void testLogoDetectGcs() throws IOException, ExecutionException, InterruptedException, TimeoutException { LogoDetectionGcs.detectLogoGcs(\"gs:\/\/cloud-samples-data\/video\/googlework_tiny.mp4\"); String got = bout.toString(); assertThat(got).contains(\"Description\"); assertThat(got).contains(\"Confidence\"); assertThat(got).contains(\"Start Time Offset\"); assertThat(got).contains(\"End Time Offset\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@jsoltes Assert#assertNotNull(java.lang.Object) method here'\nThe code is: 'private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { <START> assertTrue(dataObject.getProperty(\"id\") != null); <END> \/\/ @jsoltes Assert#assertNotNull(java.lang.Object) method here int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(\"Form field should be generated for every data field except of persistence id\", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }'","output":"private void formFieldsShouldNotBeGeneratedForPersistenceId(List<FieldDefinition> formModelFields) { assertNotNull(dataObject.getProperty(\"id\")); int EXPECTED_FORM_FIELD_COUNT = finderService.getDataObjectProperties(formModel.getClassName(), path).size() - 1; assertEquals(\"Form field should be generated for every data field except of persistence id\", EXPECTED_FORM_FIELD_COUNT, formModelFields.size()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this map is private, static intended immutable. change it'\nThe code is: 'public RelNode go(RelNode replacement_) { <START> this.RULE_MAP.clear(); <END> \/\/ this map is private, static intended immutable. change it return super.go(replacement_); }'","output":"public RelNode go(RelNode replacement_) { return super.go(replacement_); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '[Collections#emptyList](<LINK_0> here? > Returns empty list (immutable)'\nThe code is: 'public void nothingIsIncludedInAnEmptyArray() { <START> List<Integer> emptyList = Collections.unmodifiableList(new ArrayList<Integer>(0)); <END> \/\/ [Collections#emptyList](<LINK_0> here? > Returns empty list (immutable) BinarySearch<Integer> sut = new BinarySearch<>(emptyList); assertEquals(-1, sut.indexOf(1)); }'","output":"public void nothingIsIncludedInAnEmptyArray() { List<Integer> emptyList = Collections.emptyList(); BinarySearch<Integer> sut = new BinarySearch<>(emptyList); assertEquals(-1, sut.indexOf(1)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add this method check for cluster feature compatibility: return isHotPlugSupported() && osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());'\nThe code is: 'protected boolean canPerformNicHotPlug() { <START> return osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()); <END> \/\/ Please add this method check for cluster feature compatibility: return isHotPlugSupported() && osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()); }'","output":"protected boolean canPerformNicHotPlug() { return isHotPlugSupported() && osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'private, I this clearer interface is proxy methods'\nThe code is: '<START> public ChargeEntity updateChargeAndEmitEventPostAuthorisation(String chargeExternalId, <END> \/\/ private, I this clearer interface is proxy methods ChargeStatus status, AuthCardDetails authCardDetails, Optional<String> transactionId, Optional<Auth3dsDetailsEntity> auth3dsDetails, Optional<String> sessionIdentifier, Optional<WalletType> walletType, Optional<String> emailAddress) { ChargeEntity chargeEntity = updateChargePostAuthorisation(chargeExternalId, status, authCardDetails, transactionId, auth3dsDetails, sessionIdentifier, walletType, emailAddress); emitEvent(PaymentDetailsEnteredEvent.from(chargeEntity)); return chargeEntity; }'","output":"private ChargeEntity updateChargeAndEmitEventPostAuthorisation(String chargeExternalId, ChargeStatus status, AuthCardDetails authCardDetails, Optional<String> transactionId, Optional<Auth3dsDetailsEntity> auth3dsDetails, Optional<String> sessionIdentifier, Optional<WalletType> walletType, Optional<String> emailAddress) { ChargeEntity chargeEntity = updateChargePostAuthorisation(chargeExternalId, status, authCardDetails, transactionId, auth3dsDetails, sessionIdentifier, walletType, emailAddress); emitEvent(PaymentDetailsEnteredEvent.from(chargeEntity)); return chargeEntity; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '<LINK_0>'\nThe code is: 'private Collection<Policy> toPolicy(String tenant, Set<String> subjects) { Collection<Policy> policies = new ArrayList<Policy>(); for (String subject : subjects) { <START> LOGGER.debug(\"Getting policies for subject [\" + subject + \"]\"); <END> \/\/ <LINK_0> policies.addAll(dao.getPolicies(tenant, subject)); } return policies; }'","output":"private Collection<Policy> toPolicy(String tenant, Set<String> subjects) { Collection<Policy> policies = new ArrayList<Policy>(); for (String subject : subjects) { LOGGER.debug(\"Getting policies for subject [{}]\", subject); policies.addAll(dao.getPolicies(tenant, subject)); } return policies; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Negation missing? if (!cluster.isSetRequiredSwitchType()) {'\nThe code is: 'protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (cluster.isSetRequiredSwitchType()) { <END> \/\/ Negation missing? if (!cluster.isSetRequiredSwitchType()) { SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }'","output":"protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); if (!cluster.isSetRequiredSwitchType()) { SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove modifier constructor package private, remove null check'\nThe code is: '<START> public NotesToJson(Json json) { <END> \/\/ Remove modifier constructor package private, remove null check this.json = checkNotNull(json, \"json\"); }'","output":"NotesToJson(Json json) { this.json = json; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'A notifyDataSetChanged() call is in LoadSitesTask.onPostExecute loadSites() this line. remove this redundant'\nThe code is: 'void setEnableEditMode(boolean enable) { if (mIsMultiSelectEnabled == enable) { return; } if (enable) { mShowHiddenSites = true; mShowSelfHostedSites = false; } else { mShowHiddenSites = false; mShowSelfHostedSites = true; } mIsMultiSelectEnabled = enable; mSelectedPositions.clear(); <START> notifyDataSetChanged(); <END> \/\/ A notifyDataSetChanged() call is in LoadSitesTask.onPostExecute loadSites() this line. remove this redundant loadSites(); }'","output":"void setEnableEditMode(boolean enable) { if (mIsMultiSelectEnabled == enable) { return; } if (enable) { mShowHiddenSites = true; mShowSelfHostedSites = false; } else { mShowHiddenSites = false; mShowSelfHostedSites = true; } mIsMultiSelectEnabled = enable; mSelectedPositions.clear(); loadSites(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'System.out.println(String.format(\"Find footer locators: %s\", locators));'\nThe code is: 'public static WebElement findByFooter(WebDriver webDriver, String tableLocator, String content) { List<String> locators = parseTableLocator(tableLocator, \"footer\"); <START> System.out.println(Arrays.toString(locators.toArray())); <END> \/\/ System.out.println(String.format(\"Find footer locators: %s\", locators)); return searchInLocators(webDriver, locators, content); }'","output":"public static WebElement findByFooter(WebDriver webDriver, String tableLocator, String content) { List<String> locators = parseTableLocator(tableLocator, \"footer\"); return searchInLocators(webDriver, locators, content); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Accidental box'\nThe code is: 'static List<Date> getDays(long endTs, @Nullable Long lookback) { List<Date> result = new ArrayList<>(); <START> for (Long epochMillis : DateUtil.epochDays(endTs, lookback)) { <END> \/\/ Accidental box result.add(new Date(epochMillis)); } return result; }'","output":"static List<Date> getDays(long endTs, @Nullable Long lookback) { List<Date> result = new ArrayList<>(); for (long epochMillis : DateUtil.epochDays(endTs, lookback)) { result.add(new Date(epochMillis)); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'defensive copy here, this.objects = ImmutableList.copyOf(objects); this.objects = new ArrayList<G>(objects);'\nThe code is: 'private Context(final List<G> objects, final List<M> attributes, final BinaryRelation relation) { <START> this.objects = objects; <END> \/\/ defensive copy here, this.objects = ImmutableList.copyOf(objects); this.objects = new ArrayList<G>(objects); this.attributes = attributes; this.relation = relation; }'","output":"private Context(final List<G> objects, final List<M> attributes, final BinaryRelation relation) { this.objects = ImmutableList.copyOf(objects); this.attributes = ImmutableList.copyOf(attributes); this.relation = relation; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for extra variable'\nThe code is: 'public boolean hasDerivedMeasure() { <START> List<Measure> measures = getMeasures(); <END> \/\/ need for extra variable return measures.stream().anyMatch(measure -> measure.isPop() || measure.hasComputeRatio()); }'","output":"public boolean hasDerivedMeasure() { return getMeasures().stream().anyMatch(measure -> measure.isPop() || measure.hasComputeRatio()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is a member of class... This happened..'\nThe code is: 'protected void onPreExecute() { super.onPreExecute(); <START> if (context == null) { <END> \/\/ This is a member of class... This happened.. return; } String title = context.getString(R.string.please_wait); String message = context.getString(R.string.status_downloading); progressDialog = ProgressDialog.show(context, title, message); }'","output":"protected void onPreExecute() { super.onPreExecute(); if (context == null) { return; } String title = context.getString(R.string.please_wait); String progressMessage = context.getString(R.string.status_downloading); progressDialog = ProgressDialog.show(context, title, progressMessage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need spy in this case'\nThe code is: 'public void setup() { <START> this.literalExpression = spy(new LiteralExpression()); <END> \/\/ Do need spy in this case }'","output":"public void setup() { this.literalExpression = new LiteralExpression(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@fanifieiev above'\nThe code is: 'public RsWithStatus(final Response res, final int code, final CharSequence rsn) { super( <START> new RsOf( <END> \/\/ @fanifieiev above () -> RsWithStatus.head(res, code, rsn), res::body ) ); }'","output":"public RsWithStatus(final Response res, final int code, final CharSequence rsn) { super( new ResponseOf( () -> RsWithStatus.head(res, code, rsn), res::body ) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java if (activity instanceof FragmentActivity) { showRateDialog((FragmentActivity) activity); } I is developer FragmentActivity if SDK_INIT HONEYCOMS'\nThe code is: 'public static void showRateDialogIfMeetsConditions(final Activity activity) { if (shouldShowRateDialog()) { <START> if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) { <END> \/\/ java if (activity instanceof FragmentActivity) { showRateDialog((FragmentActivity) activity); } I is developer FragmentActivity if SDK_INIT HONEYCOMS showRateDialog((FragmentActivity) activity); } else { showRateDialog(activity); } } }'","output":"public static void showRateDialogIfMeetsConditions(final Activity activity) { if (shouldShowRateDialog()) { if (activity instanceof FragmentActivity) { showRateDialog((FragmentActivity) activity); } else { showRateDialog(activity); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method synchronized'\nThe code is: '<START> public void disableDarkTheme(boolean disabled) { <END> \/\/ this method synchronized darkThemeDisabled = disabled; }'","output":"public synchronized void disableDarkTheme(boolean disabled) { darkThemeDisabled = disabled; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'require null'\nThe code is: 'public PushPartialAggregationThroughExchange(FunctionRegistry functionRegistry) { <START> this.functionRegistry = functionRegistry; <END> \/\/ require null }'","output":"public PushPartialAggregationThroughExchange(FunctionRegistry functionRegistry) { this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry is null\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'moved field initialization declaration constructor? I leave in declaration for uniformity'\nThe code is: 'private ChromeCasts() { <START> chromeCasts = Collections.synchronizedList(new ArrayList<ChromeCast>()); <END> \/\/ moved field initialization declaration constructor? I leave in declaration for uniformity }'","output":"private ChromeCasts() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'switch this to: java this(new Persister());'\nThe code is: 'public SimpleXMLConverter() { <START> serializer = new Persister(); <END> \/\/ switch this to: java this(new Persister()); }'","output":"public SimpleXMLConverter() { this(new Persister()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'evaluate gitSystemConfig lazily in getGitSystemConfig(), a call discoverGitSystemConfig() avoided completely if gitSystemConfig set 'manually' before. discoverGitSystemConfig() is possibly slow hang if bash configuration is screwed up'\nThe code is: 'protected FS() { <START> gitSystemConfig = new Holder<File>(discoverGitSystemConfig()); <END> \/\/ evaluate gitSystemConfig lazily in getGitSystemConfig(), a call discoverGitSystemConfig() avoided completely if gitSystemConfig set 'manually' before. discoverGitSystemConfig() is possibly slow hang if bash configuration is screwed up }'","output":"protected FS() { }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'minor, lines combined'\nThe code is: 'public IReviewRemoteFactoryProvider createFactoryProvider(TaskRepository repository) { GerritClient client = getClient(repository); <START> return new GerritRemoteFactoryProvider(client); <END> \/\/ minor, lines combined }'","output":"public IReviewRemoteFactoryProvider createFactoryProvider(TaskRepository repository) { return new GerritRemoteFactoryProvider(getClient(repository)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'protected'\nThe code is: '<START> public void addObjectsToCollection(Cursor cursor, Collection<M> collection) { <END> \/\/ protected try { if (cursor.getCount() > 0) { cursor.moveToFirst(); do { collection.add(modelFactory.fromCursor(cursor)); } while (cursor.moveToNext()); } } finally { cursor.close(); } }'","output":"protected void addObjectsToCollection(Cursor cursor, Collection<M> collection) { try { if (cursor.getCount() > 0) { cursor.moveToFirst(); do { collection.add(modelFactory.fromCursor(cursor)); } while (cursor.moveToNext()); } } finally { cursor.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ok... a test passes fixing anything... :p'\nThe code is: 'public long getMinEnd() { <START> return fMinEnd != null ? fMinEnd : getNodeStart() + 1; <END> \/\/ Ok... a test passes fixing anything... :p }'","output":"public long getMinEnd() { return fMinEnd; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Breakpoints\"'\nThe code is: 'public String getText(Object element) { if (element instanceof IBreakpointManager) { <START> return \"Breakpoint Manager\"; END> } return super.getText(element); }'","output":"public String getText(Object element) { if (element instanceof IBreakpointManager) { return \"Breakpoints\"; } return super.getText(element); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ugly. for parameters method reading does'\nThe code is: 'private void createResourceControls(Composite parent, DataBindingContext dbc) { resourceKindLabel = new Label(parent, SWT.None); applyAlignData(SWT.FILL, SWT.CENTER, resourceKindLabel); resourceText = new Text(parent, SWT.BORDER | SWT.READ_ONLY); <START> applyGridData(2, 1, SWT.FILL, SWT.CENTER, true, false, resourceText); <END> \/\/ ugly. for parameters method reading does }'","output":"private void createResourceControls(Composite parent, DataBindingContext dbc) { resourceKindLabel = new Label(parent, SWT.None); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.CENTER).applyTo(resourceKindLabel); resourceText = new Text(parent, SWT.BORDER | SWT.READ_ONLY); GridDataFactory.fillDefaults().span(2,1).align(SWT.FILL, SWT.CENTER).grab(true, false).applyTo(resourceText); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'True, now'\nThe code is: 'public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), <START> false); <END> \/\/ True, now WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; }'","output":"public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), true); WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This cast feels a bit out of place I a suggestion - this is autowired add a separate bean a return type of SelectedContentLister returns object normal ContentLister bean'\nThe code is: 'private ContentEquivalenceUpdateTask publisherUpdateTask(final Publisher... publishers) { return new ContentEquivalenceUpdateTask( <START> (SelectedContentLister) contentLister, <END> \/\/ This cast feels a bit out of place I a suggestion - this is autowired add a separate bean a return type of SelectedContentLister returns object normal ContentLister bean contentResolver, getNewDefaultExecutor(), progressStore(), equivUpdater, ignored ).forPublishers(publishers); }'","output":"private ContentEquivalenceUpdateTask publisherUpdateTask(final Publisher... publishers) { return new ContentEquivalenceUpdateTask( contentLister, contentResolver, getNewDefaultExecutor(), progressStore(), equivUpdater, ignored ).forPublishers(publishers); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@yesamer I removed. synchronizeFactMappingsWidths put current columns widht factmappings, decided happen **only** user saves scenario - rely \"status\" implementation manage'\nThe code is: 'public void deleteColumn(int columnIndex) { checkSimulation(); final GridColumn<?> toDelete = getColumns().get(columnIndex); deleteColumn(toDelete); simulation.removeFactMappingByIndex(columnIndex); <START> synchronizeFactMappingsWidths(); <END> \/\/ @yesamer I removed. synchronizeFactMappingsWidths put current columns widht factmappings, decided happen **only** user saves scenario - rely \"status\" implementation manage }'","output":"public void deleteColumn(int columnIndex) { checkSimulation(); final GridColumn<?> toDelete = getColumns().get(columnIndex); deleteColumn(toDelete); simulation.removeFactMappingByIndex(columnIndex); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Authorization token is missing'\nThe code is: 'protected void handleMissingToken( ServletRequest request, ServletResponse response, FilterChain chain) throws IOException { <START> sendError(response, 401, \"Authorization token is missed\"); <END> \/\/ Authorization token is missing }'","output":"protected void handleMissingToken( ServletRequest request, ServletResponse response, FilterChain chain) throws IOException { sendError(response, 401, \"Authorization token is missing\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, this package private'\nThe code is: '<START> public DataCenterInfoResponseHandler(DateCodecFactory dateCodecFactory) { <END> \/\/ here, this package private super(dateCodecFactory); }'","output":"DataCenterInfoResponseHandler(DateCodecFactory dateCodecFactory) { super(dateCodecFactory); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrong error constant suggestion super(MediaWikiApiErrorHandler.ERROR_ASSERT_USER_FAILED, errorMessage);'\nThe code is: 'public AssertUserFailedException(String errorMessage) { <START> super(MediaWikiApiErrorHandler.ERROR_NO_SUCH_ENTITY, errorMessage); <END> \/\/ Wrong error constant suggestion super(MediaWikiApiErrorHandler.ERROR_ASSERT_USER_FAILED, errorMessage); }'","output":"public AssertUserFailedException(String errorMessage) { super(MediaWikiApiErrorHandler.ERROR_ASSERT_USER_FAILED, errorMessage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return Optional.of(new Relation());'\nThe code is: 'public Optional<Relation> getModelClass() { final Relation relation = new Relation(); <START> return Optional.of(relation); <END> \/\/ return Optional.of(new Relation()); }'","output":"public Optional<Relation> getModelClass() { return Optional.of(new Relation()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replacing this helper method great'\nThe code is: 'public static boolean clear() { <START> if (!isHawkInitialised()) { <END> \/\/ replacing this helper method great return false; } return hawkBuilder.getStorage().clear(); }'","output":"public static boolean clear() { Utils.validateBuild(); return internal.getStorage().clear(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again, IOUtils'\nThe code is: 'public void revertFile() throws IOException { <START> OutputStream fileOutputStream = Files.newOutputStream( <END> \/\/ Again, IOUtils Paths.get(\"src\/test\/resources\/testmetaOldFormat.xml\")); fileOutputStream.write(testMetaOldFormat); fileOutputStream.close(); }'","output":"public void revertFile() throws IOException { IOUtils.write( testMetaOldFormat, Files.newOutputStream(Paths.get(pathOfOldMetaFormat))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a NPE here, processModel.tradeManager is null'\nThe code is: 'public BuyerAsTakerProtocol(BuyerAsTakerTrade trade) { super(trade); Offer offer = checkNotNull(trade.getOffer()); processModel.getTradingPeer().setPubKeyRing(offer.getPubKeyRing()); <START> processModel.getTradeManager().requestPersistence(); <END> \/\/ a NPE here, processModel.tradeManager is null }'","output":"public BuyerAsTakerProtocol(BuyerAsTakerTrade trade) { super(trade); Offer offer = checkNotNull(trade.getOffer()); processModel.getTradingPeer().setPubKeyRing(offer.getPubKeyRing()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'specific exception here'\nThe code is: 'public void indexMarker(final IMarker marker) { try { Logger.traceIndexing(\"Indexing {} after addition...\", marker); final Document doc = LuceneDocumentFactory.createDocument(marker); Logger.debugIndexing(\"Adding Marker into index with following fields: {}\", doc.getFields()); indexWriter.addDocument(doc); indexWriter.commit(); <START> } catch (Exception e) { <END> \/\/ specific exception here Logger.error(\"Failed to index the JAX-RS Endpoint \" + marker, e); } finally { Logger.traceIndexing(\" Done indexing {}.\", marker); } }'","output":"public void indexMarker(final IMarker marker) { try { Logger.traceIndexing(\"Indexing {} after addition...\", marker); final Document doc = LuceneDocumentFactory.createDocument(marker); Logger.debugIndexing(\"Adding Marker into index with following fields: {}\", doc.getFields()); indexWriter.addDocument(doc); indexWriter.commit(); } catch (IOException e) { Logger.error(\"Failed to index the JAX-RS Endpoint \" + marker, e); } finally { Logger.traceIndexing(\" Done indexing {}.\", marker); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this.value = value;'\nThe code is: 'private QemuVolumeFormat(String value) { <START> value = <END> \/\/ this.value = value; value; }'","output":"private QemuVolumeFormat(String value) { this.value = value; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, row vector\/column vector explicitly? vector cases handled'\nThe code is: 'public void preProcess(INDArray array, DistributionStats stats) { if (array.rank() == 2) { <START> array.subiRowVector(stats.getMean()); <END> \/\/ here, row vector\/column vector explicitly? vector cases handled array.diviRowVector(filteredStd(stats)); } else { Nd4j.getExecutioner().execAndReturn(new BroadcastSubOp(array, stats.getMean(), array, 1)); Nd4j.getExecutioner().execAndReturn(new BroadcastDivOp(array, filteredStd(stats), array, 1)); } }'","output":"public void preProcess(INDArray array, DistributionStats stats) { if (array.rank() <= 2) { array.subiRowVector(stats.getMean()); array.diviRowVector(filteredStd(stats)); } else { Nd4j.getExecutioner().execAndReturn(new BroadcastSubOp(array, stats.getMean(), array, 1)); Nd4j.getExecutioner().execAndReturn(new BroadcastDivOp(array, filteredStd(stats), array, 1)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this Lists.newArrayList(deviceId);'\nThe code is: 'public void removeFromUsersTag( @Auth final AccessToken accessToken, @PathParam(\"tag_name\") final String tagName, @PathParam(\"user_id\") final Long userId) { final List<String> ids = new ArrayList<>(); <START> ids.add(String.valueOf(userId)); <END> \/\/ this Lists.newArrayList(deviceId); tagStore.remove(tagName, TagStoreDAODynamoDB.Type.USERS, ids); }'","output":"public void removeFromUsersTag( @Auth final AccessToken accessToken, @PathParam(\"tag_name\") final String tagName, @PathParam(\"user_id\") final Long userId) { final List<String> ids = Lists.newArrayList(); ids.add(String.valueOf(userId)); tagStore.remove(tagName, TagStoreDAODynamoDB.Type.USERS, ids); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need try catch overload called this'\nThe code is: 'public Mono<Boolean> exists() { <START> try { return existsWithResponse().flatMap(FluxUtil::toMono); } catch (RuntimeException ex) { return monoError(logger, ex); } <END> \/\/ need try catch overload called this }'","output":"public Mono<Boolean> exists() { return existsWithResponse().flatMap(FluxUtil::toMono); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@diegolovison warning logged setting queue size, reading it. This is I in mind: <LINK_0>'\nThe code is: 'int expiryQueueSize() { <START> log.warn(\"The expiry queueSize attribute is deprecated and will be removed\"); <END> \/\/ @diegolovison warning logged setting queue size, reading it. This is I in mind: <LINK_0> return expiryQueueSize.get(); }'","output":"int expiryQueueSize() { return expiryQueueSize.get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import for is'\nThe code is: 'public void uniqueCorrelationIDs() throws MuleException { CoreEvent firstEvent = getEventBuilder().message(of(\"first\")).build(); CoreEvent secondEvent = getEventBuilder().message(of(\"second\")).build(); assertThat(\"Duplicated correlationID\", firstEvent.getContext().getCorrelationId(), <START> not(Is.is(secondEvent.getContext().getCorrelationId()))); <END> \/\/ static import for is }'","output":"public void uniqueCorrelationIDs() throws MuleException { CoreEvent firstEvent = getEventBuilder().message(of(\"first\")).build(); CoreEvent secondEvent = getEventBuilder().message(of(\"second\")).build(); assertThat(\"Duplicated correlationID\", firstEvent.getContext().getCorrelationId(), not(is(secondEvent.getContext().getCorrelationId()))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this return file'\nThe code is: 'public static File writeOffsetFile(File storeBaseDir, String storeName, TaskName taskName, Map<SystemStreamPartition, String> offsets) throws IOException { File offsetFile = new File(getStorePartitionDir(storeBaseDir, storeName, taskName), OFFSET_FILE_NAME); String fileContents = OBJECT_WRITER.writeValueAsString(offsets); FileUtil.writeWithChecksum(offsetFile, fileContents); <START> return offsetFile; <END> \/\/ this return file }'","output":"public static void writeOffsetFile(File storeBaseDir, String storeName, TaskName taskName, Map<SystemStreamPartition, String> offsets) throws IOException { File offsetFile = new File(getStorePartitionDir(storeBaseDir, storeName, taskName), OFFSET_FILE_NAME); String fileContents = OBJECT_WRITER.writeValueAsString(offsets); FileUtil.writeWithChecksum(offsetFile, fileContents); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary)'\nThe code is: 'private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { <START> ImmutableList<PathElement> pathElements = Streams.stream(tokenizer).collect(toImmutableList()); <END> \/\/ nit: Streams.stream(tokenizer).collect(toImmutableList()); is good enough. (Assignment pathElements is necessary) fail(\"Expected failure\"); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(\"Invalid subfield path: \")); } }'","output":"private void assertInvalidPath(String path) { SubfieldTokenizer tokenizer = new SubfieldTokenizer(path); try { Streams.stream(tokenizer).collect(toImmutableList()); fail(\"Expected failure\"); } catch (PrestoException e) { assertTrue(e.getMessage().startsWith(\"Invalid subfield path: \")); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This function called marker is present, in practice input parameter null. Remove @Nullable annotation (apply this parser classes)'\nThe code is: 'protected Function<Object, IterableWithMarker<Discount>> markerToNextForArgs(List<Object> args) { return new Function<Object, IterableWithMarker<Discount>>() { @Override <START> public IterableWithMarker<Discount> apply(@Nullable Object input) { <END> \/\/ This function called marker is present, in practice input parameter null. Remove @Nullable annotation (apply this parser classes) PaginationOptions paginationOptions = PaginationOptions.class.cast(input); return api.listDiscounts(paginationOptions); } }; }'","output":"protected Function<Object, IterableWithMarker<Discount>> markerToNextForArgs(List<Object> args) { return new Function<Object, IterableWithMarker<Discount>>() { @Override public IterableWithMarker<Discount> apply(Object input) { PaginationOptions paginationOptions = PaginationOptions.class.cast(input); return api.listDiscounts(paginationOptions); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ID is restore files (from older release) this changed'\nThe code is: 'protected String getId() { <START> return \"GNU C compiler (gcc)\"; <END> \/\/ ID is restore files (from older release) this changed }'","output":"protected String getId() { return \"GNU compiler (gcc)\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reuse folderName'\nThe code is: 'protected void initDefaultOutput(ISCTFileSystemAccess access, GeneratorEntry entry) { String folderName = helper.getTargetFolderValue(entry).getStringValue(); access.setOutputPath(IFileSystemAccess.DEFAULT_OUTPUT, <START> helper.getTargetFolderValue(entry).getStringValue()); <END> \/\/ reuse folderName access.getOutputConfigurations().get(IFileSystemAccess.DEFAULT_OUTPUT).setCreateOutputDirectory(true); checkWriteAccess(access, IFileSystemAccess.DEFAULT_OUTPUT, folderName); }'","output":"protected void initDefaultOutput(ISCTFileSystemAccess access, GeneratorEntry entry) { String folderName = helper.getTargetFolderValue(entry).getStringValue(); access.setOutputPath(IFileSystemAccess.DEFAULT_OUTPUT, folderName); access.getOutputConfigurations().get(IFileSystemAccess.DEFAULT_OUTPUT).setCreateOutputDirectory(true); checkWriteAccess(access, IFileSystemAccess.DEFAULT_OUTPUT, folderName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS););'\nThe code is: 'public Map<String, String> connectorConfig(String connName) { FutureCallback<Map<String, String>> connectorConfigCallback = new FutureCallback<>(); herder.connectorConfig(connName, connectorConfigCallback); try { <START> Map<String, String> result = connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS); return new HashMap<>(result); <END> \/\/ suggestion return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS);); } catch (InterruptedException | ExecutionException | TimeoutException e) { throw new ConnectException( String.format(\"Failed to retrieve configuration for connector '%s'\", connName), e ); } }'","output":"public Map<String, String> connectorConfig(String connName) { FutureCallback<Map<String, String>> connectorConfigCallback = new FutureCallback<>(); herder.connectorConfig(connName, connectorConfigCallback); try { return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS)); } catch (InterruptedException | ExecutionException | TimeoutException e) { throw new ConnectException( String.format(\"Failed to retrieve configuration for connector '%s'\", connName), e ); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line removed'\nThe code is: 'protected Set<byte[]> executeOperation(Transport transport) { HeaderParams params = writeHeader(transport, BULK_GET_KEYS_REQUEST); transport.flush(); <START> System.out.println(\"hello\"); <END> \/\/ This line removed readHeaderAndValidate(transport, params); System.out.println(\"validated\"); Set<byte[]> result = new HashSet<byte[]>(); while ( transport.readByte() == 1) { result.add(transport.readArray()); } return result; }'","output":"protected Set<byte[]> executeOperation(Transport transport) { HeaderParams params = writeHeader(transport, BULK_GET_KEYS_REQUEST); transport.flush(); readHeaderAndValidate(transport, params); Set<byte[]> result = new HashSet<byte[]>(); while ( transport.readByte() == 1) { result.add(transport.readArray()); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'in else'\nThe code is: 'public void setSizes(String... sizes) { if (this.sizes == null) { this.sizes = new ArrayList<>(); } <START> this.sizes.clear(); <END> \/\/ in else this.sizes.addAll(Arrays.asList(sizes)); }'","output":"public void setSizes(String... sizes) { if (this.sizes == null) { this.sizes = new ArrayList<>(); } else { this.sizes.clear(); } this.sizes.addAll(Arrays.asList(sizes)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Exr0n call super()'\nThe code is: 'public SolenoidSubsystem(String name, boolean isInverted, SolenoidState defaultState, DoubleSolenoid... solenoids) { <START> setName(name); <END> \/\/ @Exr0n call super() setDefaultCommand(new SolenoidSet(this, defaultState)); this.solenoids = solenoids; this.isInverted = isInverted; this.defaultState = defaultState; this.state = defaultState; }'","output":"public SolenoidSubsystem(String name, boolean isInverted, SolenoidState defaultState, DoubleSolenoid... solenoids) { super(); setName(name); setDefaultCommand(new SolenoidSet(this, defaultState)); this.solenoids = solenoids; this.isInverted = isInverted; this.defaultState = defaultState; this.state = defaultState; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant, right'\nThe code is: 'protected void executeVmCommand() { Guid createdSnapshotId = updateActiveSnapshotId(); setActionReturnValue(createdSnapshotId); getParameters().setCreatedSnapshotId(createdSnapshotId); MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder(); freezeVm(); ActionReturnValue actionReturnValue = createSnapshotsForDisks(); if (actionReturnValue.getSucceeded()) { memoryImageBuilder.build(); addSnapshotToDB(createdSnapshotId, memoryImageBuilder); fastForwardDisksToActiveSnapshot(); setSucceeded(true); } <START> else { setSucceeded(false); } <END> \/\/ redundant, right }'","output":"protected void executeVmCommand() { Guid createdSnapshotId = updateActiveSnapshotId(); setActionReturnValue(createdSnapshotId); getParameters().setCreatedSnapshotId(createdSnapshotId); MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder(); freezeVm(); ActionReturnValue actionReturnValue = createSnapshotsForDisks(); if (actionReturnValue.getSucceeded()) { memoryImageBuilder.build(); addSnapshotToDB(createdSnapshotId, memoryImageBuilder); fastForwardDisksToActiveSnapshot(); setSucceeded(true); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Static'\nThe code is: '<START> private void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { <END> \/\/ Static final PromiseCombiner combiner = new PromiseCombiner(); for (int i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }'","output":"private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) { final PromiseCombiner combiner = new PromiseCombiner(); for (int i = 0; i < out.size(); i++) { combiner.add(ctx.write(out.getUnsafe(i))); } combiner.finish(promise); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I Travis build failed a typo. method is called getByteLength() (no 's'). If fix update PR, I merge this in'\nThe code is: 'public void writeString(Utf8 utf8) throws IOException { <START> out.write(utf8.getBytes(), 0, utf8.getBytesLength()); <END> \/\/ I Travis build failed a typo. method is called getByteLength() (no 's'). If fix update PR, I merge this in }'","output":"public void writeString(Utf8 utf8) throws IOException { out.write(utf8.getBytes(), 0, utf8.getByteLength()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Firing event wrapped in try block... in codebase. interesting. explain, please, motivation of this'\nThe code is: 'private void handleMachineRunning(final String machineId, final WorkspaceRuntimeDto workspaceRuntime) { final MachineEntity machine = getMachine(machineId, workspaceRuntime); if (machine == null) { return; } try { <START> eventBus.fireEvent(new MachineStateEvent(machine, RUNNING)); <END> \/\/ Firing event wrapped in try block... in codebase. interesting. explain, please, motivation of this } catch (Exception e) { Log.error(MachineStatusHandler.class, e.getMessage(), e); } }'","output":"private void handleMachineRunning(final String machineId, final WorkspaceRuntimeDto workspaceRuntime) { final MachineEntity machine = getMachine(machineId, workspaceRuntime); if (machine == null) { return; } eventBus.fireEvent(new MachineStateEvent(machine, RUNNING)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null empty is technical. like: Schema provided'\nThe code is: 'public Schema getSchema() { if (Strings.isNullOrEmpty(schema)) { <START> throw new IllegalArgumentException(\"Schema is either null or empty. It must be specified.\"); <END> \/\/ null empty is technical. like: Schema provided } try { return Schema.parseJson(schema); } catch (IOException e) { throw new IllegalArgumentException(String.format(\"Invalid schema : %s\", e.getMessage()), e); } }'","output":"public Schema getSchema() { if (Strings.isNullOrEmpty(schema)) { throw new IllegalArgumentException(\"Schema must be provided.\"); } try { return Schema.parseJson(schema); } catch (IOException e) { throw new IllegalArgumentException(String.format(\"Invalid schema : %s\", e.getMessage()), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static imports for form Assertion'\nThe code is: 'public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); Assertion.assertTrue(promoting.isMobileBannerDisplayed()); <START> Assertion.assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); <END> \/\/ static imports for form Assertion }'","output":"public void anonUserOnMobileCanSeeAppPromotion() { Promoting promoting = findPromoting(); assertTrue(promoting.isMobileBannerDisplayed()); assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Rebase error - Helper.getCurrentUser'\nThe code is: 'public List<TaskDTO> findOpenTasksForCurrentUser(String sort) throws DataException { <START> LoginForm login = (LoginForm) Helper.getManagedBeanValue(\"#{LoginForm}\"); <END> \/\/ Rebase error - Helper.getCurrentUser if (login == null) { return new ArrayList<>(); } List<JSONObject> results = findByProcessingStatusAndUser(TaskStatus.INWORK, login.getMyBenutzer().getId(), sort); return convertJSONObjectsToDTOs(results, false); }'","output":"public List<TaskDTO> findOpenTasksForCurrentUser(String sort) throws DataException { User user = Helper.getCurrentUser(); if (user == null) { return new ArrayList<>(); } List<JSONObject> results = findByProcessingStatusAndUser(TaskStatus.INWORK, user.getId(), sort); return convertJSONObjectsToDTOs(results, false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I suggest answer.toLowerCase() secret answer validation case insensitive'\nThe code is: 'public void changeQuestionAnswer(User u, String question, String answer) throws DAOException { log.info(\"Updating secret question and answer for \" + u.getUsername()); LoginCredential credentials = getLoginCredential(u); credentials.setSecretQuestion(question); <START> String hashedAnswer = Security.encodeString(answer + credentials.getSalt()); <END> \/\/ I suggest answer.toLowerCase() secret answer validation case insensitive credentials.setSecretAnswer(hashedAnswer); credentials.setDateChanged(new Date()); credentials.setChangedBy(u); updateLoginCredential(credentials); }'","output":"public void changeQuestionAnswer(User u, String question, String answer) throws DAOException { log.info(\"Updating secret question and answer for \" + u.getUsername()); LoginCredential credentials = getLoginCredential(u); credentials.setSecretQuestion(question); String hashedAnswer = Security.encodeString(answer.toLowerCase() + credentials.getSalt()); credentials.setSecretAnswer(hashedAnswer); credentials.setDateChanged(new Date()); credentials.setChangedBy(u); updateLoginCredential(credentials); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); }'\nThe code is: 'public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, \"Required non-null namespace\"); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); <START> if (includeRuntimes) { <END> \/\/ logic if rewrite code for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace); } } else { for (WorkspaceImpl workspace : workspaces) { workspace.setStatus(runtimes.getStatus(workspace.getId())); } } return workspaces; }'","output":"public List<WorkspaceImpl> getByNamespace(String namespace, boolean includeRuntimes) throws ServerException { requireNonNull(namespace, \"Required non-null namespace\"); final List<WorkspaceImpl> workspaces = workspaceDao.getByNamespace(namespace); for (WorkspaceImpl workspace : workspaces) { normalizeState(workspace, includeRuntimes); } return workspaces; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove synchronized'\nThe code is: '<START> public synchronized long getReservedRevocableBytes() <END> \/\/ remove synchronized { return operatorMemoryContext.getRevocableMemory(); }'","output":"public long getReservedRevocableBytes() { return operatorMemoryContext.getRevocableMemory(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'\nThe code is: 'public List<String> getJavaOptsArray() { <START> return javaOptsArray == null ? ImmutableList.<String>of() : javaOptsArray; <END> \/\/ nan }'","output":"public List<String> getJavaOptsArray() { return javaOptsArray; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'show_notification instead of allow'\nThe code is: 'public String getDataSharingNotificationForCurrentUser(Request request, Response response) { boolean shouldAllow = dataSharingNotification.allowNotificationFor(currentUsername()); <START> return jsonizeAsTopLevelObject(request, writer -> writer.add(\"allow\", shouldAllow)); <END> \/\/ show_notification instead of allow }'","output":"public String getDataSharingNotificationForCurrentUser(Request request, Response response) { boolean shouldAllow = dataSharingNotification.allowNotificationFor(currentUsername()); return jsonizeAsTopLevelObject(request, writer -> writer.add(\"show_notification\", shouldAllow)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I remove process if kill succeeded. is branch leaves stale consumer supervised anymore removed it'\nThe code is: 'private void cleanup(ConsumerProcess consumerProcess) { kill(consumerProcess); <START> runningProcesses.remove(consumerProcess); <END> \/\/ I remove process if kill succeeded. is branch leaves stale consumer supervised anymore removed it }'","output":"private void cleanup(ConsumerProcess consumerProcess) { kill(consumerProcess); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do this mocking api, this call is mock doesnt do it.'\nThe code is: 'public void invalidProviderType() { <START> provider.setType(NON_NETWORK_PROVIDER_TYPE); <END> \/\/ do this mocking api, this call is mock doesnt do it. assertThat(validator.providerTypeValid(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_TYPE_MISMATCH)); }'","output":"public void invalidProviderType() { when(provider.getType()).thenReturn(NON_NETWORK_PROVIDER_TYPE); assertThat(validator.providerTypeValid(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_TYPE_MISMATCH)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nan'\nThe code is: 'public IBinder getLegacyBrowserServiceBinder() { <START> if (mBrowserServiceLegacyStub != null) { <END> \/\/ nan Intent intent = new Intent(MediaBrowserServiceCompat.SERVICE_INTERFACE); return mBrowserServiceLegacyStub.onBind(intent); } return null; }'","output":"public IBinder getLegacyBrowserServiceBinder() { Intent intent = new Intent(MediaBrowserServiceCompat.SERVICE_INTERFACE); return mBrowserServiceLegacyStub.onBind(intent); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this if (!Strings.isNullOrEmpty(link)) {'\nThe code is: 'private String resolveUrl(URI uri, String link) { String url = cfg.getString(\"gerrit\", null, \"canonicalWebUrl\"); if (Strings.isNullOrEmpty(url)) { url = uri.toString(); } if (!url.endsWith(\"\/\")) { url += \"\/\"; } <START> if (Strings.isNullOrEmpty(link)) { <END> \/\/ this if (!Strings.isNullOrEmpty(link)) { url += \"#\" + link; } return url; }'","output":"private String resolveUrl(URI uri, String link) { String url = cfg.getString(\"gerrit\", null, \"canonicalWebUrl\"); if (Strings.isNullOrEmpty(url)) { url = uri.toString(); } if (!url.endsWith(\"\/\")) { url += \"\/\"; } if (!Strings.isNullOrEmpty(link)) { url += \"#\" + link; } return url; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'methods final accidentally overridden'\nThe code is: '<START> public void setUp() <END> \/\/ methods final accidentally overridden { tester = new RuleTester(); }'","output":"public final void setUp() { tester = new RuleTester(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a hardcoded constant (\"value\"), simply name. I this change in practice, in case people copy\/paste this code'\nThe code is: 'public void configureFieldMetadata(String name, FieldMetadataBuilder builder) { <START> builder.field( \"value\", FieldType.OBJECT ); <END> \/\/ This a hardcoded constant (\"value\"), simply name. I this change in practice, in case people copy\/paste this code }'","output":"public void configureFieldMetadata(String name, FieldMetadataBuilder builder) { builder.field( name, FieldType.OBJECT ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This SavedState constructor package-private avoid accessing a private member in createFromParcel method'\nThe code is: '<START> private SavedState(Parcel in) { <END> \/\/ This SavedState constructor package-private avoid accessing a private member in createFromParcel method super(in); in.readList(mIds, List.class.getClassLoader()); }'","output":"SavedState(Parcel in) { super(in); in.readList(mIds, List.class.getClassLoader()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this assignment \"guid\" in base class? it'\nThe code is: 'protected BackendOpenStackVolumeAuthenticationKeyResource(String providerId, String id) { super(id, OpenstackVolumeAuthenticationKey.class, LibvirtSecret.class); this.providerId = providerId; <START> this.guid = asGuidOr404(id); <END> \/\/ I this assignment \"guid\" in base class? it }'","output":"protected BackendOpenStackVolumeAuthenticationKeyResource(String providerId, String id) { super(id, OpenstackVolumeAuthenticationKey.class, LibvirtSecret.class); this.providerId = providerId; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return String.format(URL, checkerInfo.getCurrencyBaseLowerCase(), checkerInfo.getCurrencyCounterLowerCase());, hardcoding BRL here'\nThe code is: 'public String getUrl(int requestId, CheckerInfo checkerInfo) { <START> return URL.concat(checkerInfo.getCurrencyBaseLowerCase()) <END> \/\/ return String.format(URL, checkerInfo.getCurrencyBaseLowerCase(), checkerInfo.getCurrencyCounterLowerCase());, hardcoding BRL here .concat(\"_\") .concat(Currency.BRL.toLowerCase()); }'","output":"public String getUrl(int requestId, CheckerInfo checkerInfo) { return String.format(URL, checkerInfo.getCurrencyBaseLowerCase(), checkerInfo.getCurrencyCounterLowerCase()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this included in this PR'\nThe code is: 'void nextPage() { currentPage++; <START> DataResultViewerTable.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR)); <END> \/\/ is this included in this PR postPageChangeEvent(); DataResultViewerTable.this.setCursor(null); }'","output":"void nextPage() { currentPage++; postPageChangeEvent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Double.isNaN(double) ;)'\nThe code is: 'public static void finite(final double value, final String message, final Object... values) { <START> if (value != value || Double.isInfinite(value)) { <END> \/\/ Double.isNaN(double) ;) throw new IllegalArgumentException(String.format(message, values)); } }'","output":"public static void finite(final double value, final String message, final Object... values) { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException(String.format(message, values)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this logging statement'\nThe code is: 'public @ResponseBody void registerSubmit( @RequestParam(value = \"name\") String name, @RequestParam(value = \"username\") String username, @RequestParam(value = \"password\") String password) { PlayerDao playerDao = new PlayerDao(); String genPassword = StringUtils.secureString(password); Player newPlayer = new Player(name, username, genPassword); <START> System.out.println(newPlayer.toString()); <END> \/\/ remove this logging statement playerDao.savePlayer(newPlayer); }'","output":"public @ResponseBody void registerSubmit( @RequestParam(value = \"name\") String name, @RequestParam(value = \"username\") String username, @RequestParam(value = \"password\") String password) { PlayerDao playerDao = new PlayerDao(); String genPassword = StringUtils.secureString(password); Player newPlayer = new Player(name, username, genPassword); playerDao.savePlayer(newPlayer); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getServicePolicy return null. Based Python SDK functions return a policy object time. In case is in fact empty ({\"factors\": [], \"minimum_requirements\": []}), return a policy minimum_factors set false 0'\nThe code is: 'void retrievePolicyForService(UUID serviceId) throws Throwable { ServicePolicy policy = client.getServicePolicy(serviceId); <START> currentServicePolicyEntity = policy == null ? null : ServicePolicyEntity.fromServicePolicy(policy); <END> \/\/ getServicePolicy return null. Based Python SDK functions return a policy object time. In case is in fact empty ({\"factors\": [], \"minimum_requirements\": []}), return a policy minimum_factors set false 0 }'","output":"void retrievePolicyForService(UUID serviceId) throws Throwable { ServicePolicy policy = client.getServicePolicy(serviceId); currentServicePolicyEntity = ServicePolicyEntity.fromServicePolicy(policy); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tons of wrong in this call, returning null crash break other code, clear semantic meaning. need figure out failing is handled'\nThe code is: 'public static JSONArray walkToJSON(FormEntryModel fem, FormEntryController fec) { try { JSONArray ret = new JSONArray(); FormIndex formIndex = FormIndex.createBeginningOfFormIndex(); Walker walker = new Walker(ret, formIndex, fec, fem); walker.walk(); return ret; } catch (Exception e) { e.printStackTrace(); <START> return null; <END> \/\/ tons of wrong in this call, returning null crash break other code, clear semantic meaning. need figure out failing is handled } }'","output":"public static JSONArray walkToJSON(FormEntryModel fem, FormEntryController fec) { JSONArray ret = new JSONArray(); FormIndex formIndex = FormIndex.createBeginningOfFormIndex(); Walker walker = new Walker(ret, formIndex, fec, fem); walker.walk(); return ret; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I want method accessor package private :eyes:'\nThe code is: '<START> public static void showRateDialog(final Activity activity) { <END> \/\/ I want method accessor package private :eyes: final RateDialogFragment fragment = RateDialogFragment.newInstance(sIsShoWNeutralButton); fragment.show(activity.getFragmentManager(), TAG); }'","output":"private static void showRateDialog(final Activity activity) { final RateDialogFragment fragment = RateDialogFragment.newInstance(sIsShoWNeutralButton); fragment.show(activity.getFragmentManager(), TAG); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'THis return empty array'\nThe code is: 'public default IVariableBinding[] getSyntheticOuterLocals() { return <START> null; <END> \/\/ THis return empty array }'","output":"public default IVariableBinding[] getSyntheticOuterLocals() { return new IVariableBinding[0]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exception needs modified a bit'\nThe code is: 'public synchronized void resumeJob(final String jobName, final String groupName) throws SchedulerException { if (!ifJobExist(jobName, groupName)) { throw new SchedulerException( <START> \"can not find job with group name: \" + groupName + \" in quartz.\"); <END> \/\/ exception needs modified a bit } else { this.scheduler.resumeJob(new JobKey(jobName, groupName)); } }'","output":"public synchronized void resumeJob(final String jobName, final String groupName) throws SchedulerException { checkJobExistence(jobName, groupName); this.scheduler.resumeJob(new JobKey(jobName, groupName)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method public this data source return settings domain entity'\nThe code is: '<START> public MediaListMode getMediaListMode() { <END> \/\/ This method public this data source return settings domain entity MediaListMode mediaListMode = null; if(getMediaPreference().equals(MediaListMode.GRID.toString())){ mediaListMode = MediaListMode.GRID; }else if(getMediaPreference().equals(MediaListMode.LIST.toString())){ mediaListMode = MediaListMode.LIST; } return mediaListMode; }'","output":"private MediaListMode getMediaListMode() { MediaListMode mediaListMode = null; if(getMediaPreference().equals(MediaListMode.GRID.toString())){ mediaListMode = MediaListMode.GRID; }else if(getMediaPreference().equals(MediaListMode.LIST.toString())){ mediaListMode = MediaListMode.LIST; } return mediaListMode; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need catch exception here, done in overload'\nThe code is: 'public Mono<AccountProperties> getAccountProperties() { try { return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono); <START> } catch (RuntimeException ex) { <END> \/\/ need catch exception here, done in overload return monoError(logger, ex); } }'","output":"public Mono<AccountProperties> getAccountProperties() { return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary change'\nThe code is: 'public MojoExecution setupMojoExecution(final MavenProject project, final MojoExecution execution, IProgressMonitor monitor) throws CoreException { <START> return context().execute(project, new ICallable<MojoExecution>() { <END> \/\/ unnecessary change public MojoExecution call(IMavenExecutionContext context, IProgressMonitor monitor) throws CoreException { return setupMojoExecution(context.getSession(), project, execution); } }, monitor); }'","output":"public MojoExecution setupMojoExecution(final MavenProject project, final MojoExecution execution, IProgressMonitor monitor) throws CoreException { return context().execute(project, (context, pm) -> setupMojoExecution(context.getSession(), project, execution), monitor); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this be: null == patternFilter'\nThe code is: 'private void setSearchFilter(String string) { if <START> (patternFilter == null) { <END> \/\/ this be: null == patternFilter patternFilter = new TypeListPatternFilter(); commonViewer.addFilter(patternFilter); } patternFilter.setPattern(string); commonViewer.refresh(false); handleTreeExpansion(string); }'","output":"private void setSearchFilter(String string) { if (null == patternFilter) { patternFilter = new TypeListPatternFilter(); commonViewer.addFilter(patternFilter); } patternFilter.setPattern(string); commonViewer.refresh(false); handleTreeExpansion(string); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'character '.' word 'totally''\nThe code is: 'public MemberRemovedFromGroupTotally(Member member, Group group) { this.member = member; this.group = group; <START> this.message = formatMessage(\"%s was removed from %s totally\", member, group); <END> \/\/ character '.' word 'totally' }'","output":"public MemberRemovedFromGroupTotally(Member member, Group group) { this.member = member; this.group = group; this.message = formatMessage(\"%s was removed from %s totally.\", member, group); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'slack in here? suggestion return \"Slack email User ID Resolver\";'\nThe code is: 'public String getDisplayName() { <START> return \"Email User ID Resolver\"; <END> \/\/ slack in here? suggestion return \"Slack email User ID Resolver\"; }'","output":"public String getDisplayName() { return \"Slack email User ID Resolver\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is legal: collections.emptyMap returns a non-modifiable empty map (and empty map). Invoking .put fail. For maps a single element, Collections.singletonMap(...). return a non-modifiable map. Note this is highlighting trap in Java language API'\nThe code is: 'public static boolean openRenameWizard(String newName, IStructuredSelection structuredSelection) { Map<String, Object> commandParameters = Collections.emptyMap(); <START> commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); <END> \/\/ This is legal: collections.emptyMap returns a non-modifiable empty map (and empty map). Invoking .put fail. For maps a single element, Collections.singletonMap(...). return a non-modifiable map. Note this is highlighting trap in Java language API return runCommand(LTK_RENAME_ID, structuredSelection, commandParameters); }'","output":"public static boolean openRenameWizard(String newName, IStructuredSelection structuredSelection) { Map<String, Object> commandParameters = new HashMap<>(); commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); return runCommand(LTK_RENAME_ID, structuredSelection, commandParameters); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'omit'\nThe code is: 'public InstallableUnitDescription readOneIU(InputStream is) throws IOException { Parser parser = new <START> Parser(org.eclipse.tycho.p2.maven.repository.xmlio.MetadataIO.Parser.PARSER_MODE.IU); <END> \/\/ omit parser.parse(is, new NullProgressMonitor()); return parser.getUnits().get(0); }'","output":"public InstallableUnitDescription readOneIU(InputStream is) throws IOException { Parser parser = new Parser(Parser.PARSER_MODE.IU); parser.parse(is, new NullProgressMonitor()); return parser.getUnits().get(0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is ->'\nThe code is: 'public CheckNotificationsSupportedTask(ServerConnection connection) { <START> super(null, \"Check if smart notifications is available in the SonarQube edition\", true); <END> \/\/ is -> this.connection = connection; }'","output":"public CheckNotificationsSupportedTask(ServerConnection connection) { super(null, \"Check if smart notifications are available in the SonarQube edition\", true); this.connection = connection; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above; is need this injector public'\nThe code is: '<START> public void onPlayerActive(CallbackInfo ci) { <END> \/\/ above; is need this injector public ((IMixinNetHandlerPlayServer) this.connection).resendLatestResourcePackRequest(); }'","output":"private void onPlayerActive(CallbackInfo ci) { ((IMixinNetHandlerPlayServer) this.connection).resendLatestResourcePackRequest(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please static import for CompressionUtils. addFolderToTar above'\nThe code is: 'public void addFileToPackage(TarArchiveOutputStream tarArchiveOutputStream, File file, String path) throws IOException { <START> CompressionUtils.addFileToTar(tarArchiveOutputStream, file, getLibPath() + path); <END> \/\/ Please static import for CompressionUtils. addFolderToTar above }'","output":"public void addFileToPackage(TarArchiveOutputStream tarArchiveOutputStream, File file, String path) throws IOException { addFileToTar(tarArchiveOutputStream, file, getLibPath() + path); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I call escape in line @deprecated message escape methods behave (someone update escape(String) updating deprecated escape(Object)). This is minor a practice IMO'\nThe code is: 'public static String escape(Object content) { <START> return escapeAttributeValue(Objects.toString(content, null)); <END> \/\/ I call escape in line @deprecated message escape methods behave (someone update escape(String) updating deprecated escape(Object)). This is minor a practice IMO }'","output":"public static String escape(Object content) { return escape(Objects.toString(content, null)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Lines 1051-1053 redundant'\nThe code is: 'protected IFile getFile(IResource resource) { if <START> (resource instanceof <END> \/\/ Lines 1051-1053 redundant IFile) { return (IFile) resource; } return Adapters.getAdapter(resource, IFile.class, true); }'","output":"protected IFile getFile(IResource resource) { return Adapters.getAdapter(resource, IFile.class, true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'methods package-private'\nThe code is: '<START> public String getTableName() { <END> \/\/ methods package-private return this.tableName; }'","output":"String getTableName() { return tableName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tokenise? getTokens is a bit general for does'\nThe code is: 'public void lex_generalInputs() { <START> assertEquals(getTokens(\"\"), Arrays.asList( <END> \/\/ tokenise? getTokens is a bit general for does new Token(TokenType.EOF, \"\"))); assertEquals(getTokens(\"a' b' c'\"), Arrays.asList( new Token(TokenType.SYMBOL, \"a'\"), new Token(TokenType.SYMBOL, \"b'\"), new Token(TokenType.SYMBOL, \"c'\"), new Token(TokenType.EOF, \"\"))); }'","output":"public void lex_generalInputs() { assertEquals(tokenise(\"\"), Arrays.asList( new Token(TokenType.EOF, \"\"))); assertEquals(tokenise(\"a' b' c'\"), Arrays.asList( new Token(TokenType.SYMBOL, \"a'\"), new Token(TokenType.SYMBOL, \"b'\"), new Token(TokenType.SYMBOL, \"c'\"), new Token(TokenType.EOF, \"\"))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion return SystemUtils.IS_OS_LINUX && gnomeLoginKeyring.isPresent();'\nThe code is: 'public boolean isSupported() { <START> return SystemUtils.IS_OS_LINUX && gnomeLoginKeyring != null; <END> \/\/ suggestion return SystemUtils.IS_OS_LINUX && gnomeLoginKeyring.isPresent(); }'","output":"public boolean isSupported() { return SystemUtils.IS_OS_LINUX && gnomeLoginKeyring.isPresent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this public, right'\nThe code is: '<START> public PresenceStatus getPresenceStatusObject(Registration reg) { <END> \/\/ I this public, right return clientStatusList.get(reg.getEndpoint()); }'","output":"private PresenceStatus getPresenceStatusObject(Registration reg) { return clientStatusList.get(reg.getEndpoint()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Technically, Class<? extends ClockProvider>'\nThe code is: 'private ClockProvider createClockProvider(Configuration<?> config) { BootstrapConfiguration bootstrapConfiguration = config.getBootstrapConfiguration(); String clockProviderFqcn = bootstrapConfiguration.getClockProviderClassName(); if ( clockProviderFqcn == null ) { return config.getDefaultClockProvider(); } @SuppressWarnings(\"unchecked\") <START> Class<ClockProvider> clockProviderClass = (Class<ClockProvider>) run( <END> \/\/ Technically, Class<? extends ClockProvider> LoadClass.action( clockProviderFqcn, null ) ); return createInstance( clockProviderClass ); }'","output":"private ClockProvider createClockProvider(Configuration<?> config) { BootstrapConfiguration bootstrapConfiguration = config.getBootstrapConfiguration(); String clockProviderFqcn = bootstrapConfiguration.getClockProviderClassName(); if ( clockProviderFqcn == null ) { return config.getDefaultClockProvider(); } @SuppressWarnings(\"unchecked\") Class<? extends ClockProvider> clockProviderClass = (Class<? extends ClockProvider>) run( LoadClass.action( clockProviderFqcn, null ) ); return createInstance( clockProviderClass ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![MAJOR](<LINK_1> 'Severity: MAJOR') log rethrow this exception. [![rule](<LINK_2>](<LINK_0>'\nThe code is: 'public static IMEInventoryHandler getCell( final ItemStack o, final ISaveProvider container2 ) { try { return new CellInventoryHandler( new FluidCellInventory( o, container2 ), AEApi.instance().storage().getStorageChannel( IFluidStorageChannel.class ) ); } <START> catch( final AppEngException e ) <END> \/\/ ![MAJOR](<LINK_1> 'Severity: MAJOR') log rethrow this exception. [![rule](<LINK_2>](<LINK_0> { return null; } }'","output":"public static IMEInventoryHandler getCell( final ItemStack o, final ISaveProvider container2 ) { try { return new FluidCellInventoryHandler( new FluidCellInventory( o, container2 ) ); } catch( final AppEngException e ) { return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is single element list use: java final List<Element> updatedElements = Collections.singletoneList(mock(Element.class));'\nThe code is: 'public void checkNotifyElementUpdatedAndListenerUpdated() { canvasHandler.addRegistrationListener(updateListener); <START> final List<Element> updatedElements = new ArrayList<>(); updatedElements.add(mock(Element.class)); <END> \/\/ this is single element list use: java final List<Element> updatedElements = Collections.singletoneList(mock(Element.class)); canvasHandler.doBatchUpdate(updatedElements); verify(updateListener, times(1)).updateBatch(any()); }'","output":"public void checkNotifyElementUpdatedAndListenerUpdated() { canvasHandler.addRegistrationListener(updateListener); final List<Element> updatedElements = Collections.singletonList(mock(Element.class)); canvasHandler.doBatchUpdate(updatedElements); verify(updateListener, times(1)).updateBatch(any()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Objects.equals(value, name.value)'\nThe code is: 'public boolean equals(final Object o) { if (this == o) { return true; } if (!(o instanceof NameHolder)) { return false; } final NameHolder name = (NameHolder) o; <START> return value != null ? value.equals(name.value) : name.value == null; <END> \/\/ Objects.equals(value, name.value) }'","output":"public boolean equals(final Object o) { if (this == o) { return true; } if (!(o instanceof NameHolder)) { return false; } final NameHolder name = (NameHolder) o; return Objects.equals(value, name.value); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'times(0) ->'\nThe code is: 'public void processMessageShouldNotSendFirmwareFileRequestWhenFirmwareFileAvailable() throws JMSException { final String firmwareIdentification = \"unavailable\"; final ObjectMessage message = new ObjectMessageBuilder().withObject(firmwareIdentification).build(); when(this.firmwareService.isFirmwareFileAvailable(firmwareIdentification)).thenReturn(true); this.processor.processMessage(message); <START> verify(this.osgpRequestMessageSender, times(0)).send(any(RequestMessage.class), any(String.class), <END> \/\/ times(0) -> any(MessageMetadata.class)); }'","output":"public void processMessageShouldNotSendFirmwareFileRequestWhenFirmwareFileAvailable() throws JMSException { final String firmwareIdentification = \"unavailable\"; final ObjectMessage message = new ObjectMessageBuilder().withObject(firmwareIdentification).build(); when(this.firmwareService.isFirmwareFileAvailable(firmwareIdentification)).thenReturn(true); this.processor.processMessage(message); verify(this.osgpRequestMessageSender, never()).send(any(RequestMessage.class), any(String.class), any(MessageMetadata.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this in tmf.core.Activator now. this plugin depends tmf.core, loaded. Is this necessary call this again'\nThe code is: 'public void start(BundleContext context) throws Exception { super.start(context); setDefault(this); <START> TmfAnalysisManager.initializeModuleSources(); <END> \/\/ this in tmf.core.Activator now. this plugin depends tmf.core, loaded. Is this necessary call this again }'","output":"public void start(BundleContext context) throws Exception { super.start(context); setDefault(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'RecordBatch.NO_TIMESTAMP too'\nThe code is: 'public long deleteHorizonMs() { <START> return -1L; <END> \/\/ RecordBatch.NO_TIMESTAMP too }'","output":"public long deleteHorizonMs() { return RecordBatch.NO_TIMESTAMP; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'requireNN'\nThe code is: 'public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { <START> this.sslContext = sslContext; <END> \/\/ requireNN this.socksProxy = requireNonNull(socksProxy, \"socksProxy is null\"); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, \"metastoreAuthentication is null\"); }'","output":"public HiveMetastoreClientFactory( Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, Duration timeout, HiveMetastoreAuthentication metastoreAuthentication) { this.sslContext = requireNonNull(sslContext, \"sslContext is null\"); this.socksProxy = requireNonNull(socksProxy, \"socksProxy is null\"); this.timeoutMillis = toIntExact(timeout.toMillis()); this.metastoreAuthentication = requireNonNull(metastoreAuthentication, \"metastoreAuthentication is null\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'set final'\nThe code is: 'private void setStructureDependencies(final PublisherFilter publisherFilter) throws DotDataException, DotSecurityException { try { <START> for (String inode : contentTypesSet) { <END> \/\/ set final structureDependencyHelper(inode,publisherFilter); } } catch (DotDataException e) { Logger.error(this, e.getMessage(),e); } }'","output":"private void setStructureDependencies(final PublisherFilter publisherFilter) throws DotDataException, DotSecurityException { try { for (final String inode : contentTypesSet) { structureDependencyHelper(inode,publisherFilter); } } catch (DotDataException e) { Logger.error(this, e.getMessage(),e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IMHO remove this log message all'\nThe code is: 'public void activate() { hueBridgeHandler.registerLightStatusListener(this); <START> logger.info(\"Hue Light Discovery Service activated.\"); <END> \/\/ IMHO remove this log message all }'","output":"public void activate() { hueBridgeHandler.registerLightStatusListener(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@thiliA fix this exception well'\nThe code is: 'public void addExecutionPlan(String executionPlan) throws RemoteException { try { eventProcessorAdminServiceStub.deployExecutionPlan(executionPlan); } catch (RemoteException e) { log.error(\"RemoteException\", e); <START> throw new RemoteException(e.getMessage(), e); <END> \/\/ @thiliA fix this exception well } }'","output":"public void addExecutionPlan(String executionPlan) throws RemoteException { try { eventProcessorAdminServiceStub.deployExecutionPlan(executionPlan); } catch (RemoteException e) { log.error(\"RemoteException\", e); throw e; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\\n in printed output, is portable operating systems. %n instead'\nThe code is: 'public void typeProcessingOver() { if (getBooleanOption(COUNT_FRAMEWORK_BUILD_CALLS)) { <START> System.out.printf(\"Found %d build() method calls.\\n\", numBuildCalls); <END> \/\/ \\n in printed output, is portable operating systems. %n instead } super.typeProcessingOver(); }'","output":"public void typeProcessingOver() { if (getBooleanOption(COUNT_FRAMEWORK_BUILD_CALLS)) { System.out.printf(\"Found %d build() method calls.%n\", numBuildCalls); } super.typeProcessingOver(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'set servlet path for this test pass'\nThe code is: 'private MockHttpServletRequest requestToSave() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setServerPort(443); request.setSecure(true); request.setScheme(\"https\"); request.setServerName(\"abc.com\"); request.setRequestURI(\"\/destination\"); <START> request.setServletPath(\"\/destination\"); <END> \/\/ set servlet path for this test pass request.setQueryString(\"param1=a&param2=b&param3=1122\"); return request; }'","output":"private MockHttpServletRequest requestToSave() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setServerPort(443); request.setSecure(true); request.setScheme(\"https\"); request.setServerName(\"abc.com\"); request.setRequestURI(\"\/destination\"); request.setQueryString(\"param1=a&param2=b&param3=1122\"); return request; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please limit visibility of constructor'\nThe code is: '<START> public QualifierRangeFilter(String family) { <END> \/\/ please limit visibility of constructor range.setFamilyName(Preconditions.checkNotNull(family)); }'","output":"private QualifierRangeFilter(String family) { range.setFamilyName(Preconditions.checkNotNull(family)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Initialize in field declaration'\nThe code is: 'private TreeWalker(String namespace, JSTypeRegistry typeRegistry, Set<String> provides) { this.namespace = namespace; this.typeRegistry = typeRegistry; this.provides = provides; <START> this.valueSymbolsWalked = 0; <END> \/\/ Initialize in field declaration }'","output":"private TreeWalker(String namespace, JSTypeRegistry typeRegistry, Set<String> provides) { this.namespace = namespace; this.typeRegistry = typeRegistry; this.provides = provides; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a Parcel expert I want write this out unconditionally. If don't, I constructor byte offsets wrong for other values'\nThe code is: 'public void writeToParcel(Parcel parcel, int flags) { parcel.writeString(namespace); parcel.writeString(text); parcel.writeString(fragment); parcel.writeParcelable(site, flags); <START> if (hasProperties()) { <END> \/\/ a Parcel expert I want write this out unconditionally. If don't, I constructor byte offsets wrong for other values parcel.writeParcelable(properties, flags); } parcel.writeString(thumbUrl); parcel.writeString(description); }'","output":"public void writeToParcel(Parcel parcel, int flags) { parcel.writeString(namespace); parcel.writeString(text); parcel.writeString(fragment); parcel.writeParcelable(site, flags); parcel.writeParcelable(properties, flags); parcel.writeString(thumbUrl); parcel.writeString(description); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please put parameter in separate line :)'\nThe code is: 'public void testAggregationPushdownThroughOuterJoinNotFiringInCorrelatedAggregatesLeftSide() { <START> assertQuery(\"SELECT max(x) from (SELECT * from (VALUES 1) t(x) LEFT JOIN (VALUES 1) t2(y) ON t.x = t2.y) GROUP BY x\", <END> \/\/ please put parameter in separate line :) \"VALUES 1\"); }'","output":"public void testAggregationPushdownThroughOuterJoinNotFiringInCorrelatedAggregatesLeftSide() { assertQuery(\"SELECT max(x) FROM\" + \"(SELECT * from (VALUES 1) t(x) LEFT JOIN (VALUES 1) t2(y) ON t.x = t2.y)\" + \"GROUP BY x\", \"VALUES 1\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This correct in terms of isolation of objects. is this call needed'\nThe code is: 'public void add(final SampleResult sample) { synchronized (buffer) { buffer.add(sample); dataChanged = true; <START> CorrelationRecorder.setBuffer(buffer); <END> \/\/ This correct in terms of isolation of objects. is this call needed } }'","output":"public void add(final SampleResult sample) { synchronized (buffer) { buffer.add(sample); dataChanged = true; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return Optional<String> implementation decide do if is present'\nThe code is: '<START> public String getClientInfo() <END> \/\/ return Optional<String> implementation decide do if is present { return clientInfo.orElse(null); }'","output":"public Optional<String> getClientInfo() { return clientInfo; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'NoCloneClones sounds a weird. name InputNoClone'\nThe code is: 'public void testHasClone() throws Exception { final DefaultConfiguration checkConfig = createCheckConfig(NoCloneCheck.class); final String[] expected = { \"10: \" + getCheckMessage(MSG_KEY), \"27: \" + getCheckMessage(MSG_KEY), \"35: \" + getCheckMessage(MSG_KEY), \"39: \" + getCheckMessage(MSG_KEY), \"52: \" + getCheckMessage(MSG_KEY), \"60: \" + getCheckMessage(MSG_KEY), \"98: \" + getCheckMessage(MSG_KEY), }; <START> verify(checkConfig, getPath(\"InputNoCloneClones.java\"), expected); <END> \/\/ NoCloneClones sounds a weird. name InputNoClone }'","output":"public void testHasClone() throws Exception { final DefaultConfiguration checkConfig = createCheckConfig(NoCloneCheck.class); final String[] expected = { \"10: \" + getCheckMessage(MSG_KEY), \"27: \" + getCheckMessage(MSG_KEY), \"35: \" + getCheckMessage(MSG_KEY), \"39: \" + getCheckMessage(MSG_KEY), \"52: \" + getCheckMessage(MSG_KEY), \"60: \" + getCheckMessage(MSG_KEY), \"98: \" + getCheckMessage(MSG_KEY), }; verify(checkConfig, getPath(\"InputNoClone.java\"), expected); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo'\nThe code is: 'public void clearForce(MonitoringBaseElement element) throws DeploymentException { String request = <START> MessageFormat.format(FORECE_VALUE, <END> \/\/ typo this.id++, \"*\", element.getQualifiedString(), \"false\"); try { sendREQ(element.getResourceString(), request); } catch (IOException e) { throw new DeploymentException(MessageFormat.format(Messages.DeploymentExecutor_ClearForceFailed, element.getQualifiedString()), e); } }'","output":"public void clearForce(MonitoringBaseElement element) throws DeploymentException { String request = MessageFormat.format(FORCE_VALUE, this.id++, \"*\", element.getQualifiedString(), \"false\"); try { sendREQ(element.getResourceString(), request); } catch (IOException e) { throw new DeploymentException(MessageFormat.format(Messages.DeploymentExecutor_ClearForceFailed, element.getQualifiedString()), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this constructor protected'\nThe code is: '<START> public GraphService(Class<T> type) <END> \/\/ this constructor protected { this.type = type; }'","output":"protected GraphService(Class<T> type) { this.type = type; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change interface list'\nThe code is: 'protected String[] fillTypeCombo() { <START> ArrayList<String> <END> \/\/ change interface list list = new ArrayList<>(); for(DataType dataType : DataTypeLibrary.getInstance().getDataTypesSorted()){ list.add(dataType.getName()); } return list.toArray(new String[0]); }'","output":"protected String[] fillTypeCombo() { List<String> list = new ArrayList<>(); for(DataType dataType : DataTypeLibrary.getInstance().getDataTypesSorted()){ list.add(dataType.getName()); } return list.toArray(new String[0]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do cast HostProviderProxy'\nThe code is: 'protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); <END> \/\/ do cast HostProviderProxy getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }'","output":"protected void executeQueryCommand() { Provider hostProvider = getProvider(); HostProviderProxy proxy = ProviderProxyFactory.getInstance().create(hostProvider); getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Another case returning conditional'\nThe code is: 'public static boolean isTravelRequestURI(String URI) { <START> if (StringUtils.isNotBlank(URI) && URI.contains(ConcurConstants.TRAVEL_REQUEST_URI_INDICATOR)) { <END> \/\/ Another case returning conditional return true; } return false; }'","output":"public static boolean isTravelRequestURI(String URI) { return StringUtils.isNotBlank(URI) && URI.contains(ConcurConstants.TRAVEL_REQUEST_URI_INDICATOR); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Instead of creating a new Optional return removed: instancePlan'\nThe code is: 'public Optional<PackingPlan.InstancePlan> removeAnyInstanceOfComponent(String component) { Optional<PackingPlan.InstancePlan> instancePlan = getAnyInstanceOfComponent(component); if (instancePlan.isPresent()) { PackingPlan.InstancePlan plan = instancePlan.get(); this.instances.remove(plan); <START> return Optional.of(plan); <END> \/\/ Instead of creating a new Optional return removed: instancePlan } return Optional.absent(); }'","output":"public Optional<PackingPlan.InstancePlan> removeAnyInstanceOfComponent(String component) { Optional<PackingPlan.InstancePlan> instancePlan = getAnyInstanceOfComponent(component); if (instancePlan.isPresent()) { PackingPlan.InstancePlan plan = instancePlan.get(); this.instances.remove(plan); return instancePlan; } return Optional.absent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'line'\nThe code is: 'public UsersWorkspaceDto startById(@PathParam(\"id\") String workspaceId, @QueryParam(\"environment\") String envName, @QueryParam(\"accountId\") String accountId) throws ServerException, BadRequestException, NotFoundException, ForbiddenException { ensureUserIsWorkspaceOwner(workspaceId); final Map<String, String> params = ImmutableMap.of(\"accountId\", accountId, \"workspaceId\", workspaceId); <START> permissionManager.checkPermission(START_WORKSPACE, getCurrentUserId(), params); <END> \/\/ line return injectLinks(DtoConverter.asDto(workspaceManager.startWorkspaceById(workspaceId, envName, accountId))); }'","output":"public UsersWorkspaceDto startById(@PathParam(\"id\") String workspaceId, @QueryParam(\"environment\") String envName, @QueryParam(\"accountId\") String accountId) throws ServerException, BadRequestException, NotFoundException, ForbiddenException { ensureUserIsWorkspaceOwner(workspaceId); permissionManager.checkPermission(START_WORKSPACE, getCurrentUserId(), ImmutableMap.of(\"accountId\", accountId, \"workspaceId\", workspaceId)); return injectLinks(DtoConverter.asDto(workspaceManager.startWorkspaceById(workspaceId, envName, accountId))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need do this time, a field in constructor'\nThe code is: 'public String getId() { <START> return this.difficultyResourceKey.replace(\"options.difficulty.\", \"\"); <END> \/\/ need do this time, a field in constructor }'","output":"public String getId() { return this.id; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import sorts of'\nThe code is: 'public FixedDoubleHistogram(int bucketCount, double min, double max) { this.bucketCount = bucketCount; this.min = min; this.max = max; <START> FixedHistogramUtils.verifyParams(bucketCount, min, max); <END> \/\/ static import sorts of this.weights = new double[bucketCount]; }'","output":"public FixedDoubleHistogram(int bucketCount, double min, double max) { this.bucketCount = bucketCount; this.min = min; this.max = max; verifyParameters(bucketCount, min, max); this.weights = new double[bucketCount]; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'necessary'\nThe code is: 'public ModelBuilderTest() { dictionary = new EntityDictionary(Collections.EMPTY_MAP); <START> dictionary.bindEntity(getType(Book.class)); <END> \/\/ necessary dictionary.bindEntity(getType(Author.class)); dictionary.bindEntity(getType(Publisher.class)); }'","output":"public ModelBuilderTest() { dictionary = new EntityDictionary(Collections.EMPTY_MAP); dictionary.bindEntity(Book.class); dictionary.bindEntity(Author.class); dictionary.bindEntity(Publisher.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw new UnsupportedOperationException(); in UnsureResponse called'\nThe code is: 'public Object getResponseValue() { <START> return null; END> }'","output":"public Object getResponseValue() { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this passing parameters 'timeout' 'timeUnit''\nThe code is: 'public static void until(Callable<Boolean> condition, long timeout, TimeUnit timeUnit) { <START> until(condition, 10, TimeUnit.SECONDS, 50); <END> \/\/ this passing parameters 'timeout' 'timeUnit' }'","output":"public static void until(Callable<Boolean> condition, long timeout, TimeUnit timeUnit) { until(condition, timeout, timeUnit, 50); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Flip arguments here, for JUnit (unlike TestNG) argument expected value, actual one'\nThe code is: 'public void testHeaderlessSamFormat() throws PathNotFoundException { final SAMFormat result = getSamFormat(new Configuration(), \"test_headerless.sam\"); <START> assertEquals(result, SAMFormat.SAM); <END> \/\/ Flip arguments here, for JUnit (unlike TestNG) argument expected value, actual one }'","output":"public void testHeaderlessSamFormat() throws PathNotFoundException { final SAMFormat result = getSamFormat(new Configuration(), \"test_headerless.sam\"); assertEquals(SAMFormat.SAM, result); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename 'viewPart''\nThe code is: 'private boolean containsPart(IViewPart[] viewStack, IWorkbenchPart part) { if (viewStack == null) { return false; } for (IViewPart <START> element : <END> \/\/ rename 'viewPart' viewStack) { if (element == part) { return true; } } return false; }'","output":"private boolean containsPart(IViewPart[] viewStack, IWorkbenchPart part) { if (viewStack == null) { return false; } for (IViewPart viewPart : viewStack) { if (viewPart == part) { return true; } } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'synchronized removed'\nThe code is: 'public boolean addIncomingChatMarkerMessageListener(ChatMarkersListener listener) { <START> synchronized (incomingListeners) { <END> \/\/ synchronized removed return incomingListeners.add(listener); } }'","output":"public boolean addIncomingChatMarkerMessageListener(ChatMarkersListener listener) { return incomingListeners.add(listener); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'spell out ret'\nThe code is: 'public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> \/\/ spell out ret ret.put(node, null); return ret; }'","output":"public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { Map<TableScanNode, Void> result = new IdentityHashMap<>(); result.put(node, null); return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove'\nThe code is: 'public void init(Composite parent, String viewerName, ITmfTrace trace) { super.init(parent, viewerName); fCountInstance++; fInstanceNb = fCountInstance; fTrace = trace; <START> fModel = new TmfStatisticsModel(); <END> \/\/ remove fProcessAll = (trace instanceof TmfExperiment); initContent(parent); initInput(); }'","output":"public void init(Composite parent, String viewerName, ITmfTrace trace) { super.init(parent, viewerName); fCountInstance++; fInstanceNb = fCountInstance; fTrace = trace; fProcessAll = (trace instanceof TmfExperiment); initContent(parent); initInput(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is effectively final class, throw new UnsupportedOperationException()'\nThe code is: 'public Void getResult() { <START> throw new UnsupportedOperationException(getClass().getName()); <END> \/\/ This is effectively final class, throw new UnsupportedOperationException() }'","output":"public Void getResult() { throw new UnsupportedOperationException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do set property outer class field? Please refer isVoidContext object: java isVoidContext = voidReturn;'\nThe code is: 'public void visitLiteralReturn(int maxAssigned, Boolean voidReturn) { <START> context.isVoidContext = voidReturn; <END> \/\/ do set property outer class field? Please refer isVoidContext object: java isVoidContext = voidReturn; if (maxAllowed == null) { maxAllowed = maxAssigned; } ++count; }'","output":"public void visitLiteralReturn(int maxAssigned, Boolean voidReturn) { isVoidContext = voidReturn; if (maxAllowed == null) { maxAllowed = maxAssigned; } ++count; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getClusterId()'\nThe code is: '<START> public String getClusterName() { <END> \/\/ getClusterId() return clusterId; }'","output":"public String getClusterName() { return clusterName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is normal a \/'\nThe code is: 'public String getProtoFileName() { <START> return \"\/library.proto\"; <END> \/\/ is normal a \/ }'","output":"public String getProtoFileName() { return \"library.proto\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line moved @Before method too'\nThe code is: 'public void createFeaturesTest() throws IOException { String[] tokens = new String[] {\"he\", \"went\", \"with\", \"you\"}; <START> AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster); <END> \/\/ This line moved @Before method too List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(\"pbrowncluster,browncluster=0101,0010\")); Assert.assertTrue(features.contains(\"pbrowncluster,browncluster=01010,00101\")); }'","output":"public void createFeaturesTest() throws IOException { String[] tokens = new String[] {\"he\", \"went\", \"with\", \"you\"}; List<String> features = new ArrayList<>(); generator.createFeatures(features, tokens, 3, null); Assert.assertEquals(2, features.size()); Assert.assertTrue(features.contains(\"pbrowncluster,browncluster=0101,0010\")); Assert.assertTrue(features.contains(\"pbrowncluster,browncluster=01010,00101\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This create 4 connections 3. init index 1 '<''\nThe code is: 'private List<StorageServerConnections> getConnections() { List<StorageServerConnections> connectionsList = new ArrayList<>(); for (int i = 0; i <START> <= NUMBER_OF_EXISTING_CONNECTIONS; <END> \/\/ This create 4 connections 3. init index 1 '<' i++) { StorageServerConnections conn = new StorageServerConnections(); conn.setId(Guid.newGuid().toString()); connectionsList.add(conn); } return connectionsList; }'","output":"private List<StorageServerConnections> getConnections() { List<StorageServerConnections> connectionsList = new ArrayList<>(); for (int i = 0; i < NUMBER_OF_EXISTING_CONNECTIONS; i++) { StorageServerConnections conn = new StorageServerConnections(); conn.setId(Guid.newGuid().toString()); connectionsList.add(conn); } return connectionsList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remoteTimeout() is correct one'\nThe code is: 'public void init(StateTransferLock stateTransferLock, Configuration configuration, StateTransferManager stateTransferManager, GroupManager groupManager) { this.stateTransferLock = stateTransferLock; this.stateTransferManager = stateTransferManager; this.groupManager = groupManager; <START> transactionDataTimeout = configuration.clustering().sync().replTimeout(); <END> \/\/ remoteTimeout() is correct one }'","output":"public void init(StateTransferLock stateTransferLock, Configuration configuration, StateTransferManager stateTransferManager, GroupManager groupManager) { this.stateTransferLock = stateTransferLock; this.stateTransferManager = stateTransferManager; this.groupManager = groupManager; transactionDataTimeout = configuration.clustering().remoteTimeout(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'public double withReadLock() { return rwLock.withReadLock(() -> { <START> return Math.random(); <END> \/\/ static import }); }'","output":"public double withReadLock() { return rwLock.withReadLock(() -> { return random(); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java public Seq<E> getErrors()'\nThe code is: '<START> public Seq<? extends E> getErrors() { <END> \/\/ java public Seq<E> getErrors() return errors; }'","output":"public Seq<E> getErrors() { return errors; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need this? Is necessary in test'\nThe code is: 'public void logoClickOnEnglishCommunityOpensFandom() { new HomePage().getGlobalNavigation().clickFandomLogo(); System.out.println(driver.getCurrentUrl()); <START> System.out.println(fandomUrlBuilder.getFandomUrl(new Configuration().getEnvType())); <END> \/\/ do need this? Is necessary in test Assertion.assertEquals( urlChecker.getProtocolRelativeURL(driver.getCurrentUrl()), urlChecker.getProtocolRelativeURL(fandomUrlBuilder.getFandomUrl(new Configuration().getEnvType())) ); }'","output":"public void logoClickOnEnglishCommunityOpensFandom() { new HomePage().getGlobalNavigation().clickFandomLogo(); Assertion.assertEquals( urlChecker.getProtocolRelativeURL(driver.getCurrentUrl()), urlChecker.getProtocolRelativeURL(fandomUrlBuilder.getFandomUrl(new Configuration().getEnvType())) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());'\nThe code is: 'public List<MLModelField> getModelInputFields(MLModelInfo modelInfo) throws IOException, SAXException, JAXBException { <START> final List<MLModelField> fieldNames = doGetInputFieldsFromPMMLStream(modelInfo.getPmml()); <END> \/\/ inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml()); return fieldNames; }'","output":"public List<MLModelField> getModelInputFields(MLModelInfo modelInfo) throws IOException, SAXException, JAXBException { return doGetInputFieldsFromPMMLStream(modelInfo.getPmml()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please add access modifier, private probably'\nThe code is: '<START> String getCreatedTime(final AssetInfo asset) { <END> \/\/ Please add access modifier, private probably return ts.format(LibraryConstants.Created) + \" \" + SocialDateFormatter.format(asset.getCreatedTime()); }'","output":"private String getCreatedTime(final AssetInfo asset) { return ts.format(LibraryConstants.Created) + \" \" + SocialDateFormatter.format(asset.getCreatedTime()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (keyedStateBackend instanceof CheckpointListener) { Ditto'\nThe code is: 'public void notifyCheckpointAborted(long checkpointId) throws Exception { <START> if (keyedStateBackend != null && keyedStateBackend instanceof CheckpointListener) { <END> \/\/ suggestion if (keyedStateBackend instanceof CheckpointListener) { Ditto ((CheckpointListener) keyedStateBackend).notifyCheckpointAborted(checkpointId); } }'","output":"public void notifyCheckpointAborted(long checkpointId) throws Exception { if (keyedStateBackend instanceof CheckpointListener) { ((CheckpointListener) keyedStateBackend).notifyCheckpointAborted(checkpointId); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a constant instead of 100'\nThe code is: 'public void setSlaveConnectTimeoutStr(String slaveConnectTimeoutStr) { if (StringUtils.isBlank(slaveConnectTimeoutStr)) { <START> setSlaveConnectTimeout(100); END> } else { setSlaveConnectTimeout(Integer.parseInt(slaveConnectTimeoutStr)); } }'","output":"public void setSlaveConnectTimeoutStr(String slaveConnectTimeoutStr) { if (StringUtils.isBlank(slaveConnectTimeoutStr)) { setSlaveConnectTimeout(DEFAULT_SLAVE_JENKINS_CONNECTION_TIMEOUT); } else { setSlaveConnectTimeout(Integer.parseInt(slaveConnectTimeoutStr)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collections.<String> emptySet()'\nThe code is: 'public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException { <START> parseOptionMap(parameters, new ArrayList<String>()); <END> \/\/ Collections.<String> emptySet() }'","output":"public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException { parseOptionMap(parameters, Collections.<String>emptySet()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throws part is there. This part exist'\nThe code is: '<START> public ANetApiResponse TestGetAccountUpdaterJobDetails() throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException <END> \/\/ throws part is there. This part exist { return GetAccountUpdaterJobDetails.run(apiLoginId, transactionKey); }'","output":"public ANetApiResponse TestGetAccountUpdaterJobDetails() { return GetAccountUpdaterJobDetails.run(apiLoginId, transactionKey); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is a duplicated check, this is invoked command.hasFlows() is true, required invoke again. If absolutely want this check, opt for java if (hasFlows != null) { ... } is easier read'\nThe code is: 'private void addCriteriaForFlows(final OnmsCriteria criteria, final Boolean hasFlows) { <START> if (hasFlows == null) { <END> \/\/ This is a duplicated check, this is invoked command.hasFlows() is true, required invoke again. If absolutely want this check, opt for java if (hasFlows != null) { ... } is easier read return; } criteria.add(Restrictions.eq(\"node.hasFlows\", hasFlows)); }'","output":"private void addCriteriaForFlows(final OnmsCriteria criteria, final Boolean hasFlows) { criteria.add(Restrictions.eq(\"node.hasFlows\", hasFlows)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Needs \"getLocalizedMessage()\"'\nThe code is: 'private List<UrlInfo> getTargetEndpoints(NhinTargetCommunitiesType targetCommunities) { List<UrlInfo> urlInfoList = null; try { urlInfoList = connectionManager.getEndpointURLFromNhinTargetCommunities(targetCommunities, NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME); } catch (ConnectionManagerException ex) { LOG.error(\"Failed to obtain target URLs for service \" <START> + NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME + ex.getMessage(), ex); <END> \/\/ Needs \"getLocalizedMessage()\" return null; } return urlInfoList; }'","output":"private List<UrlInfo> getTargetEndpoints(NhinTargetCommunitiesType targetCommunities) { List<UrlInfo> urlInfoList = null; try { urlInfoList = connectionManager.getEndpointURLFromNhinTargetCommunities(targetCommunities, NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME); } catch (ConnectionManagerException ex) { LOG.error(\"Failed to obtain target URLs for service \" + NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME + ex.getLocalizedMessage(), ex); return null; } return urlInfoList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'cast is longer needed'\nThe code is: 'public RuleAssert overrideStats(String nodeId, PlanNodeStatsEstimate nodeStats) { <START> ((TestingStatsCalculator) statsCalculator).setNodeStats(new PlanNodeId(nodeId), nodeStats); <END> \/\/ cast is longer needed return this; }'","output":"public RuleAssert overrideStats(String nodeId, PlanNodeStatsEstimate nodeStats) { statsCalculator.setNodeStats(new PlanNodeId(nodeId), nodeStats); return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'print stack trace if rethrow a'\nThe code is: 'public Object register(Object obj, Runnable action) { try { return createMtd.invoke(null, obj, action); } catch (IllegalAccessException | InvocationTargetException e) { <START> e.printStackTrace(); <END> \/\/ print stack trace if rethrow a throw new RuntimeException(\"Reflection failure: invoke sun.misc.Cleaner.create method failed\", e); } }'","output":"public Object register(Object obj, Runnable action) { try { return createMtd.invoke(null, obj, action); } catch (IllegalAccessException | InvocationTargetException e) { throw new RuntimeException(\"Reflection failure: invoke sun.misc.Cleaner.create method failed\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'In this case, defining default behavior for user in case of passing null. if a user wants true false, forcing of these. rule applies of changes below'\nThe code is: 'private void createBooleanAccessor() { accessors.put(Boolean.class, new Accessor<Boolean>() { @Override public Boolean get(String key, Boolean defaultValue) { <START> return preferences.getBoolean(key, (defaultValue == null) ? false : defaultValue); <END> \/\/ In this case, defining default behavior for user in case of passing null. if a user wants true false, forcing of these. rule applies of changes below } @Override public void put(String key, Boolean value) { editor.putBoolean(key, value).apply(); } }); }'","output":"private void createBooleanAccessor() { accessors.put(Boolean.class, new Accessor<Boolean>() { @Override public Boolean get(String key) { return preferences.getBoolean(key, false); } @Override public void put(String key, Boolean value) { editor.putBoolean(key, value).apply(); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'byte[] [](start = 11, length = 6) updating methods return a data structure a simple type for forwards compat. This return DecryptResult property plaintext'\nThe code is: '<START> public byte[] decrypt(EncryptionAlgorithm algorithm, byte[] cipherText, byte[] iv, byte[] authenticationData, byte[] authenticationTag) { <END> \/\/ byte[] [](start = 11, length = 6) updating methods return a data structure a simple type for forwards compat. This return DecryptResult property plaintext return withContext(context -> client.decrypt(algorithm, cipherText, iv, authenticationData, authenticationTag, context)).block(); }'","output":"public DecryptResult decrypt(EncryptionAlgorithm algorithm, byte[] cipherText, byte[] iv, byte[] authenticationData, byte[] authenticationTag) { return decrypt(algorithm, cipherText, iv, authenticationData, authenticationTag, Context.NONE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'worth adding pattern Util? public static <T> List<T> Util.unmodifiableList(T[] elems)'\nThe code is: 'public List<SqlNode> getOperandList() { <START> return Collections.unmodifiableList(Arrays.asList(operands)); <END> \/\/ worth adding pattern Util? public static <T> List<T> Util.unmodifiableList(T[] elems) }'","output":"public List<SqlNode> getOperandList() { return Util.unmodifiableList(operands); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I cleaner do Boolean.toString(Boolean.parseBoolean(distribute)). way, string \"true\" in code'\nThe code is: 'public String getDistribute() { <START> return String.valueOf(\"true\".equals(distribute)); <END> \/\/ I cleaner do Boolean.toString(Boolean.parseBoolean(distribute)). way, string \"true\" in code }'","output":"public String getDistribute() { return Boolean.toString(Boolean.parseBoolean(distribute)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inline this variable'\nThe code is: 'public boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); boolean handles = data instanceof Match && data.eContainer() instanceof Comparison; return <START> handles; <END> \/\/ inline this variable }'","output":"public boolean handle(TreeNode treeNode) { EObject data = treeNode.getData(); return data instanceof Match && data.eContainer() instanceof Comparison; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ShellIsAvailable'\nThe code is: 'public void ok() { new OkButton().click(); <START> new WaitWhile(new ShellIsActive(\"Open CDI Named Bean\")); <END> \/\/ ShellIsAvailable }'","output":"public void ok() { new OkButton().click(); new WaitWhile(new ShellIsAvailable(\"Open CDI Named Bean\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringBuilder'\nThe code is: 'public String toString() { <START> return \"DataInfoImpl{\" + <END> \/\/ StringBuilder \"dataType='\" + dataType + '\\'' + \", numUnits=\" + numUnits + '}'; }'","output":"public String toString() { final StringBuilder sb = new StringBuilder(\"DataInfoImpl{\"); sb.append(\"dataType='\").append(dataType).append('\\''); sb.append(\", numUnits=\").append(numUnits); sb.append('}'); return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do a newline annotations (in 99.9% of cases). please leave as-is. I reformat codebase soon formatter. I opportunity customize Sputnik\/Checkstyle rules then'\nThe code is: '<START> @Override default Stream<T> shuffle() { <END> \/\/ do a newline annotations (in 99.9% of cases). please leave as-is. I reformat codebase soon formatter. I opportunity customize Sputnik\/Checkstyle rules then return Collections.shuffle(this, Stream::ofAll); }'","output":"default Stream<T> shuffle() { return Collections.shuffle(this, Stream::ofAll); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename 'child''\nThe code is: 'public void setEnabled(boolean enabled, Composite parent) { super.setEnabled(enabled, parent); group.setEnabled(enabled); for (Control <START> element : <END> \/\/ rename 'child' group.getChildren()) { element.setEnabled(enabled); } }'","output":"public void setEnabled(boolean enabled, Composite parent) { super.setEnabled(enabled, parent); group.setEnabled(enabled); for (Control child : group.getChildren()) { child.setEnabled(enabled); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this \"final\"'\nThe code is: '<START> public long getFilterBlobLimit() { <END> \/\/ I this \"final\" return filterSpec.getBlobLimit(); }'","output":"public final long getFilterBlobLimit() { return filterSpec.getBlobLimit(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new Guid(String) - this literal null'\nThe code is: 'public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, <START> Guid.createGuidFromString(\"6d849ebf-755f-4552-ad09-9a090cda105d\")); <END> \/\/ new Guid(String) - this literal null assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }'","output":"public void testGetPermittedStorageDomains() { List<StorageDomain> result = dao.getPermittedStorageDomainsByStoragePool(EXISTING_USER_ID, ActionGroup.CONFIGURE_VM_STORAGE, new Guid(\"6d849ebf-755f-4552-ad09-9a090cda105d\")); assertNotNull(result); assertFalse(result.isEmpty()); assertEquals(result.get(0).getId(), existingDomain.getId()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'shorter inline this variable in scope. :-)'\nThe code is: 'private void initPlugins() throws Exception { <START> Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps(); <END> \/\/ shorter inline this variable in scope. :-) for (InitStep initStep : pluginsInitSteps) { initStep.run(); } }'","output":"private void initPlugins() throws Exception { for (InitStep initStep : pluginLoader.getInitSteps()) { initStep.run(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'clearer if rawBytes.length - (endOfTableName + 1)? fussed'\nThe code is: 'public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); <START> ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - 1 - endOfTableName); <END> \/\/ clearer if rawBytes.length - (endOfTableName + 1)? fussed return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }'","output":"public static Optional<TableRefAndRemainder> tryParseTableRef(LockDescriptor lockDescriptor) { byte[] rawBytes = lockDescriptor.getBytes(); int endOfTableName = Bytes.indexOf(rawBytes, (byte) 0); if (endOfTableName == -1) { return Optional.empty(); } String fullyQualifiedName = new String(rawBytes, 0, endOfTableName); TableReference tableRef = TableReference.createFromFullyQualifiedName(fullyQualifiedName); ByteString remainingBytes = ByteString.of(rawBytes, endOfTableName + 1, rawBytes.length - (endOfTableName + 1)); return Optional.of(ImmutableTableRefAndRemainder.of(tableRef, remainingBytes)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This bloc of code is repeated times, centralized in a single method'\nThe code is: 'public GWCConfig getConfig() { <START> if (gsEnvironment != null && gsEnvironment.isStale()) { <END> \/\/ This bloc of code is repeated times, centralized in a single method syncEnvironment(); } return gwcConfigPersister.getConfig(); }'","output":"public GWCConfig getConfig() { return gwcConfigPersister.getConfig(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Floating semicolon'\nThe code is: 'private void buildTestedInstance() { <START> ; <END> \/\/ Floating semicolon this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }'","output":"private void buildTestedInstance() { this.tested = new ClientFullSessionImpl(factory, canvasCommandManager, sessionCommandManager, requestCommandManager, registryFactory); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a java.lang.Boolean a primitive boolean'\nThe code is: 'protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); <START> Boolean dbShouldBeUpdated <END> \/\/ a java.lang.Boolean a primitive boolean = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }'","output":"protected void executeCommand() { final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue(); final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage()); Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb); boolean dbShouldBeUpdated = lunsToUpdateInDb.containsKey(updateExistingLuns) || lunsToUpdateInDb.containsKey(saveNewLuns); if (dbShouldBeUpdated) { TransactionSupport.executeInNewTransaction(() -> { updateLunsInDb(lunsToUpdateInDb); refreshLunsConnections(lunsFromVgInfo); cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb); return null; }); } setSucceeded(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wants start startPhase if generic'\nThe code is: 'private TracingContext traceToMap(Map<String, Object> map) { <START> long startParse = System.nanoTime(); <END> \/\/ wants start startPhase if generic return () -> { long now = System.nanoTime(); long duration = now - startParse; long startOffset = now - startRequestNanos; map.put(\"startOffset\", startOffset); map.put(\"duration\", duration); }; }'","output":"private TracingContext traceToMap(Map<String, Object> map) { long start = System.nanoTime(); return () -> { long now = System.nanoTime(); long duration = now - start; long startOffset = now - startRequestNanos; map.put(\"startOffset\", startOffset); map.put(\"duration\", duration); }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need super'\nThe code is: 'public Trader(String name, double cashInHand) { <START> super(); <END> \/\/ need super this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }'","output":"public Trader(String name, double cashInHand) { this.name = name; this.cashInHand = cashInHand; this.stocksOwned = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Replace Objects.requireNotNull'\nThe code is: 'public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { <START> throw new IllegalArgumentException(\"eventData cannot be null.\"); <END> \/\/ Replace Objects.requireNotNull } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, \"Size of the payload exceeded Maximum message size: %s kb\", this.maxMessageSize \/ 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }'","output":"public boolean tryAdd(final EventData eventData) throws PayloadSizeExceededException { if (eventData == null) { throw new IllegalArgumentException(\"eventData cannot be null\"); } final EventDataImpl eventDataImpl = (EventDataImpl) eventData; final int size; try { size = getSize(eventDataImpl, events.isEmpty()); } catch (java.nio.BufferOverflowException exception) { throw new PayloadSizeExceededException(String.format(Locale.US, \"Size of the payload exceeded Maximum message size: %s kb\", this.maxMessageSize \/ 1024)); } if (this.currentSize + size > this.maxMessageSize) { return false; } this.events.add(eventDataImpl); this.currentSize += size; return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Unrelated change. in a separate commit'\nThe code is: 'public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(\"message must be non-empty\"); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { <START> throw new ResourceNotFoundException(); <END> \/\/ Unrelated change. in a separate commit } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }'","output":"public ChangeInfo apply(RevisionResource rsrc, Input input) throws BadRequestException, ResourceConflictException, EmailException, OrmException, ResourceNotFoundException, IOException { if (Strings.isNullOrEmpty(input.message)) { throw new BadRequestException(\"message must be non-empty\"); } final Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(e.getMessage()); } try { return json.format(ChangeUtil.editCommitMessage( rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), (IdentifiedUser) rsrc.getControl().getCurrentUser(), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (InvalidChangeOperationException e) { throw new BadRequestException(e.getMessage()); } catch (MissingObjectException e) { throw new ResourceConflictException(e.getMessage()); } catch (IncorrectObjectTypeException e) { throw new ResourceConflictException(e.getMessage()); } catch (PatchSetInfoNotAvailableException e) { throw new ResourceConflictException(e.getMessage()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(); } finally { git.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'TREEHASH a HashCode'\nThe code is: 'public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), <START> buildPayload(4 * MiB))).isEqualTo(HashCode.fromString(TREEHASH)); <END> \/\/ TREEHASH a HashCode RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), \"PUT \/-\/vaults\/\" + VAULT_NAME + \"\/multipart-uploads\/\" + MULTIPART_UPLOAD_ID + \" \" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), \"bytes 0-4194303\/*\"); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), \"4194304\"); }'","output":"public void testUploadPart() throws InterruptedException { MockResponse mr = buildBaseResponse(204); mr.addHeader(GlacierHeaders.TREE_HASH, TREEHASH); server.enqueue(mr); assertThat(client.uploadPart(VAULT_NAME, MULTIPART_UPLOAD_ID, ContentRange.fromPartNumber(0, 4), buildPayload(4 * MiB))).isEqualTo(TREEHASH); RecordedRequest request = server.takeRequest(); assertEquals(request.getRequestLine(), \"PUT \/-\/vaults\/\" + VAULT_NAME + \"\/multipart-uploads\/\" + MULTIPART_UPLOAD_ID + \" \" + HTTP); assertEquals(request.getHeader(HttpHeaders.CONTENT_RANGE), \"bytes 0-4194303\/*\"); assertEquals(request.getHeader(HttpHeaders.CONTENT_LENGTH), \"4194304\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@jomarko Thanks.. this Integer.class.getName()'\nThe code is: 'private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( \"org.Address\", new ModelField[]{ new ModelField( \"this\", \"org.Address\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, \"this\" ), new ModelField( \"street\", \"String\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( \"homeAddress\", \"Boolean\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( \"number\", <START> \"java.lang.Integer\", <END> \/\/ @jomarko Thanks.. this Integer.class.getName() ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }'","output":"private PackageDataModelOracleIncrementalPayload createAddressPayload() { PackageDataModelOracleIncrementalPayload payload = new PackageDataModelOracleIncrementalPayload(); HashMap<String, ModelField[]> addressModelFields = new HashMap<String, ModelField[]>(); addressModelFields.put( \"org.Address\", new ModelField[]{ new ModelField( \"this\", \"org.Address\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.SELF, FieldAccessorsAndMutators.ACCESSOR, \"this\" ), new ModelField( \"street\", \"String\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_STRING ), new ModelField( \"homeAddress\", \"Boolean\", ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_BOOLEAN ), new ModelField( \"number\", Integer.class.getName(), ModelField.FIELD_CLASS_TYPE.REGULAR_CLASS, ModelField.FIELD_ORIGIN.DECLARED, FieldAccessorsAndMutators.BOTH, DataType.TYPE_NUMERIC_INTEGER )} ); payload.setModelFields( addressModelFields ); return payload; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a field'\nThe code is: 'public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject <START> fDiffProject : <END> \/\/ a field fDiffProjects) { IProject tempProject = Utilities.getProject(fDiffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }'","output":"public ISchedulingRule[] getTargetProjects() { List<ISchedulingRule> projects= new ArrayList<>(); IResourceRuleFactory ruleFactory= ResourcesPlugin.getWorkspace().getRuleFactory(); for (DiffProject diffProject : fDiffProjects) { IProject tempProject = Utilities.getProject(diffProject); ISchedulingRule scheduleRule= ruleFactory.modifyRule(tempProject.getFile(IProjectDescription.DESCRIPTION_FILE_NAME)); MultiRule multiRule= new MultiRule(new ISchedulingRule[] { scheduleRule, tempProject } ); projects.add(multiRule); } return projects.toArray(new ISchedulingRule[projects.size()]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I suggest providing more clue exception throw new IllegalArgumentException( \"startTimeNanos [\" + startTimeNanos + \"] greater 0!\" ); debugger a bit'\nThe code is: 'public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { <START> throw new IllegalArgumentException( \"startTimeNanos should be greater than 0!\" ); <END> \/\/ I suggest providing more clue exception throw new IllegalArgumentException( \"startTimeNanos [\" + startTimeNanos + \"] greater 0!\" ); debugger a bit } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = \"SlowQuery: \" + queryExecutionMillis + \" milliseconds. SQL: '\" + sql + \"'\"; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }'","output":"public void logSlowQuery(String sql, long startTimeNanos) { if ( logSlowQuery < 1 ) { return; } if ( startTimeNanos <= 0 ) { throw new IllegalArgumentException( \"startTimeNanos [\" + startTimeNanos + \"] should be greater than 0!\" ); } long queryExecutionMillis = TimeUnit.NANOSECONDS.toMillis( System.nanoTime() - startTimeNanos ); if ( queryExecutionMillis > logSlowQuery ) { String logData = \"SlowQuery: \" + queryExecutionMillis + \" milliseconds. SQL: '\" + sql + \"'\"; LOG_SLOW.info( logData ); if ( logToStdout ) { System.out.println( logData ); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo'\nThe code is: 'public DataSource call() throws Exception { try { Class.forName(CONNECTION_POOL_DRIVER); } catch (Exception ex) { <START> throw new OseeDataStoreException(ex, \"Error loading connectino pool driver [%s]\", CONNECTION_POOL_DRIVER); <END> \/\/ typo } ConnectionFactory connectionFactory = createConnectionFactory(dbInfo); ObjectPool<Connection> connectionPool = new GenericObjectPool<Connection>(); @SuppressWarnings({\"rawtypes\", \"unchecked\"}) KeyedObjectPoolFactory statementPool = new GenericKeyedObjectPoolFactory(null); new PoolableConnectionFactory(connectionFactory, connectionPool, statementPool, null, false, true); DataSource dataSource = new PoolingDataSource(connectionPool); String poolId = dbInfo.getId(); PoolingDriver driver = poolingDriver.get(); driver.registerPool(poolId, connectionPool); return dataSource; }'","output":"public DataSource call() throws Exception { try { Class.forName(CONNECTION_POOL_DRIVER); } catch (Exception ex) { throw new OseeDataStoreException(ex, \"Error loading connection pool driver [%s]\", CONNECTION_POOL_DRIVER); } ConnectionFactory connectionFactory = createConnectionFactory(dbInfo); ObjectPool<Connection> connectionPool = new GenericObjectPool<Connection>(); @SuppressWarnings({\"rawtypes\", \"unchecked\"}) KeyedObjectPoolFactory statementPool = new GenericKeyedObjectPoolFactory(null); new PoolableConnectionFactory(connectionFactory, connectionPool, statementPool, null, false, true); DataSource dataSource = new PoolingDataSource(connectionPool); String poolId = dbInfo.getId(); PoolingDriver driver = poolingDriver.get(); driver.registerPool(poolId, connectionPool); return dataSource; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add a check verify serialDataReceived method called'\nThe code is: 'public void testBroadcastSerialDataReceiveSubscribedRx16() throws Exception { Mockito.when(rx16Packet.getReceiveOptions()).thenReturn(RECEIVE_OPTIONS_BROADCAST); dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx16Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_16BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).broadcastSerialDataReceived(XBEE_16BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); <START> <END> \/\/ Add a check verify serialDataReceived method called assertEquals(XBEE_16BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }'","output":"public void testBroadcastSerialDataReceiveSubscribedRx16() throws Exception { Mockito.when(rx16Packet.getReceiveOptions()).thenReturn(RECEIVE_OPTIONS_BROADCAST); dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx16Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_16BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).broadcastSerialDataReceived(XBEE_16BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); Mockito.verify(receiveSerialDataListener, Mockito.never()).serialDataReceived(Mockito.anyString(), (byte[])Mockito.any()); assertEquals(XBEE_16BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'New local variable anywhere'\nThe code is: 'public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, boolean activateViewpoint, boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); <START> ArrayList<Viewpoint> arrayList = new ArrayList<>(); arrayList.addAll(newViewpointToSelectionStateMap.keySet()); <END> \/\/ New local variable anywhere for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }'","output":"public static void handleViewpointActivation(Session session, Set<Viewpoint> viewpointsToHandle, boolean activateViewpoint, boolean askUserForDependencyActivation) { Collection<Viewpoint> selectedViewpoints = session.getSelectedViewpoints(false); final SortedMap<Viewpoint, Boolean> originalViewpointsMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); Collection<Viewpoint> availableViewpoints = ViewpointHelper.getAvailableViewpoints(session); for (final Viewpoint viewpoint : availableViewpoints) { boolean selected = false; for (Viewpoint selectedViewpoint : selectedViewpoints) { if (EqualityHelper.areEquals(selectedViewpoint, viewpoint)) { selected = true; break; } } originalViewpointsMap.put(viewpoint, Boolean.valueOf(selected)); } SortedMap<Viewpoint, Boolean> newViewpointToSelectionStateMap = Maps.newTreeMap(new ViewpointRegistry.ViewpointComparator()); newViewpointToSelectionStateMap.putAll(originalViewpointsMap); for (Viewpoint viewpoint : viewpointsToHandle) { newViewpointToSelectionStateMap.put(viewpoint, activateViewpoint); } Display.getCurrent().syncExec(() -> { ViewpointHelper.applyNewViewpointSelection(originalViewpointsMap, newViewpointToSelectionStateMap, session, true, new ViewpointSelectionCallbackWithConfimationAndDependenciesHandling(askUserForDependencyActivation)); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'object result'\nThe code is: 'public Observable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) { final RealmConfiguration realmConfig = realm.getConfiguration(); return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() { @Override public void call(final Subscriber<? super DynamicRealmObject> subscriber) { final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig); objectRefs.get().acquireReference(object); final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() { @Override <START> public void onChange(DynamicRealmObject result) { <END> \/\/ object result if (!subscriber.isUnsubscribed()) { subscriber.onNext(object); } } }; RealmObject.addChangeListener(object, listener); subscriber.add(Subscriptions.create(new Action0() { @Override public void call() { RealmObject.removeChangeListener(object, listener); observableRealm.close(); objectRefs.get().releaseReference(object); } })); subscriber.onNext(object); } }); }'","output":"public Observable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) { final RealmConfiguration realmConfig = realm.getConfiguration(); return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() { @Override public void call(final Subscriber<? super DynamicRealmObject> subscriber) { final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig); objectRefs.get().acquireReference(object); final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() { @Override public void onChange(DynamicRealmObject object) { if (!subscriber.isUnsubscribed()) { subscriber.onNext(object); } } }; RealmObject.addChangeListener(object, listener); subscriber.add(Subscriptions.create(new Action0() { @Override public void call() { RealmObject.removeChangeListener(object, listener); observableRealm.close(); objectRefs.get().releaseReference(object); } })); subscriber.onNext(object); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'needed'\nThe code is: 'void setup() { <START> Constant.getInstance(); I18N i18n = Mockito.mock(I18N.class, withSettings().lenient()); given(i18n.getString(anyString())).willReturn(\"\"); given(i18n.getString(anyString(), any())).willReturn(\"\"); given(i18n.getLocal()).willReturn(Locale.getDefault()); Constant.messages = i18n; <END> \/\/ needed extensionAuthentication = new ExtensionAuthentication(); }'","output":"void setup() { extensionAuthentication = new ExtensionAuthentication(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typo, timeElapsedMillis'\nThe code is: 'public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { <START> long timeEalpsedMillis = <END> \/\/ typo, timeElapsedMillis (new Date().getTime() - status.getCreationTime().getTime()); int estimatedCompletionMillis = (int) ((timeEalpsedMillis \/ progress) * timeEalpsedMillis + timeEalpsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }'","output":"public void fireProgress(float progress, String task) { if (progress > status.progress || StringUtils.equals(task, status.task)) { if (status.getPhase() == ProcessState.QUEUED) { status.setPhase(ProcessState.RUNNING); } status.setProgress(progress); status.setTask(task); if (progress > 0) { long timeElapsedMillis = (new Date().getTime() - status.getCreationTime().getTime()); int estimatedCompletionMillis = (int) ((timeElapsedMillis \/ progress) * timeElapsedMillis + timeElapsedMillis); Calendar calendar = Calendar.getInstance(); calendar.setTime(status.getCreationTime()); calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis); status.setEstimatedCompletion(calendar.getTime()); } ProcessEvent event = new ProcessEvent(status, inputs, outputs); for (ProcessListener listener : listeners) { listener.progress(event); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'naming'\nThe code is: 'private void syncEntity(Entity ent, Set<? extends Entity> observers, boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); <START> int view = network.getSyncDistance(); <END> \/\/ naming boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > view * view || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }'","output":"private void syncEntity(Entity ent, Set<? extends Entity> observers, boolean forceDestroy) { for (Entity observer : observers) { if (ent == observer) { continue; } if (!(observer instanceof Player)) { continue; } Player player = (Player) observer; if (!player.isOnline()) { continue; } PlayerNetworkComponent network = player.getNetwork(); int syncDistance = network.getSyncDistance(); boolean spawn, sync, destroy; spawn = sync = destroy = false; final SpoutPhysicsComponent physics = (SpoutPhysicsComponent) ent.getPhysics(); if (forceDestroy || ent.isRemoved() || physics.getTransformLive().getPosition().distanceSquared(player.getPhysics().getPosition()) > syncDistance * syncDistance || player.isInvisible(ent)) { destroy = true; } else if (network.hasSpawned(ent)) { sync = true; } else { spawn = true; } network.syncEntity(ent, physics.getTransformLive(), spawn, destroy, sync); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this public'\nThe code is: '<START> public void doHeal(EntityRef entity, int healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { <END> \/\/ this public HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } int healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }'","output":"private void doHeal(EntityRef entity, int healAmount, EntityRef instigator, HealthComponent targetHealthComponent) { HealthComponent health = targetHealthComponent; if (health == null) { health = entity.getComponent(HealthComponent.class); } int healedAmount = Math.min(health.currentHealth + healAmount, health.maxHealth) - health.currentHealth; health.currentHealth += healedAmount; entity.saveComponent(health); entity.send(new OnHealedEvent(healAmount, healedAmount, instigator)); if (health.currentHealth == health.maxHealth) { entity.send(new FullHealthEvent(instigator)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this line'\nThe code is: 'public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = \"7\"; String stageId = \"20170707_223500_67496_zguwn.2\"; String classSuffix = stageId + \"_\" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); <START> System.out.println(pageProjectionOutput.getClass().getSimpleName()); <END> \/\/ remove this line assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(\"PageProjectionOutput_\" + stageId.replace('.', '_') + \"_\" + planNodeId)); }'","output":"public void testGeneratedClassName() { PageFunctionCompiler functionCompiler = new PageFunctionCompiler(createTestMetadataManager(), 0); String planNodeId = \"7\"; String stageId = \"20170707_223500_67496_zguwn.2\"; String classSuffix = stageId + \"_\" + planNodeId; Supplier<PageProjection> projectionSupplier = functionCompiler.compileProjection(ADD_10_EXPRESSION, Optional.of(classSuffix)); PageProjection projection = projectionSupplier.get(); PageProjectionOutput pageProjectionOutput = projection.project(SESSION, new DriverYieldSignal(), createLongBlockPage(0), SelectedPositions.positionsRange(0, 1)); assertTrue(pageProjectionOutput.getClass().getSimpleName().startsWith(\"PageProjectionOutput_\" + stageId.replace('.', '_') + \"_\" + planNodeId)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is'\nThe code is: 'public void testOpenSessionEditorByDoubleClick5() { designerProject.convertToModelingProject(); Display.getDefault().syncExec(() -> { try { PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.eclipse.ui.navigator.ProjectExplorer\"); } catch (PartInitException e) { e.printStackTrace(); } }); <START> SWTBotView packageExplorerView = bot.viewById(\"org.eclipse.ui.navigator.ProjectExplorer\"); packageExplorerView.setFocus(); SWTBot packageExplorerViewBot = packageExplorerView.bot(); SWTBotTreeItem expandedNode = packageExplorerViewBot.tree().expandNode(\"DesignerTestProject\", true); SWTBotTreeItem node = expandedNode.getNode(\"My.aird\"); node.doubleClick(); bot.waitUntil(new DefaultCondition() { @Override public boolean test() throws Exception { return PlatformUI.getWorkbench().getWorkbenchWindows()[0].getActivePage().getActiveEditor() != null; } @Override public String getFailureMessage() { return \"Wrong Active editor is : \" + PlatformUI.getWorkbench().getWorkbenchWindows()[0].getActivePage().getActiveEditor().getEditorSite().getId(); } }); assertEquals(\"The session editor has not opened.\", \"org.eclipse.sirius.ui.editor.session\", PlatformUI.getWorkbench().getWorkbenchWindows()[0].getActivePage().getActiveEditor().getEditorSite().getId()); <END> \/\/ is }'","output":"public void testOpenSessionEditorByDoubleClick5() { designerProject.convertToModelingProject(); Display.getDefault().syncExec(() -> { try { PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.eclipse.ui.navigator.ProjectExplorer\"); } catch (PartInitException e) { e.printStackTrace(); } }); SWTBotView packageExplorerView = bot.viewById(\"org.eclipse.ui.navigator.ProjectExplorer\"); packageExplorerView.setFocus(); SWTBot packageExplorerViewBot = packageExplorerView.bot(); assertSessionEditorOpened(packageExplorerViewBot); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'setting this false a correctness issue? GetBlobInfo relies returning BlobProperties of metadata chunk. this passedInBlobProperties.isEncrypted()'\nThe code is: 'private void finalizeMetadataChunk() { finalBlobProperties = new BlobProperties(getBlobSize(), passedInBlobProperties.getServiceId(), passedInBlobProperties.getOwnerId(), passedInBlobProperties.getContentType(), passedInBlobProperties.isPrivate(), passedInBlobProperties.getTimeToLiveInSeconds(), passedInBlobProperties.getCreationTimeInMs(), <START> passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(), false); <END> \/\/ setting this false a correctness issue? GetBlobInfo relies returning BlobProperties of metadata chunk. this passedInBlobProperties.isEncrypted() if (getNumDataChunks() > 1) { List<StoreKey> orderedChunkIdList = new ArrayList<>(indexToChunkIds.values()); buf = MetadataContentSerDe.serializeMetadataContent(routerConfig.routerMaxPutChunkSizeBytes, getBlobSize(), orderedChunkIdList); onFillComplete(false); } else { blobId = (BlobId) indexToChunkIds.get(0); state = ChunkState.Complete; operationCompleted = true; } }'","output":"private void finalizeMetadataChunk() { finalBlobProperties = new BlobProperties(getBlobSize(), passedInBlobProperties.getServiceId(), passedInBlobProperties.getOwnerId(), passedInBlobProperties.getContentType(), passedInBlobProperties.isPrivate(), passedInBlobProperties.getTimeToLiveInSeconds(), passedInBlobProperties.getCreationTimeInMs(), passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(), passedInBlobProperties.isEncrypted()); if (getNumDataChunks() > 1) { List<StoreKey> orderedChunkIdList = new ArrayList<>(indexToChunkIds.values()); buf = MetadataContentSerDe.serializeMetadataContent(routerConfig.routerMaxPutChunkSizeBytes, getBlobSize(), orderedChunkIdList); onFillComplete(false); } else { blobId = (BlobId) indexToChunkIds.get(0); state = ChunkState.Complete; operationCompleted = true; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'canExecute() check for this case relies canDisconnect(getData()...) decision. consistent do delegate case disconnect(). actually, disconnect() checks for empty array, need remove if check'\nThe code is: 'public boolean execute(final IDebugCommandRequest request) { if (request.getElements().length == 0) { request.done(); return false; } getContainerDMContexts(request.getElements(), new DataRequestMonitor<IContainerDMContext[]>(fExecutor, null) { @Override protected void handleCompleted() { if (!isSuccess()) { request.setStatus(getStatus()); request.done(); } <START> else if (getData().length == 0){ <END> \/\/ canExecute() check for this case relies canDisconnect(getData()...) decision. consistent do delegate case disconnect(). actually, disconnect() checks for empty array, need remove if check request.done(); } else { disconnect(getData(), new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!isSuccess()) { request.setStatus(getStatus()); request.done(); } else { waitForTermination(request); } } }); } } }); return false; }'","output":"public boolean execute(final IDebugCommandRequest request) { if (request.getElements().length == 0) { request.done(); return false; } getContainerDMContexts(request.getElements(), new DataRequestMonitor<IContainerDMContext[]>(fExecutor, null) { @Override protected void handleCompleted() { if (!isSuccess()) { request.setStatus(getStatus()); request.done(); } else { disconnect(getData(), new ImmediateRequestMonitor() { @Override protected void handleCompleted() { if (!isSuccess()) { request.setStatus(getStatus()); request.done(); } else { waitForTermination(request); } } }); } } }); return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this else case. scheduling fails showing error?'\nThe code is: 'protected void executeCommand() { Time originalExecutionTime = getSchedule().getExecutionTime(); try { String jobId = scheduleJob(); if (jobId != null) { setSucceeded(true); getSchedule().setJobId(jobId); getSchedule().setExecutionTime(originalExecutionTime); getGlusterVolumeSnapshotScheduleDao().save(getSchedule()); } else { <START> setSucceeded(false); <END> \/\/ this else case. scheduling fails showing error? } } catch (Exception ex) { setSucceeded(false); handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_FAILED, ex.getMessage()); } }'","output":"protected void executeCommand() { Time originalExecutionTime = getSchedule().getExecutionTime(); try { String jobId = scheduleJob(); setSucceeded(true); getSchedule().setJobId(jobId); getSchedule().setExecutionTime(originalExecutionTime); getGlusterVolumeSnapshotScheduleDao().save(getSchedule()); } catch (Exception ex) { setSucceeded(false); handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_FAILED, ex.getMessage()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: ''==' compare constants'\nThe code is: 'public static Html toValue(Field field, JsonNode value) { <START> if (field.getDatatype().equals(Datatype.TEXT)) { <END> \/\/ '==' compare constants return Html.apply(new MarkdownProcessor().markdown(toRawValue(field, value))); } else if (field.getDatatype().equals(Datatype.COLOUR)) { return Html.apply(new MarkdownProcessor().markdown(toColourValue(field, value))); } else { return Html.apply(toRawValue(field, value)); } }'","output":"public static Html toValue(Field field, JsonNode value) { if (field.getDatatype() == Datatype.TEXT) { return Html.apply(new MarkdownProcessor().markdown(toRawValue(field, value))); } else if (field.getDatatype() == Datatype.COLOUR) { return Html.apply(new MarkdownProcessor().markdown(toColourValue(field, value))); } else { return Html.apply(toRawValue(field, value)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a throw new NullPointerException(\"metric == null\"); instead'\nThe code is: 'public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException { if (metric == null) { <START> throw new IllegalArgumentException(\"metric variable must not be null !!!\"); <END> \/\/ this a throw new NullPointerException(\"metric == null\"); instead } if (metric instanceof MetricRegistry) { final MetricRegistry childRegistry = (MetricRegistry)metric; final String childName = name; childRegistry.addListener(new MetricRegistryListener() { @Override public void onGaugeAdded(String name, Gauge<?> gauge) { register(name(childName, name), gauge); } @Override public void onGaugeRemoved(String name) { remove(name(childName, name)); } @Override public void onCounterAdded(String name, Counter counter) { register(name(childName, name), counter); } @Override public void onCounterRemoved(String name) { remove(name(childName, name)); } @Override public void onHistogramAdded(String name, Histogram histogram) { register(name(childName, name), histogram); } @Override public void onHistogramRemoved(String name) { remove(name(childName, name)); } @Override public void onMeterAdded(String name, Meter meter) { register(name(childName, name), meter); } @Override public void onMeterRemoved(String name) { remove(name(childName, name)); } @Override public void onTimerAdded(String name, Timer timer) { register(name(childName, name), timer); } @Override public void onTimerRemoved(String name) { remove(name(childName, name)); } }); } else if (metric instanceof MetricSet) { registerAll(name, (MetricSet) metric); } else { final Metric existing = metrics.putIfAbsent(name, metric); if (existing == null) { onMetricAdded(name, metric); } else { throw new IllegalArgumentException(\"A metric named \" + name + \" already exists\"); } } return metric; }'","output":"public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException { if (metric == null) { throw new NullPointerException(\"metric == null\"); } if (metric instanceof MetricRegistry) { final MetricRegistry childRegistry = (MetricRegistry)metric; final String childName = name; childRegistry.addListener(new MetricRegistryListener() { @Override public void onGaugeAdded(String name, Gauge<?> gauge) { register(name(childName, name), gauge); } @Override public void onGaugeRemoved(String name) { remove(name(childName, name)); } @Override public void onCounterAdded(String name, Counter counter) { register(name(childName, name), counter); } @Override public void onCounterRemoved(String name) { remove(name(childName, name)); } @Override public void onHistogramAdded(String name, Histogram histogram) { register(name(childName, name), histogram); } @Override public void onHistogramRemoved(String name) { remove(name(childName, name)); } @Override public void onMeterAdded(String name, Meter meter) { register(name(childName, name), meter); } @Override public void onMeterRemoved(String name) { remove(name(childName, name)); } @Override public void onTimerAdded(String name, Timer timer) { register(name(childName, name), timer); } @Override public void onTimerRemoved(String name) { remove(name(childName, name)); } }); } else if (metric instanceof MetricSet) { registerAll(name, (MetricSet) metric); } else { final Metric existing = metrics.putIfAbsent(name, metric); if (existing == null) { onMetricAdded(name, metric); } else { throw new IllegalArgumentException(\"A metric named \" + name + \" already exists\"); } } return metric; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'necessary'\nThe code is: 'public List<IBaseEventInfo> getKernelProvider(IProgressMonitor monitor) throws ExecutionException { List<String> command = createCommand(LTTngControlServiceConstants.COMMAND_LIST, LTTngControlServiceConstants.OPTION_KERNEL); ICommandResult result = executeCommand(command, monitor, false); List<IBaseEventInfo> events = new ArrayList<>(); <START> if (isError(result) && result.getErrorOutput().length > 0) { <END> \/\/ necessary if (ignoredPattern(result.getErrorOutput(), LTTngControlServiceConstants.LIST_KERNEL_NO_KERNEL_PROVIDER_PATTERN)) { return events; } throw new ExecutionException(Messages.TraceControl_CommandError + toCommandString(command)); } Document document = getDocumentFromStrings(result.getOutput()); NodeList rawEvents = document.getElementsByTagName(MIStrings.EVENT); getBaseEventInfo(rawEvents, events); return events; }'","output":"public List<IBaseEventInfo> getKernelProvider(IProgressMonitor monitor) throws ExecutionException { List<String> command = createCommand(LTTngControlServiceConstants.COMMAND_LIST, LTTngControlServiceConstants.OPTION_KERNEL); ICommandResult result = executeCommand(command, monitor, false); List<IBaseEventInfo> events = new ArrayList<>(); if (isError(result)) { if (ignoredPattern(result.getErrorOutput(), LTTngControlServiceConstants.LIST_KERNEL_NO_KERNEL_PROVIDER_PATTERN)) { return events; } throw new ExecutionException(Messages.TraceControl_CommandError + toCommandString(command)); } Document document = getDocumentFromStrings(result.getOutput()); NodeList rawEvents = document.getElementsByTagName(MIStrings.EVENT); getBaseEventInfo(rawEvents, events); return events; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'adding condition'\nThe code is: 'private void adjustSequencesDueToFailedBatch(ProducerBatch batch) { <START> if (!topicPartitionBookkeeper.contains(batch.topicPartition) || !hasProducerIdAndEpoch(batch.producerId(), batch.producerEpoch())) <END> \/\/ adding condition return; log.debug(\"producerId: {}, send to partition {} failed fatally. Reducing future sequence numbers by {}\", batch.producerId(), batch.topicPartition, batch.recordCount); int currentSequence = sequenceNumber(batch.topicPartition); currentSequence -= batch.recordCount; if (currentSequence < 0) throw new IllegalStateException(\"Sequence number for partition \" + batch.topicPartition + \" is going to become negative: \" + currentSequence); setNextSequence(batch.topicPartition, currentSequence); topicPartitionBookkeeper.getPartition(batch.topicPartition).resetSequenceNumbers(inFlightBatch -> { if (inFlightBatch.baseSequence() < batch.baseSequence()) return; int newSequence = inFlightBatch.baseSequence() - batch.recordCount; if (newSequence < 0) throw new IllegalStateException(\"Sequence number for batch with sequence \" + inFlightBatch.baseSequence() + \" for partition \" + batch.topicPartition + \" is going to become negative: \" + newSequence); log.info(\"Resetting sequence number of batch with current sequence {} for partition {} to {}\", inFlightBatch.baseSequence(), batch.topicPartition, newSequence); inFlightBatch.resetProducerState(new ProducerIdAndEpoch(inFlightBatch.producerId(), inFlightBatch.producerEpoch()), newSequence, inFlightBatch.isTransactional()); }); }'","output":"private void adjustSequencesDueToFailedBatch(ProducerBatch batch) { if (!topicPartitionBookkeeper.contains(batch.topicPartition)) return; log.debug(\"producerId: {}, send to partition {} failed fatally. Reducing future sequence numbers by {}\", batch.producerId(), batch.topicPartition, batch.recordCount); int currentSequence = sequenceNumber(batch.topicPartition); currentSequence -= batch.recordCount; if (currentSequence < 0) throw new IllegalStateException(\"Sequence number for partition \" + batch.topicPartition + \" is going to become negative: \" + currentSequence); setNextSequence(batch.topicPartition, currentSequence); topicPartitionBookkeeper.getPartition(batch.topicPartition).resetSequenceNumbers(inFlightBatch -> { if (inFlightBatch.baseSequence() < batch.baseSequence()) return; int newSequence = inFlightBatch.baseSequence() - batch.recordCount; if (newSequence < 0) throw new IllegalStateException(\"Sequence number for batch with sequence \" + inFlightBatch.baseSequence() + \" for partition \" + batch.topicPartition + \" is going to become negative: \" + newSequence); log.info(\"Resetting sequence number of batch with current sequence {} for partition {} to {}\", inFlightBatch.baseSequence(), batch.topicPartition, newSequence); inFlightBatch.resetProducerState(new ProducerIdAndEpoch(inFlightBatch.producerId(), inFlightBatch.producerEpoch()), newSequence, inFlightBatch.isTransactional()); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Serranya here. above'\nThe code is: 'public void returnsCorrectNamesSet() throws Exception { final String body = \"441 N Wolfe Rd, Sunnyvale, CA 94085\"; final RqMultipart multi = new RqMtFake( new RqFake(), new RqWithHeaders( new RqFake(\"\", \"\", body), new FormattedText( \"Content-Length: %s\", body.getBytes().length ).asString(), \"Content-Disposition: form-data; name=\\\"address\\\"\" ), new RqWithHeaders( new RqFake(\"\", \"\", \"\"), \"Content-Length: 0\", <START> \"Content-Disposition: form-data; name=\\\"data\\\"; filename=\\\"a.bin\\\"\" <END> \/\/ @Serranya here. above ) ); try { MatcherAssert.assertThat( multi.names(), Matchers.<Iterable<String>>equalTo( new HashSet<String>(Arrays.asList(\"address\", \"data\")) ) ); } finally { multi.body().close(); } }'","output":"public void returnsCorrectNamesSet() throws Exception { final String body = \"441 N Wolfe Rd, Sunnyvale, CA 94085\"; final RqMultipart multi = new RqMtFake( new RqFake(), new RqWithHeaders( new RqFake(\"\", \"\", body), new FormattedText( RqMtFakeTest.CONTENT_LENGTH, body.getBytes().length ).asString(), new FormattedText( RqMtFakeTest.CONTENT_DISP, \"name=\\\"address\\\"\" ).asString() ), new RqWithHeaders( new RqFake(\"\", \"\", \"\"), new FormattedText(RqMtFakeTest.CONTENT_LENGTH, 0).asString(), new FormattedText( RqMtFakeTest.CONTENT_DISP, \"name=\\\"data\\\"; filename=\\\"a.bin\\\"\" ).asString() ) ); try { MatcherAssert.assertThat( multi.names(), Matchers.<Iterable<String>>equalTo( new HashSet<String>(Arrays.asList(\"address\", \"data\")) ) ); } finally { multi.body().close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'multiple hadoopy shard specs'\nThe code is: 'public HadoopDruidIndexerConfig( final @JsonProperty(\"schema\") HadoopIngestionSpec schema ) { this.columnConfig = columnConfig; this.schema = schema; this.pathSpec = jsonMapper.convertValue(schema.getIOConfig().getPathSpec(), PathSpec.class); for (Map.Entry<DateTime, List<HadoopyShardSpec>> entry : schema.getTuningConfig().getShardSpecs().entrySet()) { if (entry.getValue() == null || entry.getValue().isEmpty()) { continue; } <START> final ShardSpec actualSpec = entry.getValue().get(0).getActualSpec(); <END> \/\/ multiple hadoopy shard specs shardSpecLookups.put( entry.getKey(), actualSpec.getLookup( Lists.transform( entry.getValue(), new Function<HadoopyShardSpec, ShardSpec>() { @Nullable @Override public ShardSpec apply(@Nullable HadoopyShardSpec input) { return input.getActualSpec(); } } ) ) ); for (HadoopyShardSpec hadoopyShardSpec : entry.getValue()) { hadoopShardSpecLookup.put(hadoopyShardSpec.getActualSpec(), hadoopyShardSpec); } } }'","output":"public HadoopDruidIndexerConfig( final @JsonProperty(\"schema\") HadoopIngestionSpec schema ) { this.columnConfig = columnConfig; this.schema = schema; this.pathSpec = jsonMapper.convertValue(schema.getIOConfig().getPathSpec(), PathSpec.class); for (Map.Entry<DateTime, List<HadoopyShardSpec>> entry : schema.getTuningConfig().getShardSpecs().entrySet()) { if (entry.getValue() == null || entry.getValue().isEmpty()) { continue; } final ShardSpec actualSpec = entry.getValue().get(0).getActualSpec(); shardSpecLookups.put( entry.getKey(), actualSpec.getLookup( Lists.transform( entry.getValue(), new Function<HadoopyShardSpec, ShardSpec>() { @Override public ShardSpec apply(HadoopyShardSpec input) { return input.getActualSpec(); } } ) ) ); for (HadoopyShardSpec hadoopyShardSpec : entry.getValue()) { hadoopShardSpecLookup.put(hadoopyShardSpec.getActualSpec(), hadoopyShardSpec); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: 1 -> map.size()'\nThe code is: 'public static <K, V> Block createMapBlock(MapType type, Map<K, V> map) { <START> BlockBuilder blockBuilder = type.createBlockBuilder(null, 1); <END> \/\/ nit: 1 -> map.size() for (Map.Entry<K, V> entry : map.entrySet()) { BlockBuilder entryBuilder = blockBuilder.beginBlockEntry(); appendToBlockBuilder(BIGINT, entry.getKey(), entryBuilder); appendToBlockBuilder(BIGINT, entry.getValue(), entryBuilder); blockBuilder.closeEntry(); } return blockBuilder.build(); }'","output":"public static <K, V> Block createMapBlock(MapType type, Map<K, V> map) { BlockBuilder blockBuilder = type.createBlockBuilder(null, map.size()); for (Map.Entry<K, V> entry : map.entrySet()) { BlockBuilder entryBuilder = blockBuilder.beginBlockEntry(); appendToBlockBuilder(BIGINT, entry.getKey(), entryBuilder); appendToBlockBuilder(BIGINT, entry.getValue(), entryBuilder); blockBuilder.closeEntry(); } return blockBuilder.build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Companion'\nThe code is: 'public SpeakerViewHolder(View itemView, Context context) { super(itemView); ButterKnife.bind(this, itemView); this.context = context; itemView.setOnClickListener(view -> { String speakerName = speaker.getName(); Intent intent = new Intent(this.context, SpeakerDetailsActivity.class); <START> intent.putExtra(Speaker.Companion.getSPEAKER(), speakerName); <END> \/\/ Companion try{ if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP){ Bundle bundle = ActivityOptions.makeSceneTransitionAnimation((Activity) this.context, speakerImage, speakerImage.getTransitionName()).toBundle(); this.context.startActivity(intent, bundle); } else{ this.context.startActivity(intent); } } catch(Exception e){ Timber.d(\"Speaker's transition doesnt occur\"); } }); }'","output":"public SpeakerViewHolder(View itemView, Context context) { super(itemView); ButterKnife.bind(this, itemView); this.context = context; itemView.setOnClickListener(view -> { String speakerName = speaker.getName(); Intent intent = new Intent(this.context, SpeakerDetailsActivity.class); intent.putExtra(Speaker.SPEAKER, speakerName); try{ if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP){ Bundle bundle = ActivityOptions.makeSceneTransitionAnimation((Activity) this.context, speakerImage, speakerImage.getTransitionName()).toBundle(); this.context.startActivity(intent, bundle); } else{ this.context.startActivity(intent); } } catch(Exception e){ Timber.d(\"Speaker's transition doesnt occur\"); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need for debug lines here, please'\nThe code is: 'public void testSchemaTypePromotion() throws Exception { <START> LOG.debug(\"########## testSchemaTypePromotion ##############\"); <END> \/\/ need for debug lines here, please InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(\"utf8\")); Schema schema = CSVUtil.inferSchema(\"TestRecord\", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(\"long\")); Assert.assertNotNull(schema.getField(\"nullable_double\")); Assert.assertNotNull(schema.getField(\"nullable_double2\")); Assert.assertNotNull(schema.getField(\"string\")); Assert.assertEquals(\"Should infer a long\", schema(Schema.Type.LONG), schema.getField(\"long\").schema()); Assert.assertEquals(\"Should infer a double (third row is decimal)\", nullable(Schema.Type.DOUBLE), schema.getField(\"nullable_double\").schema()); Assert.assertEquals(\"Should infer a double (second row is decimal)\", nullable(Schema.Type.DOUBLE), schema.getField(\"nullable_double2\").schema()); Assert.assertEquals(\"Should infer a nullable string (third row is string)\", schema(Schema.Type.STRING), schema.getField(\"string\").schema()); LOG.debug(\"########## END typePromotion ############\"); }'","output":"public void testSchemaTypePromotion() throws Exception { InputStream stream = new ByteArrayInputStream(csvLines2.getBytes(\"utf8\")); Schema schema = CSVUtil.inferSchema(\"TestRecord\", stream, new CSVProperties.Builder().hasHeader().build()); Assert.assertNotNull(schema.getField(\"long\")); Assert.assertNotNull(schema.getField(\"nullable_double\")); Assert.assertNotNull(schema.getField(\"nullable_double2\")); Assert.assertNotNull(schema.getField(\"string\")); Assert.assertEquals(\"Should infer a long\", schema(Schema.Type.LONG), schema.getField(\"long\").schema()); Assert.assertEquals(\"Should infer a double (third row is decimal)\", nullable(Schema.Type.DOUBLE), schema.getField(\"nullable_double\").schema()); Assert.assertEquals(\"Should infer a double (second row is decimal)\", nullable(Schema.Type.DOUBLE), schema.getField(\"nullable_double2\").schema()); Assert.assertEquals(\"Should infer a nullable string (third row is string)\", schema(Schema.Type.STRING), schema.getField(\"string\").schema()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename adapterFactories'\nThe code is: 'public synchronized void removed(IExtension[] extensions) { theAdapterManager.flushLookup(); for (IExtension extension : extensions) { for (List<IAdapterFactory> <START> list : <END> \/\/ rename adapterFactories theAdapterManager.getFactories().values()) { for (Iterator<IAdapterFactory> it2 = (list).iterator(); it2.hasNext();) { IAdapterFactory factory = it2.next(); if (!(factory instanceof AdapterFactoryProxy)) continue; if (((AdapterFactoryProxy) factory).originatesFrom(extension)) { it2.remove(); } } } } }'","output":"public synchronized void removed(IExtension[] extensions) { theAdapterManager.flushLookup(); for (IExtension extension : extensions) { for (List<IAdapterFactory> adapterFactories : theAdapterManager.getFactories().values()) { for (Iterator<IAdapterFactory> it2 = (adapterFactories).iterator(); it2.hasNext();) { IAdapterFactory factory = it2.next(); if (!(factory instanceof AdapterFactoryProxy)) continue; if (((AdapterFactoryProxy) factory).originatesFrom(extension)) { it2.remove(); } } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'more times(1)'\nThe code is: 'public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView, times(1)).setExpanded(true); <START> verify(dragComponentGroupView, times(1)).setExpanded(false); <END> \/\/ more times(1) verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }'","output":"public void testAddDraggableGroupsWithExperimental() { disabledExperimentalFeatures.add(Group1LayoutDragComponent1.class.getName()); disabledExperimentalFeatures.add(Group1LayoutDragComponent3.class.getName()); disabledExperimentalFeatures.add(Group2LayoutComponentPaletteGroupProvider.class.getName()); disabledExperimentalFeatures.add(Group3LayoutDragComponent1.class.getName()); presenter.addDraggableGroups(Arrays.asList(new Group1LayoutComponentPaletteGroupProvider(true), new Group2LayoutComponentPaletteGroupProvider(), new Group3LayoutComponentPaletteGroupProvider())); verify(dragComponentGroupPresenter, times(2)).init(any()); verify(dragComponentGroupPresenter, times(2)).getView(); verify(dragComponentGroupView).setExpanded(true); verify(dragComponentGroupView).setExpanded(false); verify(view, times(2)).addDraggableComponentGroup(any()); assertEquals(2, presenter.getLayoutDragComponentGroups().size()); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group1LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent1.ID)); assertTrue(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent2.ID)); assertFalse(presenter.hasDraggableComponent(Group1LayoutComponentPaletteGroupProvider.ID, Group1LayoutDragComponent3.ID)); assertNull(presenter.getLayoutDragComponentGroups().get(Group2LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent1.ID)); assertFalse(presenter.hasDraggableComponent(Group2LayoutComponentPaletteGroupProvider.ID, Group2LayoutDragComponent2.ID)); assertNotNull(presenter.getLayoutDragComponentGroups().get(Group3LayoutComponentPaletteGroupProvider.ID)); assertFalse(presenter.hasDraggableComponent(Group3LayoutComponentPaletteGroupProvider.ID, Group3LayoutDragComponent1.ID)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion client.incrementCounter(\"jenkins.job.stage_completed\", hostname, tags);'\nThe code is: 'public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); int stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = \"root\"; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(\"\"); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, \"stage_name\", getStageName(startNode)); TagsUtil.addTagToTags(tags, \"parent_stage_name\", directParentName); TagsUtil.addTagToTags(tags, \"stage_depth\", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, \"result\", result); client.gauge(\"jenkins.job.stage_duration\", getTime(startNode, endNode), hostname, tags); <START> client.gauge(\"jenkins.job.stage_completed\", 1, hostname, tags); <END> \/\/ suggestion client.incrementCounter(\"jenkins.job.stage_completed\", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, \"Unable to submit the stage duration metric for \" + getStageName(startNode)); } }'","output":"public void onNewHead(FlowNode flowNode) { DatadogClient client = ClientFactory.getClient(); if (client == null){ return; } client.sendPipelineTrace(runFor(flowNode.getExecution()), flowNode); if (!isMonitored(flowNode)) { return; } StepEndNode endNode = (StepEndNode) flowNode; StepStartNode startNode = endNode.getStartNode(); int stageDepth = 0; String directParentName = null; for (BlockStartNode node : startNode.iterateEnclosingBlocks()) { if (DatadogUtilities.isStageNode(node)) { if(directParentName == null){ directParentName = getStageName(node); } stageDepth++; } } if(directParentName == null){ directParentName = \"root\"; } WorkflowRun run = getRun(flowNode); if(run == null){ return; } try { String result = DatadogUtilities.getResultTag(endNode); BuildData buildData = new BuildData(run, flowNode.getExecution().getOwner().getListener()); String hostname = buildData.getHostname(\"\"); Map<String, Set<String>> tags = buildData.getTags(); TagsUtil.addTagToTags(tags, \"stage_name\", getStageName(startNode)); TagsUtil.addTagToTags(tags, \"parent_stage_name\", directParentName); TagsUtil.addTagToTags(tags, \"stage_depth\", String.valueOf(stageDepth)); TagsUtil.addTagToTags(tags, \"result\", result); client.gauge(\"jenkins.job.stage_duration\", getTime(startNode, endNode), hostname, tags); client.incrementCounter(\"jenkins.job.stage_completed\", hostname, tags); } catch (IOException | InterruptedException e) { DatadogUtilities.severe(logger, e, \"Unable to submit the stage duration metric for \" + getStageName(startNode)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this inverted'\nThe code is: 'public @ResponseBody boolean updateGame( @PathVariable int id, @RequestParam(value = \"location\") String location, @RequestParam(value = \"addOfficial\") String addOfficial, @RequestParam(value = \"removeOfficial\") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(\"member\"); <START> if(MemberUtils.atLeastCoordinator(member)) { <END> \/\/ this inverted return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!=\"\") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }'","output":"public @ResponseBody boolean updateGame( @PathVariable int id, @RequestParam(value = \"location\") String location, @RequestParam(value = \"addOfficial\") String addOfficial, @RequestParam(value = \"removeOfficial\") String removeOfficial, HttpSession session) { Member member = (Member) session.getAttribute(\"member\"); if(!MemberUtils.atLeastCoordinator(member)) { return false; } GameDao gameDao = new GameDao(); MemberDao memberDao = new MemberDao(); Game game = gameDao.getGameById(id, true); if(location!=\"\") { game.setGameLocation(location); } game.removeOfficial(memberDao.getMemberByUsername(removeOfficial)); game.addOfficial(memberDao.getMemberByUsername(addOfficial)); gameDao.saveGame(game); return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add SaslException here'\nThe code is: '<START> public byte[] evaluateInitialResponse(OAuth2InitialClientMessage initialClientMessage) throws AuthenticationMechanismException, SaslException { <END> \/\/ add SaslException here if (initialClientMessage.isBearerToken()) { String auth = initialClientMessage.getAuth(); String token = auth.substring(auth.indexOf(\" \") + 1); BearerTokenEvidence evidence = new BearerTokenEvidence(token); EvidenceVerifyCallback evidenceVerifyCallback = new EvidenceVerifyCallback(evidence); try { MechanismUtil.handleCallbacks(this.mechanismName, this.callbackHandler, evidenceVerifyCallback); } catch (UnsupportedCallbackException e) { throw log.mechAuthorizationUnsupported(this.mechanismName, e); } if (evidenceVerifyCallback.isVerified()) { AuthorizeCallback authorizeCallback = new AuthorizeCallback(null, null); try { MechanismUtil.handleCallbacks(this.mechanismName, this.callbackHandler, authorizeCallback); } catch (UnsupportedCallbackException e) { throw log.mechAuthorizationUnsupported(this.mechanismName, e); } if (authorizeCallback.isAuthorized()) { return new byte[0]; } } return createErrorMessage(); } throw log.mechInvalidClientMessage(this.mechanismName); }'","output":"public byte[] evaluateInitialResponse(OAuth2InitialClientMessage initialClientMessage) throws AuthenticationMechanismException { if (initialClientMessage.isBearerToken()) { String auth = initialClientMessage.getAuth(); String token = auth.substring(auth.indexOf(\" \") + 1); BearerTokenEvidence evidence = new BearerTokenEvidence(token); EvidenceVerifyCallback evidenceVerifyCallback = new EvidenceVerifyCallback(evidence); try { MechanismUtil.handleCallbacks(this.mechanismName, this.callbackHandler, evidenceVerifyCallback); } catch (UnsupportedCallbackException e) { throw log.mechAuthorizationUnsupported(this.mechanismName, e); } if (evidenceVerifyCallback.isVerified()) { AuthorizeCallback authorizeCallback = new AuthorizeCallback(null, null); try { MechanismUtil.handleCallbacks(this.mechanismName, this.callbackHandler, authorizeCallback); } catch (UnsupportedCallbackException e) { throw log.mechAuthorizationUnsupported(this.mechanismName, e); } if (authorizeCallback.isAuthorized()) { return new byte[0]; } } return createErrorMessage(); } throw log.mechInvalidClientMessage(this.mechanismName); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new loop strucutre: for(Category cat: resCategories) {..'\nThe code is: 'public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); <START> for (int i = 0; i < resCategories.size(); i++) { <END> \/\/ new loop strucutre: for(Category cat: resCategories) {.. Category resCat = resCategories.get(i); this.getCategoryCodes().add(resCat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(\"error in edit\", t); return FAILURE; } return SUCCESS; }'","output":"public String edit() { try { savedId.clear(); ResourceInterface resource = this.loadResource(this.getResourceId()); this.setResourceTypeCode(resource.getType()); List fileDescr = new ArrayList<String>(); fileDescr.add(resource.getDescription()); setFileDescriptions(fileDescr); List<Category> resCategories = resource.getCategories(); for (Category cat : resCategories) { this.getCategoryCodes().add(cat.getCode()); } this.setMainGroup(resource.getMainGroup()); this.setStrutsAction(ApsAdminSystemConstants.EDIT); } catch (Throwable t) { logger.error(\"error in edit\", t); return FAILURE; } return SUCCESS; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@maria-farooq provide a description log message'\nThe code is: 'protected Response getIncomingPhoneNumber(final String accountSid, final String sid, final MediaType responseType) { try{ Account operatedAccount = accountsDao.getAccount(accountSid); secure(operatedAccount, \"RestComm:Read:IncomingPhoneNumbers\"); final IncomingPhoneNumber incomingPhoneNumber = dao.getIncomingPhoneNumber(new Sid(sid)); if (incomingPhoneNumber == null) { return status(NOT_FOUND).build(); } else { if (operatedAccount == null) { return status(BAD_REQUEST).build(); } secure(operatedAccount, incomingPhoneNumber.getAccountSid(), SecuredType.SECURED_STANDARD); if (APPLICATION_JSON_TYPE == responseType) { return ok(gson.toJson(incomingPhoneNumber), APPLICATION_JSON).build(); } else if (APPLICATION_XML_TYPE == responseType) { final RestCommResponse response = new RestCommResponse(incomingPhoneNumber); return ok(xstream.toXML(response), APPLICATION_XML).build(); } else { return null; } } }catch(Exception e){ <START> logger.error(\"\", e); <END> \/\/ @maria-farooq provide a description log message return status(INTERNAL_SERVER_ERROR).build(); } }'","output":"protected Response getIncomingPhoneNumber(final String accountSid, final String sid, final MediaType responseType) { Account operatedAccount = accountsDao.getAccount(accountSid); secure(operatedAccount, \"RestComm:Read:IncomingPhoneNumbers\"); try{ final IncomingPhoneNumber incomingPhoneNumber = dao.getIncomingPhoneNumber(new Sid(sid)); if (incomingPhoneNumber == null) { return status(NOT_FOUND).build(); } else { if (operatedAccount == null) { return status(BAD_REQUEST).build(); } secure(operatedAccount, incomingPhoneNumber.getAccountSid(), SecuredType.SECURED_STANDARD); if (APPLICATION_JSON_TYPE == responseType) { return ok(gson.toJson(incomingPhoneNumber), APPLICATION_JSON).build(); } else if (APPLICATION_XML_TYPE == responseType) { final RestCommResponse response = new RestCommResponse(incomingPhoneNumber); return ok(xstream.toXML(response), APPLICATION_XML).build(); } else { return null; } } }catch(Exception e){ logger.error(\"Exception while performing getIncomingPhoneNumber: \", e); return status(INTERNAL_SERVER_ERROR).build(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'context sync obj'\nThe code is: 'public PieChartViewerStateContentSelected(final TmfPieChartViewer context) { if (context.isDisposed()) { return; } Display.getDefault().asyncExec(new Runnable() { @Override public void run() { <START> synchronized (context.getMutexLayoutChange()) { <END> \/\/ context sync obj if (!context.isDisposed()) { context.updateGlobalPieChart(); context.updateTimeRangeSelectionPieChart(); context.getTimeRangePC().redraw(); context.getGlobalPC().getLegend().setPosition(SWT.BOTTOM); context.layout(); } } } }); }'","output":"public PieChartViewerStateContentSelected(final TmfPieChartViewer context) { if (context.isDisposed()) { return; } Display.getDefault().asyncExec(new Runnable() { @Override public void run() { synchronized (context) { if (!context.isDisposed()) { context.updateGlobalPieChart(); context.updateTimeRangeSelectionPieChart(); context.getTimeRangePC().redraw(); context.getGlobalPC().getLegend().setPosition(SWT.BOTTOM); context.layout(); } } } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'openSansSemiBoldFont rename a general name semiBoldFont'\nThe code is: 'public DiscussionPostsAdapter(Context context, IEdxEnvironment environment) { super(context, R.layout.row_discussion_thread, environment); edx_brand_primary_base = context.getResources().getColor(R.color.edx_brand_primary_base); edx_grayscale_neutral_dark = context.getResources().getColor(R.color.edx_brand_gray_base); edx_brand_secondary_dark = context.getResources().getColor(R.color.edx_brand_secondary_dark); edx_utility_success_dark = context.getResources().getColor(R.color.edx_success_text); <START> openSansSemiBoldFont = ResourcesCompat.getFont(context, R.font.inter_semi_bold); <END> \/\/ openSansSemiBoldFont rename a general name semiBoldFont }'","output":"public DiscussionPostsAdapter(Context context, IEdxEnvironment environment) { super(context, R.layout.row_discussion_thread, environment); edx_brand_primary_base = context.getResources().getColor(R.color.edx_brand_primary_base); edx_grayscale_neutral_dark = context.getResources().getColor(R.color.edx_brand_gray_base); edx_brand_secondary_dark = context.getResources().getColor(R.color.edx_brand_secondary_dark); edx_utility_success_dark = context.getResources().getColor(R.color.edx_success_text); semiBoldFont = ResourcesCompat.getFont(context, R.font.inter_semi_bold); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'get bundle easier: FrameworkUtil.getBundle(getClass());'\nThe code is: 'private void hookFillMenu(Menu menu) { ScenarioParser parser = new ScenarioParser(); <START> Bundle bundle = Platform.getBundle(Constants.BUNDLE_ID); <END> \/\/ get bundle easier: FrameworkUtil.getBundle(getClass()); File stateLocation = Platform.getStateLocation(bundle).toFile(); hookDirectoryScenarios(menu, parser, stateLocation); new MenuItem(menu, SWT.SEPARATOR); MenuItem menuItemCategory = new MenuItem(menu, SWT.CASCADE); menuItemCategory.setText(\"Open scenarios directory\\u2026\"); menuItemCategory.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { Program.launch(stateLocation.getAbsolutePath()); } }); new MenuItem(menu, SWT.SEPARATOR); hookPredefinedScenarios(menu); }'","output":"private void hookFillMenu(Menu menu) { ScenarioParser parser = new ScenarioParser(); Bundle bundle = FrameworkUtil.getBundle(getClass()); File stateLocation = Platform.getStateLocation(bundle).toFile(); hookDirectoryScenarios(menu, parser, stateLocation); new MenuItem(menu, SWT.SEPARATOR); MenuItem menuItemCategory = new MenuItem(menu, SWT.CASCADE); menuItemCategory.setText(\"Open scenarios directory\\u2026\"); menuItemCategory.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { Program.launch(stateLocation.getAbsolutePath()); } }); new MenuItem(menu, SWT.SEPARATOR); hookPredefinedScenarios(menu); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'mType is originally 0'\nThe code is: 'public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); Announcement announcement = null; <START> mType = ORIGINAL; <END> \/\/ mType is originally 0 ObjectMapper mapper = new ObjectMapper(); try { announcement = mapper.readValue(getIntent().getStringExtra(\"Announcement\"), Announcement.class); FragUtils.replace(R.id.container, AnnouncementFragment.newInstance(announcement), this); } catch (IOException exception) { String error = \"Announcement\"; Toast.makeText(this, getString(R.string.cannot_be_displayed, error), Toast.LENGTH_SHORT).show(); onBackPressed(); } }'","output":"public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); Announcement announcement = null; ObjectMapper mapper = new ObjectMapper(); try { announcement = mapper.readValue(getIntent().getStringExtra(\"Announcement\"), Announcement.class); FragUtils.replace(R.id.container, AnnouncementFragment.newInstance(announcement), this); } catch (IOException exception) { String error = \"Announcement\"; Toast.makeText(this, getString(R.string.cannot_be_displayed, error), Toast.LENGTH_SHORT).show(); onBackPressed(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I pinning disable this action'\nThe code is: 'protected void fillTimeGraphEntryContextMenu(@NonNull IMenuManager menuManager) { ISelection selection = getSite().getSelectionProvider().getSelection(); if (selection instanceof StructuredSelection) { StructuredSelection sSel = (StructuredSelection) selection; if (sSel.getFirstElement() instanceof ControlFlowEntry) { ControlFlowEntry entry = (ControlFlowEntry) sSel.getFirstElement(); <START> if (fShowFollowThreadAction) { <END> \/\/ I pinning disable this action menuManager.add(new FollowThreadAction(ControlFlowView.this, entry.getName(), entry.getThreadId(), entry.getTrace())); } } } }'","output":"protected void fillTimeGraphEntryContextMenu(@NonNull IMenuManager menuManager) { ISelection selection = getSite().getSelectionProvider().getSelection(); if (selection instanceof StructuredSelection) { StructuredSelection sSel = (StructuredSelection) selection; if (sSel.getFirstElement() instanceof ControlFlowEntry) { ControlFlowEntry entry = (ControlFlowEntry) sSel.getFirstElement(); menuManager.add(new FollowThreadAction(ControlFlowView.this, entry.getName(), entry.getThreadId(), entry.getTrace())); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is necessary, try-with-resources block call walk.close() automatically'\nThe code is: 'private List<String> revList(ObjectId initialObjectId) throws IOException { ArrayList<String> revs = new ArrayList<>(); Repository repo = git.getRepository(); try (RevWalk walk = new RevWalk(repo)) { walk.setRetainBody(false); RevCommit head = walk.parseCommit(initialObjectId); while (true) { revs.add(head.getName()); RevCommit[] parents = head.getParents(); if (parents == null || parents.length == 0) { break; } head = walk.parseCommit(parents[0]); } <START> walk.close(); <END> \/\/ this is necessary, try-with-resources block call walk.close() automatically } return revs; }'","output":"private List<String> revList(ObjectId initialObjectId) throws IOException { ArrayList<String> revs = new ArrayList<>(); Repository repo = git.getRepository(); try (RevWalk walk = new RevWalk(repo)) { walk.setRetainBody(false); RevCommit head = walk.parseCommit(initialObjectId); while (true) { revs.add(head.getName()); RevCommit[] parents = head.getParents(); if (parents == null || parents.length == 0) { break; } head = walk.parseCommit(parents[0]); } } return revs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove need for finally statement a [try resources statement](<LINK_0>'\nThe code is: 'private void readJsonFromURL() { InputStream is = null; <START> try { <END> \/\/ remove need for finally statement a [try resources statement](<LINK_0> is = url.openStream(); BufferedReader rd = new BufferedReader(new InputStreamReader(is)); JsonReader jr = Json.createReader(rd); parseJson(jr.readObject()); } catch (IOException | NotFoundException e) { Utils.logException(LOG, \"Unable to load url: \" + url.toString(), e); } finally { try { is.close(); } catch (IOException e) { Utils.logException(LOG, e); } } streamsAreLoaded = true; }'","output":"private void readJsonFromURL() { try (InputStream is = url.openStream()) { BufferedReader rd = new BufferedReader(new InputStreamReader(is)); JsonReader jr = Json.createReader(rd); parseJson(jr.readObject()); } catch (IOException | NotFoundException e) { Utils.logException(LOG, \"Unable to load url: \" + url.toString(), e); } streamsAreLoaded = true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this property typed boolean, use: Boolean.toString(vmInterface.isPortMirroring())'\nThe code is: 'private static void addNetworkInterfaceProperties(XmlRpcStruct struct, VmNetworkInterface vmInterface, VmDevice vmDevice, String nicModel) { struct.add(VdsProperties.Type, vmDevice.getType()); struct.add(VdsProperties.Device, vmDevice.getDevice()); struct.add(VdsProperties.network, vmInterface.getNetworkName()); addAddress(vmDevice, struct); struct.add(VdsProperties.mac_addr, vmInterface.getMacAddress()); addBootOrder(vmDevice, struct); struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams()); struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId())); struct.add(VdsProperties.nic_type, nicModel); <START> struct.add(VdsProperties.portMirroring, new Boolean(vmInterface.isPortMirroring()).toString()); <END> \/\/ this property typed boolean, use: Boolean.toString(vmInterface.isPortMirroring()) }'","output":"private static void addNetworkInterfaceProperties(XmlRpcStruct struct, VmNetworkInterface vmInterface, VmDevice vmDevice, String nicModel) { struct.add(VdsProperties.Type, vmDevice.getType()); struct.add(VdsProperties.Device, vmDevice.getDevice()); struct.add(VdsProperties.network, vmInterface.getNetworkName()); addAddress(vmDevice, struct); struct.add(VdsProperties.mac_addr, vmInterface.getMacAddress()); addBootOrder(vmDevice, struct); struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams()); struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId())); struct.add(VdsProperties.nic_type, nicModel); struct.add(VdsProperties.portMirroring, Boolean.toString(vmInterface.isPortMirroring())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this need done in refresh instead of creation of controls'\nThe code is: 'protected void createMainControl(Composite parent, IEEFFormContainer formContainer) { EEFWidgetFactory widgetFactory = formContainer.getWidgetFactory(); this.comboViewer = new ComboViewer(parent, SWT.READ_ONLY); this.combo = comboViewer.getCombo(); this.comboViewer.setContentProvider(ArrayContentProvider.getInstance()); this.comboViewer.setLabelProvider(new EEFSelectLabelProvider()); this.comboViewer.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TEXT_BORDER); widgetFactory.paintBordersFor(parent); FormData comboFormData = new FormData(); comboFormData.left = new FormAttachment(0, LABEL_WIDTH); comboFormData.right = new FormAttachment(100, 0); this.combo.setLayoutData(comboFormData); <START> if (!isEnabled()) { this.combo.setEnabled(false); } <END> \/\/ this need done in refresh instead of creation of controls this.controller = new EEFControllersFactory().createSelectController(this.description, this.variableManager, this.interpreter, this.editingDomain); }'","output":"protected void createMainControl(Composite parent, IEEFFormContainer formContainer) { EEFWidgetFactory widgetFactory = formContainer.getWidgetFactory(); this.comboViewer = new ComboViewer(parent, SWT.READ_ONLY); this.combo = comboViewer.getCombo(); this.comboViewer.setContentProvider(ArrayContentProvider.getInstance()); this.comboViewer.setLabelProvider(new EEFSelectLabelProvider()); this.comboViewer.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TEXT_BORDER); widgetFactory.paintBordersFor(parent); FormData comboFormData = new FormData(); comboFormData.left = new FormAttachment(0, LABEL_WIDTH); comboFormData.right = new FormAttachment(100, 0); this.combo.setLayoutData(comboFormData); this.controller = new EEFControllersFactory().createSelectController(this.description, this.variableManager, this.interpreter, this.editingDomain); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'i == Const.POINTS_NOT_SUBMITTED necessary return is else clause'\nThe code is: 'public static String convertToEqualShareFormat(int i) { if (i > 100) { return \"Equal share + \" + (i - 100) + \"%\"; } else if (i == 100) { return \"Equal share\"; } else if (i > 0) { return \"Equal share - \" + (100 - i) + \"%\"; } else if (i == 0) { return \"0%\"; } else if (i == Const.POINTS_NOT_SURE) { return \"Not Sure\"; } else if (i == Const.POINTS_NOT_SUBMITTED) { return \"\"; } else { return \"\"; <START> } <END> \/\/ i == Const.POINTS_NOT_SUBMITTED necessary return is else clause }'","output":"public static String convertToEqualShareFormat(int i) { if (i > 100) { return \"Equal share + \" + (i - 100) + \"%\"; } else if (i == 100) { return \"Equal share\"; } else if (i > 0) { return \"Equal share - \" + (100 - i) + \"%\"; } else if (i == 0) { return \"0%\"; } else if (i == Const.POINTS_NOT_SURE) { return \"Not Sure\"; } else { return \"\"; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion LOG.debug(\"The underlying Yarn version support external resources.\", e);'\nThe code is: 'ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(\"setResourceInformation\", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(\"getResources\"); resourceInformationGetNameMethod = resourceInfoClass.getMethod(\"getName\"); resourceInformationGetValueMethod = resourceInfoClass.getMethod(\"getValue\"); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(\"newInstance\", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { <START> LOG.debug(\"The underlying Yarn does not support external resource.\", e); <END> \/\/ suggestion LOG.debug(\"The underlying Yarn version support external resources.\", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }'","output":"ResourceInformationReflector(String resourceClassName, String resourceInfoClassName) { Method resourceSetResourceInformationMethod = null; Method resourceGetResourcesMethod = null; Method resourceInformationGetNameMethod = null; Method resourceInformationGetValueMethod = null; Method resourceInformationNewInstanceMethod = null; boolean isYarnResourceTypesAvailable = false; try { final Class<?> resourceClass = Class.forName(resourceClassName); final Class<?> resourceInfoClass = Class.forName(resourceInfoClassName); resourceSetResourceInformationMethod = resourceClass.getMethod(\"setResourceInformation\", String.class, resourceInfoClass); resourceGetResourcesMethod = resourceClass.getMethod(\"getResources\"); resourceInformationGetNameMethod = resourceInfoClass.getMethod(\"getName\"); resourceInformationGetValueMethod = resourceInfoClass.getMethod(\"getValue\"); resourceInformationNewInstanceMethod = resourceInfoClass.getMethod(\"newInstance\", String.class, long.class); isYarnResourceTypesAvailable = true; } catch (Exception e) { LOG.debug(\"The underlying Yarn version does not support external resources.\", e); } finally { this.resourceSetResourceInformationMethod = resourceSetResourceInformationMethod; this.resourceGetResourcesMethod = resourceGetResourcesMethod; this.resourceInformationGetNameMethod = resourceInformationGetNameMethod; this.resourceInformationGetValueMethod = resourceInformationGetValueMethod; this.resourceInformationNewInstanceMethod = resourceInformationNewInstanceMethod; this.isYarnResourceTypesAvailable = isYarnResourceTypesAvailable; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Logging'\nThe code is: 'public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(int i=0; i<100; i++){ String key = String.format(\"key-%d\", i); String value = String.format(\"value-%d\", i); cache.put(key, value); cachedValues.put(key, value); } <START> System.out.println(\"Key's added\"); <END> \/\/ Logging Map<String, String> values = cache.getAll(cachedValues.keySet()); System.out.println(\"done\"); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }'","output":"public void testGetAllWithCompatibility() { RemoteCache<String, String> cache = client(0).getCache(); HashMap<String, String> cachedValues = new HashMap<>(); for(int i=0; i<100; i++){ String key = String.format(\"key-%d\", i); String value = String.format(\"value-%d\", i); cache.put(key, value); cachedValues.put(key, value); } Map<String, String> values = cache.getAll(cachedValues.keySet()); assertEquals(cachedValues.size(), values.size()); for(String key : values.keySet()){ assertEquals(cachedValues.get(key), values.get(key)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary concatenation line some formatting changes'\nThe code is: 'private Method checkProxy(Method methodArg, Object bean) { Method method = methodArg; if (AopUtils.isJdkDynamicProxy(bean)) { try { method = bean.getClass().getMethod(method.getName(), method.getParameterTypes()); Class<?>[] proxiedInterfaces = ((Advised) bean).getProxiedInterfaces(); for (Class<?> iface : proxiedInterfaces) { try { method = iface.getMethod(method.getName(), method.getParameterTypes()); break; } catch (NoSuchMethodException noMethod) { } } } catch (SecurityException ex) { ReflectionUtils.handleReflectionException(ex); } catch (NoSuchMethodException ex) { throw new IllegalStateException(String.format( \"@StreamListener method '%s' found on bean target class '%s', \" + \"but not found in any interface(s) for bean JDK proxy. Either \" + \"pull the method up to an interface or switch to subclass (CGLIB) \" <START> + \"proxies by setting proxy-target-class\/proxyTargetClass \" + \"attribute to 'true'\", <END> \/\/ unnecessary concatenation line some formatting changes method.getName(), method.getDeclaringClass().getSimpleName()), ex); } } return method; }'","output":"private Method checkProxy(Method methodArg, Object bean) { Method method = methodArg; if (AopUtils.isJdkDynamicProxy(bean)) { try { method = bean.getClass().getMethod(method.getName(), method.getParameterTypes()); Class<?>[] proxiedInterfaces = ((Advised) bean).getProxiedInterfaces(); for (Class<?> iface : proxiedInterfaces) { try { method = iface.getMethod(method.getName(), method.getParameterTypes()); break; } catch (NoSuchMethodException noMethod) { } } } catch (SecurityException ex) { ReflectionUtils.handleReflectionException(ex); } catch (NoSuchMethodException ex) { throw new IllegalStateException(String.format( \"@StreamListener method '%s' found on bean target class '%s', \" + \"but not found in any interface(s) for bean JDK proxy. Either \" + \"pull the method up to an interface or switch to subclass (CGLIB) \" + \"proxies by setting proxy-target-class\/proxyTargetClass attribute to 'true'\", method.getName(), method.getDeclaringClass().getSimpleName()), ex); } } return method; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move save\/replacer logic a shared Impl class + Interface default methods? a common use-case for Jenkins reused in other model objects. in external class help, especially when\/if starts working pluggable storage stories in core'\nThe code is: 'public synchronized void save() throws IOException, FormValidation { if (! isIdOrFullnameAllowed(id)) { throw FormValidation.error(Messages.User_IllegalUsername(id)); } if (! isIdOrFullnameAllowed(fullName)) { throw FormValidation.error(Messages.User_IllegalFullname(fullName)); } if(BulkChange.contains(this)) return; synchronized (saving) { saving.add(this); } try { <START> getConfigFile().write(this); <END> \/\/ move save\/replacer logic a shared Impl class + Interface default methods? a common use-case for Jenkins reused in other model objects. in external class help, especially when\/if starts working pluggable storage stories in core } finally { synchronized (saving) { saving.remove(this); } } SaveableListener.fireOnChange(this, getConfigFile()); }'","output":"public synchronized void save() throws IOException, FormValidation { if (! isIdOrFullnameAllowed(id)) { throw FormValidation.error(Messages.User_IllegalUsername(id)); } if (! isIdOrFullnameAllowed(fullName)) { throw FormValidation.error(Messages.User_IllegalFullname(fullName)); } if(BulkChange.contains(this)) return; getConfigFile().write(this); SaveableListener.fireOnChange(this, getConfigFile()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this line'\nThe code is: 'public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } if (!firstControl) { <START> ((GridData)children.get(0).getLayoutData()).verticalIndent = 0; <END> \/\/ remove this line } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, \"Only text hovers producing an AbstractInformationControl can be aggregated; got a \" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }'","output":"public void createContent(Composite parent) { this.controls = new LinkedHashMap<>(); GridLayout layout = new GridLayout(1, false); parent.setLayout(layout); boolean firstControl = true; for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { IInformationControl informationControl = hoverControlCreator.getValue().createInformationControl(parent.getShell()); if (informationControl instanceof AbstractInformationControl) { List<Control> children = Arrays.asList(((AbstractInformationControl)informationControl).getShell().getChildren()); children.remove(parent); if (children.isEmpty() ) { continue; } for (Control control : children) { control.setParent(parent); control.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); } controls.put(hoverControlCreator.getKey(), informationControl); firstControl = false; } else { GenericEditorPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, GenericEditorPlugin.BUNDLE_ID, \"Only text hovers producing an AbstractInformationControl can be aggregated; got a \" + informationControl.getClass().getSimpleName())); informationControl.dispose(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a private constructor, builder is used'\nThe code is: '<START> public PushSetupSms(final CosemObisCode logicalName, final List<CosemObjectDefinition> pushObjectList, <END> \/\/ a private constructor, builder is used final SendDestinationAndMethod sendDestinationAndMethod, final List<WindowElement> communicationWindow, final Integer randomisationStartInterval, final Integer numberOfRetries, final Integer repetitionDelay) { this.checkRandomisationStartInterval(randomisationStartInterval); this.checkNumberOfRetries(numberOfRetries); this.checkRepetitionDelay(repetitionDelay); this.logicalName = logicalName; if (pushObjectList == null) { this.pushObjectList = null; } else { this.pushObjectList = new ArrayList<>(pushObjectList); } this.sendDestinationAndMethod = sendDestinationAndMethod; if (communicationWindow == null) { this.communicationWindow = null; } else { this.communicationWindow = new ArrayList<>(communicationWindow); } this.randomisationStartInterval = randomisationStartInterval; this.numberOfRetries = numberOfRetries; this.repetitionDelay = repetitionDelay; }'","output":"private PushSetupSms(final CosemObisCode logicalName, final List<CosemObjectDefinition> pushObjectList, final SendDestinationAndMethod sendDestinationAndMethod, final List<WindowElement> communicationWindow, final Integer randomisationStartInterval, final Integer numberOfRetries, final Integer repetitionDelay) { this.checkRandomisationStartInterval(randomisationStartInterval); this.checkNumberOfRetries(numberOfRetries); this.checkRepetitionDelay(repetitionDelay); this.logicalName = logicalName; if (pushObjectList == null) { this.pushObjectList = null; } else { this.pushObjectList = new ArrayList<>(pushObjectList); } this.sendDestinationAndMethod = sendDestinationAndMethod; if (communicationWindow == null) { this.communicationWindow = null; } else { this.communicationWindow = new ArrayList<>(communicationWindow); } this.randomisationStartInterval = randomisationStartInterval; this.numberOfRetries = numberOfRetries; this.repetitionDelay = repetitionDelay; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'debug\/trace\/remove'\nThe code is: 'protected void onBind() { super.onBind(); <START> logger.info(this.getClass().toString() + \" onBind\"); END> currentErrataModel = getModelProvider().getModel(); updateModel(currentErrataModel); getView().getTotalSecurity().setCommand(currentErrataModel.getShowSecurityCommand()); getView().getTotalBugFix().setCommand(currentErrataModel.getShowBugsCommand()); getView().getTotalEnhancement().setCommand(currentErrataModel.getShowEnhancementsCommand()); registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalSecurity().getCommand().execute(); } })); registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalBugFix().getCommand().execute(); } })); registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalEnhancement().getCommand().execute(); } })); currentErrataModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() { @Override public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) { logger.info(this.getClass().toString() + \": bus published message that the counts changed. update view.\"); ErrataCounts counts = currentErrataModel.getErrataCounts(); getView().showCounts(counts); } }); currentErrataModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() { @Override public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) { logger.info(this.getClass().toString() + \": bus published message that there was a query error. update view.\"); getView().showErrorMessage(SafeHtmlUtils.fromString(currentErrataModel.getMessage())); } }); }'","output":"protected void onBind() { super.onBind(); currentErrataModel = getModelProvider().getModel(); updateModel(currentErrataModel); getView().getTotalSecurity().setCommand(currentErrataModel.getShowSecurityCommand()); getView().getTotalBugFix().setCommand(currentErrataModel.getShowBugsCommand()); getView().getTotalEnhancement().setCommand(currentErrataModel.getShowEnhancementsCommand()); registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalSecurity().getCommand().execute(); } })); registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalBugFix().getCommand().execute(); } })); registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { getView().getTotalEnhancement().getCommand().execute(); } })); currentErrataModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() { @Override public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) { ErrataCounts counts = currentErrataModel.getErrataCounts(); getView().showCounts(counts); } }); currentErrataModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() { @Override public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) { getView().showErrorMessage(SafeHtmlUtils.fromString(currentErrataModel.getMessage())); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I minimum is 1 for of these, matters here, good consistent'\nThe code is: 'private int computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, \"Unexpected serverFactory instance on TimeLockServerConfiguration.\"); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), \"applicationConnectors of TimeLockServerConfiguration must not be null.\"); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, \"applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.\"); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); <START> int selectorThreads = connectorFactory.getSelectorThreads().orElse(0); <END> \/\/ I minimum is 1 for of these, matters here, good consistent int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(0); return maxServerThreads - selectorThreads - acceptorThreads - 1; }'","output":"private int computeNumberOfAvailableThreads() { Preconditions.checkState(getServerFactory() instanceof DefaultServerFactory, \"Unexpected serverFactory instance on TimeLockServerConfiguration.\"); DefaultServerFactory serverFactory = (DefaultServerFactory) getServerFactory(); int maxServerThreads = serverFactory.getMaxThreads(); Preconditions.checkNotNull(serverFactory.getApplicationConnectors(), \"applicationConnectors of TimeLockServerConfiguration must not be null.\"); Preconditions.checkState(serverFactory.getApplicationConnectors().get(0) instanceof HttpConnectorFactory, \"applicationConnectors of TimeLockServerConfiguration must have a HttpConnectorFactory instance.\"); HttpConnectorFactory connectorFactory = (HttpConnectorFactory) serverFactory.getApplicationConnectors().get(0); int selectorThreads = connectorFactory.getSelectorThreads().orElse(1); int acceptorThreads = connectorFactory.getAcceptorThreads().orElse(1); return maxServerThreads - selectorThreads - acceptorThreads - 1; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change variable name newMember'\nThe code is: 'public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(\"user1\"), properties.getProperty(\"passwordUser1\")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member new_member = new Member(communityService, properties.getProperty(\"email2\")); <START> communityService.addMember(community.getCommunityUuid(), new_member ); <END> \/\/ change variable name newMember MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(\"email2\")); }'","output":"public final void testAddRemoveMember() throws Exception { CommunityService communityService = new CommunityService(); authenticateEndpoint(communityService.getEndpoint(), properties.getProperty(\"user1\"), properties.getProperty(\"passwordUser1\")); CommunityList communities = communityService.getMyCommunities(); Community community = communities.iterator().next(); Member newMember = new Member(communityService, properties.getProperty(\"email2\")); communityService.addMember(community.getCommunityUuid(), newMember ); MemberList members = communityService.getMembers(community.getCommunityUuid()); for (Member member : members) { assertNotNull(member.getUserid()); assertNotNull(member.getName()); } communityService.removeMember(community.getCommunityUuid(), properties.getProperty(\"email2\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a warning info level message? happen'\nThe code is: 'void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { <START> Log.i(LOG_TAG, \"Caller error: geoPoint is null\"); <END> \/\/ this a warning info level message? happen return; } final Point point = pj.toPixels(geoPoint, null); final int size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }'","output":"void update(ObservationPoint obsPoint, MapView mapView, boolean isMlsPointUpdate) { final Projection pj = mapView.getProjection(); GeoPoint geoPoint = (isMlsPointUpdate)? obsPoint.pointMLS : obsPoint.pointGPS; if (geoPoint == null) { Log.w(LOG_TAG, \"Caller error: geoPoint is null\"); return; } final Point point = pj.toPixels(geoPoint, null); final int size = mSize3px * 2; final Rect dirty = new Rect(point.x - size, point.y - size, point.x + size, point.y + size); dirty.offset(mapView.getScrollX(), mapView.getScrollY()); mapView.postInvalidate(dirty.left, dirty.top, dirty.right, dirty.bottom); if (!isMlsPointUpdate) { addToGridHash(obsPoint, point); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'System.lineSeparator()'\nThe code is: 'public void testConverter() throws Exception { String converterName = cs.getConverterName(\"application\/pdf\", \"text\/plain\"); assertEquals(\"pdf2text\", converterName); checkConverterAvailability(converterName); checkCommandAvailability(\"pdftotext\"); BlobHolder pdfBH = getBlobFromPath(\"test-docs\/hello.pdf\"); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(\"text\/plain\", blob.getMimeType()); assertTrue(blob.getLength() > 0); <START> String newline = System.getProperty(\"line.separator\"); <END> \/\/ System.lineSeparator() assertEquals(\"Hello from a PDF Document!\" + newline + newline + \"\\f\", blob.getString()); }'","output":"public void testConverter() throws Exception { String converterName = cs.getConverterName(\"application\/pdf\", \"text\/plain\"); assertEquals(\"pdf2text\", converterName); checkConverterAvailability(converterName); checkCommandAvailability(\"pdftotext\"); BlobHolder pdfBH = getBlobFromPath(\"test-docs\/hello.pdf\"); BlobHolder result = cs.convert(converterName, pdfBH, null); assertNotNull(result); List<Blob> blobs = result.getBlobs(); assertNotNull(blobs); assertEquals(1, blobs.size()); Blob blob = result.getBlob(); assertNotNull(blob); assertEquals(\"text\/plain\", blob.getMimeType()); assertTrue(blob.getLength() > 0); String newline = System.lineSeparator(); assertEquals(\"Hello from a PDF Document!\" + newline + newline + \"\\f\", blob.getString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Rename JOB_NAME constant APP_NAME'\nThe code is: 'private TestRunner() { this.configs = new HashMap<>(); this.inMemoryScope = RandomStringUtils.random(10, true, true); <START> configs.put(ApplicationConfig.APP_NAME, JOB_NAME); <END> \/\/ Rename JOB_NAME constant APP_NAME configs.put(JobConfig.PROCESSOR_ID(), \"1\"); configs.put(JobCoordinatorConfig.JOB_COORDINATOR_FACTORY, PassthroughJobCoordinatorFactory.class.getName()); configs.put(JobConfig.STARTPOINT_METADATA_STORE_FACTORY(), InMemoryMetadataStoreFactory.class.getCanonicalName()); configs.put(TaskConfig.GROUPER_FACTORY(), SingleContainerGrouperFactory.class.getName()); configs.put(JobConfig.JOB_NON_LOGGED_STORE_BASE_DIR(), new File(System.getProperty(\"java.io.tmpdir\"), this.inMemoryScope + \"-non-logged\").getAbsolutePath()); configs.put(JobConfig.JOB_LOGGED_STORE_BASE_DIR(), new File(System.getProperty(\"java.io.tmpdir\"), this.inMemoryScope + \"-logged\").getAbsolutePath()); addConfig(JobConfig.JOB_DEFAULT_SYSTEM(), JOB_DEFAULT_SYSTEM); addConfig(ClusterManagerConfig.JOB_HOST_AFFINITY_ENABLED, Boolean.FALSE.toString()); addConfig(InMemorySystemConfig.INMEMORY_SCOPE, inMemoryScope); addConfig(new InMemorySystemDescriptor(JOB_DEFAULT_SYSTEM).withInMemoryScope(inMemoryScope).toConfig()); }'","output":"private TestRunner() { this.configs = new HashMap<>(); this.inMemoryScope = RandomStringUtils.random(10, true, true); configs.put(ApplicationConfig.APP_NAME, APP_NAME); configs.put(JobConfig.PROCESSOR_ID(), \"1\"); configs.put(JobCoordinatorConfig.JOB_COORDINATOR_FACTORY, PassthroughJobCoordinatorFactory.class.getName()); configs.put(JobConfig.STARTPOINT_METADATA_STORE_FACTORY(), InMemoryMetadataStoreFactory.class.getCanonicalName()); configs.put(TaskConfig.GROUPER_FACTORY(), SingleContainerGrouperFactory.class.getName()); configs.put(JobConfig.JOB_NON_LOGGED_STORE_BASE_DIR(), new File(System.getProperty(\"java.io.tmpdir\"), this.inMemoryScope + \"-non-logged\").getAbsolutePath()); configs.put(JobConfig.JOB_LOGGED_STORE_BASE_DIR(), new File(System.getProperty(\"java.io.tmpdir\"), this.inMemoryScope + \"-logged\").getAbsolutePath()); addConfig(JobConfig.JOB_DEFAULT_SYSTEM(), JOB_DEFAULT_SYSTEM); addConfig(ClusterManagerConfig.JOB_HOST_AFFINITY_ENABLED, Boolean.FALSE.toString()); addConfig(InMemorySystemConfig.INMEMORY_SCOPE, inMemoryScope); addConfig(new InMemorySystemDescriptor(JOB_DEFAULT_SYSTEM).withInMemoryScope(inMemoryScope).toConfig()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'for printer. Session a local variable. need for putting in constructor'\nThe code is: 'public static String printLogical(List<PlanFragment> fragments, Session session) { <START> GraphvizPrinter printer = new GraphvizPrinter(session); <END> \/\/ for printer. Session a local variable. need for putting in constructor Map<PlanFragmentId, PlanFragment> fragmentsById = Maps.uniqueIndex(fragments, PlanFragment::getId); PlanNodeIdGenerator idGenerator = new PlanNodeIdGenerator(); StringBuilder output = new StringBuilder(); output.append(\"digraph logical_plan {\\n\"); for (PlanFragment fragment : fragments) { printFragmentNodes(output, fragment, idGenerator, session); } for (PlanFragment fragment : fragments) { fragment.getRoot().accept(new EdgePrinter(output, fragmentsById, idGenerator), null); } output.append(\"}\\n\"); return output.toString(); }'","output":"public static String printLogical(List<PlanFragment> fragments, Session session) { Map<PlanFragmentId, PlanFragment> fragmentsById = Maps.uniqueIndex(fragments, PlanFragment::getId); PlanNodeIdGenerator idGenerator = new PlanNodeIdGenerator(); StringBuilder output = new StringBuilder(); output.append(\"digraph logical_plan {\\n\"); for (PlanFragment fragment : fragments) { printFragmentNodes(output, fragment, idGenerator, session); } for (PlanFragment fragment : fragments) { fragment.getRoot().accept(new EdgePrinter(output, fragmentsById, idGenerator), null); } output.append(\"}\\n\"); return output.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'java.util.Map.Entry -> Map.Entry -> Entry is enough (already in other places)'\nThe code is: 'public Set<java.util.Map.Entry<String, Object>> entrySet() { <START> return new AbstractSet<Map.Entry<String,Object>>() { <END> \/\/ java.util.Map.Entry -> Map.Entry -> Entry is enough (already in other places) @Override public Iterator<Entry<String, Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String, Object> next() { Entry<String,Object> entry = iterator.next(); return new Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public int size() { return vars.size(); } }; }'","output":"public Set<Map.Entry<String, Object>> entrySet() { return new AbstractSet<Map.Entry<String,Object>>() { @Override public Iterator<Entry<String, Object>> iterator() { Iterator<Entry<String,Object>> iterator = vars.entrySet().iterator(); return new Iterator<Entry<String,Object>>() { @Override public boolean hasNext() { return iterator.hasNext(); } @Override public Entry<String, Object> next() { Entry<String,Object> entry = iterator.next(); return new Entry<String,Object>() { @Override public String getKey() { return entry.getKey(); } @Override public Object getValue() { return resolve(entry.getValue()); } @Override public Object setValue(Object value) { Object previous = entry.setValue(value); return resolve(previous); } }; } }; } @Override public int size() { return vars.size(); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Lets VectorUtils.of(...)'\nThe code is: 'public void scikitLearnExample() { Map<Integer, double[]> data = new HashMap<>(); double one = 1.; double two = 2.; data.put(0, new double[] {one, -1, 1}); data.put(2, new double[] {one, -2, -1}); data.put(3, new double[] {one, -3, -2}); data.put(4, new double[] {two, 1, 1}); data.put(5, new double[] {two, 2, 1}); data.put(6, new double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); <START> Vector observation = new DenseVector(new double[] {-0.8, -1}); <END> \/\/ Lets VectorUtils.of(...) Assert.assertEquals(one, model.apply(observation), PRECISION); }'","output":"public void scikitLearnExample() { Map<Integer, double[]> data = new HashMap<>(); double one = 1.; double two = 2.; data.put(0, new double[] {one, -1, 1}); data.put(2, new double[] {one, -2, -1}); data.put(3, new double[] {one, -3, -2}); data.put(4, new double[] {two, 1, 1}); data.put(5, new double[] {two, 2, 1}); data.put(6, new double[] {two, 3, 2}); GaussianNaiveBayesTrainer trainer = new GaussianNaiveBayesTrainer(); GaussianNaiveBayesModel model = trainer.fit( new LocalDatasetBuilder<>(data, 2), (k, v) -> VectorUtils.of(Arrays.copyOfRange(v, 1, v.length)), (k, v) -> v[0] ); Vector observation = VectorUtils.of(-0.8, -1); Assert.assertEquals(one, model.apply(observation), PRECISION); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need this here. adding this part of activation logic, worry it'\nThe code is: 'private SelectionListener downloadButtonListener(Composite parent) { return new SelectionListener() { @Override public void widgetSelected(SelectionEvent e) { MenuManager mgr = new MenuManager(); mgr.add(new CherryPickRevision(fChangeInfo.getUserSelectedRevision(), fGerritClient)); mgr.add(new CheckoutRevision(fChangeInfo.getUserSelectedRevision(), fGerritClient)); mgr.createContextMenu(parent).setVisible(true); <START> ActiveWorkspaceRevision.getInstance().enableQuickDiff(getSite(), fGerritClient, fChangeInfo); <END> \/\/ need this here. adding this part of activation logic, worry it } @Override public void widgetDefaultSelected(SelectionEvent e) { } }; }'","output":"private SelectionListener downloadButtonListener(Composite parent) { return new SelectionListener() { @Override public void widgetSelected(SelectionEvent e) { MenuManager mgr = new MenuManager(); mgr.add(new CherryPickRevision(fChangeInfo.getUserSelectedRevision(), fGerritClient)); mgr.add(new CheckoutRevision(fChangeInfo.getUserSelectedRevision(), fGerritClient)); mgr.createContextMenu(parent).setVisible(true); } @Override public void widgetDefaultSelected(SelectionEvent e) { } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion if (s.isEmpty()) {'\nThe code is: 'private static boolean isJavaIdentifier(String s) { <START> if (s.length() == 0) { <END> \/\/ suggestion if (s.isEmpty()) { return false; } int start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } int charCount = Character.charCount(start); for (int i = charCount; i < s.length(); i += charCount) { int codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }'","output":"private static boolean isJavaIdentifier(String s) { if (s.isEmpty()) { return false; } int start = s.codePointAt(0); if (!Character.isJavaIdentifierStart(start)) { return false; } int charCount = Character.charCount(start); for (int i = charCount; i < s.length(); i += charCount) { int codePoint = s.codePointAt(i); if (!Character.isJavaIdentifierPart(codePoint)) { return false; } } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'log pls'\nThe code is: 'public DDF transformUDF(String RExp, List<String> columns) throws DDFException { String sqlCmd = String.format(\"SELECT %s FROM %s\", RToSqlUdf(RExp, columns, this.getDDF().getSchema().getColumns()), this.getDDF().getTableName()); <START> System.out.println(\"Performing: \" + sqlCmd); <END> \/\/ log pls DDF newddf = this.getManager().sql2ddf(sqlCmd); if (this.getDDF().isMutable()) { return this.getDDF().updateInplace(newddf); } else { newddf.getMetaDataHandler().copyFactor(this.getDDF()); return newddf; } }'","output":"public DDF transformUDF(String RExp, List<String> columns) throws DDFException { String sqlCmd = String.format(\"SELECT %s FROM %s\", RToSqlUdf(RExp, columns, this.getDDF().getSchema().getColumns()), this.getDDF().getTableName()); DDF newddf = this.getManager().sql2ddf(sqlCmd); if (this.getDDF().isMutable()) { return this.getDDF().updateInplace(newddf); } else { newddf.getMetaDataHandler().copyFactor(this.getDDF()); return newddf; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a new method in AssociativeCommutativeCollection returns union of collections? In this way, shorter code in Visitors Transformers. Besides, next time want change contents of AssociativeCommutativeCollection, places change'\nThe code is: 'public void visit(BuiltinMap builtinMap) { for (java.util.Map.Entry<Term, Term> entry : builtinMap.getEntries().entrySet()) { entry.getKey().accept(this); entry.getValue().accept(this); } <START> for (KItem pattern : builtinMap.collectionPatterns()) { <END> \/\/ a new method in AssociativeCommutativeCollection returns union of collections? In this way, shorter code in Visitors Transformers. Besides, next time want change contents of AssociativeCommutativeCollection, places change pattern.accept(this); } for (Variable variable : builtinMap.collectionVariables()) { variable.accept(this); } for (Term term : builtinMap.collectionFunctions()) { term.accept(this); } visit((Collection) builtinMap); }'","output":"public void visit(BuiltinMap builtinMap) { for (java.util.Map.Entry<Term, Term> entry : builtinMap.getEntries().entrySet()) { entry.getKey().accept(this); entry.getValue().accept(this); } for (Term term : builtinMap.baseTerms()) { term.accept(this); } visit((Collection) builtinMap); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is called ETag (see CosmosAsyncItemResponse.java: public String getETag()). Etag. consistent this'\nThe code is: 'private Mono<Document> tryUpdateDocument(AsyncDocumentClient client, String collectionUri, Document document, int index) { BridgeInternal.setProperty(document, \"regionId\", index); BridgeInternal.setProperty(document, \"regionEndpoint\", client.getReadEndpoint()); RequestOptions options = new RequestOptions(); <START> options.setIfMatchEtag(document.getETag()); <END> \/\/ This is called ETag (see CosmosAsyncItemResponse.java: public String getETag()). Etag. consistent this return client.replaceDocument(document.getSelfLink(), document, null).onErrorResume(e -> { if (hasDocumentClientException(e, 412)) { return Mono.empty(); } return Mono.error(e); }).map(ResourceResponse::getResource); }'","output":"private Mono<Document> tryUpdateDocument(AsyncDocumentClient client, String collectionUri, Document document, int index) { BridgeInternal.setProperty(document, \"regionId\", index); BridgeInternal.setProperty(document, \"regionEndpoint\", client.getReadEndpoint()); RequestOptions options = new RequestOptions(); options.setIfMatchETag(document.getETag()); return client.replaceDocument(document.getSelfLink(), document, null).onErrorResume(e -> { if (hasDocumentClientException(e, 412)) { return Mono.empty(); } return Mono.error(e); }).map(ResourceResponse::getResource); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'authenticationAttribues --> authenticationAttributes'\nThe code is: 'public final Authentication getAuthentication() { if (!isEmpty()) { final String principalId = this.chainedAuthentication.get(0).getPrincipal().getId(); final MutablePrincipal compositePrincipal = new MutablePrincipal(principalId); <START> final Map<String, Object> authenticationAttribues = new Hashtable<String, Object>(); <END> \/\/ authenticationAttribues --> authenticationAttributes for (final Authentication authn : this.chainedAuthentication) { final Principal authenticatedPrincipal = authn.getPrincipal(); compositePrincipal.getAttributes().putAll(authenticatedPrincipal.getAttributes()); for (final String attrName : authn.getAttributes().keySet()) { if (!authenticationAttribues.containsKey(attrName)) { authenticationAttribues.put(attrName, authn.getAttributes().get(attrName)); } else { final Object oldValue = authenticationAttribues.remove(attrName); final Collection<Object> listOfValues = MultiFactorUtils.convertValueToCollection(oldValue); listOfValues.add(authn.getAttributes().get(attrName)); authenticationAttribues.put(attrName, listOfValues); } } } return new DefaultCompositeAuthentication(compositePrincipal, authenticationAttribues); } return null; }'","output":"public final Authentication getAuthentication() { if (!isEmpty()) { final String principalId = this.chainedAuthentication.get(0).getPrincipal().getId(); final MutablePrincipal compositePrincipal = new MutablePrincipal(principalId); final Map<String, Object> authenticationAttributes = new Hashtable<String, Object>(); for (final Authentication authn : this.chainedAuthentication) { final Principal authenticatedPrincipal = authn.getPrincipal(); compositePrincipal.getAttributes().putAll(authenticatedPrincipal.getAttributes()); for (final String attrName : authn.getAttributes().keySet()) { if (!authenticationAttributes.containsKey(attrName)) { authenticationAttributes.put(attrName, authn.getAttributes().get(attrName)); } else { final Object oldValue = authenticationAttributes.remove(attrName); final Collection<Object> listOfValues = MultiFactorUtils.convertValueToCollection(oldValue); listOfValues.add(authn.getAttributes().get(attrName)); authenticationAttributes.put(attrName, listOfValues); } } } return new DefaultCompositeAuthentication(compositePrincipal, authenticationAttributes); } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Minor nit: Missing line carriage @VisibleForTesting'\nThe code is: '<START> @VisibleForTesting void waitForBytesToFree(long minBytes, long startTimeMs) { <END> \/\/ Minor nit: Missing line carriage @VisibleForTesting try { logger.debug(\"Waiting for \" + (usedMemoryBytes + minBytes - maxMemoryBytes) + \" bytes to be free \" + startTimeMs); long remainingWaitTimeMs = maxWaitMs - (System.currentTimeMillis() - startTimeMs); if (remainingWaitTimeMs <= 0) { throw new InsufficientMemoryException(\"Requested memory of \" + minBytes + \" bytes could not be allocated. Using memory of \" + usedMemoryBytes + \" bytes from global pool of \" + maxMemoryBytes + \" bytes after waiting for \" + maxWaitMs + \"ms.\"); } sync.wait(remainingWaitTimeMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\"Interrupted allocation of \" + minBytes + \" bytes\", ie); } }'","output":"void waitForBytesToFree(long minBytes, long startTimeMs) { try { logger.debug(\"Waiting for \" + (usedMemoryBytes + minBytes - maxMemoryBytes) + \" bytes to be free \" + startTimeMs); long remainingWaitTimeMs = maxWaitMs - (System.currentTimeMillis() - startTimeMs); if (remainingWaitTimeMs <= 0) { throw new InsufficientMemoryException(\"Requested memory of \" + minBytes + \" bytes could not be allocated. Using memory of \" + usedMemoryBytes + \" bytes from global pool of \" + maxMemoryBytes + \" bytes after waiting for \" + maxWaitMs + \"ms.\"); } sync.wait(remainingWaitTimeMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\"Interrupted allocation of \" + minBytes + \" bytes\", ie); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '1. providing core level support protected. reason ti change private? 2. Create more method Multimap change here'\nThe code is: '<START> private String uploadPartCopy( <END> \/\/ 1. providing core level support protected. reason ti change private? 2. Create more method Multimap change here String bucketName, String objectName, String uploadId, int partNumber, Multimap<String, String> headerMap) throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException, InsufficientDataException, IOException, InvalidKeyException, ServerException, XmlParserException, ErrorResponseException, InternalException, InvalidResponseException { Multimap<String, String> queryParamMap = HashMultimap.create(); queryParamMap.put(\"partNumber\", Integer.toString(partNumber)); queryParamMap.put(\"uploadId\", uploadId); Response response = execute( Method.PUT, bucketName, objectName, getRegion(bucketName), headerMap, queryParamMap, \"\", 0); try (ResponseBody body = response.body()) { CopyPartResult result = Xml.unmarshal(CopyPartResult.class, body.charStream()); return result.etag(); } }'","output":"protected String uploadPartCopy( String bucketName, String objectName, String uploadId, int partNumber, Multimap<String, String> headerMap) throws InvalidBucketNameException, IllegalArgumentException, NoSuchAlgorithmException, InsufficientDataException, IOException, InvalidKeyException, ServerException, XmlParserException, ErrorResponseException, InternalException, InvalidResponseException { Multimap<String, String> queryParamMap = HashMultimap.create(); queryParamMap.put(\"partNumber\", Integer.toString(partNumber)); queryParamMap.put(\"uploadId\", uploadId); Response response = execute( Method.PUT, bucketName, objectName, getRegion(bucketName), headerMap, queryParamMap, \"\", 0); try (ResponseBody body = response.body()) { CopyPartResult result = Xml.unmarshal(CopyPartResult.class, body.charStream()); return result.etag(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Arrays.asList(...) for short lists'\nThe code is: 'public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( <START> IntStream.range(0, 4) <END> \/\/ Arrays.asList(...) for short lists .boxed() .collect(Collectors.toList()) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = IntStream.range(0, 4) .boxed() .collect(Collectors.toList()); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }'","output":"public void shouldConcatenateOneEmptyAndOneNonEmptyLists() { final List<Integer> list = Collections.unmodifiableList( Arrays.asList(0, 1, 2, 3, 4) ); final List<Integer> actual = ListOps.concat(list, EMPTY_LIST); final List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4); assertNotNull(actual); assertFalse(actual.isEmpty()); assertEquals(expected, actual); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move this logic certificatemanagerserviceImpl class'\nThe code is: 'public String getAuthorityKeyID() { if(authorityKeyID == null){ byte[] authorityKey = x509Cert.getExtensionValue(AUTHORITY_KEY_ID); try { if (authorityKey != null) { DERDecoder extValA = new DERDecoder(authorityKey); extValA.skip(AUTHORITY_KEY_POSITION); <START> int length = authorityKey.length - AUTHORITY_KEY_POSITION; <END> \/\/ move this logic certificatemanagerserviceImpl class authorityKeyID = Hex.encodeHexString(extValA.getBytes(length)); } } catch (WSSecurityException e) { LOG.error(\"Unable to convert AIK into human readable {} \", e.getLocalizedMessage(), e); } } return StringUtils.isEmpty(authorityKeyID) ? EMPTY_FIELD : authorityKeyID; }'","output":"public String getAuthorityKeyID() { return authorityKeyID; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'intentional error'\nThe code is: 'public boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { <START> log.error(\"Failed to initialize Vds on up.\", e); <END> \/\/ intentional error } } }); } return isSucceeded; }'","output":"public boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(\"Failed to initialize Vds on up: {}\", e.getMessage()); log.debug(\"Exception\", e); } } }); } return isSucceeded; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'align rest of codebase, please leave final keyword of local variables'\nThe code is: 'private boolean hasValidSignature(SignableSAMLObject samlObject, Saml2AuthenticationToken token) { if (!samlObject.isSigned()) { if (logger.isDebugEnabled()) { logger.debug(\"SAML object is not signed, no signatures found\"); } return false; } <START> final List<X509Certificate> verificationKeys = getVerificationCertificates(token); <END> \/\/ align rest of codebase, please leave final keyword of local variables if (verificationKeys.isEmpty()) { return false; } for (X509Certificate certificate : verificationKeys) { final Credential credential = getVerificationCredential(certificate); try { SignatureValidator.validate(samlObject.getSignature(), credential); if (logger.isDebugEnabled()) { logger.debug(\"Valid signature found in SAML object:\"+samlObject.getClass().getName()); } return true; } catch (SignatureException ignored) { if (logger.isTraceEnabled()) { logger.trace(\"Signature validation failed with cert:\"+certificate.toString(), ignored); } else if (logger.isDebugEnabled()) { logger.debug(\"Signature validation failed with cert:\"+certificate.toString()); } } } return false; }'","output":"private boolean hasValidSignature(SignableSAMLObject samlObject, Saml2AuthenticationToken token) { if (!samlObject.isSigned()) { if (logger.isDebugEnabled()) { logger.debug(\"SAML object is not signed, no signatures found\"); } return false; } List<X509Certificate> verificationKeys = getVerificationCertificates(token); if (verificationKeys.isEmpty()) { return false; } for (X509Certificate certificate : verificationKeys) { Credential credential = getVerificationCredential(certificate); try { SignatureValidator.validate(samlObject.getSignature(), credential); if (logger.isDebugEnabled()) { logger.debug(\"Valid signature found in SAML object:\"+samlObject.getClass().getName()); } return true; } catch (SignatureException ignored) { if (logger.isTraceEnabled()) { logger.trace(\"Signature validation failed with cert:\"+certificate.toString(), ignored); } else if (logger.isDebugEnabled()) { logger.debug(\"Signature validation failed with cert:\"+certificate.toString()); } } } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'written assertThat(logList).containsExactly(logEntry2, logEntry1). 3 previous checks once. :) I admit I more advanced assertions myself..'\nThe code is: 'public static void testComparator() { final LogEntry logEntry1 = new LogEntry(100, LogType.FOUND_IT, \"logEntry1 is older than logEntry2\"); final LogEntry logEntry2 = new LogEntry(200, LogType.FOUND_IT, \"logEntry2 is more recent than logEntry1\"); final List<LogEntry> logList = new ArrayList<>(2); logList.add(logEntry1); logList.add(logEntry2); Collections.sort(logList, LogEntry.DESCENDING_DATE_COMPARATOR); <START> assertThat(logList).hasSize(2); <END> \/\/ written assertThat(logList).containsExactly(logEntry2, logEntry1). 3 previous checks once. :) I admit I more advanced assertions myself.. assertThat(logList.get(0)).isEqualTo(logEntry2); assertThat(logList.get(1)).isEqualTo(logEntry1); }'","output":"public static void testComparator() { final LogEntry logEntry1 = new LogEntry(100, LogType.FOUND_IT, \"logEntry1 is older than logEntry2\"); final LogEntry logEntry2 = new LogEntry(200, LogType.FOUND_IT, \"logEntry2 is more recent than logEntry1\"); final List<LogEntry> logList = new ArrayList<>(2); logList.add(logEntry1); logList.add(logEntry2); Collections.sort(logList, LogEntry.DESCENDING_DATE_COMPARATOR); assertThat(logList).containsExactly(logEntry2, logEntry1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please rename objectoutputstream camelcase naming'\nThe code is: 'private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <START> ObjectOutputStream objectoutputstream = new ObjectOutputStream(byteArrayOutputStream); <END> \/\/ Please rename objectoutputstream camelcase naming objectoutputstream.writeObject(result); objectoutputstream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(\"Could not read resource \" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }'","output":"private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(result); objectOutputStream.flush(); byte[] bytes = byteArrayOutputStream.toByteArray(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes)); Result fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(result, fromStream); InputStream resource = getClass().getResourceAsStream(getName()); assertNotNull(\"Could not read resource \" + getName(), resource); objectInputStream = new ObjectInputStream(resource); fromStream = (Result) objectInputStream.readObject(); assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Consider adding additional layer of abstraction for this block. This similar lines other methods'\nThe code is: 'public PalantirContent updateMapPosition(double lat, double lng, int zoom) { waitForElementVisibleByElement(mapFrame); driver.switchTo().activeElement(); JavascriptExecutor jsexec = (JavascriptExecutor) driver; driver.manage().timeouts().setScriptTimeout(20, TimeUnit.SECONDS); Object res = jsexec.executeAsyncScript( PalantirContent.PONTO_UPDATEPOSITION, lat, lng, zoom ); PalantirContent handle = new PalantirContent(); <START> try { <END> \/\/ Consider adding additional layer of abstraction for this block. This similar lines other methods JSONObject json = new JSONObject(res.toString()); handle.success = json.getString(PalantirContent.PONTO_MSG_SUCCESS); handle.responseCode = json.getString(PalantirContent.PONTO_MSG_RESPONSECODE); handle.message = json.getString(PalantirContent.PONTO_MSG_MESSAGE); PageObjectLogging.log( \"updateMapPosition\", handle.message, true ); }catch (JSONException e) { PageObjectLogging.log( \"updateMapPosition\", \"Map position was not changed\", true); } return handle; }'","output":"public PalantirContent updateMapPosition(double lat, double lng, int zoom) { waitForElementVisibleByElement(mapFrame); JavascriptExecutor jsexec = (JavascriptExecutor) driver; driver.manage().timeouts().setScriptTimeout(20, TimeUnit.SECONDS); Object res = jsexec.executeAsyncScript( PalantirContent.PONTO_UPDATEPOSITION, lat, lng, zoom ); return getResponse(res, \"updateMapPosition\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need this section in anymore'\nThe code is: 'public void searchedAddress(VoterInfo voterInfo) { app.setVoterInfo(voterInfo); <START> if (voterInfo != null) { <END> \/\/ Do need this section in anymore Election el = voterInfo.election; String show = \"Election:\\n\" + el.id + \": \" + el.name + \"\\n\" + el.electionDay + \"\\n\\n\"; State state = voterInfo.state.get(0); show += \"State: \" + state.name + \"\\n\"; show += \"Sources:\\n\" + state.sources.get(0).name; Log.d(\"HomeActivity\", \"Result: \" + show); } else { Log.d(\"HomeActivity\", \"VoterInfo set to null\"); } }'","output":"public void searchedAddress(VoterInfo voterInfo) { app.setVoterInfo(voterInfo); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else { is redundant'\nThe code is: 'public static FunctionMetadata removeTypeParameters(FunctionMetadata metadata) { ImmutableList.Builder<TypeSignature> argumentsBuilder = ImmutableList.builder(); for (TypeSignature typeSignature : metadata.getArgumentTypes()) { argumentsBuilder.add(removeTypeParameters(typeSignature)); } if (metadata.getOperatorType().isPresent()) { return new FunctionMetadata( metadata.getOperatorType().get(), argumentsBuilder.build(), metadata.getReturnType(), metadata.getFunctionKind(), metadata.isDeterministic(), metadata.isCalledOnNullInput()); } <START> else { <END> \/\/ else { is redundant return new FunctionMetadata( metadata.getName(), argumentsBuilder.build(), metadata.getReturnType(), metadata.getFunctionKind(), metadata.isDeterministic(), metadata.isCalledOnNullInput()); } }'","output":"private static FunctionMetadata removeTypeParameters(FunctionMetadata metadata) { ImmutableList.Builder<TypeSignature> argumentsBuilder = ImmutableList.builder(); for (TypeSignature typeSignature : metadata.getArgumentTypes()) { argumentsBuilder.add(removeTypeParameters(typeSignature)); } if (metadata.getOperatorType().isPresent()) { return new FunctionMetadata( metadata.getOperatorType().get(), argumentsBuilder.build(), metadata.getReturnType(), metadata.getFunctionKind(), metadata.isDeterministic(), metadata.isCalledOnNullInput()); } return new FunctionMetadata( metadata.getName(), argumentsBuilder.build(), metadata.getReturnType(), metadata.getFunctionKind(), metadata.isDeterministic(), metadata.isCalledOnNullInput()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If all, debug level. error level'\nThe code is: 'public Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupRelationNotAllowed, GroupRelationAlreadyExists { Vo vo = this.getVo(sess, parentGroup); group = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group); try { parentGroup = createGroupUnion(sess, parentGroup, group, true); } catch (WrongAttributeValueException | WrongReferenceAttributeValueException e) { <START> log.debug(\"Exception thrown in createGroup method, while it shouldn't be thrown. Cause:{}\",e); <END> \/\/ If all, debug level. error level } catch (GroupNotExistsException e) { throw new ConsistencyErrorException(\"Database consistency error while creating group: {}\",e); } getPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup); return group; }'","output":"public Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupRelationNotAllowed, GroupRelationAlreadyExists { Vo vo = this.getVo(sess, parentGroup); group = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group); try { parentGroup = createGroupUnion(sess, parentGroup, group, true); } catch (WrongAttributeValueException | WrongReferenceAttributeValueException e) { log.error(\"Exception thrown in createGroup method, while it shouldn't be thrown. Cause:{}\",e); } catch (GroupNotExistsException e) { throw new ConsistencyErrorException(\"Database consistency error while creating group: {}\",e); } getPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup); return group; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: ''L''\nThe code is: 'private static ArtifactProxy createProxy(final String artGuid, final String artifactName, final long branchGuid, final String branchName) { return new ArtifactProxy() { @Override public IOseeBranch getBranch() { return TokenFactory.createBranch(branchGuid, branchName); } @Override public String getName() { return artifactName; } @Override public String getGuid() { return artGuid; } @Override public ArtifactType getArtifactType() { return null; } @Override public boolean isAttributeTypeValid(IAttributeType attributeType) { return false; } @Override public Collection<RelationType> getValidRelationTypes() { return null; } @Override public Collection<ArtifactProxy> getHierarchy() { return null; } @Override public IBasicArtifact<?> getObject() { return null; } @Override public Long getUuid() { <START> return new Long(0); <END> \/\/ 'L' } }; }'","output":"private static ArtifactProxy createProxy(final String artGuid, final String artifactName, final long branchGuid, final String branchName) { return new ArtifactProxy() { @Override public IOseeBranch getBranch() { return TokenFactory.createBranch(branchGuid, branchName); } @Override public String getName() { return artifactName; } @Override public String getGuid() { return artGuid; } @Override public ArtifactType getArtifactType() { return null; } @Override public boolean isAttributeTypeValid(IAttributeType attributeType) { return false; } @Override public Collection<RelationType> getValidRelationTypes() { return null; } @Override public Collection<ArtifactProxy> getHierarchy() { return null; } @Override public IBasicArtifact<?> getObject() { return null; } @Override public Long getUuid() { return 0L; } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logging infrastructure set log level accordingly? Include in log4j2.xml: <Logger name=\"org.jabref.logic.importer.fetcher\" level=\"DEBUG\"> <AppenderRef ref=\"CONSOLE\"\/> <\/Logger>'\nThe code is: 'private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { boolean fetchIDs = false; boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); <START> System.out.println(\"parsing xml\"); <END> \/\/ logging infrastructure set log level accordingly? Include in log4j2.xml: <Logger name=\"org.jabref.logic.importer.fetcher\" level=\"DEBUG\"> <AppenderRef ref=\"CONSOLE\"\/> <\/Logger> fetchLoop: while (streamReader.hasNext()) { int event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(\"Count\")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(\"IdList\")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(\"IdList\")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(\"Unable to get PubMed IDs\", Localization.lang(\"Unable to get PubMed IDs\"), e); } catch (XMLStreamException e) { throw new FetcherException(\"Error while parsing ID list\", Localization.lang(\"Error while parsing ID list\"), e); } }'","output":"private List<String> getPubMedIdsFromQuery(String query) throws FetcherException { boolean fetchIDs = false; boolean firstOccurrenceOfCount = false; List<String> idList = new ArrayList<>(); try { URL ncbi = createSearchUrl(query); XMLInputFactory inputFactory = XMLInputFactory.newFactory(); XMLStreamReader streamReader = inputFactory.createXMLStreamReader(ncbi.openStream()); fetchLoop: while (streamReader.hasNext()) { int event = streamReader.getEventType(); switch (event) { case XMLStreamConstants.START_ELEMENT: if (streamReader.getName().toString().equals(\"Count\")) { firstOccurrenceOfCount = true; } if (streamReader.getName().toString().equals(\"IdList\")) { fetchIDs = true; } break; case XMLStreamConstants.CHARACTERS: if (firstOccurrenceOfCount) { numberOfResultsFound = Integer.parseInt(streamReader.getText()); firstOccurrenceOfCount = false; } if (fetchIDs) { idList.add(streamReader.getText()); } break; case XMLStreamConstants.END_ELEMENT: if (streamReader.getName().toString().equals(\"IdList\")) { break fetchLoop; } } streamReader.next(); } streamReader.close(); return idList; } catch (IOException | URISyntaxException e) { throw new FetcherException(\"Unable to get PubMed IDs\", Localization.lang(\"Unable to get PubMed IDs\"), e); } catch (XMLStreamException e) { throw new FetcherException(\"Error while parsing ID list\", Localization.lang(\"Error while parsing ID list\"), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is EC policy patch again. I abfs needs all'\nThe code is: 'public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); <START> assertFalse(ls.isDisplayECPolicy()); <END> \/\/ This is EC policy patch again. I abfs needs all }'","output":"public void processOptionsNone() throws IOException { LinkedList<String> options = new LinkedList<String>(); Ls ls = new Ls(); ls.processOptions(options); assertFalse(ls.isPathOnly()); assertTrue(ls.isDirRecurse()); assertFalse(ls.isHumanReadable()); assertFalse(ls.isRecursive()); assertFalse(ls.isOrderReverse()); assertFalse(ls.isOrderSize()); assertFalse(ls.isOrderTime()); assertFalse(ls.isUseAtime()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'isEmpty'\nThe code is: 'public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + \"\/\" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(\"Check the representation file test data.\", analysis); assertTrue(\"Check the migration logic.\", ((XMLResource) <START> analysis.eResource()).getEObjectToExtensionMap().size() == 0); <END> \/\/ isEmpty String version = analysis.getVersion(); assertTrue(\"Before save, the migration framework will return true even if the migration has been done during load.\", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(\"The version tag should now be set telling that the migration was done.\", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, \"After migration, the resource should not contains any DRepresentationContainer.\"); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }'","output":"public void testDRepresentationContainerRemovalMigrationDone() { ResourceSet set = new ResourceSetImpl(); DAnalysis analysis = null; try { analysis = (DAnalysis) ModelUtils.load(URI.createPlatformResourceURI(TEMPORARY_PROJECT_NAME + \"\/\" + SESSION_RESOURCE_NAME, true), set); } catch (IOException e) { failCheckData(); } assertNotNull(\"Check the representation file test data.\", analysis); assertTrue(\"Check the migration logic.\", ((XMLResource) analysis.eResource()).getEObjectToExtensionMap().isEmpty()); String version = analysis.getVersion(); assertTrue(\"Before save, the migration framework will return true even if the migration has been done during load.\", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); try { analysis.eResource().save(Collections.emptyMap()); } catch (IOException e) { failCheckData(); } version = analysis.getVersion(); assertFalse(\"The version tag should now be set telling that the migration was done.\", RepresentationsFileMigrationService.getInstance().isMigrationNeeded(Version.parseVersion(version))); checkFileContainsDRepresentationContainer(analysis.eResource().getURI(), false, \"After migration, the resource should not contains any DRepresentationContainer.\"); assertFalse(getErrorLoggersMessage(), doesAnErrorOccurs()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'try resource'\nThe code is: 'public static FileReftableDatabase convertFrom(FileRepository repo, File refstackName, boolean writeLogs) throws IOException { FileReftableDatabase newDb = null; try { File reftableDir = new File(repo.getDirectory(), Constants.REFTABLE); if (!reftableDir.isDirectory()) { reftableDir.mkdir(); } <START> FileReftableStack stack = new FileReftableStack(refstackName, <END> \/\/ try resource reftableDir, null, () -> repo.getConfig()); stack.addReftable(rw -> writeConvertTable(repo, rw, writeLogs)); stack.close(); } catch (Exception e) { refstackName.delete(); throw e; } return newDb; }'","output":"public static FileReftableDatabase convertFrom(FileRepository repo, File refstackName, boolean writeLogs) throws IOException { FileReftableDatabase newDb = null; try { File reftableDir = new File(repo.getDirectory(), Constants.REFTABLE); if (!reftableDir.isDirectory()) { reftableDir.mkdir(); } try (FileReftableStack stack = new FileReftableStack(refstackName, reftableDir, null, () -> repo.getConfig())) { stack.addReftable(rw -> writeConvertTable(repo, rw, writeLogs)); } } catch (Exception e) { refstackName.delete(); throw e; } return newDb; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);'\nThe code is: 'void pushSubmissionAndAttachments(Path submissionFile, List<Path> attachments, RunnerStatus runnerStatus, PushToAggregateTracker tracker, int submissionNumber, int totalSubmissions, int part, int parts) { if (runnerStatus.isCancelled()) { tracker.trackCancellation(\"Sending submissions \" + submissionNumber + \" of \" + totalSubmissions); return; } tracker.trackStartSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts); Response<XmlElement> response = http.execute(server.getPushSubmissionRequest( submissionFile, attachments )); <START> for (InputStream stream : server.getFileStreams()) { closeInputStream(stream); } <END> \/\/ suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream); server.getFileStreams().clear(); if (response.isSuccess()) tracker.trackEndSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts); else tracker.trackErrorSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts, response); }'","output":"void pushSubmissionAndAttachments(Path submissionFile, List<Path> attachments, RunnerStatus runnerStatus, PushToAggregateTracker tracker, int submissionNumber, int totalSubmissions, int part, int parts) { if (runnerStatus.isCancelled()) { tracker.trackCancellation(\"Sending submissions \" + submissionNumber + \" of \" + totalSubmissions); return; } tracker.trackStartSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts); Response<XmlElement> response = http.execute(server.getPushSubmissionRequest( submissionFile, attachments )); if (response.isSuccess()) tracker.trackEndSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts); else tracker.trackErrorSendingSubmissionAndAttachments(submissionNumber, totalSubmissions, part, parts, response); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'order of parameters other way? argument is \"expected\", this mislead assertion error'\nThe code is: 'public void addressCloneTest() throws Exception { Address address = new Address(\"172.16.16.1\", 4223); AddressConstructor constructor = new AddressConstructor(Address.class); Address clonedAddress = (Address) constructor.createNew(address); <START> assertEquals(clonedAddress.getHost(), address.getHost()); <END> \/\/ order of parameters other way? argument is \"expected\", this mislead assertion error assertEquals(clonedAddress.getPort(), address.getPort()); assertEquals(clonedAddress.getInetAddress(), address.getInetAddress()); assertEquals(clonedAddress.getInetSocketAddress(), address.getInetSocketAddress()); }'","output":"public void addressCloneTest() throws Exception { Address address = new Address(\"172.16.16.1\", 4223); AddressConstructor constructor = new AddressConstructor(Address.class); Address clonedAddress = (Address) constructor.createNew(address); assertEquals(address.getHost(), clonedAddress.getHost()); assertEquals(address.getPort(), clonedAddress.getPort()); assertEquals(address.getInetAddress(), clonedAddress.getInetAddress()); assertEquals(address.getInetSocketAddress(), clonedAddress.getInetSocketAddress()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a need for this line'\nThe code is: 'public void editFeedbackResponseComment(String commentIdSuffix, String newCommentText) { <START> executeScript(\"scroll(0,300)\"); <END> \/\/ a need for this line WebElement commentRow = waitForElementPresence(By.id(\"responseCommentRow\" + commentIdSuffix)); click(commentRow.findElements(By.tagName(\"a\")).get(1)); WebElement commentEditForm = browser.driver.findElement(By.id(\"responseCommentEditForm\" + commentIdSuffix)); fillRichTextEditor(\"responsecommenttext\" + commentIdSuffix, newCommentText); click(commentEditForm.findElement(By.className(\"col-sm-offset-5\")).findElement(By.tagName(\"a\"))); ThreadHelper.waitFor(1000); }'","output":"public void editFeedbackResponseComment(String commentIdSuffix, String newCommentText) { WebElement commentRow = waitForElementPresence(By.id(\"responseCommentRow\" + commentIdSuffix)); click(commentRow.findElements(By.tagName(\"a\")).get(1)); WebElement commentEditForm = browser.driver.findElement(By.id(\"responseCommentEditForm\" + commentIdSuffix)); fillRichTextEditor(\"responsecommenttext\" + commentIdSuffix, newCommentText); click(commentEditForm.findElement(By.className(\"col-sm-offset-5\")).findElement(By.tagName(\"a\"))); ThreadHelper.waitFor(1000); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(constructor criterion)'\nThe code is: 'public void copyAllLeftToRight(Iterable<? extends Diff> differences, Monitor monitor) { long start = 0; if (LOGGER.isDebugEnabled()) { start = System.currentTimeMillis(); LOGGER.debug(\"copyAllLeftToRight(differences, monitor) - Start\"); } ComputeDiffsToMerge computer = new <START> ComputeDiffsToMerge(false, registry, null); <END> \/\/ (constructor criterion) for (Diff diff : Iterables.filter(differences, filter)) { if (!AbstractMerger.isInTerminalState(diff)) { Set<Diff> diffsToMerge = computer.getAllDiffsToMergeFor(diff); for (Diff toMerge : diffsToMerge) { if (!AbstractMerger.isInTerminalState(toMerge)) { final IMerger merger = registry.getHighestRankingMerger(toMerge); if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"copyAllLeftToRight - Selected merger: \" + merger.getClass().getSimpleName()); } merger.copyLeftToRight(toMerge, monitor); } } } } if (LOGGER.isDebugEnabled()) { long duration = System.currentTimeMillis() - start; LOGGER.debug(\"copyAllLeftToRight(differences, monitor) - Stop - Time spent: \" + duration + \"ms\"); } }'","output":"public void copyAllLeftToRight(Iterable<? extends Diff> differences, Monitor monitor) { long start = 0; if (LOGGER.isDebugEnabled()) { start = System.currentTimeMillis(); LOGGER.debug(\"copyAllLeftToRight(differences, monitor) - Start\"); } ComputeDiffsToMerge computer = new ComputeDiffsToMerge(false, registry); for (Diff diff : Iterables.filter(differences, filter)) { if (!AbstractMerger.isInTerminalState(diff)) { Set<Diff> diffsToMerge = computer.getAllDiffsToMerge(diff); for (Diff toMerge : diffsToMerge) { if (!AbstractMerger.isInTerminalState(toMerge)) { final IMerger merger = registry.getHighestRankingMerger(toMerge); if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"copyAllLeftToRight - Selected merger: \" + merger.getClass().getSimpleName()); } merger.copyLeftToRight(toMerge, monitor); } } } } if (LOGGER.isDebugEnabled()) { long duration = System.currentTimeMillis() - start; LOGGER.debug(\"copyAllLeftToRight(differences, monitor) - Stop - Time spent: \" + duration + \"ms\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'extra space'\nThe code is: 'private IFolder copyExperiment(final String newName) { WorkspaceModifyOperation operation = new WorkspaceModifyOperation() { @Override public void execute(IProgressMonitor monitor) throws CoreException { try { monitor.beginTask(\"\", 1000); if (monitor.isCanceled()) { throw new OperationCanceledException(); } <START> fExperiment.copy(newName, fExperimentFolder, true); <END> \/\/ extra space if (monitor.isCanceled()) { throw new OperationCanceledException(); } } finally { monitor.done(); } } }; try { PlatformUI.getWorkbench().getProgressService().busyCursorWhile(operation); } catch (InterruptedException exception) { return null; } catch (InvocationTargetException exception) { MessageDialog.openError(getShell(), \"\", NLS.bind(\"\", exception.getTargetException().getMessage())); return null; } catch (RuntimeException exception) { return null; } return fExperiment.getResource(); }'","output":"private IFolder copyExperiment(final String newName) { WorkspaceModifyOperation operation = new WorkspaceModifyOperation() { @Override public void execute(IProgressMonitor monitor) throws CoreException { try { monitor.beginTask(\"\", 1000); if (monitor.isCanceled()) { throw new OperationCanceledException(); } fExperiment.copy(newName, true); if (monitor.isCanceled()) { throw new OperationCanceledException(); } } finally { monitor.done(); } } }; try { PlatformUI.getWorkbench().getProgressService().busyCursorWhile(operation); } catch (InterruptedException exception) { return null; } catch (InvocationTargetException exception) { MessageDialog.openError(getShell(), \"\", NLS.bind(\"\", exception.getTargetException().getMessage())); return null; } catch (RuntimeException exception) { return null; } return fExperiment.getResource(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need change this method signature. I leave this method private'\nThe code is: '<START> protected File writeMergedFile(MergeResult<RawText> result) <END> \/\/ need change this method signature. I leave this method private throws FileNotFoundException, IOException { MergeFormatter fmt = new MergeFormatter(); File of = null; FileOutputStream fos; if (!inCore) { File workTree = db.getWorkTree(); if (workTree == null) throw new UnsupportedOperationException(); of = new File(workTree, tw.getPathString()); File parentFolder = of.getParentFile(); if (!parentFolder.exists()) parentFolder.mkdirs(); fos = new FileOutputStream(of); try { fmt.formatMerge(fos, result, Arrays.asList(commitNames), Constants.CHARACTER_ENCODING); } finally { fos.close(); } } else if (!result.containsConflicts()) { of = File.createTempFile(\"merge_\", \"_temp\", null); fos = new FileOutputStream(of); try { fmt.formatMerge(fos, result, Arrays.asList(commitNames), Constants.CHARACTER_ENCODING); } finally { fos.close(); } } return of; }'","output":"private File writeMergedFile(MergeResult<RawText> result) throws FileNotFoundException, IOException { MergeFormatter fmt = new MergeFormatter(); File of = null; FileOutputStream fos; if (!inCore) { File workTree = db.getWorkTree(); if (workTree == null) throw new UnsupportedOperationException(); of = new File(workTree, tw.getPathString()); File parentFolder = of.getParentFile(); if (!parentFolder.exists()) parentFolder.mkdirs(); fos = new FileOutputStream(of); try { fmt.formatMerge(fos, result, Arrays.asList(commitNames), Constants.CHARACTER_ENCODING); } finally { fos.close(); } } else if (!result.containsConflicts()) { of = File.createTempFile(\"merge_\", \"_temp\", null); fos = new FileOutputStream(of); try { fmt.formatMerge(fos, result, Arrays.asList(commitNames), Constants.CHARACTER_ENCODING); } finally { fos.close(); } } return of; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this truststorePasswordAlias instead of string'\nThe code is: 'public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(\"basedir\"); if (basedir == null) { basedir = new File(\".\").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, \"target\", \"test-classes\", \"keystores\", \"server-keystore.jks\"); String identityKeystoreType = \"jks\"; char[] identityKeystorePassword = \"horton\".toCharArray(); char[] identityKeyPassphrase = \"horton\".toCharArray(); String identityKeyAlias = \"server\"; Path truststorePath = Paths.get(basedir, \"target\", \"test-classes\", \"keystores\", \"server-truststore.jks\"); String truststoreType = \"jks\"; String truststorePasswordAlias = \"trust_store_password\"; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); <START> expect(aliasService.getPasswordFromAliasForGateway(eq(\"trust_store_password\"))).andReturn(null).atLeastOnce(); <END> \/\/ I this truststorePasswordAlias instead of string KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias(identityKeyAlias)); assertFalse(sslContextFactory.getTrustStore().containsAlias(identityKeyAlias)); verify(config, aliasService, keystoreService); }'","output":" public void TestBuildSslContextFactoryExplicitTrustStoreNullPassword() throws Exception { String basedir = System.getProperty(\"basedir\"); if (basedir == null) { basedir = new File(\".\").getCanonicalPath(); } Path identityKeystorePath = Paths.get(basedir, \"target\", \"test-classes\", \"keystores\", \"server-keystore.jks\"); String identityKeystoreType = \"jks\"; char[] identityKeystorePassword = \"horton\".toCharArray(); char[] identityKeyPassphrase = \"horton\".toCharArray(); String identityKeyAlias = \"server\"; Path truststorePath = Paths.get(basedir, \"target\", \"test-classes\", \"keystores\", \"server-truststore.jks\"); String truststoreType = \"jks\"; String truststorePasswordAlias = \"trust_store_password\"; GatewayConfig config = createGatewayConfig(true, true, identityKeystorePath, identityKeystoreType, identityKeyAlias, truststorePath, truststoreType, truststorePasswordAlias); AliasService aliasService = createMock(AliasService.class); expect(aliasService.getGatewayIdentityKeystorePassword()).andReturn(identityKeystorePassword).atLeastOnce(); expect(aliasService.getGatewayIdentityPassphrase()).andReturn(identityKeyPassphrase).atLeastOnce(); expect(aliasService.getPasswordFromAliasForGateway(eq(truststorePasswordAlias))).andReturn(null).atLeastOnce(); KeystoreService keystoreService = createMock(KeystoreService.class); replay(config, aliasService, keystoreService); JettySSLService sslService = new JettySSLService(); sslService.setAliasService(aliasService); sslService.setKeystoreService(keystoreService); Object result = sslService.buildSslContextFactory(config); assertNotNull(result); assertTrue(result instanceof SslContextFactory); SslContextFactory sslContextFactory = (SslContextFactory) result; sslContextFactory.start(); assertEquals(identityKeystorePath.toUri().toString(), sslContextFactory.getKeyStorePath()); assertEquals(identityKeystoreType, sslContextFactory.getKeyStoreType()); assertNotNull(sslContextFactory.getKeyStore()); assertEquals(truststorePath.toUri().toString(), sslContextFactory.getTrustStorePath()); assertEquals(truststoreType, sslContextFactory.getTrustStoreType()); assertNotNull(sslContextFactory.getTrustStore()); assertTrue(sslContextFactory.getKeyStore().containsAlias"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Collections.singletonList(range1));'\nThe code is: 'public void testValidateOverlapWithOtherPools( String range1From, String range1To, String range2From, String range2To, boolean overlapping) { MacRange range1 = new MacRange(); range1.setMacFrom(range1From); range1.setMacTo(range1To); MacRange range2 = new MacRange(); range2.setMacFrom(range2From); range2.setMacTo(range2To); <START> PARAM_POOL.setId(Guid.newGuid()); PARAM_POOL.setName(\"p1\"); PARAM_POOL.setRanges(Collections.singletonList(range1)); <END> \/\/ MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Collections.singletonList(range1)); MacPool macPool2 = new MacPool(); macPool2.setId(Guid.newGuid()); macPool2.setName(\"p2\"); macPool2.setRanges(Collections.singletonList(range2)); when(macPoolDao.getAll()).thenReturn(Collections.singletonList(macPool2)); MacPool oldMacPool = new MacPool(); oldMacPool.setId(Guid.newGuid()); when(macPoolDao.get(any())).thenReturn(oldMacPool); when(macPoolPerCluster.isDuplicateMacAddressesAllowed(any())).thenReturn(false); assertEquals(!overlapping, command.validate()); }'","output":"public void testValidateOverlapWithOtherPools( String range1From, String range1To, String range2From, String range2To, boolean overlapping) { MacRange range1 = new MacRange(); range1.setMacFrom(range1From); range1.setMacTo(range1To); MacRange range2 = new MacRange(); range2.setMacFrom(range2From); range2.setMacTo(range2To); command.getParameters().getMacPool().setId(Guid.newGuid()); command.getParameters().getMacPool().setName(\"p1\"); command.getParameters().getMacPool().setRanges(Collections.singletonList(range1)); MacPool macPool2 = new MacPool(); macPool2.setId(Guid.newGuid()); macPool2.setName(\"p2\"); macPool2.setRanges(Collections.singletonList(range2)); when(macPoolDao.getAll()).thenReturn(Collections.singletonList(macPool2)); MacPool oldMacPool = new MacPool(); oldMacPool.setId(Guid.newGuid()); when(macPoolDao.get(any())).thenReturn(oldMacPool); when(macPoolPerCluster.isDuplicateMacAddressesAllowed(any())).thenReturn(false); assertEquals(!overlapping, command.validate()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This change is related PR. Is this fixing else witnessed? create another PR for fixing this issue'\nThe code is: 'public Thing createThingOfType(ThingTypeUID thingTypeUID, ThingUID thingUID, ThingUID bridgeUID, String label, Configuration configuration) { logger.debug(\"Creating thing for type '{}'.\", thingTypeUID); for (ThingHandlerFactory thingHandlerFactory : thingHandlerFactories) { if (thingHandlerFactory.supportsThingType(thingTypeUID)) { Thing thing = thingHandlerFactory.createThing(thingTypeUID, configuration, thingUID, bridgeUID); <START> if (thing == null) { <END> \/\/ This change is related PR. Is this fixing else witnessed? create another PR for fixing this issue logger.warn( \"Cannot create thing of type '{}'. Binding '{}' says it supports it, but it could not be created.\", thingTypeUID, thingHandlerFactory.getClass().getName()); } else { thing.setLabel(label); } return thing; } } logger.warn(\"Cannot create thing. No binding found that supports creating a thing of type '{}'.\", thingTypeUID); return null; }'","output":"public Thing createThingOfType(ThingTypeUID thingTypeUID, ThingUID thingUID, ThingUID bridgeUID, String label, Configuration configuration) { logger.debug(\"Creating thing for type '{}'.\", thingTypeUID); for (ThingHandlerFactory thingHandlerFactory : thingHandlerFactories) { if (thingHandlerFactory.supportsThingType(thingTypeUID)) { Thing thing = thingHandlerFactory.createThing(thingTypeUID, configuration, thingUID, bridgeUID); thing.setLabel(label); return thing; } } logger.warn(\"Cannot create thing. No binding found that supports creating a thing of type '{}'.\", thingTypeUID); return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'copy-paste bug, frame.toImmutable()'\nThe code is: 'public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (int i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); <START> Tuple tupleFromFrame = tuple.toImmutable(); <END> \/\/ copy-paste bug, frame.toImmutable() assertTrue(\"equality tuple\", Objects.equals(tuple, tupleFromTuple)); assertTrue(\"equality tuple\", Objects.equals(tupleFromTuple, tuple)); assertTrue(\"equality frame\", Objects.equals(frame, tupleFromFrame)); assertTrue(\"equality frame\", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, \"x\"); assertFalse(\"equality frame\", Objects.equals(frame, tupleFromFrame)); assertFalse(\"equality frame\", Objects.equals(tupleFromFrame, frame)); } }'","output":"public void testToImmutable() { MatchingFrame frame = new MatchingFrame(arity); for (int i=0; i<arity; ++i) { frame.set(i, values[i]); } Tuple tuple = Tuples.flatTupleOf(values); Tuple tupleFromTuple = tuple.toImmutable(); Tuple tupleFromFrame = frame.toImmutable(); assertTrue(\"equality tuple\", Objects.equals(tuple, tupleFromTuple)); assertTrue(\"equality tuple\", Objects.equals(tupleFromTuple, tuple)); assertTrue(\"equality frame\", Objects.equals(frame, tupleFromFrame)); assertTrue(\"equality frame\", Objects.equals(tupleFromFrame, frame)); if (arity > 0) { frame.setValue(0, \"x\"); assertFalse(\"equality frame\", Objects.equals(frame, tupleFromFrame)); assertFalse(\"equality frame\", Objects.equals(tupleFromFrame, frame)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If decided refactor it,it great if refactor methods. useful on. BTW Consider adding getIntegerConfig other method types Config class maybe, more cleaner Config.<Integer> GetValue, clean code in places'\nThe code is: 'public Quota getUnlimitedQuota(storage_pool storagePool, boolean isDefaultQuota) { if (storagePool == null || storagePool.getId() == null) { log.error(\"Unlimited Quota cannot be created, Storage pool is not valid \"); return null; } Quota quota = new Quota(); Guid quotaId = Guid.NewGuid(); quota.setId(quotaId); quota.setStoragePoolId(storagePool.getId()); quota.setQuotaName(getDefaultQuotaName(storagePool)); quota.setDescription(\"Automatic generated Quota for Data Center \" + storagePool.getname()); quota.setThresholdVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaThresholdVdsGroup)); quota.setThresholdStoragePercentage(getIntegerConfig(ConfigValues.QuotaThresholdStorage)); quota.setGraceVdsGroupPercentage(getIntegerConfig(ConfigValues.QuotaGraceVdsGroup)); <START> quota.setGraceStoragePercentage(getIntegerConfig(ConfigValues.QuotaGraceStorage)); <END> \/\/ If decided refactor it,it great if refactor methods. useful on. BTW Consider adding getIntegerConfig other method types Config class maybe, more cleaner Config.<Integer> GetValue, clean code in places quota.setIsDefaultQuota(isDefaultQuota); quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>()); quota.setQuotaStorages(new ArrayList<QuotaStorage>()); QuotaStorage quotaStorage = new QuotaStorage(); quotaStorage.setStorageSizeGB(UNLIMITED); quota.setGlobalQuotaStorage(quotaStorage); QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup(); quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue()); quotaVdsGroup.setMemSizeMB(UNLIMITED); quota.setGlobalQuotaVdsGroup(quotaVdsGroup); return quota; }'","output":"public Quota getUnlimitedQuota(storage_pool storagePool, boolean isDefaultQuota) { if (storagePool == null || storagePool.getId() == null) { log.error(\"Unlimited Quota cannot be created, Storage pool is not valid \"); return null; } Quota quota = new Quota(); Guid quotaId = Guid.NewGuid(); quota.setId(quotaId); quota.setStoragePoolId(storagePool.getId()); quota.setQuotaName(getDefaultQuotaName(storagePool)); quota.setDescription(\"Automatic generated Quota for Data Center \" + storagePool.getname()); quota.setThresholdVdsGroupPercentage(getQuotaThresholdVdsGroup()); quota.setThresholdStoragePercentage(getQuotaThresholdStorage()); quota.setGraceVdsGroupPercentage(getQuotaGraceVdsGroup()); quota.setGraceStoragePercentage(getQuotaGraceStorage()); quota.setIsDefaultQuota(isDefaultQuota); quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>()); quota.setQuotaStorages(new ArrayList<QuotaStorage>()); QuotaStorage quotaStorage = new QuotaStorage(); quotaStorage.setStorageSizeGB(UNLIMITED); quota.setGlobalQuotaStorage(quotaStorage); QuotaVdsGroup quotaVdsGroup = new QuotaVdsGroup(); quotaVdsGroup.setVirtualCpu(UNLIMITED.intValue()); quotaVdsGroup.setMemSizeMB(UNLIMITED); quota.setGlobalQuotaVdsGroup(quotaVdsGroup); return quota; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I serverAddressDeclaration.getText().toString() instead'\nThe code is: 'protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_server_declaration, this); final EditText serverAddressDeclaration = Views.findById(this, R.id.bot_server_declaration); View connectToServer = Views.findById(this, R.id.bot_server_connect); connectToServer.setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { <START> String serverAddress = String.valueOf(serverAddressDeclaration.getText()); <END> \/\/ I serverAddressDeclaration.getText().toString() instead serverDeclarationListener.onConnect(serverAddress); } }); }'","output":"protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_server_declaration, this); final EditText serverAddressDeclaration = Views.findById(this, R.id.bot_server_declaration); View connectToServer = Views.findById(this, R.id.bot_server_connect); connectToServer.setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { String serverAddress = serverAddressDeclaration.getText().toString(); serverDeclarationListener.onConnect(serverAddress); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a logger instead of System.out'\nThe code is: 'public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); System.out.println(\"tagImageActionName inbound variables keys: \" + inBoundVariables.keySet()); System.out.println(\"tagImageActionName inbound variables values: \" + inBoundVariables.values()); <START> <END> \/\/ a logger instead of System.out boolean expectedValue = (Boolean) inBoundVariables.get(\"expectedKey\"); integrationContext.addOutBoundVariable(\"approved\", expectedValue); assertThat(((String) inBoundVariables.get(\"input-variable-name-2\"))).isEqualTo(\"input-variable-name-2\"); return integrationContext; }; }'","output":"public Connector tagImageActionName() { return integrationContext -> { Map<String, Object> inBoundVariables = integrationContext.getInBoundVariables(); LOGGER.info(\"tagImageActionName inbound variables keys: \" + inBoundVariables.keySet()); LOGGER.info(\"tagImageActionName inbound variables values: \" + inBoundVariables.values()); boolean expectedValue = (Boolean) inBoundVariables.get(\"expectedKey\"); integrationContext.addOutBoundVariable(\"approved\", expectedValue); assertThat(((String) inBoundVariables.get(\"input-variable-name-2\"))).isEqualTo(\"input-variable-name-2\"); return integrationContext; }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'port property int in place'\nThe code is: 'private DefaultRepositorySystemSession newRepositorySystemSession(RepositorySystem system, String localRepoPath) { DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession(); LocalRepository localRepo = new LocalRepository(localRepoPath); session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo)); session.setOffline(this.offline); if (isProxyEnabled()) { DefaultProxySelector proxySelector = new DefaultProxySelector(); Proxy proxy = new Proxy(proxyProperties.getProtocol(), proxyProperties.getHost(), <START> Integer.parseInt(proxyProperties.getPort()), authentication); <END> \/\/ port property int in place proxySelector.add(proxy, proxyProperties.getNonProxyHosts()); session.setProxySelector(proxySelector); } return session; }'","output":"private DefaultRepositorySystemSession newRepositorySystemSession(RepositorySystem system, String localRepoPath) { DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession(); LocalRepository localRepo = new LocalRepository(localRepoPath); session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo)); session.setOffline(this.offline); if (isProxyEnabled()) { DefaultProxySelector proxySelector = new DefaultProxySelector(); Proxy proxy = new Proxy(proxyProperties.getProtocol(), proxyProperties.getHost(), proxyProperties.getPort(), authentication); proxySelector.add(proxy, proxyProperties.getNonProxyHosts()); session.setProxySelector(proxySelector); } return session; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'exactRef'\nThe code is: 'public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(\"Yes\").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, \"Git flow jobs\")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); <START> assertNotNull(repository.findRef(Constants.R_HEADS <END> \/\/ exactRef + DEVELOP_BRANCH)); }'","output":"public void testInitMissingMaster() throws Exception { selectProject(PROJ1); clickInit(); fillDialog(MASTER_BRANCH_MISSING); bot.waitUntil(shellIsActive(UIText.InitDialog_masterBranchIsMissing)); bot.button(\"Yes\").click(); bot.waitUntil(Conditions.waitForJobs(JobFamilies.GITFLOW_FAMILY, \"Git flow jobs\")); GitFlowRepository gitFlowRepository = new GitFlowRepository(repository); GitFlowConfig config = gitFlowRepository.getConfig(); assertEquals(DEVELOP_BRANCH, repository.getBranch()); assertEquals(MASTER_BRANCH_MISSING, config.getMaster()); assertEquals(FEATURE_BRANCH_PREFIX, config.getFeaturePrefix()); assertEquals(RELEASE_BRANCH_PREFIX, config.getReleasePrefix()); assertEquals(HOTFIX_BRANCH_PREFIX, config.getHotfixPrefix()); assertEquals(VERSION_TAG_PREFIX, config.getVersionTagPrefix()); assertNotNull(repository.exactRef(Constants.R_HEADS + DEVELOP_BRANCH)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Swallowing stacktrace ;-) I in favour of: LOG.error(\"Error while playing command\", e);'\nThe code is: 'public static void main(String[] args) { try { doMain(args); System.exit(0); } catch (JamesCliException e) { failWithMessage(e.getMessage()); } catch (ParseException e) { failWithMessage(\"Error parsing command line : \" + e.getMessage()); } catch (IOException ioe) { failWithMessage(\"Error connecting to remote JMX agent : \" + ioe.getMessage()); } catch (Exception e) { <START> LOG.error(\"Error on command: {}\", e.toString()); <END> \/\/ Swallowing stacktrace ;-) I in favour of: LOG.error(\"Error while playing command\", e); failWithMessage(\"Error \" + e.getClass() + \" while executing command:\" + e.getMessage()); } }'","output":"public static void main(String[] args) { try { doMain(args); System.exit(0); } catch (JamesCliException e) { failWithMessage(e.getMessage()); } catch (ParseException e) { failWithMessage(\"Error parsing command line : \" + e.getMessage()); } catch (IOException ioe) { failWithMessage(\"Error connecting to remote JMX agent : \" + ioe.getMessage()); } catch (Exception e) { LOG.error(\"Error while playing command\", e); failWithMessage(\"Error \" + e.getClass() + \" while executing command:\" + e.getMessage()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Dimension.USED_JAVA_HEAP'\nThe code is: 'private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, int loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); <START> perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.CPU_TIME); <END> \/\/ Dimension.USED_JAVA_HEAP for (int i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }'","output":"private static void runMemoryTest(Set<ITmfTrace> testTraces, String testName, int loop_count) { Performance perf = Performance.getDefault(); PerformanceMeter pm = perf.createPerformanceMeter(TEST_ID + MEMORY + '#' + testName); perf.tagAsSummary(pm, TEST_SUMMARY + MEMORY + ':' + testName, Dimension.USED_JAVA_HEAP); for (int i = 0; i < loop_count; i++) { TmfNetworkEventMatching traceMatch = new TmfNetworkEventMatching(testTraces); System.gc(); pm.start(); traceMatch.matchEvents(); System.gc(); pm.stop(); } pm.commit(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above, client needs closed'\nThe code is: 'public void testOneway() throws Exception { latch = new CountDownLatch(1); <START> Client client = ResteasyClientBuilder.newClient(); <END> \/\/ above, client needs closed WebTarget target = client.target(\"http:\/\/localhost:\" + TestPortProvider.getPort() + \"?oneway=true\"); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(\"content\", \"text\/plain\")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }'","output":"public void testOneway() throws Exception { latch = new CountDownLatch(1); WebTarget target = client.target(\"http:\/\/localhost:\" + TestPortProvider.getPort() + \"?oneway=true\"); long start = System.currentTimeMillis(); Response response = target.request().put(Entity.entity(\"content\", \"text\/plain\")); long end = System.currentTimeMillis() - start; Assert.assertEquals(HttpServletResponse.SC_ACCEPTED, response.getStatus()); Assert.assertTrue(end < 1000); Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)); response.close(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'test is PageStore-only. disabled, especially in way. I a fix in #1123'\nThe code is: 'private void testOldClientNewServer() throws Exception { if (!config.mvStore) { <START> return; <END> \/\/ test is PageStore-only. disabled, especially in way. I a fix in #1123 } Server server = org.h2.tools.Server.createTcpServer(); server.start(); int port = server.getPort(); assertThrows(ErrorCode.DRIVER_VERSION_ERROR_2, driver).connect( \"jdbc:h2:tcp:\/\/localhost:\" + port + \"\/mem:test\", null); server.stop(); Class<?> serverClass = cl.loadClass(\"org.h2.tools.Server\"); Method m; m = serverClass.getMethod(\"createTcpServer\", String[].class); Object serverOld = m.invoke(null, new Object[] { new String[] { \"-tcpPort\", \"\" + port } }); m = serverOld.getClass().getMethod(\"start\"); m.invoke(serverOld); Connection conn; conn = org.h2.Driver.load().connect(\"jdbc:h2:mem:\", null); Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery(\"call 1\"); rs.next(); assertEquals(1, rs.getInt(1)); conn.close(); m = serverOld.getClass().getMethod(\"stop\"); m.invoke(serverOld); }'","output":"private void testOldClientNewServer() throws Exception { Server server = org.h2.tools.Server.createTcpServer(); server.start(); int port = server.getPort(); assertThrows(ErrorCode.DRIVER_VERSION_ERROR_2, driver).connect( \"jdbc:h2:tcp:\/\/localhost:\" + port + \"\/mem:test\", null); server.stop(); Class<?> serverClass = cl.loadClass(\"org.h2.tools.Server\"); Method m; m = serverClass.getMethod(\"createTcpServer\", String[].class); Object serverOld = m.invoke(null, new Object[] { new String[] { \"-tcpPort\", \"\" + port } }); m = serverOld.getClass().getMethod(\"start\"); m.invoke(serverOld); Connection conn; conn = org.h2.Driver.load().connect(\"jdbc:h2:mem:\", null); Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery(\"call 1\"); rs.next(); assertEquals(1, rs.getInt(1)); conn.close(); m = serverOld.getClass().getMethod(\"stop\"); m.invoke(serverOld); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'lines here'\nThe code is: 'public void render(Graphics g, float x, float y, float width, float height) { g.drawNinePatch(ninePatch, x, y, width, height); <START> g.drawLineSegment(x, 0, x, g.getWindowHeight()); <END> \/\/ lines here g.drawLineSegment(0, y, g.getWindowWidth(), y); g.drawLineSegment(x + width, 0, x + width, g.getWindowHeight()); g.drawLineSegment(0, y + height, g.getWindowWidth(), y + height); }'","output":"public void render(Graphics g, float x, float y, float width, float height) { g.drawNinePatch(ninePatch, x, y, width, height); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'places in druid objectMapper.readValue(persistFile, new TypeReference<List<LookupBean>>(){})'\nThe code is: 'public synchronized List<LookupBean> pullExistingSnapshot() { List<LookupBean> lookupBeanList; try { if (!persistFile.isFile()) { LOGGER.warn(\"could not find any snapshot file under working directory [%s]\", persistDirectory); return Collections.emptyList(); } else if( persistFile.length() == 0){ LOGGER.warn(\"found empty file no lookups to load from [%s]\", persistFile.getAbsolutePath()); return Collections.emptyList(); } <START> lookupBeanList = objectMapper.reader(new TypeReference<List<LookupBean>>() <END> \/\/ places in druid objectMapper.readValue(persistFile, new TypeReference<List<LookupBean>>(){}) { }).readValue(persistFile); return lookupBeanList; } catch (IOException e) { throw new ISE(e, \"Exception during reading lookups from [%s]\", persistFile.getAbsolutePath()); } }'","output":"public synchronized List<LookupBean> pullExistingSnapshot() { List<LookupBean> lookupBeanList; try { if (!persistFile.isFile()) { LOGGER.warn(\"could not find any snapshot file under working directory [%s]\", persistDirectory); return Collections.emptyList(); } else if( persistFile.length() == 0){ LOGGER.warn(\"found empty file no lookups to load from [%s]\", persistFile.getAbsolutePath()); return Collections.emptyList(); } lookupBeanList = objectMapper.readValue(persistFile, new TypeReference<List<LookupBean>>(){}); return lookupBeanList; } catch (IOException e) { throw new ISE(e, \"Exception during reading lookups from [%s]\", persistFile.getAbsolutePath()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'toUpperCase() useless is done in \"WorkspaceImageFigure.isSvgImage(resourceExtension)\"'\nThe code is: 'private boolean needClearCache(IResource resource) { boolean cacheUpdated = false; <START> String resourceExtension = resource.getFileExtension().toUpperCase(); <END> \/\/ toUpperCase() useless is done in \"WorkspaceImageFigure.isSvgImage(resourceExtension)\" if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(\"Invalid uri : \" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }'","output":"private boolean needClearCache(IResource resource) { boolean cacheUpdated = false; String resourceExtension = resource.getFileExtension(); if (WorkspaceImageFigure.isSvgImage(resourceExtension)) { String svgUri = resource.getFullPath().toString(); Option<String> removed = SVGWorkspaceImageFigure.removeFromCache(svgUri); if (removed.some()) { cacheUpdated = true; } } else { URL url; try { url = new File(ResourcesPlugin.getWorkspace().getRoot().getLocation().append(resource.getFullPath()).toOSString()).toURI().toURL(); } catch (MalformedURLException e) { DiagramPlugin.getDefault().logError(\"Invalid uri : \" + e.getMessage()); return false; } ImageDescriptor bundledImageDescriptor = ImageDescriptor.createFromURL(url); boolean removed = DiagramUIPlugin.getPlugin().removeCacheImage(bundledImageDescriptor); if (removed) { cacheUpdated = true; } } return cacheUpdated; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please consider moving this in a setUp() method'\nThe code is: 'public void testPurgeTxnLogWhenRecentSnapshotsAreAllInvalid() throws Exception { <START> tmpDir = ClientBase.createTmpDir(); <END> \/\/ Please consider moving this in a setUp() method File dataDir = new File(tmpDir, \"dataDir\"); File dataLogDir = new File(tmpDir, \"dataLogDir\"); File dataDirVersion2 = new File(dataDir, \"version-2\"); dataDirVersion2.mkdirs(); File dataLogDirVersion2 = new File(dataLogDir, \"version-2\"); dataLogDirVersion2.mkdirs(); int totalFiles = 10; int numberOfSnapFilesToKeep = 3; for (int i = 0; i < totalFiles; i++) { File logFile = new File(dataLogDirVersion2, \"log.\" + Long.toHexString(i)); logFile.createNewFile(); File snapFile = new File(dataDirVersion2, \"snapshot.\" + Long.toHexString(i)); snapFile.createNewFile(); if (i < (totalFiles - numberOfSnapFilesToKeep)) { makeValidSnapshot(snapFile); } else { makeInvalidSnapshot(snapFile); } } String[] args = new String[]{dataLogDir.getAbsolutePath(), dataDir.getAbsolutePath(), \"-n\", Integer.toString(numberOfSnapFilesToKeep)}; PurgeTxnLog.main(args); assertEquals(numberOfSnapFilesToKeep + numberOfSnapFilesToKeep, dataDirVersion2.listFiles().length); assertEquals(numberOfSnapFilesToKeep + numberOfSnapFilesToKeep, dataLogDirVersion2.listFiles().length); ClientBase.recursiveDelete(tmpDir); }'","output":"public void testPurgeTxnLogWhenRecentSnapshotsAreAllInvalid() throws Exception { File dataDir = new File(tmpDir, \"dataDir\"); File dataLogDir = new File(tmpDir, \"dataLogDir\"); File dataDirVersion2 = new File(dataDir, \"version-2\"); dataDirVersion2.mkdirs(); File dataLogDirVersion2 = new File(dataLogDir, \"version-2\"); dataLogDirVersion2.mkdirs(); int totalFiles = 10; int numberOfSnapFilesToKeep = 3; for (int i = 0; i < totalFiles; i++) { File logFile = new File(dataLogDirVersion2, \"log.\" + Long.toHexString(i)); logFile.createNewFile(); File snapFile = new File(dataDirVersion2, \"snapshot.\" + Long.toHexString(i)); snapFile.createNewFile(); if (i < (totalFiles - numberOfSnapFilesToKeep)) { makeValidSnapshot(snapFile); } else { makeInvalidSnapshot(snapFile); } } String[] args = new String[]{dataLogDir.getAbsolutePath(), dataDir.getAbsolutePath(), \"-n\", Integer.toString(numberOfSnapFilesToKeep)}; PurgeTxnLog.main(args); assertEquals(numberOfSnapFilesToKeep + numberOfSnapFilesToKeep, dataDirVersion2.listFiles().length); assertEquals(numberOfSnapFilesToKeep + numberOfSnapFilesToKeep, dataLogDirVersion2.listFiles().length); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this in init() start()? initialization in init() processing threads start in start()'\nThe code is: 'public synchronized void start() { synchronized (allQueries) { for (QueryContext ctx : allQueries.values()) { try { if (sessionMap.containsKey(ctx.getGrillSessionIdentifier())) { ctx.setConf(getGrillConf(getSessionHandle( ctx.getGrillSessionIdentifier()), ctx.getQconf())); } else { ctx.setConf(getGrillConf(GrillSessionImpl.sessionDefaultConf(),ctx.getQconf())); } } catch (GrillException e) { LOG.error(\"Could not set query conf\"); } } } super.start(); querySubmitter.start(); statusPoller.start(); queryPurger.start(); prepareQueryPurger.start(); this.queryExecutionStatisticsGenerator = new QueryExecutionStatisticsGenerator(this); <START> getStatisticsService().addHandler(queryExecutionStatisticsGenerator); <END> \/\/ this in init() start()? initialization in init() processing threads start in start() }'","output":"public synchronized void start() { synchronized (allQueries) { for (QueryContext ctx : allQueries.values()) { try { if (sessionMap.containsKey(ctx.getGrillSessionIdentifier())) { ctx.setConf(getGrillConf(getSessionHandle( ctx.getGrillSessionIdentifier()), ctx.getQconf())); } else { ctx.setConf(getGrillConf(GrillSessionImpl.sessionDefaultConf(),ctx.getQconf())); } } catch (GrillException e) { LOG.error(\"Could not set query conf\"); } } } super.start(); querySubmitter.start(); statusPoller.start(); queryPurger.start(); prepareQueryPurger.start(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'getNonNullRequestParamValue'\nThe code is: 'private void editQuestion(FeedbackQuestionAttributes updatedQuestion) throws InvalidParametersException, EntityDoesNotExistException { String err = validateQuestionGiverRecipientVisibility(updatedQuestion); if (!err.isEmpty()) { statusToUser.add(new StatusMessage(err, StatusMessageColor.DANGER)); isError = true; } <START> String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID); <END> \/\/ getNonNullRequestParamValue FeedbackQuestionDetails updatedQuestionDetails = updatedQuestion.getQuestionDetails(); List<String> questionDetailsErrors = updatedQuestionDetails.validateQuestionDetails(courseId); List<StatusMessage> questionDetailsErrorsMessages = new ArrayList<>(); for (String error : questionDetailsErrors) { questionDetailsErrorsMessages.add(new StatusMessage(error, StatusMessageColor.DANGER)); } if (questionDetailsErrors.isEmpty()) { logic.updateFeedbackQuestionNumber(updatedQuestion); statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_EDITED, StatusMessageColor.SUCCESS)); statusToAdmin = \"Feedback Question \" + updatedQuestion.questionNumber + \" for session:<span class=\\\"bold\\\">(\" + updatedQuestion.feedbackSessionName + \")<\/span> for Course <span class=\\\"bold\\\">[\" + updatedQuestion.courseId + \"]<\/span> edited.<br>\" + \"<span class=\\\"bold\\\">\" + updatedQuestionDetails.getQuestionTypeDisplayName() + \":<\/span> \" + SanitizationHelper.sanitizeForHtml(updatedQuestionDetails.getQuestionText()); } else { statusToUser.addAll(questionDetailsErrorsMessages); isError = true; } }'","output":"private void editQuestion(FeedbackQuestionAttributes updatedQuestion) throws InvalidParametersException, EntityDoesNotExistException { String err = validateQuestionGiverRecipientVisibility(updatedQuestion); if (!err.isEmpty()) { statusToUser.add(new StatusMessage(err, StatusMessageColor.DANGER)); isError = true; } String courseId = getNonNullRequestParamValue(Const.ParamsNames.COURSE_ID); FeedbackQuestionDetails updatedQuestionDetails = updatedQuestion.getQuestionDetails(); List<String> questionDetailsErrors = updatedQuestionDetails.validateQuestionDetails(courseId); List<StatusMessage> questionDetailsErrorsMessages = new ArrayList<>(); for (String error : questionDetailsErrors) { questionDetailsErrorsMessages.add(new StatusMessage(error, StatusMessageColor.DANGER)); } if (questionDetailsErrors.isEmpty()) { logic.updateFeedbackQuestionNumber(updatedQuestion); statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_EDITED, StatusMessageColor.SUCCESS)); statusToAdmin = \"Feedback Question \" + updatedQuestion.questionNumber + \" for session:<span class=\\\"bold\\\">(\" + updatedQuestion.feedbackSessionName + \")<\/span> for Course <span class=\\\"bold\\\">[\" + updatedQuestion.courseId + \"]<\/span> edited.<br>\" + \"<span class=\\\"bold\\\">\" + updatedQuestionDetails.getQuestionTypeDisplayName() + \":<\/span> \" + SanitizationHelper.sanitizeForHtml(updatedQuestionDetails.getQuestionText()); } else { statusToUser.addAll(questionDetailsErrorsMessages); isError = true; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This odd place for methods. in SqlGraph'\nThe code is: '<START> private SqlMap<InMemoryTableElement<InMemoryEdge>> newEdgeMap() { <END> \/\/ This odd place for methods. in SqlGraph return new SqlMap<InMemoryTableElement<InMemoryEdge>>( tableNameWithPrefix(EDGE_TABLE_NAME), KEY_COLUMN_NAME, VALUE_COLUMN_NAME, dataSource, serializer) { @Override protected Map<String, Object> additionalColumns(String key, InMemoryTableElement<InMemoryEdge> value) { SqlTableEdge edge = (SqlTableEdge) value; Map<String, Object> columns = new HashMap<>(); columns.put(IN_VERTEX_ID_COLUMN, edge.inVertexId()); columns.put(OUT_VERTEX_ID_COLUMN, edge.outVertexId()); return columns; } }; }'","output":"protected SqlMap<InMemoryTableElement<InMemoryEdge>> newEdgeMap() { return new SqlMap<InMemoryTableElement<InMemoryEdge>>( tableNameWithPrefix(EDGE_TABLE_NAME), KEY_COLUMN_NAME, VALUE_COLUMN_NAME, dataSource, serializer) { @Override protected Map<String, Object> additionalColumns(String key, InMemoryTableElement<InMemoryEdge> value) { SqlTableEdge edge = (SqlTableEdge) value; Map<String, Object> columns = new HashMap<>(); columns.put(IN_VERTEX_ID_COLUMN, edge.inVertexId()); columns.put(OUT_VERTEX_ID_COLUMN, edge.outVertexId()); return columns; } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please final StringReader sr'\nThe code is: 'public Map<Import, String> getImportXML(final Metadata metadata, final List<Import> imports) { final Map<Import, String> importXML = new HashMap<>(); if (imports.size() > 0) { for (final String xml : getOtherDMNDiagramsXML(metadata)) { <START> try (StringReader sr = toStringReader(xml)) { <END> \/\/ please final StringReader sr final Definitions definitions = marshaller.unmarshal(sr); findImportByDefinitions(definitions, imports).ifPresent(anImport -> { importXML.put(anImport, xml); }); } } } return importXML; }'","output":"public Map<Import, String> getImportXML(final Metadata metadata, final List<Import> imports) { final Map<Import, String> importXML = new HashMap<>(); if (imports.size() > 0) { for (final String xml : getOtherDMNDiagramsXML(metadata)) { try (final StringReader sr = toStringReader(xml)) { final Definitions definitions = marshaller.unmarshal(sr); findImportByDefinitions(definitions, imports).ifPresent(anImport -> { importXML.put(anImport, xml); }); } } } return importXML; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's\/failedToBeRemoved\/failedRemoving\/'\nThe code is: 'protected void executeVmCommand() { Set<Guid> mImagesToBeRemoved = new HashSet<Guid>(); List<DiskImage> images = getParameters().Images; if (images == null) { images = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), true, false); } for (DiskImage image : images) { if (Boolean.TRUE.equals(image.getActive())) { mImagesToBeRemoved.add(image.getImageId()); } } <START> Collection<DiskImage> failedToBeRemoved = new LinkedList<>(); <END> \/\/ s\/failedToBeRemoved\/failedRemoving\/ for (final DiskImage image : images) { if (mImagesToBeRemoved.contains(image.getImageId())) { VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveImage, buildRemoveImageParameters(image), ExecutionHandler.createDefaultContexForTasks(getExecutionContext())); if (vdcReturnValue.getSucceeded()) { getReturnValue().getInternalTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList()); } else { failedToBeRemoved.add(image); log.errorFormat(\"Can't remove image id: {0} for VM id: {1} due to: {2}. Image will be set at illegal state with no snapshot id.\", image.getImageId(), getParameters().getVmId(), vdcReturnValue.getFault().getMessage()); TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() { @Override public Object runInTransaction() { updateDiskImagesToIllegal(image); return true; } }); } } } setActionReturnValue(failedToBeRemoved); setSucceeded(true); }'","output":"protected void executeVmCommand() { Set<Guid> mImagesToBeRemoved = new HashSet<Guid>(); List<DiskImage> images = getParameters().Images; if (images == null) { images = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), true, false); } for (DiskImage image : images) { if (Boolean.TRUE.equals(image.getActive())) { mImagesToBeRemoved.add(image.getImageId()); } } Collection<DiskImage> failedRemoving = new LinkedList<>(); for (final DiskImage image : images) { if (mImagesToBeRemoved.contains(image.getImageId())) { VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveImage, buildRemoveImageParameters(image), ExecutionHandler.createDefaultContexForTasks(getExecutionContext())); if (vdcReturnValue.getSucceeded()) { getReturnValue().getInternalTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList()); } else { failedRemoving.add(image); log.errorFormat(\"Can't remove image id: {0} for VM id: {1} due to: {2}. Image will be set at illegal state with no snapshot id.\", image.getImageId(), getParameters().getVmId(), vdcReturnValue.getFault().getMessage()); TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() { @Override public Object runInTransaction() { updateDiskImagesToIllegal(image); return true; } }); } } } setActionReturnValue(failedRemoving); setSucceeded(true); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this if postdraw for entries'\nThe code is: 'protected @NonNull List<IMarkerEvent> getViewMarkerList(long startTime, long endTime, long resolution, @NonNull IProgressMonitor monitor) { ITimeGraphEntry[] expandedElements = getTimeGraphViewer().getExpandedElements(); List<IMarkerEvent> markers = new ArrayList<>(); for (ITimeGraphEntry element : expandedElements) { if (((TimeGraphEntry) element).getModel() instanceof SpanLifeEntryModel) { SpanLifeEntryModel model = (SpanLifeEntryModel) ((TimeGraphEntry) element).getModel(); for (LogEvent log : model.getLogs()) { markers.add(new SpanMarkerEvent(element, log.getTime(), MARKER_COLOR, log.getType())); } <START> if (model.getErrorTag()) { markers.add(new SpanMarkerEvent(element, model.getStartTime(), MARKER_COLOR, \"error.object\")); } <END> \/\/ Remove this if postdraw for entries } } return markers; }'","output":"protected @NonNull List<IMarkerEvent> getViewMarkerList(long startTime, long endTime, long resolution, @NonNull IProgressMonitor monitor) { ITimeGraphEntry[] expandedElements = getTimeGraphViewer().getExpandedElements(); List<IMarkerEvent> markers = new ArrayList<>(); for (ITimeGraphEntry element : expandedElements) { if (((TimeGraphEntry) element).getModel() instanceof SpanLifeEntryModel) { SpanLifeEntryModel model = (SpanLifeEntryModel) ((TimeGraphEntry) element).getModel(); for (LogEvent log : model.getLogs()) { markers.add(new SpanMarkerEvent(element, log.getTime(), MARKER_COLOR, log.getType())); } } } return markers; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'needed, registered 3 events'\nThe code is: 'public StorageQosMetricParametersModel(ConfigurationValues maxTotal, ConfigurationValues maxRead, ConfigurationValues maxWrite) { this.maxTotal = maxTotal; this.maxRead = maxRead; this.maxWrite = maxWrite; setTotal(new EntityModel<Integer>()); setRead(new EntityModel<Integer>()); setWrite(new EntityModel<Integer>()); setChoiceGroupNone(new EntityModel<Boolean>()); setChoiceGroupTotal(new EntityModel<Boolean>()); setChoiceGroupReadWrite(new EntityModel<Boolean>()); getChoiceGroupNone().getEntityChangedEvent().addListener(this); getChoiceGroupTotal().getEntityChangedEvent().addListener(this); getChoiceGroupReadWrite().getEntityChangedEvent().addListener(this); <START> getPropertyChangedEvent().addListener(this); <END> \/\/ needed, registered 3 events }'","output":"public StorageQosMetricParametersModel(ConfigurationValues maxTotal, ConfigurationValues maxRead, ConfigurationValues maxWrite) { this.maxTotal = maxTotal; this.maxRead = maxRead; this.maxWrite = maxWrite; setTotal(new EntityModel<Integer>()); setRead(new EntityModel<Integer>()); setWrite(new EntityModel<Integer>()); setChoiceGroupNone(new EntityModel<Boolean>()); setChoiceGroupTotal(new EntityModel<Boolean>()); setChoiceGroupReadWrite(new EntityModel<Boolean>()); getChoiceGroupNone().getEntityChangedEvent().addListener(this); getChoiceGroupTotal().getEntityChangedEvent().addListener(this); getChoiceGroupReadWrite().getEntityChangedEvent().addListener(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename source'\nThe code is: 'private void saveStateAsLast(URL url) { File lastBundlesTxt = getLastBundleInfo(); try (OutputStream destinationStream = new FileOutputStream(lastBundlesTxt)) { ArrayList<File> sourcesLocation = SimpleConfiguratorUtils.getInfoFiles(); List<InputStream> sourceStreams = new ArrayList<>(sourcesLocation.size() + 1); sourceStreams.add(url.openStream()); if (Activator.EXTENDED) { for (File <START> element : <END> \/\/ rename source sourcesLocation) { sourceStreams.add(new FileInputStream(element)); } } SimpleConfiguratorUtils.transferStreams(sourceStreams, destinationStream); } catch (URISyntaxException e) { } catch (IOException e) { } }'","output":"private void saveStateAsLast(URL url) { File lastBundlesTxt = getLastBundleInfo(); try (OutputStream destinationStream = new FileOutputStream(lastBundlesTxt)) { ArrayList<File> sourcesLocation = SimpleConfiguratorUtils.getInfoFiles(); List<InputStream> sourceStreams = new ArrayList<>(sourcesLocation.size() + 1); sourceStreams.add(url.openStream()); if (Activator.EXTENDED) { for (File source : sourcesLocation) { sourceStreams.add(new FileInputStream(source)); } } SimpleConfiguratorUtils.transferStreams(sourceStreams, destinationStream); } catch (URISyntaxException e) { } catch (IOException e) { } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Knock this protected (no need define public api here) - this provide a chance for subclasses smarter (for example WKTStratagy start recogning geometry column). this method is ugly\/confusing :)'\nThe code is: '<START> public static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, <END> \/\/ Knock this protected (no need define public api here) - this provide a chance for subclasses smarter (for example WKTStratagy start recogning geometry column). this method is ugly\/confusing :) String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } int i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }'","output":"protected static Map<String, Class<?>> findMostSpecificTypesFromData(CsvReader csvReader, String[] headers) throws IOException { Map<String, Class<?>> result = new HashMap<String, Class<?>>(); for (String header : headers) { result.put(header, Integer.class); } while (csvReader.readRecord()) { String[] record = csvReader.getValues(); List<String> values = Arrays.asList(record); if (record.length >= headers.length) { values = values.subList(0, headers.length); } int i = 0; for (String value : values) { String header = headers[i]; Class<?> type = result.get(header); if (type == Integer.class) { try { Integer.parseInt(value); } catch (NumberFormatException e) { try { Double.parseDouble(value); type = Double.class; } catch (NumberFormatException ex) { type = String.class; } } } else if (type == Double.class) { try { Double.parseDouble(value); } catch (NumberFormatException e) { type = String.class; } } else { type = String.class; } result.put(header, type); i++; } } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'string declaration for SSL_FACTORY? If do this, do for strings in property. If not, remove variable. is wrong implementation is varies in style professional'\nThe code is: 'private Properties buildProperties() { Properties props = System.getProperties(); <START> final String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\"; <END> \/\/ string declaration for SSL_FACTORY? If do this, do for strings in property. If not, remove variable. is wrong implementation is varies in style professional props.setProperty(\"mail.smtp.host\", \"smtp.gmail.com\"); props.setProperty(\"mail.smtp.socketFactory.class\", SSL_FACTORY); props.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\"); props.setProperty(\"mail.smtp.port\", \"465\"); props.setProperty(\"mail.smtp.socketFactory.port\", \"465\"); props.put(\"mail.smtp.auth\", \"true\"); props.put(\"mail.debug\", \"true\"); props.put(\"mail.store.protocol\", \"pop3\"); props.put(\"mail.transport.protocol\", \"smtp\"); return props; }'","output":"private Properties buildProperties() { Properties props = System.getProperties(); props.setProperty(\"mail.smtp.host\", \"smtp.gmail.com\"); props.setProperty(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); props.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\"); props.setProperty(\"mail.smtp.port\", \"465\"); props.setProperty(\"mail.smtp.socketFactory.port\", \"465\"); props.put(\"mail.smtp.auth\", \"true\"); props.put(\"mail.debug\", \"true\"); props.put(\"mail.store.protocol\", \"pop3\"); props.put(\"mail.transport.protocol\", \"smtp\"); return props; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'events removed list, this creates a memory leak. notifier a reference events, events a reference players games, references, preventing objects garbage collected. this added; event is fired once, contains() check return false. if remove eventList'\nThe code is: 'public void onFriendJoinedGame(FriendJoinedGameEvent event) { Player player = event.getPlayer(); Game game = event.getGame(); audioService.playFriendJoinsGameSound(); if (preferencesService.getPreferences().getNotification().isFriendJoinsGameToastEnabled() && !eventList.contains(event)) { <START> eventList.add(event); <END> \/\/ events removed list, this creates a memory leak. notifier a reference events, events a reference players games, references, preventing objects garbage collected. this added; event is fired once, contains() check return false. if remove eventList notificationService.addNotification(new TransientNotification( i18n.get(\"friend.joinedGameNotification.title\", player.getUsername(), game.getTitle()), i18n.get(\"friend.joinedGameNotification.action\"), IdenticonUtil.createIdenticon(player.getId()), event1 -> joinGameHelper.join(player.getGame()) )); } }'","output":"public void onFriendJoinedGame(FriendJoinedGameEvent event) { Player player = event.getPlayer(); Game game = event.getGame(); audioService.playFriendJoinsGameSound(); if (preferencesService.getPreferences().getNotification().isFriendJoinsGameToastEnabled()) { notificationService.addNotification(new TransientNotification( i18n.get(\"friend.joinedGameNotification.title\", player.getUsername(), game.getTitle()), i18n.get(\"friend.joinedGameNotification.action\"), IdenticonUtil.createIdenticon(player.getId()), event1 -> joinGameHelper.join(player.getGame()) )); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'avoid NPEs use; MLConstants.DEEPLEARNING.equalsIgnoreCase(model.getAlgorithmClass())'\nThe code is: 'private void persistModel(long modelId, String modelName, MLModel model) throws MLModelBuilderException { try { MLStorage storage = databaseService.getModelStorage(modelId); if (storage == null) { throw new MLModelBuilderException(\"Invalid model ID: \" + modelId); } String storageType = storage.getType(); String storageLocation = storage.getLocation(); <START> if (model.getAlgorithmClass().equalsIgnoreCase(MLConstants.DEEPLEARNING)) { <END> \/\/ avoid NPEs use; MLConstants.DEEPLEARNING.equalsIgnoreCase(model.getAlgorithmClass()) MLDeeplearningModel mlDeeplearningModel = (MLDeeplearningModel) model.getModel(); mlDeeplearningModel.setStorageLocation(storageLocation); model.setModel(mlDeeplearningModel); } MLIOFactory ioFactory = new MLIOFactory(mlProperties); MLOutputAdapter outputAdapter = ioFactory.getOutputAdapter(storageType + MLConstants.OUT_SUFFIX); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(model); oos.flush(); oos.close(); InputStream is = new ByteArrayInputStream(baos.toByteArray()); String outPath = storageLocation + File.separator + modelName; outputAdapter.write(outPath, is); databaseService.updateModelStorage(modelId, storageType, outPath); log.info(String.format(\"Successfully persisted the model [id] %s\", modelId)); } catch (Exception e) { throw new MLModelBuilderException(\"Failed to persist the model [id] \" + modelId + \". \" + e.getMessage(), e); } }'","output":"private void persistModel(long modelId, String modelName, MLModel model) throws MLModelBuilderException { try { MLStorage storage = databaseService.getModelStorage(modelId); if (storage == null) { throw new MLModelBuilderException(\"Invalid model ID: \" + modelId); } String storageType = storage.getType(); String storageLocation = storage.getLocation(); if (MLConstants.DEEPLEARNING.equalsIgnoreCase(model.getAlgorithmClass())) { MLDeeplearningModel mlDeeplearningModel = (MLDeeplearningModel) model.getModel(); mlDeeplearningModel.setStorageLocation(storageLocation); model.setModel(mlDeeplearningModel); } MLIOFactory ioFactory = new MLIOFactory(mlProperties); MLOutputAdapter outputAdapter = ioFactory.getOutputAdapter(storageType + MLConstants.OUT_SUFFIX); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(model); oos.flush(); oos.close(); InputStream is = new ByteArrayInputStream(baos.toByteArray()); String outPath = storageLocation + File.separator + modelName; outputAdapter.write(outPath, is); databaseService.updateModelStorage(modelId, storageType, outPath); log.info(String.format(\"Successfully persisted the model [id] %s\", modelId)); } catch (Exception e) { throw new MLModelBuilderException(\"Failed to persist the model [id] \" + modelId + \". \" + e.getMessage(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this \"Creating LocalCacheManager {} existing pages\"'\nThe code is: 'public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException { MetaStore metaStore = MetaStore.create(); CacheEvictor evictor = CacheEvictor.create(conf); PageStore pageStore = PageStore.create(conf); try { Collection<PageInfo> pageInfos = pageStore.getPages(); <START> LOG.info(\"Loading {} existing pages\", pageInfos.size()); <END> \/\/ this \"Creating LocalCacheManager {} existing pages\" for (PageInfo pageInfo : pageInfos) { PageId pageId = pageInfo.getPageId(); metaStore.addPage(pageId, pageInfo); evictor.updateOnPut(pageId); } return new LocalCacheManager(conf, metaStore, pageStore, evictor); } catch (Exception e) { try { pageStore.close(); } catch (Exception ex) { e.addSuppressed(ex); } throw new IOException(\"failed to create local cache manager\", e); } }'","output":"public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException { MetaStore metaStore = MetaStore.create(); CacheEvictor evictor = CacheEvictor.create(conf); PageStore pageStore = PageStore.create(conf); try { Collection<PageInfo> pageInfos = pageStore.getPages(); LOG.info(\"Creating LocalCacheManager with {} existing pages\", pageInfos.size()); for (PageInfo pageInfo : pageInfos) { PageId pageId = pageInfo.getPageId(); metaStore.addPage(pageId, pageInfo); evictor.updateOnPut(pageId); } return new LocalCacheManager(conf, metaStore, pageStore, evictor); } catch (Exception e) { try { pageStore.close(); } catch (Exception ex) { e.addSuppressed(ex); } throw new IOException(\"failed to create local cache manager\", e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I guess need change parameter type List.class: java }).when(nodeDiscovery, NOTIFY_DEVICE_DISCOVERED, Mockito.any(List.class), (RemoteXBeeDevice) Mockito.any());'\nThe code is: 'public void setup() throws Exception { discoverListener = PowerMockito.spy(new MyDiscoverListener()); listeners.add(discoverListener); nodeDiscovery = PowerMockito.spy(new NodeDiscovery(Mockito.mock(XBeeDevice.class))); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); RemoteXBeeDevice remote = (RemoteXBeeDevice) args[1]; discoverListener.deviceDiscovered(remote); return null; } <START> }).when(nodeDiscovery, NOTIFY_DEVICE_DISCOVERED, Mockito.any(ArrayList.class), (RemoteXBeeDevice) Mockito.any()); <END> \/\/ I guess need change parameter type List.class: java }).when(nodeDiscovery, NOTIFY_DEVICE_DISCOVERED, Mockito.any(List.class), (RemoteXBeeDevice) Mockito.any()); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); String error = (String) args[1]; discoverListener.discoveryError(error); return null; } }).when(nodeDiscovery, NOTIFY_DISCOVERY_ERROR, Mockito.any(ArrayList.class), Mockito.anyString()); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); String error = (String) args[1]; discoverListener.discoveryFinished(error); return null; } }).when(nodeDiscovery, NOTIFY_DISCOVERY_FINISHED, Mockito.any(ArrayList.class), Mockito.anyString()); }'","output":"public void setup() throws Exception { discoverListener = PowerMockito.spy(new MyDiscoverListener()); listeners.add(discoverListener); nodeDiscovery = PowerMockito.spy(new NodeDiscovery(Mockito.mock(XBeeDevice.class))); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); RemoteXBeeDevice remote = (RemoteXBeeDevice) args[1]; discoverListener.deviceDiscovered(remote); return null; } }).when(nodeDiscovery, NOTIFY_DEVICE_DISCOVERED, Mockito.any(List.class), (RemoteXBeeDevice) Mockito.any()); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); String error = (String) args[1]; discoverListener.discoveryError(error); return null; } }).when(nodeDiscovery, NOTIFY_DISCOVERY_ERROR, Mockito.any(List.class), Mockito.anyString()); PowerMockito.doAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); String error = (String) args[1]; discoverListener.discoveryFinished(error); return null; } }).when(nodeDiscovery, NOTIFY_DISCOVERY_FINISHED, Mockito.any(List.class), Mockito.anyString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is naming convention - variable CONSTANT name'\nThe code is: 'private void setPlatformPropertiesToState(Dictionary<Object, Object> props) { Properties platformProperties = setDefaultPlatformProperties(); for (Enumeration<Object> enumeration = props.keys(); enumeration.hasMoreElements();) { String key = (String) enumeration.nextElement(); for (String <START> PROPS1 : <END> \/\/ this is naming convention - variable CONSTANT name PROPS) { if (key.equals(PROPS1)) { platformProperties.put(key, props.get(key)); break; } } } platformProperties.put(\"osgi.resolver.usesMode\", \"ignore\"); state.setPlatformProperties(platformProperties); }'","output":"private void setPlatformPropertiesToState(Dictionary<Object, Object> props) { Properties platformProperties = setDefaultPlatformProperties(); for (Enumeration<Object> enumeration = props.keys(); enumeration.hasMoreElements();) { String key = (String) enumeration.nextElement(); for (String property : PROPS) { if (key.equals(property)) { platformProperties.put(key, props.get(key)); break; } } } platformProperties.put(\"osgi.resolver.usesMode\", \"ignore\"); state.setPlatformProperties(platformProperties); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove this, I fixed in a432e377a8d4e7dd04f2267bc59b1e66ea6d6656'\nThe code is: 'public void calculateMip(double scale, double mapScale, double screenScale) { int size = (int) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { int smallestSide = (int) (size * screenScale); int closestValue = Integer.MAX_VALUE; int closestIndex = -1; <START> if(iconSizes != null) { <END> \/\/ Please remove this, I fixed in a432e377a8d4e7dd04f2267bc59b1e66ea6d6656 for (int i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } } if (closestIndex > 0) { iconIndex = closestIndex; } } }'","output":"public void calculateMip(double scale, double mapScale, double screenScale) { int size = (int) (16 * scale * viewSize()); if (isTile) { size *= mapScale; } if (icons.length > 1) { int smallestSide = (int) (size * screenScale); int closestValue = Integer.MAX_VALUE; int closestIndex = -1; for (int i = 0; i < iconSizes.length; i++) { if (iconSizes[i] < closestValue && iconSizes[i] >= smallestSide) { closestValue = iconSizes[i]; closestIndex = i; } } if (closestIndex > 0) { iconIndex = closestIndex; } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Cosmetic: mind static import statements for assertion methods? Thanks! :)'\nThe code is: 'public void testRebuildIndexesInRepository(@MavenRepository(repositoryId = REPOSITORY_RELEASES_1, setup = MavenIndexedRepositorySetup.class) Repository repository, @MavenTestArtifact(repositoryId = REPOSITORY_RELEASES_1, id = GROUP_ID + \":\" + ARTIFACT_ID1, versions = { VERSION }) Path artifact1, @MavenTestArtifact(repositoryId = REPOSITORY_RELEASES_1, id = GROUP_ID + \":\" + ARTIFACT_ID2, versions = { VERSION }) Path artifact2) throws Exception { final UUID jobKey = expectedJobKey; final String jobName = expectedJobName; jobManager.registerExecutionListener(jobKey.toString(), (jobKey1, statusExecuted) -> { if (StringUtils.equals(jobKey1, jobKey.toString()) && statusExecuted) { try { RepositoryPath indexPath = repositoryIndexDirectoryPathResolver.resolve(repository); RepositoryPath packedIndexPath = indexPath.resolve(IndexingContext.INDEX_FILE_PREFIX + \".gz\"); <START> Assertions.assertThat(packedIndexPath).matches(Files::exists); <END> \/\/ Cosmetic: mind static import statements for assertion methods? Thanks! :) } catch (Exception e) { throw new UndeclaredThrowableException(e); } } }); addCronJobConfig(jobKey, jobName, RebuildMavenIndexesCronJob.class, STORAGE0, repository.getId()); await().atMost(EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS).untilTrue(receivedExpectedEvent()); }'","output":"public void testRebuildIndexesInRepository(@MavenRepository(repositoryId = REPOSITORY_RELEASES_1, setup = MavenIndexedRepositorySetup.class) Repository repository, @MavenTestArtifact(repositoryId = REPOSITORY_RELEASES_1, id = GROUP_ID + \":\" + ARTIFACT_ID1, versions = { VERSION }) Path artifact1, @MavenTestArtifact(repositoryId = REPOSITORY_RELEASES_1, id = GROUP_ID + \":\" + ARTIFACT_ID2, versions = { VERSION }) Path artifact2) throws Exception { final UUID jobKey = expectedJobKey; final String jobName = expectedJobName; jobManager.registerExecutionListener(jobKey.toString(), (jobKey1, statusExecuted) -> { if (StringUtils.equals(jobKey1, jobKey.toString()) && statusExecuted) { try { RepositoryPath indexPath = repositoryIndexDirectoryPathResolver.resolve(repository); RepositoryPath packedIndexPath = indexPath.resolve(IndexingContext.INDEX_FILE_PREFIX + \".gz\"); assertThat(packedIndexPath).matches(Files::exists); } catch (Exception e) { throw new UndeclaredThrowableException(e); } } }); addCronJobConfig(jobKey, jobName, RebuildMavenIndexesCronJob.class, STORAGE0, repository.getId()); await().atMost(EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS).untilTrue(receivedExpectedEvent()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Missing final'\nThe code is: 'public static ImmutableMap<String, Ds3Type> removeDollarSignFromTypeMap( final ImmutableMap<String, Ds3Type> map) throws TypeRenamingConflictException { if (isEmpty(map)) { return ImmutableMap.of(); } final ImmutableMap.Builder<String, Ds3Type> builder = ImmutableMap.builder(); <START> for (Map.Entry<String, Ds3Type> entry : map.entrySet()) { <END> \/\/ Missing final final String typeName = removeDollarSignFromName(entry.getKey()); final Ds3Type type = removeDollarSignFromType(entry.getValue()); if (!containsType(typeName, entry.getValue(), builder.build())) { builder.put(typeName, type); } } return builder.build(); }'","output":"public static ImmutableMap<String, Ds3Type> removeDollarSignFromTypeMap( final ImmutableMap<String, Ds3Type> map) throws TypeRenamingConflictException { if (isEmpty(map)) { return ImmutableMap.of(); } final ImmutableMap.Builder<String, Ds3Type> builder = ImmutableMap.builder(); for (final Map.Entry<String, Ds3Type> entry : map.entrySet()) { final String typeName = removeDollarSignFromName(entry.getKey()); final Ds3Type type = removeDollarSignFromType(entry.getValue()); if (!containsType(typeName, entry.getValue(), builder.build())) { builder.put(typeName, type); } } return builder.build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This logically clearer: java if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); }'\nThe code is: 'private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); boolean isNotEmailLog = (!logMsg.contains(\"TEAMMATESEMAILLOG\")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if(!data.shouldShowLog(emailLogEntry)) { continue; } <START> emailLogs.add(emailLogEntry); <END> \/\/ This logically clearer: java if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }'","output":"private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines, AdminEmailLogPageData data) { List<EmailLogEntry> emailLogs = new LinkedList<EmailLogEntry>(); for (AppLogLine appLog : appLogLines) { String logMsg = appLog.getLogMessage(); boolean isNotEmailLog = (!logMsg.contains(\"TEAMMATESEMAILLOG\")); if (isNotEmailLog) { continue; } EmailLogEntry emailLogEntry = new EmailLogEntry(appLog); if (data.shouldShowLog(emailLogEntry)) { emailLogs.add(emailLogEntry); } } return emailLogs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this toast. annoying'\nThe code is: 'private void addItemsToBudgetSpinner() { final List<Budget> budgetList = appData.getBudgetList(); List<String> budgetNameList = new ArrayList<String>(); for (Budget b : budgetList) { Log.d(TAG, b.getName()); budgetNameList.add(b.getName()); } budgetNameList.add(getResources().getString(R.string.new_budget)); ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this, R.layout.spinner_layout, budgetNameList); dataAdapter.setDropDownViewResource(R.layout.spinner_entry_layout); mBudgetView.setAdapter(dataAdapter); mBudgetView.setOnItemSelectedListener(new OnItemSelectedListener() { @Override public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { if (pos == budgetList.size()) { startActivity(new Intent(AddEntryActivity.this, AddBudgetActivity.class)); <START> Toast.makeText(parent.getContext(), \"new budget!\", Toast.LENGTH_LONG).show(); <END> \/\/ this toast. annoying } } @Override public void onNothingSelected(AdapterView<?> arg0) { } }); }'","output":"private void addItemsToBudgetSpinner() { final List<Budget> budgetList = appData.getBudgetList(); List<String> budgetNameList = new ArrayList<String>(); for (Budget b : budgetList) { Log.d(TAG, b.getName()); budgetNameList.add(b.getName()); } budgetNameList.add(getResources().getString(R.string.new_budget)); ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this, R.layout.spinner_layout, budgetNameList); dataAdapter.setDropDownViewResource(R.layout.spinner_entry_layout); mBudgetView.setAdapter(dataAdapter); mBudgetView.setOnItemSelectedListener(new OnItemSelectedListener() { @Override public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { if (pos == budgetList.size()) { startActivity(new Intent(AddEntryActivity.this, AddBudgetActivity.class)); } } @Override public void onNothingSelected(AdapterView<?> arg0) { } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '-allow-duplicates is a name, \"f\" is a good short name. \"a\" \"d\", short name'\nThe code is: 'public RenameCommand() { Options o = CommandLineHelper.getCommonOptions(); o.addOption(\"i\", \"input\", true, \"load ontology from a file\"); o.addOption(\"I\", \"input-iri\", true, \"load ontology from an IRI\"); o.addOption(\"o\", \"output\", true, \"save ontology to a file\"); o.addOption(\"m\", \"mappings\", true, \"table of mappings for renaming\"); o.addOption(\"r\", \"prefix-mappings\", true, \"table of prefix mappings for renaming\"); o.addOption(\"A\", \"add-prefix\", true, \"add a new prefix to ontology file header\"); <START> o.addOption(\"f\", \"allow-duplicates\", true, \"allow two or more terms to be renamed to the same full IRI\"); <END> \/\/ -allow-duplicates is a name, \"f\" is a good short name. \"a\" \"d\", short name options = o; }'","output":"public RenameCommand() { Options o = CommandLineHelper.getCommonOptions(); o.addOption(\"i\", \"input\", true, \"load ontology from a file\"); o.addOption(\"I\", \"input-iri\", true, \"load ontology from an IRI\"); o.addOption(\"o\", \"output\", true, \"save ontology to a file\"); o.addOption(\"m\", \"mappings\", true, \"table of mappings for renaming\"); o.addOption(\"r\", \"prefix-mappings\", true, \"table of prefix mappings for renaming\"); o.addOption(\"A\", \"add-prefix\", true, \"add a new prefix to ontology file header\"); o.addOption(\"d\", \"allow-duplicates\", true, \"allow two or more terms to be renamed to the same full IRI\"); options = o; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Debug statement removed'\nThe code is: 'public synchronized GrillResultSetMetadata getMetadata() throws GrillException { if (grillResultMeta == null) { grillResultMeta = new GrillResultSetMetadata() { @Override public List<ColumnDescriptor> getColumns() { try{ ResultSetMetaData rsmeta = getRsMetadata(); List<ColumnDescriptor> columns = new ArrayList<ColumnDescriptor>(rsmeta.getColumnCount()); System.out.println(\"Column count:\" + rsmeta.getColumnCount()); <START> for (int i = 1; i <= rsmeta.getColumnCount(); i++) { <END> \/\/ Debug statement removed FieldSchema col = new FieldSchema(rsmeta.getColumnName(i), TypeInfoUtils.getTypeInfoFromTypeString( getHiveTypeForSQLType(i, rsmeta)).getTypeName(), rsmeta.getColumnTypeName(i)); columns.add(new ColumnDescriptor(col, i)); } return columns; } catch (Exception e) { LOG.error(\"Error getting JDBC type information: \" + e.getMessage(), e); return null; } } }; } return grillResultMeta; }'","output":"public synchronized GrillResultSetMetadata getMetadata() throws GrillException { if (grillResultMeta == null) { grillResultMeta = new GrillResultSetMetadata() { @Override public List<ColumnDescriptor> getColumns() { try{ ResultSetMetaData rsmeta = getRsMetadata(); List<ColumnDescriptor> columns = new ArrayList<ColumnDescriptor>(rsmeta.getColumnCount()); for (int i = 1; i <= rsmeta.getColumnCount(); i++) { FieldSchema col = new FieldSchema(rsmeta.getColumnName(i), TypeInfoUtils.getTypeInfoFromTypeString( getHiveTypeForSQLType(i, rsmeta)).getTypeName(), rsmeta.getColumnTypeName(i)); columns.add(new ColumnDescriptor(col, i)); } return columns; } catch (Exception e) { LOG.error(\"Error getting JDBC type information: \" + e.getMessage(), e); return null; } } }; } return grillResultMeta; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List.of(...)'\nThe code is: 'public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(\"user1\"); userManager.createUser(u1); DocumentModel g1 = getGroup(\"group1\"); <START> g1.setProperty(\"group\", \"members\", Arrays.asList(\"user1\")); <END> \/\/ List.of(...) userManager.createGroup(g1); DocumentModel g2 = getGroup(\"group2\"); g2.setProperty(\"group\", \"members\", Arrays.asList(\"user1\")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(\"user1\"); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(\"user1\", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(\"defgr\")); assertFalse(principal1.isMemberOf(\"group1\")); }'","output":"public void testGetPrincipalWithoutReferences() throws Exception { DocumentModel u1 = getUser(\"user1\"); userManager.createUser(u1); DocumentModel g1 = getGroup(\"group1\"); g1.setProperty(\"group\", \"members\", List.of(\"user1\")); userManager.createGroup(g1); DocumentModel g2 = getGroup(\"group2\"); g2.setProperty(\"group\", \"members\", List.of(\"user1\")); userManager.createGroup(g2); NuxeoPrincipal principal1 = userManager.getPrincipal(\"user1\"); assertEquals(3, principal1.getAllGroups().size()); principal1 = userManager.getPrincipal(\"user1\", false); assertEquals(1, principal1.getAllGroups().size()); assertTrue(principal1.isMemberOf(\"defgr\")); assertFalse(principal1.isMemberOf(\"group1\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Util.getShortObjectId() instead of putting 7 here'\nThe code is: 'public String getName() { if (title == null) { if (base == null) { title = MessageFormat.format(UIText.DiffEditorInput_Title1, <START> tip.getObjectId().abbreviate(7).name(), GitLabels.getPlainShortLabel(tip.getRepository())); } else { title = MessageFormat.format(UIText.DiffEditorInput_Title2, base.getObjectId().abbreviate(7).name(), tip.getObjectId().abbreviate(7).name(), <END> \/\/ Util.getShortObjectId() instead of putting 7 here GitLabels.getPlainShortLabel(tip.getRepository())); } } return title; }'","output":"public String getName() { if (title == null) { if (base == null) { title = MessageFormat.format(UIText.DiffEditorInput_Title1, Utils.getShortObjectId(tip.getObjectId()), GitLabels.getPlainShortLabel(tip.getRepository())); } else { title = MessageFormat.format(UIText.DiffEditorInput_Title2, Utils.getShortObjectId(base.getObjectId()), Utils.getShortObjectId(tip.getObjectId()), GitLabels.getPlainShortLabel(tip.getRepository())); } } return title; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move this'\nThe code is: 'public void configure(Binder binder) { <START> configBinder(binder).bindConfig(StorageManagerConfig.class); <END> \/\/ move this binder.bind(RaptorConnectorId.class).toInstance(new RaptorConnectorId(connectorId)); binder.bind(RaptorConnector.class).in(Scopes.SINGLETON); binder.bind(RaptorMetadataFactory.class).in(Scopes.SINGLETON); binder.bind(RaptorSplitManager.class).in(Scopes.SINGLETON); binder.bind(RaptorPageSourceProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorPageSinkProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorHandleResolver.class).in(Scopes.SINGLETON); binder.bind(RaptorNodePartitioningProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorSessionProperties.class).in(Scopes.SINGLETON); binder.bind(RaptorTableProperties.class).in(Scopes.SINGLETON); Multibinder<SystemTable> tableBinder = newSetBinder(binder, SystemTable.class); tableBinder.addBinding().to(ShardMetadataSystemTable.class).in(Scopes.SINGLETON); tableBinder.addBinding().to(TableMetadataSystemTable.class).in(Scopes.SINGLETON); tableBinder.addBinding().to(TableStatsSystemTable.class).in(Scopes.SINGLETON); }'","output":"public void configure(Binder binder) { binder.bind(RaptorConnectorId.class).toInstance(new RaptorConnectorId(connectorId)); binder.bind(RaptorConnector.class).in(Scopes.SINGLETON); binder.bind(RaptorMetadataFactory.class).in(Scopes.SINGLETON); binder.bind(RaptorSplitManager.class).in(Scopes.SINGLETON); binder.bind(RaptorPageSourceProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorPageSinkProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorHandleResolver.class).in(Scopes.SINGLETON); binder.bind(RaptorNodePartitioningProvider.class).in(Scopes.SINGLETON); binder.bind(RaptorSessionProperties.class).in(Scopes.SINGLETON); binder.bind(RaptorTableProperties.class).in(Scopes.SINGLETON); Multibinder<SystemTable> tableBinder = newSetBinder(binder, SystemTable.class); tableBinder.addBinding().to(ShardMetadataSystemTable.class).in(Scopes.SINGLETON); tableBinder.addBinding().to(TableMetadataSystemTable.class).in(Scopes.SINGLETON); tableBinder.addBinding().to(TableStatsSystemTable.class).in(Scopes.SINGLETON); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@After method clears authorizations if assert statement fails'\nThe code is: 'public void shouldResolveHistoricTaskAuthorization_HistoricProcessInstance() { processEngineConfiguration.setEnableHistoricInstancePermissions(true); testRule.deploy(CALLING_PROCESS); testRule.deploy(CALLED_PROCESS); ClockUtil.setCurrentTime(START_DATE); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(CALLING_PROCESS_KEY); Authorization authorization = authorizationService.createNewAuthorization(Authorization.AUTH_TYPE_GRANT); authorization.setUserId(\"myUserId\"); authorization.setResource(Resources.HISTORIC_PROCESS_INSTANCE); String processInstanceId = processInstance.getProcessInstanceId(); authorization.setResourceId(processInstanceId); authorizationService.saveAuthorization(authorization); Date removalTime = addDays(START_DATE, 5); assertThat(authorization.getRootProcessInstanceId(), is(processInstance.getRootProcessInstanceId())); assertThat(authorization.getRemovalTime(), is(removalTime)); <START> clearAuthorization(); <END> \/\/ @After method clears authorizations if assert statement fails }'","output":"public void shouldResolveHistoricTaskAuthorization_HistoricProcessInstance() { processEngineConfiguration.setEnableHistoricInstancePermissions(true); testRule.deploy(CALLING_PROCESS); testRule.deploy(CALLED_PROCESS); ClockUtil.setCurrentTime(START_DATE); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(CALLING_PROCESS_KEY); Authorization authorization = authorizationService.createNewAuthorization(Authorization.AUTH_TYPE_GRANT); authorization.setUserId(\"myUserId\"); authorization.setResource(Resources.HISTORIC_PROCESS_INSTANCE); String processInstanceId = processInstance.getProcessInstanceId(); authorization.setResourceId(processInstanceId); authorizationService.saveAuthorization(authorization); Date removalTime = addDays(START_DATE, 5); assertThat(authorization.getRootProcessInstanceId(), is(processInstance.getRootProcessInstanceId())); assertThat(authorization.getRemovalTime(), is(removalTime)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is in JiraUpdateWriter. I suggest put Reject Exception creation validateRequestBody() method. Here, leave a call validateRequestBody(json);'\nThe code is: 'public void write(Object datum) throws IOException { if (!opened) { throw new IOException(MESSAGES.getMessage(\"error.writerNotOpened\")); } result.totalCount++; if (datum == null) { return; } IndexedRecord record = getFactory(datum).convertToAvro(datum); if (dataSchema == null) { dataSchema = record.getSchema(); Field jsonField = dataSchema.getField(\"json\"); if (jsonField == null) { throw new IOException(MESSAGES.getMessage(\"error.schemaNotContainJson\")); } jsonPos = jsonField.pos(); } String json = (String) record.get(jsonPos); try { validateRequestBody(json); } catch (DataRejectException e) { throw createRejectException(\"error.invalidRecordCreate\", json, (String) e.getRejectInfo().get(\"message\")); <START> } <END> \/\/ This is in JiraUpdateWriter. I suggest put Reject Exception creation validateRequestBody() method. Here, leave a call validateRequestBody(json); JiraResponse response = getConnection().post(resource, json); handleResponse(response, json, record); }'","output":"public void write(Object datum) throws IOException { if (!opened) { throw new IOException(MESSAGES.getMessage(\"error.writerNotOpened\")); } result.totalCount++; if (datum == null) { return; } IndexedRecord record = getFactory(datum).convertToAvro(datum); if (dataSchema == null) { dataSchema = record.getSchema(); Field jsonField = dataSchema.getField(\"json\"); if (jsonField == null) { throw new IOException(MESSAGES.getMessage(\"error.schemaNotContainJson\")); } jsonPos = jsonField.pos(); } String json = (String) record.get(jsonPos); validateRequestBody(json); JiraResponse response = getConnection().post(resource, json); handleResponse(response, json, record); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This capped max, so: byte[] nb = new byte[Math.min(buf.length * 2, max)];'\nThe code is: 'public static final byte[] readFully(final File path, final int max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(int) sz]; int valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } <START> byte[] nb = new byte[buf.length * 2]; <END> \/\/ This capped max, so: byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } int n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }'","output":"public static final byte[] readFully(final File path, final int max) throws FileNotFoundException, IOException { final FileInputStream in = new FileInputStream(path); try { long sz = Math.max(path.length(), 1); if (sz > max) throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); byte[] buf = new byte[(int) sz]; int valid = 0; for (;;) { if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < 0) break; throw new IOException(MessageFormat.format( JGitText.get().fileIsTooLarge, path)); } byte[] nb = new byte[Math.min(buf.length * 2, max)]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } int n = in.read(buf, valid, buf.length - valid); if (n < 0) break; valid += n; } if (valid < buf.length) { byte[] nb = new byte[valid]; System.arraycopy(buf, 0, nb, 0, valid); buf = nb; } return buf; } finally { try { in.close(); } catch (IOException ignored) { } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@wangqiaoshi if else logic redundant. Is move projectLoader.uploadProjectProperty(project, prop) of if else logics'\nThe code is: 'public void setJobOverrideProperty(Project project, Props prop, String jobName, User modifier) throws ProjectManagerException { prop.setSource(jobName + \".jor\"); Props oldProps = projectLoader.fetchProjectProperty(project, prop.getSource()); if (oldProps == null) { oldProps = new Props(); <START> projectLoader.uploadProjectProperty(project, prop); <END> \/\/ @wangqiaoshi if else logic redundant. Is move projectLoader.uploadProjectProperty(project, prop) of if else logics } else { projectLoader.updateProjectProperty(project, prop); } String diffMessage = PropsUtils.getPropertyDiff(oldProps, prop); projectLoader.postEvent(project, EventType.PROPERTY_OVERRIDE, modifier.getUserId(), diffMessage); return; }'","output":"public void setJobOverrideProperty(Project project, Props prop, String jobName, User modifier) throws ProjectManagerException { prop.setSource(jobName + \".jor\"); Props oldProps = projectLoader.fetchProjectProperty(project, prop.getSource()); projectLoader.updateProjectProperty(project, prop); String diffMessage = PropsUtils.getPropertyDiff(oldProps, prop); projectLoader.postEvent(project, EventType.PROPERTY_OVERRIDE, modifier.getUserId(), diffMessage); return; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'LEGACY_ACCOUNT_ID LEGACY_CONTAINER_ID defined in BlobProperties. Lets declaration in place others same'\nThe code is: 'public void getReplicasTest() throws Exception { List<? extends PartitionId> partitionIds = CLUSTER_MAP.getWritablePartitionIds(); for (PartitionId partitionId : partitionIds) { String originalReplicaStr = partitionId.getReplicaIds().toString().replace(\", \", \",\"); <START> BlobId blobId = new BlobId(BlobId.DEFAULT_FLAG, ClusterMapUtils.LEGACY_DATACENTER_ID, Account.LEGACY_ACCOUNT_ID, <END> \/\/ LEGACY_ACCOUNT_ID LEGACY_CONTAINER_ID defined in BlobProperties. Lets declaration in place others same Container.LEGACY_CONTAINER_ID, partitionId); RestRequest restRequest = AdminTestUtils.createRestRequest(RestMethod.GET, blobId.getID() + \"\/\" + RestUtils.SubResource.Replicas, null, null); MockRestResponseChannel restResponseChannel = new MockRestResponseChannel(); doOperation(restRequest, restResponseChannel); JSONObject response = new JSONObject(new String(restResponseChannel.getResponseBody())); String returnedReplicasStr = response.getString(GetReplicasHandler.REPLICAS_KEY).replace(\"\\\"\", \"\"); assertEquals(\"Replica IDs returned for the BlobId do no match with the replicas IDs of partition\", originalReplicaStr, returnedReplicasStr); } }'","output":"public void getReplicasTest() throws Exception { List<? extends PartitionId> partitionIds = CLUSTER_MAP.getWritablePartitionIds(); for (PartitionId partitionId : partitionIds) { String originalReplicaStr = partitionId.getReplicaIds().toString().replace(\", \", \",\"); BlobId blobId = new BlobId(BlobId.DEFAULT_FLAG, ClusterMapUtils.UNKNOWN_DATACENTER_ID, Account.UNKNOWN_ACCOUNT_ID, Container.UNKNOWN_CONTAINER_ID, partitionId); RestRequest restRequest = AdminTestUtils.createRestRequest(RestMethod.GET, blobId.getID() + \"\/\" + RestUtils.SubResource.Replicas, null, null); MockRestResponseChannel restResponseChannel = new MockRestResponseChannel(); doOperation(restRequest, restResponseChannel); JSONObject response = new JSONObject(new String(restResponseChannel.getResponseBody())); String returnedReplicasStr = response.getString(GetReplicasHandler.REPLICAS_KEY).replace(\"\\\"\", \"\"); assertEquals(\"Replica IDs returned for the BlobId do no match with the replicas IDs of partition\", originalReplicaStr, returnedReplicasStr); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This check is adding removing problem \/ nodes. Returning true leads a prune of child-tree branch beneath node. this \"rule\" (skipping visited nodes) applied node types e.g. ExecTCs e.g. if parent is re-used in contexts, occurring multiple times a traversing run relevant problem cleanup new problem creation'\nThe code is: 'public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { <START> if (alreadyVisited) { return true; } <END> \/\/ This check is adding removing problem \/ nodes. Returning true leads a prune of child-tree branch beneath node. this \"rule\" (skipping visited nodes) applied node types e.g. ExecTCs e.g. if parent is re-used in contexts, occurring multiple times a traversing run relevant problem cleanup new problem creation clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { int severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }'","output":"public boolean operate(ITreeTraverserContext<INodePO> ctx, INodePO parent, INodePO node, boolean alreadyVisited) { clearNodeFromTeststyleProblem(node); for (BaseCheck chk : ProblemCont.instance.getChecksFor(node)) { int severity = getIntForSeverity(chk.getSeverity()); String message = chk.getDescription(); if (severity > IStatus.INFO) { node.addProblem(ProblemFactory.createProblem( new Status(severity, Activator.PLUGIN_ID, message))); } } if (node instanceof IExecTestCasePO) { IExecTestCasePO execTestCase = (IExecTestCasePO) node; handleExecTestCase(execTestCase); } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add final Exceptions'\nThe code is: 'public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, \"RyaStreams-Query-\" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\"); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); <START> } catch (MalformedQueryException | TopologyBuilderException e) { <END> \/\/ add final Exceptions throw new KafkaStreamsFactoryException(\"Could not create a KafkaStreams processing topology for query \" + query.getQueryId(), e); } }'","output":"public KafkaStreams make(final String ryaInstance, final StreamsQuery query) throws KafkaStreamsFactoryException { requireNonNull(ryaInstance); requireNonNull(query); final Properties streamsProps = new Properties(); streamsProps.setProperty(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig); streamsProps.put(StreamsConfig.APPLICATION_ID_CONFIG, \"RyaStreams-Query-\" + query.getQueryId()); streamsProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\"); final String statementsTopic = KafkaTopics.statementsTopic(ryaInstance); final String resultsTopic = KafkaTopics.queryResultsTopic(query.getQueryId()); try { final TopologyBuilder topologyBuilder = topologyFactory.build(query.getSparql(), statementsTopic, resultsTopic, new RandomUUIDFactory()); return new KafkaStreams(topologyBuilder, new StreamsConfig(streamsProps)); } catch (final MalformedQueryException | TopologyBuilderException e) { throw new KafkaStreamsFactoryException(\"Could not create a KafkaStreams processing topology for query \" + query.getQueryId(), e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new UdpMatcher(config) ..'\nThe code is: 'public CoapEndpoint(Connector connector, NetworkConfig config) { this.config = config; this.connector = connector; if (connector.isTcp()) { this.matcher = new TcpMatcher(config); this.coapstack = new CoapTcpStack(config, new OutboxImpl()); this.serializer = new Serializer(new TcpDataSerializer()); this.parser = new TcpDataParser(); } else { <START> this.matcher = new TcpMatcher(config); <END> \/\/ new UdpMatcher(config) .. this.coapstack = new CoapUdpStack(config, new OutboxImpl()); this.serializer = new Serializer(new UdpDataSerializer()); this.parser = new UdpDataParser(); } this.connector.setRawDataReceiver(new InboxImpl()); }'","output":"public CoapEndpoint(Connector connector, NetworkConfig config) { this.config = config; this.connector = connector; if (connector.isTcp()) { this.matcher = new TcpMatcher(config); this.coapstack = new CoapTcpStack(config, new OutboxImpl()); this.serializer = new Serializer(new TcpDataSerializer()); this.parser = new TcpDataParser(); } else { this.matcher = new UdpMatcher(config); this.coapstack = new CoapUdpStack(config, new OutboxImpl()); this.serializer = new Serializer(new UdpDataSerializer()); this.parser = new UdpDataParser(); } this.connector.setRawDataReceiver(new InboxImpl()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Swap equals condition'\nThe code is: 'public void initialize() throws Exception { super.init(userMode); backendUrl = gatewayContextMgt.getContextUrls().getBackEndUrl(); loginClient = new AuthenticatorClient(backendUrl); String session = loginClient.login(user.getUserName(), user.getPassword(), \"localhost\"); lifeCycleAdminClient = new LifeCycleAdminClient(backendUrl, session); originalLifeCycleContent = lifeCycleAdminClient.getLifecycleConfiguration(apiLifeCycleName); String customizedAPILifecycleContent = FileManager.readFile(customizedAPILifecyclePath); lifeCycleAdminClient.editLifeCycle(apiLifeCycleName, customizedAPILifecycleContent); String gatewayUrl; <START> if (gatewayContextWrk.getContextTenant().getDomain().equals(MultitenantConstants.SUPER_TENANT_DOMAIN_NAME)) { <END> \/\/ Swap equals condition gatewayUrl = gatewayUrlsWrk.getWebAppURLNhttp(); } else { gatewayUrl = gatewayUrlsWrk.getWebAppURLNhttp() + \"t\/\" + gatewayContextWrk.getContextTenant().getDomain() + \"\/\"; } apiEndPointUrl = gatewayUrl + \"jaxrs_basic\/services\/customers\/customerservice\"; APIRequest apiRequest = new APIRequest(API_NAME, API_CONTEXT, new URL(apiEndPointUrl)); apiRequest.setVersion(API_VERSION_1_0_0); apiRequest.setSandbox(apiEndPointUrl); apiRequest.setProvider(user.getUserName()); HttpResponse serviceResponse = restAPIPublisher.addAPI(apiRequest); apiId = serviceResponse.getData(); }'","output":"public void initialize() throws Exception { super.init(userMode); backendUrl = gatewayContextMgt.getContextUrls().getBackEndUrl(); loginClient = new AuthenticatorClient(backendUrl); String session = loginClient.login(user.getUserName(), user.getPassword(), \"localhost\"); lifeCycleAdminClient = new LifeCycleAdminClient(backendUrl, session); originalLifeCycleContent = lifeCycleAdminClient.getLifecycleConfiguration(apiLifeCycleName); String customizedAPILifecycleContent = FileManager.readFile(customizedAPILifecyclePath); lifeCycleAdminClient.editLifeCycle(apiLifeCycleName, customizedAPILifecycleContent); String gatewayUrl; if (MultitenantConstants.SUPER_TENANT_DOMAIN_NAME.equals(gatewayContextWrk.getContextTenant().getDomain())) { gatewayUrl = gatewayUrlsWrk.getWebAppURLNhttp(); } else { gatewayUrl = gatewayUrlsWrk.getWebAppURLNhttp() + \"t\/\" + gatewayContextWrk.getContextTenant().getDomain() + \"\/\"; } apiEndPointUrl = gatewayUrl + \"jaxrs_basic\/services\/customers\/customerservice\"; APIRequest apiRequest = new APIRequest(API_NAME, API_CONTEXT, new URL(apiEndPointUrl)); apiRequest.setVersion(API_VERSION_1_0_0); apiRequest.setSandbox(apiEndPointUrl); apiRequest.setProvider(user.getUserName()); HttpResponse serviceResponse = restAPIPublisher.addAPI(apiRequest); apiId = serviceResponse.getData(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: again, error text'\nThe code is: 'public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(\"\/dir1\/fileK1\", \"\/dir1\/fileK2\", \"\/dir1\/fileK3\")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(\"\/dir1\/fileR1\", \"\/dir1\/fileR2\", \"\/dir1\/fileR3\")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); <START> assertNull(pathMetadata); <END> \/\/ nit: again, error text } }'","output":"public void testPruneExpiredTombstones() throws Exception { List<String> keepFilenames = new ArrayList<>( Arrays.asList(\"\/dir1\/fileK1\", \"\/dir1\/fileK2\", \"\/dir1\/fileK3\")); List<String> removeFilenames = new ArrayList<>( Arrays.asList(\"\/dir1\/fileR1\", \"\/dir1\/fileR2\", \"\/dir1\/fileR3\")); long cutoff = 9001; for(String fN : keepFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9002L); ms.put(pathMetadata); } for(String fN : removeFilenames) { final PathMetadata pathMetadata = new PathMetadata(makeFileStatus(fN, 1)); pathMetadata.setLastUpdated(9000L); pathMetadata.setIsDeleted(true); ms.put(pathMetadata); } ms.prune(MetadataStore.PruneMode.TOMBSTONES_BY_LASTUPDATED, cutoff); if(!allowMissing()) { for (String fN : keepFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNotNull(\"Kept files should be in the metastore after prune\", pathMetadata); } } for(String fN : removeFilenames) { final PathMetadata pathMetadata = ms.get(strToPath(fN)); assertNull(\"Expired tombstones should be removed from metastore after \" + \"the prune.\", pathMetadata); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'avoid increasing visibility?'\nThe code is: '<START> public IStatus runInternal(final IProgressMonitor monitor) { <END> \/\/ avoid increasing visibility? ResourceSet set = new ResourceSetImpl(); try { if (!resource.isLoaded()) return Status.CANCEL_STATUS; final Resource shadowResource = set.createResource(resource.getURI()); cloneResource(monitor, shadowResource); if (monitor.isCanceled()) return Status.CANCEL_STATUS; final List<Issue> issues = Lists.newArrayList(); try { issues.addAll(validator.validate(shadowResource, CheckMode.FAST_ONLY, new CancelIndicator() { public boolean isCanceled() { return monitor.isCanceled(); } })); } catch (Throwable ex) { return Status.CANCEL_STATUS; } validationIssueProcessor.processIssues(issues, monitor); } catch (Exception ex) { ex.printStackTrace(); return new Status(IStatus.ERROR, DiagramActivator.PLUGIN_ID, ex.getMessage()); } return Status.OK_STATUS; }'","output":"protected IStatus runInternal(final IProgressMonitor monitor) { ResourceSet set = new ResourceSetImpl(); try { if (!resource.isLoaded()) return Status.CANCEL_STATUS; final Resource shadowResource = set.createResource(resource.getURI()); cloneResource(monitor, shadowResource); if (monitor.isCanceled()) return Status.CANCEL_STATUS; final List<Issue> issues = Lists.newArrayList(); try { issues.addAll(validator.validate(shadowResource, CheckMode.FAST_ONLY, new CancelIndicator() { public boolean isCanceled() { return monitor.isCanceled(); } })); } catch (Throwable ex) { return Status.CANCEL_STATUS; } validationIssueProcessor.processIssues(issues, monitor); } catch (Exception ex) { ex.printStackTrace(); return new Status(IStatus.ERROR, DiagramActivator.PLUGIN_ID, ex.getMessage()); } return Status.OK_STATUS; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If test is measuring scalability of read operations, persist data touch data needs change. means writing data part of test, a separate script is run manually need. For measuring scalability of write operations, need separate _primary_ objects write measured _supplementary_ objects simply need for write succeed. e.g. session object needs in datastore for operation of writing responses succeed. that, supplementary object written a script, similar case above'\nThe code is: 'private void refreshTestData(int numStudents, int numQuestions) { if (testData.students.size() == 0) { addStudents(numStudents); } else if (testData.students.size() < numStudents) { addStudents(numStudents - testData.students.size()); } else if (testData.students.size() > numStudents) { decreaseNumOfStudents(numStudents); } if (testData.feedbackQuestions.size() == 0) { addQuestions(numQuestions); } else if (testData.feedbackQuestions.size() < numQuestions) { addQuestions(numQuestions - testData.feedbackQuestions.size()); } else if (testData.feedbackQuestions.size() > numQuestions) { decreaseNumOfQuestions(numQuestions); } updateFeedbackResponses(); <START> removeAndRestoreDataBundle(testData); <END> \/\/ If test is measuring scalability of read operations, persist data touch data needs change. means writing data part of test, a separate script is run manually need. For measuring scalability of write operations, need separate _primary_ objects write measured _supplementary_ objects simply need for write succeed. e.g. session object needs in datastore for operation of writing responses succeed. that, supplementary object written a script, similar case above }'","output":"private void refreshTestData(int numStudents, int numQuestions) { if (testData.students.size() == 0) { addStudents(numStudents); } else if (testData.students.size() < numStudents) { addStudents(numStudents - testData.students.size()); } else if (testData.students.size() > numStudents) { decreaseNumOfStudents(numStudents); } if (testData.feedbackQuestions.size() == 0) { addQuestions(numQuestions); } else if (testData.feedbackQuestions.size() < numQuestions) { addQuestions(numQuestions - testData.feedbackQuestions.size()); } else if (testData.feedbackQuestions.size() > numQuestions) { decreaseNumOfQuestions(numQuestions); } updateFeedbackResponses(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This 4.2, no'\nThe code is: 'public Aggregation(StreamInput in) throws IOException { functionInfo = new FunctionInfo(in); valueType = DataTypes.fromStream(in); if (in.getVersion().onOrAfter(Version.V_4_1_0)) { filter = Symbols.fromStream(in); } else { filter = Literal.BOOLEAN_TRUE; } inputs = Symbols.listFromStream(in); <START> if (in.getVersion().onOrAfter(Version.V_4_1_0) && in.readBoolean()) { <END> \/\/ This 4.2, no signature = new Signature(in); } else { signature = null; } }'","output":"public Aggregation(StreamInput in) throws IOException { functionInfo = new FunctionInfo(in); valueType = DataTypes.fromStream(in); if (in.getVersion().onOrAfter(Version.V_4_1_0)) { filter = Symbols.fromStream(in); } else { filter = Literal.BOOLEAN_TRUE; } inputs = Symbols.listFromStream(in); if (in.getVersion().onOrAfter(Version.V_4_2_0) && in.readBoolean()) { signature = new Signature(in); } else { signature = null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertTrue'\nThe code is: 'public void testFailWithMultipleDisksWhichOneInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId1 = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId1)).thenReturn(backupStorageDomain(false)); Guid storageDomainId2 = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId2)).thenReturn(backupStorageDomain(true)); <START> assertFalse(\"checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain\", <END> \/\/ assertTrue command.checkDisksInBackupStorage()); }'","output":"public void testFailWithMultipleDisksWhichOneInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId1 = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId1)).thenReturn(backupStorageDomain(false)); Guid storageDomainId2 = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId2)).thenReturn(backupStorageDomain(true)); assertTrue(\"checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain\", command.checkDisksInBackupStorage()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's\/any(List.class)\/anyList\/'\nThe code is: 'public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). <START> when(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); <END> \/\/ s\/any(List.class)\/anyList\/ doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class)); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class)); }'","output":"public void validateSpaceNotEnough() throws Exception { AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0); doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds(); doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)). when(storageDomainValidator).hasSpaceForNewDisks(anyList()); doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class)); assertFalse(command.validateSpaceRequirements()); verify(storageDomainValidator).hasSpaceForNewDisks(anyList()); verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please this more deterministic sleeping'\nThe code is: 'public void testEntryMemTableParallelFlushWithFlushException() throws Exception { int gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); <START> Thread.sleep(1000); <END> \/\/ please this more deterministic sleeping assertFalse(\"EntryMemTable SnapShot is not expected to be empty\", memTable.snapshot.isEmpty()); assertEquals(\"Flusher called\", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); Thread.sleep(1000); assertTrue(\"EntryMemTable SnapShot is expected to be empty\", memTable.snapshot.isEmpty()); assertEquals(\"Flusher called\", 2, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }'","output":"public void testEntryMemTableParallelFlushWithFlushException() throws Exception { int gcWaitTime = 1000; ServerConfiguration conf = TestBKConfiguration.newServerConfiguration(); conf.setGcWaitTime(gcWaitTime); conf.setLedgerDirNames(createAndGetLedgerDirs(1)); conf.setLedgerStorageClass(FlushTestSortedLedgerStorage.class.getName()); conf.setEntryLogPerLedgerEnabled(true); Bookie bookie = new Bookie(conf); FlushTestSortedLedgerStorage flushTestSortedLedgerStorage = (FlushTestSortedLedgerStorage) bookie.ledgerStorage; EntryMemTable memTable = flushTestSortedLedgerStorage.memTable; bookie.addEntry(generateEntry(1, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); bookie.addEntry(generateEntry(2, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); bookie.addEntry(generateEntry(3, 1), false, new Bookie.NopWriteCallback(), null, \"passwd\".getBytes()); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(2, 4)); flushTestSortedLedgerStorage.addEntry(generateEntry(3, 4)); flushTestSortedLedgerStorage.setInjectMemTableSizeLimitReached(true); flushTestSortedLedgerStorage.setInjectFlushException(true, 1L); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertFalse(\"EntryMemTable SnapShot is not expected to be empty\", memTable.snapshot.isEmpty()); assertEquals(\"Flusher called\", 1, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); flushTestSortedLedgerStorage.setInjectFlushException(false, FlushTestSortedLedgerStorage.FORALLLEDGERS); flushTestSortedLedgerStorage.addEntry(generateEntry(1, 5)); assertTrue(\"EntryMemTable SnapShot is expected to be empty\", memTable.snapshot.isEmpty()); assertEquals(\"Flusher called\", 2, flushTestSortedLedgerStorage.getNumOfTimesFlushSnapshotCalled()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove this check do this check initializeRunId()'\nThe code is: 'public void run(ExternalContext externalContext) { <START> if (isAppModeBatch) { <END> \/\/ remove this check do this check initializeRunId() initializeRunId(); } LocalJobPlanner planner = getPlanner(); try { List<JobConfig> jobConfigs = planner.prepareJobs(); if (jobConfigs.isEmpty()) { throw new SamzaException(\"No jobs to run.\"); } jobConfigs.forEach(jobConfig -> { LOG.debug(\"Starting job {} StreamProcessor with config {}\", jobConfig.getName(), jobConfig); StreamProcessor processor = createStreamProcessor(jobConfig, appDesc, sp -> new LocalStreamProcessorLifecycleListener(sp, jobConfig), Optional.ofNullable(externalContext)); processors.add(processor); }); numProcessorsToStart.set(processors.size()); processors.forEach(StreamProcessor::start); } catch (Throwable throwable) { cleanup(); appStatus = ApplicationStatus.unsuccessfulFinish(throwable); shutdownLatch.countDown(); throw new SamzaException(String.format(\"Failed to start application: %s\", new ApplicationConfig(appDesc.getConfig()).getGlobalAppId()), throwable); } }'","output":"public void run(ExternalContext externalContext) { initializeRunId(); LocalJobPlanner planner = getPlanner(); try { List<JobConfig> jobConfigs = planner.prepareJobs(); if (jobConfigs.isEmpty()) { throw new SamzaException(\"No jobs to run.\"); } jobConfigs.forEach(jobConfig -> { LOG.debug(\"Starting job {} StreamProcessor with config {}\", jobConfig.getName(), jobConfig); StreamProcessor processor = createStreamProcessor(jobConfig, appDesc, sp -> new LocalStreamProcessorLifecycleListener(sp, jobConfig), Optional.ofNullable(externalContext)); processors.add(processor); }); numProcessorsToStart.set(processors.size()); processors.forEach(StreamProcessor::start); } catch (Throwable throwable) { cleanup(); appStatus = ApplicationStatus.unsuccessfulFinish(throwable); shutdownLatch.countDown(); throw new SamzaException(String.format(\"Failed to start application: %s\", new ApplicationConfig(appDesc.getConfig()).getGlobalAppId()), throwable); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is Syso needed? try log function remove it'\nThe code is: 'protected void fillDisplay(final Collection collection) { DecimalFormat format = new DecimalFormat(\"0.##\"); java.util.List<Collectible> list = collection.sort(new RarityComparator()); cContentTable.clear(); <START> System.out.println(list); <END> \/\/ Is Syso needed? try log function remove it for (final Collectible collectible : list) { cContentTable.add(new Image(CollectibleDrawer.drawCollectible(collectible))).space(30); } cContentTable.row(); for (final Collectible collectible : list) { cContentTable.add(cGameSkin.generateDefaultLabel(format.format(collectible.getRarity()))); } }'","output":"protected void fillDisplay(final Collection collection) { DecimalFormat format = new DecimalFormat(\"0.##\"); java.util.List<Collectible> list = collection.sort(new RarityComparator()); cContentTable.clear(); for (final Collectible collectible : list) { cContentTable.add(new Image(CollectibleDrawer.drawCollectible(collectible))).space(30); } cContentTable.row(); for (final Collectible collectible : list) { cContentTable.add(cGameSkin.generateDefaultLabel(format.format(collectible.getRarity()))); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else needed , exception stops method code'\nThe code is: 'public String viewEntityDetailsById(@PathVariable(value = \"entityTypeId\") String entityTypeId, @PathVariable(value = \"entityId\") String entityId, Model model) throws Exception { EntityType entityType = dataService.getEntityType(entityTypeId); if (entityType == null) { throw new MolgenisDataAccessException( \"EntityType with id [\" + entityTypeId + \"] does not exist. Did you use the correct URL?\"); } <START> else <END> \/\/ else needed , exception stops method code { Object id = getTypedValue(entityId, entityType.getIdAttribute()); model.addAttribute(\"entity\", dataService.getRepository(entityTypeId).findOneById(id)); model.addAttribute(\"entityType\", entityType); model.addAttribute(\"entityTypeId\", entityTypeId); model.addAttribute(\"viewName\", getStandaloneReportViewName(entityTypeId)); return \"view-standalone-report\"; } }'","output":"public String viewEntityDetailsById(@PathVariable(value = \"entityTypeId\") String entityTypeId, @PathVariable(value = \"entityId\") String entityId, Model model) throws Exception { EntityType entityType = dataService.getEntityType(entityTypeId); if (entityType == null) { throw new MolgenisDataAccessException( \"EntityType with id [\" + entityTypeId + \"] does not exist. Did you use the correct URL?\"); } Object id = getTypedValue(entityId, entityType.getIdAttribute()); model.addAttribute(\"entity\", dataService.getRepository(entityTypeId).findOneById(id)); model.addAttribute(\"entityType\", entityType); model.addAttribute(\"entityTypeId\", entityTypeId); model.addAttribute(\"viewName\", getStandaloneReportViewName(entityTypeId)); return \"view-standalone-report\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please AssertJ'\nThe code is: 'public void streamEventsbyName() throws IOException, InterruptedException { List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"\/backendA\"); CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"\/backendA\"); dummyService.doSomething(false); Thread.sleep(1000); try { dummyService.doSomething(true); } catch (IOException ex) { } CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"\/backendA\"); Thread.sleep(1000); <START> assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size()); <END> \/\/ Please AssertJ assert (events.size() == 2); }'","output":"public void streamEventsbyName() throws IOException, InterruptedException { List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"\/backendB\"); CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"\/backendB\"); publishEvents(); CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"\/backendB\"); Thread.sleep(1000); assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size()); assertThat (events.size()).isEqualTo(2); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Check args'\nThe code is: '<START> public VolatilitySurface getVolSurface(final DoubleMatrix1D modelParameters) { <END> \/\/ Check args final Function1D<double[], Double> func = new BasisFunctionAggregation<>(_bSplines, modelParameters.getData()); final Function2D<Double, Double> func2D = new Function2D<Double, Double>() { @Override public Double evaluate(final Double t, final Double k) { return func.evaluate(new double[] {t, k }); } }; final FunctionalDoublesSurface surface = new FunctionalDoublesSurface(func2D); return new VolatilitySurface(surface); }'","output":"public VolatilitySurface getVolSurface(final DoubleMatrix1D modelParameters) { ArgumentChecker.notNull(modelParameters, \"modelParameters\"); final Function1D<double[], Double> func = new BasisFunctionAggregation<>(_bSplines, modelParameters.getData()); final Function2D<Double, Double> func2D = new Function2D<Double, Double>() { @Override public Double evaluate(final Double t, final Double k) { return func.evaluate(new double[] {t, k }); } }; final FunctionalDoublesSurface surface = new FunctionalDoublesSurface(func2D); return new VolatilitySurface(surface); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ditto \"indeterminate\" in error messages'\nThe code is: 'private static void buildHashTableStrict( Block keyBlock, int keyOffset, int keyCount, MethodHandle keyBlockEquals, MethodHandle keyBlockHashCode, int[] outputHashTable, int hashTableOffset, int hashTableSize) throws DuplicateMapKeyException { for (int i = 0; i < keyCount; i++) { int hash = getHashPosition(keyBlock, keyOffset + i, keyBlockHashCode, hashTableSize); while (true) { if (outputHashTable[hashTableOffset + hash] == -1) { outputHashTable[hashTableOffset + hash] = i; break; } Boolean isDuplicateKey; try { isDuplicateKey = (Boolean) keyBlockEquals.invokeExact(keyBlock, keyOffset + i, keyBlock, keyOffset + outputHashTable[hashTableOffset + hash]); } catch (RuntimeException e) { throw e; } catch (Throwable throwable) { throw new RuntimeException(throwable); } if (isDuplicateKey == null) { <START> throw new PrestoException(NOT_SUPPORTED, \"map key cannot be indeterminate\"); <END> \/\/ ditto \"indeterminate\" in error messages } if (isDuplicateKey) { throw new DuplicateMapKeyException(keyBlock, keyOffset + i); } hash++; if (hash == hashTableSize) { hash = 0; } } } }'","output":"private static void buildHashTableStrict( Block keyBlock, int keyOffset, int keyCount, MethodHandle keyBlockEquals, MethodHandle keyBlockHashCode, int[] outputHashTable, int hashTableOffset, int hashTableSize) throws DuplicateMapKeyException { for (int i = 0; i < keyCount; i++) { int hash = getHashPosition(keyBlock, keyOffset + i, keyBlockHashCode, hashTableSize); while (true) { if (outputHashTable[hashTableOffset + hash] == -1) { outputHashTable[hashTableOffset + hash] = i; break; } Boolean isDuplicateKey; try { isDuplicateKey = (Boolean) keyBlockEquals.invokeExact(keyBlock, keyOffset + i, keyBlock, keyOffset + outputHashTable[hashTableOffset + hash]); } catch (RuntimeException e) { throw e; } catch (Throwable throwable) { throw new RuntimeException(throwable); } if (isDuplicateKey == null) { throw new PrestoException(NOT_SUPPORTED, \"map key cannot be null or contain nulls\"); } if (isDuplicateKey) { throw new DuplicateMapKeyException(keyBlock, keyOffset + i); } hash++; if (hash == hashTableSize) { hash = 0; } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is unnecessary -- of resolution is done population of entity DTO'\nThe code is: 'public PoolDTO createPool(@PathParam(\"owner_key\") @Verify(Owner.class) String ownerKey, @ApiParam(name = \"pool\", required = true) PoolDTO inputPoolDTO) { log.info(\"Creating custom pool for owner {}: {}\" + ownerKey, inputPoolDTO); Pool pool = new Pool(); Owner owner = findOwnerByKey(ownerKey); pool.setOwner(owner); this.populateEntity(pool, inputPoolDTO); <START> pool = resolverUtil.resolvePool(pool); <END> \/\/ This is unnecessary -- of resolution is done population of entity DTO pool = poolManager.createAndEnrichPools(pool); return this.translator.translate(pool, PoolDTO.class); }'","output":"public PoolDTO createPool(@PathParam(\"owner_key\") @Verify(Owner.class) String ownerKey, @ApiParam(name = \"pool\", required = true) PoolDTO inputPoolDTO) { log.info(\"Creating custom pool for owner {}: {}\" + ownerKey, inputPoolDTO); Pool pool = new Pool(); Owner owner = findOwnerByKey(ownerKey); pool.setOwner(owner); this.populateEntity(pool, inputPoolDTO); pool = poolManager.createAndEnrichPools(pool); return this.translator.translate(pool, PoolDTO.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'local variable'\nThe code is: 'public void testPublish() { byte[] testBytes = {}; <START> String testString = \"Test\"; <END> \/\/ local variable when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(testString); Response response = resource.publish(key, \"Test\", inputStream, contentDisposition, \"photo\", \"Test\", \"Test\"); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, \"Test\"); }'","output":"public void testPublish() { byte[] testBytes = {}; when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(\"Test\"); Response response = resource.publish(key, \"Test\", inputStream, contentDisposition, \"photo\", \"Test\", \"Test\"); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, \"Test\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this if-else if-else if-else longer, switch case'\nThe code is: 'public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, \"\/jmx\")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(\"beans\"); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(\"name\").equals(\"Hadoop:service=NameNode,name=BlockStats\")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(\"StorageTypeStats\"); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(\"key\"); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(\"value\"); typesPresent.add(storageType); if (storageType.equals(\"ARCHIVE\") || storageType.equals(\"DISK\") ) { assertEquals(3L, storageTypeStats.get(\"nodesInService\")); } else if (storageType.equals(\"RAM_DISK\")) { <START> assertEquals(7L, storageTypeStats.get(\"nodesInService\")); <END> \/\/ this if-else if-else if-else longer, switch case } else if (storageType.equals(\"NVDIMM\")) { assertEquals(1L, storageTypeStats.get(\"nodesInService\")); } else { fail(); } } assertTrue(typesPresent.contains(\"ARCHIVE\")); assertTrue(typesPresent.contains(\"DISK\")); assertTrue(typesPresent.contains(\"RAM_DISK\")); assertTrue(typesPresent.contains(\"NVDIMM\")); }'","output":"public void testStorageTypeStatsJMX() throws Exception { URL baseUrl = new URL (cluster.getHttpUri(0)); String result = readOutput(new URL(baseUrl, \"\/jmx\")); Map<String, Object> stat = (Map<String, Object>) JSON.parse(result); Object[] beans =(Object[]) stat.get(\"beans\"); Map<String, Object> blockStats = null; for (Object bean : beans) { Map<String, Object> map = (Map<String, Object>) bean; if (map.get(\"name\").equals(\"Hadoop:service=NameNode,name=BlockStats\")) { blockStats = map; } } assertNotNull(blockStats); Object[] storageTypeStatsList = (Object[])blockStats.get(\"StorageTypeStats\"); assertNotNull(storageTypeStatsList); assertEquals(4, storageTypeStatsList.length); Set<String> typesPresent = new HashSet<> (); for (Object obj : storageTypeStatsList) { Map<String, Object> entry = (Map<String, Object>)obj; String storageType = (String)entry.get(\"key\"); Map<String,Object> storageTypeStats = (Map<String,Object>)entry.get(\"value\"); typesPresent.add(storageType); switch (storageType) { case \"ARCHIVE\": case \"DISK\": assertEquals(3L, storageTypeStats.get(\"nodesInService\")); break; case \"RAM_DISK\": assertEquals(7L, storageTypeStats.get(\"nodesInService\")); break; case \"NVDIMM\": assertEquals(1L, storageTypeStats.get(\"nodesInService\")); break; default: fail(); } } assertTrue(typesPresent.contains(\"ARCHIVE\")); assertTrue(typesPresent.contains(\"DISK\")); assertTrue(typesPresent.contains(\"RAM_DISK\")); assertTrue(typesPresent.contains(\"NVDIMM\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, for clarifying: Build.VERSION_CODES.JELLY_BEAN_MR2'\nThe code is: 'protected Dialog onCreateDialog(int id) { Dialog dialog = null; AlertDialog.Builder builder; switch (id) { case DIALOG_SHORT_WAIT: { ProgressDialog working_dialog = new ProgressDialog(this); working_dialog.setMessage(getResources().getString( R.string.wait_a_moment)); working_dialog.setIndeterminate(true); working_dialog.setCancelable(false); dialog = working_dialog; break; } case DIALOG_CHOOSE_UPLOAD_SOURCE: { String[] allTheItems = { getString(R.string.actionbar_upload_files), getString(R.string.actionbar_upload_from_apps) }; builder = new AlertDialog.Builder(this); builder.setTitle(R.string.actionbar_upload); builder.setItems(allTheItems, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int item) { if (item == 0) { Intent action = new Intent(FileDisplayActivity.this, UploadFilesActivity.class); action.putExtra(UploadFilesActivity.EXTRA_ACCOUNT, FileDisplayActivity.this.getAccount()); startActivityForResult(action, ACTION_SELECT_MULTIPLE_FILES); } else if (item == 1) { Intent action = new Intent(Intent.ACTION_GET_CONTENT); action = action.setType(\"*\/*\").addCategory(Intent.CATEGORY_OPENABLE); <START> if(Build.VERSION.SDK_INT >= 18) { <END> \/\/ here, for clarifying: Build.VERSION_CODES.JELLY_BEAN_MR2 action.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); } startActivityForResult(Intent.createChooser(action, getString(R.string.upload_chooser_title)), ACTION_SELECT_CONTENT_FROM_APPS); } } }); dialog = builder.create(); break; } case DIALOG_CERT_NOT_SAVED: { builder = new AlertDialog.Builder(this); builder.setMessage(getResources().getString(R.string.ssl_validator_not_saved)); builder.setCancelable(false); builder.setPositiveButton(R.string.common_ok, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); }; }); dialog = builder.create(); break; } default: dialog = null; } return dialog; }'","output":"protected Dialog onCreateDialog(int id) { Dialog dialog = null; AlertDialog.Builder builder; switch (id) { case DIALOG_SHORT_WAIT: { ProgressDialog working_dialog = new ProgressDialog(this); working_dialog.setMessage(getResources().getString( R.string.wait_a_moment)); working_dialog.setIndeterminate(true); working_dialog.setCancelable(false); dialog = working_dialog; break; } case DIALOG_CHOOSE_UPLOAD_SOURCE: { String[] allTheItems = { getString(R.string.actionbar_upload_files), getString(R.string.actionbar_upload_from_apps) }; builder = new AlertDialog.Builder(this); builder.setTitle(R.string.actionbar_upload); builder.setItems(allTheItems, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int item) { if (item == 0) { Intent action = new Intent(FileDisplayActivity.this, UploadFilesActivity.class); action.putExtra(UploadFilesActivity.EXTRA_ACCOUNT, FileDisplayActivity.this.getAccount()); startActivityForResult(action, ACTION_SELECT_MULTIPLE_FILES); } else if (item == 1) { Intent action = new Intent(Intent.ACTION_GET_CONTENT); action = action.setType(\"*\/*\").addCategory(Intent.CATEGORY_OPENABLE); if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) { action.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); } startActivityForResult(Intent.createChooser(action, getString(R.string.upload_chooser_title)), ACTION_SELECT_CONTENT_FROM_APPS); } } }); dialog = builder.create(); break; } case DIALOG_CERT_NOT_SAVED: { builder = new AlertDialog.Builder(this); builder.setMessage(getResources().getString(R.string.ssl_validator_not_saved)); builder.setCancelable(false); builder.setPositiveButton(R.string.common_ok, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); }; }); dialog = builder.create(); break; } default: dialog = null; } return dialog; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'end variable is once, hence, is inline it: qualifyingSet.setEnd(qualifyingSet.getEnd()); However, inlining shows variable statement necessary. remove these'\nThe code is: 'private QualifyingSet evaluateFilterFunction(int streamIdx, QualifyingSet qualifyingSet) { boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { int[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; int numRows = qualifyingSet.getPositionCount(); for (int channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new int[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); int numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); <START> int end = qualifyingSet.getEnd(); <END> \/\/ end variable is once, hence, is inline it: qualifyingSet.setEnd(qualifyingSet.getEnd()); However, inlining shows variable statement necessary. remove these qualifyingSet.setEnd(end); int[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }'","output":"private QualifyingSet evaluateFilterFunction(int streamIdx, QualifyingSet qualifyingSet) { boolean isFirstFunction = true; for (FilterFunction function : filterFunctionOrder[streamIdx]) { int[] channels = function.getInputChannels(); Block[] blocks = new Block[channels.length]; int numRows = qualifyingSet.getPositionCount(); for (int channelIdx = 0; channelIdx < channels.length; channelIdx++) { blocks[channelIdx] = makeFilterFunctionInputBlock(channelIdx, streamIdx, numRows, function); } if (filterResults == null || filterResults.length < numRows) { filterResults = new int[numRows + 100]; } StreamReader reader = sortedStreamReaders[streamIdx]; qualifyingSet = reader.getOrCreateOutputQualifyingSet(); long start = System.nanoTime(); int numHits = function.filter(new Page(numRows, blocks), filterResults, qualifyingSet.getOrCreateErrorSet()); function.updateStats(numRows, numHits, System.nanoTime() - start); if (reader.getFilter() == null && isFirstFunction) { qualifyingSet.copyFrom(reader.getInputQualifyingSet()); int[] inputNumbers = qualifyingSet.getMutableInputNumbers(numHits); System.arraycopy(filterResults, 0, inputNumbers, 0, numHits); } else { qualifyingSet.compactInputNumbers(filterResults, numHits); } reader.compactValues(filterResults, numRowsInResult, numHits); if (numHits == 0) { return qualifyingSet; } isFirstFunction = false; } return qualifyingSet; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this. required'\nThe code is: 'public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final int extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (int i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); <START> if (this.pQueue.size() > this.threshold) { <END> \/\/ is this. required pQueue.poll(); } } return this; }'","output":"public TopNResultBuilder addEntry( String dimName, Object dimValIndex, Object[] metricVals ) { final Map<String, Object> metricValues = Maps.newHashMapWithExpectedSize(metricVals.length + 1); if (shouldAdd(dimName)) { metricValues.put(dimSpec.getOutputName(), dimName); final int extra = metricVals.length % LOOP_UNROLL_COUNT; switch (extra) { case 7: metricValues.put(aggFactoryNames[6], metricVals[6]); case 6: metricValues.put(aggFactoryNames[5], metricVals[5]); case 5: metricValues.put(aggFactoryNames[4], metricVals[4]); case 4: metricValues.put(aggFactoryNames[3], metricVals[3]); case 3: metricValues.put(aggFactoryNames[2], metricVals[2]); case 2: metricValues.put(aggFactoryNames[1], metricVals[1]); case 1: metricValues.put(aggFactoryNames[0], metricVals[0]); } for (int i = extra; i < metricVals.length; i += LOOP_UNROLL_COUNT) { metricValues.put(aggFactoryNames[i + 0], metricVals[i + 0]); metricValues.put(aggFactoryNames[i + 1], metricVals[i + 1]); metricValues.put(aggFactoryNames[i + 2], metricVals[i + 2]); metricValues.put(aggFactoryNames[i + 3], metricVals[i + 3]); metricValues.put(aggFactoryNames[i + 4], metricVals[i + 4]); metricValues.put(aggFactoryNames[i + 5], metricVals[i + 5]); metricValues.put(aggFactoryNames[i + 6], metricVals[i + 6]); metricValues.put(aggFactoryNames[i + 7], metricVals[i + 7]); } pQueue.add(new DimValHolder.Builder().withDimName(dimName).withMetricValues(metricValues).build()); if (pQueue.size() > threshold) { pQueue.poll(); } } return this; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this false, selectively enable - initially'\nThe code is: 'public ReplicationConfig(VerifiableProperties verifiableProperties) { replicationTokenFactory = verifiableProperties.getString(\"replication.token.factory\", \"com.github.ambry.store.StoreFindTokenFactory\"); replicationNumOfIntraDCReplicaThreads = verifiableProperties.getInt(\"replication.no.of.intra.dc.replica.threads\", 1); replicationNumOfInterDCReplicaThreads = verifiableProperties.getInt(\"replication.no.of.inter.dc.replica.threads\", 1); replicationConnectionPoolCheckoutTimeoutMs = verifiableProperties.getIntInRange(\"replication.connection.pool.checkout.timeout.ms\", 5000, 1000, 10000); replicationTokenFlushIntervalSeconds = verifiableProperties.getIntInRange(\"replication.token.flush.interval.seconds\", 300, 5, Integer.MAX_VALUE); replicationTokenFlushDelaySeconds = verifiableProperties.getIntInRange(\"replication.token.flush.delay.seconds\", 5, 1, Integer.MAX_VALUE); replicationFetchSizeInBytes = verifiableProperties.getLongInRange(\"replication.fetch.size.in.bytes\", 1048576, 0, 2097152); replicaWaitTimeBetweenReplicasMs = verifiableProperties.getIntInRange(\"replication.wait.time.between.replicas.ms\", 1000, 0, 1000000); replicationMaxLagForWaitTimeInBytes = verifiableProperties.getLongInRange(\"replication.max.lag.for.wait.time.in.bytes\", 5242880, 0, 104857600); <START> validateMessageStream = verifiableProperties.getBoolean(\"replication.validate.message.stream\", true); <END> \/\/ this false, selectively enable - initially }'","output":"public ReplicationConfig(VerifiableProperties verifiableProperties) { replicationTokenFactory = verifiableProperties.getString(\"replication.token.factory\", \"com.github.ambry.store.StoreFindTokenFactory\"); replicationNumOfIntraDCReplicaThreads = verifiableProperties.getInt(\"replication.no.of.intra.dc.replica.threads\", 1); replicationNumOfInterDCReplicaThreads = verifiableProperties.getInt(\"replication.no.of.inter.dc.replica.threads\", 1); replicationConnectionPoolCheckoutTimeoutMs = verifiableProperties.getIntInRange(\"replication.connection.pool.checkout.timeout.ms\", 5000, 1000, 10000); replicationTokenFlushIntervalSeconds = verifiableProperties.getIntInRange(\"replication.token.flush.interval.seconds\", 300, 5, Integer.MAX_VALUE); replicationTokenFlushDelaySeconds = verifiableProperties.getIntInRange(\"replication.token.flush.delay.seconds\", 5, 1, Integer.MAX_VALUE); replicationFetchSizeInBytes = verifiableProperties.getLongInRange(\"replication.fetch.size.in.bytes\", 1048576, 0, 2097152); replicaWaitTimeBetweenReplicasMs = verifiableProperties.getIntInRange(\"replication.wait.time.between.replicas.ms\", 1000, 0, 1000000); replicationMaxLagForWaitTimeInBytes = verifiableProperties.getLongInRange(\"replication.max.lag.for.wait.time.in.bytes\", 5242880, 0, 104857600); validateMessageStream = verifiableProperties.getBoolean(\"replication.validate.message.stream\", false); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'For null values, do supply properties in autoGenerationOption'\nThe code is: 'public void shouldNotEditAnAutoGenerationOptionProvidedWithAllNullParams() throws Exception { SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(\"location\", null); <START> autoGenerationOption.add(\"source\", null); <END> \/\/ For null values, do supply properties in autoGenerationOption autoGenerationOption.add(\"manualEntryEnabled\", null); autoGenerationOption.add(\"automaticGenerationEnabled\", null); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + \"\/\" + getUuid()); req.setContent(json.getBytes()); handle(req); }'","output":"public void shouldNotEditAnAutoGenerationOptionProvidedWithAllNullParams() throws Exception { SimpleObject autoGenerationOption = new SimpleObject(); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + \"\/\" + getUuid()); req.setContent(json.getBytes()); handle(req); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'category'\nThe code is: 'private Object[] mapExpandedElements(AbstractHistoryCategory[] categories, Object[] expandedElements) { HashSet<String> names = new HashSet<>(); for (Object expandedElement : expandedElements) { names.add(((DateHistoryCategory) expandedElement).getName()); } ArrayList<AbstractHistoryCategory> expandable = new ArrayList<>(); for (AbstractHistoryCategory <START> categorie : <END> \/\/ category categories) { if (names.contains(categorie.getName())) { expandable.add(categorie); } } return expandable.toArray(new Object[expandable.size()]); }'","output":"private Object[] mapExpandedElements(AbstractHistoryCategory[] categories, Object[] expandedElements) { HashSet<String> names = new HashSet<>(); for (Object expandedElement : expandedElements) { names.add(((DateHistoryCategory) expandedElement).getName()); } ArrayList<AbstractHistoryCategory> expandable = new ArrayList<>(); for (AbstractHistoryCategory category : categories) { if (names.contains(category.getName())) { expandable.add(category); } } return expandable.toArray(new Object[expandable.size()]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace this for user.isAdmin'\nThe code is: 'public List<FilterDescriptor> getFiltersDescriptorsByRole(final User user) throws DotDataException { <START> if(APILocator.getUserAPI().isCMSAdmin(user)){ <END> \/\/ replace this for user.isAdmin return new ArrayList<>(this.loadedFilters.values()); } final List<Role> roles = APILocator.getRoleAPI().loadRolesForUser(user.getUserId(), true); Logger.info(this,\"User Roles: \" + roles.toString()); final List<FilterDescriptor> filters = new ArrayList<>(); for(final Map.Entry<String,FilterDescriptor> filterDescriptorMap : this.loadedFilters.entrySet()){ final String filterRoles = filterDescriptorMap.getValue().getRoles(); Logger.info(PublisherAPI.class,\"File: \" +filterDescriptorMap.getKey() + \" Roles: \" + filterRoles ); for(final Role role : roles){ if(UtilMethods.isSet(role.getRoleKey()) && filterRoles.contains(role.getRoleKey())){ filters.add(filterDescriptorMap.getValue()); } } } return filters; }'","output":"public List<FilterDescriptor> getFiltersDescriptorsByRole(final User user) throws DotDataException { if(user.isAdmin()){ return new ArrayList<>(this.loadedFilters.values()); } final List<Role> roles = APILocator.getRoleAPI().loadRolesForUser(user.getUserId(), true); Logger.info(this,\"User Roles: \" + roles.toString()); final List<FilterDescriptor> filters = new ArrayList<>(); for(final Map.Entry<String,FilterDescriptor> filterDescriptorMap : this.loadedFilters.entrySet()){ final String filterRoles = filterDescriptorMap.getValue().getRoles(); Logger.info(PublisherAPI.class,\"File: \" +filterDescriptorMap.getKey() + \" Roles: \" + filterRoles ); for(final Role role : roles){ if(UtilMethods.isSet(role.getRoleKey()) && filterRoles.contains(role.getRoleKey())){ filters.add(filterDescriptorMap.getValue()); } } } return filters; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'qualified name'\nThe code is: 'private void enableHook() { if (getEntity() == null || getSelectedItems() == null || getSelectedItems().size() == 0) { return; } <START> ArrayList<VdcActionParametersBase> list = new java.util.ArrayList<VdcActionParametersBase>(); <END> \/\/ qualified name for (Object item : getSelectedItems()) { GlusterHookEntity hook = (GlusterHookEntity) item; list.add(new GlusterHookParameters(getEntity().getId(), hook.getId())); } Frontend.RunMultipleAction(VdcActionType.EnableGlusterHook, list); }'","output":"private void enableHook() { if (getEntity() == null || getSelectedItems() == null || getSelectedItems().size() == 0) { return; } ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>(); for (Object item : getSelectedItems()) { GlusterHookEntity hook = (GlusterHookEntity) item; list.add(new GlusterHookParameters(getEntity().getId(), hook.getId())); } Frontend.RunMultipleAction(VdcActionType.EnableGlusterHook, list); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please mock Future'\nThe code is: 'public void shouldDecorateFutureAndReturnSuccess() throws Exception { CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults(\"testName\"); <START> final Future<String> future = executor.submit(() -> \"Hello World\"); <END> \/\/ please mock Future CircuitBreakerFuture<String> decoratedFuture = new CircuitBreakerFuture<>(circuitBreaker, future); String value = decoratedFuture.get(); assertThat(value).isEqualTo(\"Hello World\"); assertThat(circuitBreaker.getMetrics().getNumberOfBufferedCalls()).isEqualTo(1); assertThat(circuitBreaker.getMetrics().getNumberOfFailedCalls()).isEqualTo(0); assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1); assertThat(circuitBreaker.getMetrics().getNumberOfNotPermittedCalls()).isEqualTo(0); assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); }'","output":"public void shouldDecorateFutureAndReturnSuccess() throws Exception { CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults(\"testName\"); final Future<String> future = mock(Future.class); when(future.get()).thenReturn(\"Hello World\"); CircuitBreakerFuture<String> decoratedFuture = new CircuitBreakerFuture<>(circuitBreaker, future); String value = decoratedFuture.get(); assertThat(value).isEqualTo(\"Hello World\"); assertThat(circuitBreaker.getMetrics().getNumberOfBufferedCalls()).isEqualTo(1); assertThat(circuitBreaker.getMetrics().getNumberOfFailedCalls()).isEqualTo(0); assertThat(circuitBreaker.getMetrics().getNumberOfSuccessfulCalls()).isEqualTo(1); assertThat(circuitBreaker.getMetrics().getNumberOfNotPermittedCalls()).isEqualTo(0); assertThat(circuitBreaker.getState()).isEqualTo(CircuitBreaker.State.CLOSED); then(future).should().get(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'of this.getClass().getName'\nThe code is: 'public void putCheckpoint(String replicatorIdentifier, String sequence) { <START> logger.entering(this.getClass().getCanonicalName(),\"putCheckpoint\",new Object[]{replicatorIdentifier,sequence}); <END> \/\/ of this.getClass().getName String checkpointDocumentId = getCheckpointDocumentId(replicatorIdentifier); BasicDocumentRevision doc = dbCore.getLocalDocument(checkpointDocumentId); Map<String, String> checkpointDoc = new HashMap<String, String>(); checkpointDoc.put(\"lastSequence\", sequence); byte[] json = JSONUtils.serializeAsBytes(checkpointDoc); if(doc == null) { dbCore.createLocalDocument(checkpointDocumentId, DocumentBodyFactory.create(json)); } else { dbCore.updateLocalDocument(doc.getId(), doc.getRevision(), DocumentBodyFactory.create(json)); } }'","output":"public void putCheckpoint(String replicatorIdentifier, String sequence) { logger.entering(\"DatastoreWrapper\",\"putCheckpoint\",new Object[]{replicatorIdentifier,sequence}); String checkpointDocumentId = getCheckpointDocumentId(replicatorIdentifier); BasicDocumentRevision doc = dbCore.getLocalDocument(checkpointDocumentId); Map<String, String> checkpointDoc = new HashMap<String, String>(); checkpointDoc.put(\"lastSequence\", sequence); byte[] json = JSONUtils.serializeAsBytes(checkpointDoc); if(doc == null) { dbCore.createLocalDocument(checkpointDocumentId, DocumentBodyFactory.create(json)); } else { dbCore.updateLocalDocument(doc.getId(), doc.getRevision(), DocumentBodyFactory.create(json)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please do Java **assert** keyword. Java Assertions disabled default in maven-surefire. I pretty test pass assert(false). JUnit method assertTrue instead'\nThe code is: 'public void shouldSupportLimits() { final SObjectBatch batch = new SObjectBatch(version); batch.addLimits(); final SObjectBatchResponse response = testBatch(batch); final List<SObjectBatchResult> results = response.getResults(); final SObjectBatchResult batchResult = results.get(0); @SuppressWarnings(\"unchecked\") final Map<String, Object> result = (Map<String, Object>) batchResult.getResult(); @SuppressWarnings(\"unchecked\") final Map<String, Object> limits = (Map<String, Object>) result.getOrDefault(\"LimitsSnapshot\", result); @SuppressWarnings(\"unchecked\") final Map<String, String> apiRequests = (Map<String, String>) limits.get(\"DailyApiRequests\"); <START> assert(Integer.valueOf(String.valueOf(apiRequests.get(\"Max\"))) > 0); <END> \/\/ Please do Java **assert** keyword. Java Assertions disabled default in maven-surefire. I pretty test pass assert(false). JUnit method assertTrue instead }'","output":"public void shouldSupportLimits() { final SObjectBatch batch = new SObjectBatch(version); batch.addLimits(); final SObjectBatchResponse response = testBatch(batch); final List<SObjectBatchResult> results = response.getResults(); final SObjectBatchResult batchResult = results.get(0); @SuppressWarnings(\"unchecked\") final Map<String, Object> result = (Map<String, Object>) batchResult.getResult(); @SuppressWarnings(\"unchecked\") final Map<String, Object> limits = (Map<String, Object>) result.getOrDefault(\"LimitsSnapshot\", result); @SuppressWarnings(\"unchecked\") final Map<String, String> apiRequests = (Map<String, String>) limits.get(\"DailyApiRequests\"); assertTrue(Integer.valueOf(String.valueOf(apiRequests.get(\"Max\"))) > 0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is DELIM needed here'\nThe code is: 'public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(\"message\").create(); remote.update(\"master\", tip); server.updateRef(\"HEAD\").link(\"refs\/heads\/master\"); RevTag tag = remote.tag(\"tag\", tip); remote.update(\"refs\/tags\/tag\", tag); ByteArrayInputStream recvStream = uploadPackV2(\"command=ls-refs\\n\", <START> PacketLineIn.DELIM, PacketLineIn.END); <END> \/\/ is DELIM needed here PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + \" HEAD\")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + \" refs\/heads\/master\")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + \" refs\/tags\/tag\")); assertTrue(pckIn.readString() == PacketLineIn.END); }'","output":"public void testV2LsRefs() throws Exception { RevCommit tip = remote.commit().message(\"message\").create(); remote.update(\"master\", tip); server.updateRef(\"HEAD\").link(\"refs\/heads\/master\"); RevTag tag = remote.tag(\"tag\", tip); remote.update(\"refs\/tags\/tag\", tag); ByteArrayInputStream recvStream = uploadPackV2(\"command=ls-refs\\n\", PacketLineIn.END); PacketLineIn pckIn = new PacketLineIn(recvStream); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + \" HEAD\")); assertThat(pckIn.readString(), is(tip.toObjectId().getName() + \" refs\/heads\/master\")); assertThat(pckIn.readString(), is(tag.toObjectId().getName() + \" refs\/tags\/tag\")); assertTrue(pckIn.readString() == PacketLineIn.END); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'initial size of list is _2_..'\nThe code is: 'private List<EventHandler<ActiveContext>> getActiveContextHandler(final String namespace) { <START> final List<EventHandler<ActiveContext>> activeContextHandlers = new ArrayList<>(3); <END> \/\/ initial size of list is _2_.. switch (namespace) { case NAMESPACE_SERVER: activeContextHandlers.add(asyncDolphinDriver.get().getFirstContextActiveHandlerForServer(true)); activeContextHandlers.add(new ServerContextActiveHandler()); break; case NAMESPACE_WORKER: activeContextHandlers.add(asyncDolphinDriver.get().getFirstContextActiveHandlerForWorker(true)); activeContextHandlers.add(new WorkerContextActiveHandler()); break; default: throw new RuntimeException(\"Unsupported namespace\"); } return activeContextHandlers; }'","output":"private List<EventHandler<ActiveContext>> getActiveContextHandler(final String namespace) { final List<EventHandler<ActiveContext>> activeContextHandlers = new ArrayList<>(2); switch (namespace) { case NAMESPACE_SERVER: activeContextHandlers.add(asyncDolphinDriver.get().getFirstContextActiveHandlerForServer(true)); activeContextHandlers.add(new ServerContextActiveHandler()); break; case NAMESPACE_WORKER: activeContextHandlers.add(asyncDolphinDriver.get().getFirstContextActiveHandlerForWorker(true)); activeContextHandlers.add(new WorkerContextActiveHandler()); break; default: throw new RuntimeException(\"Unsupported namespace\"); } return activeContextHandlers; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename p prop'\nThe code is: 'private boolean overwrite(String name) { for (Object <START> propertie : <END> \/\/ rename p prop getProperties()) { Property property = (Property) propertie; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }'","output":"private boolean overwrite(String name) { for (Object prop : getProperties()) { Property property = (Property) prop; String propertyName = property.getName(); if (propertyName.equals(name)) { if (property.isDefault()) { MessageDialog.openError(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_17, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_18, new Object[] { propertyName, property.getPluginLabel() })); return false; } boolean overWrite = MessageDialog.openQuestion(propertyTableViewer.getControl().getShell(), AntPreferencesMessages.AntPropertiesBlock_15, MessageFormat.format(AntPreferencesMessages.AntPropertiesBlock_16, new Object[] { name })); if (!overWrite) { return false; } ((AntContentProvider) propertyTableViewer.getContentProvider()).remove(property); break; } } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '* 100? simply projects.size() newChild(1) clearer'\nThe code is: 'public void execute(IProgressMonitor m) throws CoreException { SubMonitor progress = SubMonitor.convert(m, CoreText.ConnectProviderOperation_connecting, <START> 100 * projects.size()); <END> \/\/ * 100? simply projects.size() newChild(1) clearer MultiStatus ms = new MultiStatus(Activator.getPluginId(), 0, CoreText.ConnectProviderOperation_ConnectErrors, null); for (Entry<IProject, File> entry : projects.entrySet()) { connectProject(entry, ms, progress.newChild(100)); } if (!ms.isOK()) { throw new CoreException(ms); } }'","output":"public void execute(IProgressMonitor m) throws CoreException { SubMonitor progress = SubMonitor.convert(m, CoreText.ConnectProviderOperation_connecting, projects.size()); MultiStatus ms = new MultiStatus(Activator.getPluginId(), 0, CoreText.ConnectProviderOperation_ConnectErrors, null); for (Entry<IProject, File> entry : projects.entrySet()) { connectProject(entry, ms, progress.newChild(1)); } if (!ms.isOK()) { throw new CoreException(ms); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'above; Consider getClass().getSimpleName() instead of this'\nThe code is: 'public List<Credential> fromRequest(final HttpServletRequest request, final MultiValueMap<String, String> requestBody) { if (requestBody == null || requestBody.isEmpty()) { <START> LOGGER.debug(\"Skipping {} because the requestBody is null or empty\", this); <END> \/\/ above; Consider getClass().getSimpleName() instead of this return new ArrayList<>(0); } final String cert = requestBody.getFirst(CERTIFICATE); LOGGER.debug(\"Certificate in the request body: [{}]\", cert); if (StringUtils.isBlank(cert)) { return new ArrayList<>(0); } try (InputStream is = new ByteArrayInputStream(cert.getBytes(StandardCharsets.UTF_8))) { final InputStreamSource iso = new InputStreamResource(is); final X509Certificate certificate = CertUtils.readCertificate(iso); final X509CertificateCredential credential = new X509CertificateCredential(new X509Certificate[]{certificate}); credential.setCertificate(certificate); return CollectionUtils.wrap(credential); } catch (final Exception e) { LOGGER.error(e.getMessage(), e); } return new ArrayList<>(0); }'","output":"public List<Credential> fromRequest(final HttpServletRequest request, final MultiValueMap<String, String> requestBody) { if (requestBody == null || requestBody.isEmpty()) { LOGGER.debug(\"Skipping {} because the requestBody is null or empty\", getClass().getSimpleName()); return new ArrayList<>(0); } final String cert = requestBody.getFirst(CERTIFICATE); LOGGER.debug(\"Certificate in the request body: [{}]\", cert); if (StringUtils.isBlank(cert)) { return new ArrayList<>(0); } try (InputStream is = new ByteArrayInputStream(cert.getBytes(StandardCharsets.UTF_8))) { final InputStreamSource iso = new InputStreamResource(is); final X509Certificate certificate = CertUtils.readCertificate(iso); final X509CertificateCredential credential = new X509CertificateCredential(new X509Certificate[]{certificate}); credential.setCertificate(certificate); return CollectionUtils.wrap(credential); } catch (final Exception e) { LOGGER.error(e.getMessage(), e); } return new ArrayList<>(0); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tritto'\nThe code is: 'public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); <START> bounds.x = 0; bounds.y = 0; bounds.height = 1000; bounds.width <END> \/\/ tritto = 1000; int x0 = 100; int y0 = -10000; int x1 = 100; int y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }'","output":"public void verticalTest() { Rectangle bounds = new Rectangle(0, 0, 1000, 1000); int x0 = 100; int y0 = -10000; int x1 = 100; int y1 = 10000; Rectangle rect = LineClipper.clip(bounds, x0, y0, x1, y1); assertEquals(new Rectangle(100, 0, 0, 1000), rect); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IBM-specific dash'\nThe code is: 'public void perform(GraphRewrite event, EvaluationContext context, XmlFileModel payload) { ClassificationService classificationService = new ClassificationService(event.getGraphContext()); ClassificationModel classificationModel = classificationService.attachClassification(event, context, payload, IssueCategoryRegistry.MANDATORY, \"WebSphere WS Binding\", \"WebSphere Webservice Binding XML Deployment Descriptor. \\n\" <START> + \"This deployment descriptor extension is IBM-specific and it needs to be migrated to JBossWS. \\n\" <END> \/\/ IBM-specific dash + \"JBossWS implements the latest JAX-WS specification, which users can reference for any vendor-agnostic web service usage need. \\n\" + \"You can migrate deployment descriptors following the links below. \\n\"); classificationModel.setEffort(3); GraphContext graphContext = event.getGraphContext(); LinkService linkService = new LinkService(graphContext); LinkModel documentationEAP6Link = linkService.create(); documentationEAP6Link.setDescription(\"JAX-WS Web Services (EAP 6)\"); documentationEAP6Link.setLink( \"<LINK_0>\"); classificationService.attachLink(classificationModel, documentationEAP6Link); LinkModel documentationEAP7Link = linkService.create(); documentationEAP7Link.setDescription(\"Developing JAX-WS Web Services (EAP 7)\"); documentationEAP7Link.setLink( \"<LINK_2>\"); classificationService.attachLink(classificationModel, documentationEAP7Link); LinkModel documentationCommunityLink = linkService.create(); documentationCommunityLink.setDescription(\"JBossWS configuration (community documentation)\"); documentationCommunityLink.setLink(\"<LINK_1>\"); classificationService.attachLink(classificationModel, documentationCommunityLink); TechnologyTagService technologyTagService = new TechnologyTagService(event.getGraphContext()); technologyTagService.addTagToFileModel(payload, \"WebSphere WS Binding\", TechnologyTagLevel.IMPORTANT); }'","output":"public void perform(GraphRewrite event, EvaluationContext context, XmlFileModel payload) { ClassificationService classificationService = new ClassificationService(event.getGraphContext()); ClassificationModel classificationModel = classificationService.attachClassification(event, context, payload, IssueCategoryRegistry.MANDATORY, \"WebSphere WS Binding\", \"WebSphere Webservice Binding XML Deployment Descriptor. \\n\" + \"This deployment descriptor extension is IBM specific and it needs to be migrated to JBossWS. \\n\" + \"JBossWS implements the latest JAX-WS specification, which users can reference for any vendor-agnostic web service usage need. \\n\" + \"You can migrate deployment descriptors following the links below. \\n\"); classificationModel.setEffort(3); GraphContext graphContext = event.getGraphContext(); LinkService linkService = new LinkService(graphContext); LinkModel documentationEAP6Link = linkService.create(); documentationEAP6Link.setDescription(\"JAX-WS Web Services (EAP 6)\"); documentationEAP6Link.setLink( \"<LINK_0>\"); classificationService.attachLink(classificationModel, documentationEAP6Link); LinkModel documentationEAP7Link = linkService.create(); documentationEAP7Link.setDescription(\"Developing JAX-WS Web Services (EAP 7)\"); documentationEAP7Link.setLink( \"<LINK_2>\"); classificationService.attachLink(classificationModel, documentationEAP7Link); LinkModel documentationCommunityLink = linkService.create(); documentationCommunityLink.setDescription(\"JBossWS configuration (community documentation)\"); documentationCommunityLink.setLink(\"<LINK_1>\"); classificationService.attachLink(classificationModel, documentationCommunityLink); TechnologyTagService technologyTagService = new TechnologyTagService(event.getGraphContext()); technologyTagService.addTagToFileModel(payload, \"WebSphere WS Binding\", TechnologyTagLevel.IMPORTANT); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'condition redundant'\nThe code is: 'private List<Class<? extends Annotation>> findGinjectorAnnotations() throws UnableToCompleteException { List<Class<? extends Annotation>> annotations = new ArrayList<Class<? extends Annotation>>(); List<String> values = findConfigurationProperty(GIN_GINJECTOR_ANNOTATION).getValues(); <START> if (values.size() > 0) { <END> \/\/ condition redundant for (String value : values) { String annotationClassName = value.trim(); if (!annotationClassName.isEmpty()) { try { annotations.add(Class.forName(annotationClassName).asSubclass(Annotation.class)); } catch (ClassNotFoundException e) { getTreeLogger().log(TreeLogger.ERROR, \"Cannot find the class '\" + annotationClassName + \"' used in '\" + GIN_GINJECTOR_ANNOTATION + \"' property.\"); throw new UnableToCompleteException(); } catch (ClassCastException e) { getTreeLogger().log(TreeLogger.ERROR, \"Class '\" + annotationClassName + \"' used in '\" + GIN_GINJECTOR_ANNOTATION + \"' property is not an Annotation.\"); throw new UnableToCompleteException(); } } } } return annotations; }'","output":"private List<Class<? extends Annotation>> findGinjectorAnnotations() throws UnableToCompleteException { List<Class<? extends Annotation>> annotations = new ArrayList<Class<? extends Annotation>>(); List<String> values = findConfigurationProperty(GIN_GINJECTOR_ANNOTATION).getValues(); for (String value : values) { String annotationClassName = value.trim(); if (!annotationClassName.isEmpty()) { try { annotations.add(Class.forName(annotationClassName).asSubclass(Annotation.class)); } catch (ClassNotFoundException e) { getTreeLogger().log(TreeLogger.ERROR, \"Cannot find the class '\" + annotationClassName + \"' used in '\" + GIN_GINJECTOR_ANNOTATION + \"' property.\"); throw new UnableToCompleteException(); } catch (ClassCastException e) { getTreeLogger().log(TreeLogger.ERROR, \"Class '\" + annotationClassName + \"' used in '\" + GIN_GINJECTOR_ANNOTATION + \"' property is not an Annotation.\"); throw new UnableToCompleteException(); } } } return annotations; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is this semicolon doing'\nThe code is: 'private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); <START> ; <END> \/\/ is this semicolon doing private int currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public int write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public int addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(\"Wrote more bytes[%,d] than available[%,d]. Don't do that.\", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }'","output":"private SmooshedWriter delegateSmooshedWriter(final String name, final long size) throws IOException { final File tmpFile = new File(baseDir, name); filesInProcess.add(tmpFile); return new SmooshedWriter() { private final FileOutputStream out = new FileOutputStream(tmpFile); private final GatheringByteChannel channel = out.getChannel(); private final Closer closer = Closer.create(); private int currOffset = 0; { closer.register(out); closer.register(channel); } @Override public void close() throws IOException { closer.close(); completedFiles.add(tmpFile); filesInProcess.remove(tmpFile); if (!writerCurrentlyInUse) { mergeWithSmoosher(); } } public int bytesLeft() { return (int) (size - currOffset); } @Override public int write(ByteBuffer buffer) throws IOException { return addToOffset(channel.write(buffer)); } @Override public int write(InputStream in) throws IOException { return addToOffset(ByteStreams.copy(Channels.newChannel(in), channel)); } @Override public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { return addToOffset(channel.write(srcs, offset, length)); } @Override public long write(ByteBuffer[] srcs) throws IOException { return addToOffset(channel.write(srcs)); } public int addToOffset(long numBytesWritten) { if (numBytesWritten > bytesLeft()) { throw new ISE(\"Wrote more bytes[%,d] than available[%,d]. Don't do that.\", numBytesWritten, bytesLeft()); } currOffset += numBytesWritten; return Ints.checkedCast(numBytesWritten); } @Override public boolean isOpen() { return channel.isOpen(); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'expect 200000 - possibly source data needs converting microseconds'\nThe code is: 'public void testProcessSingle() { Trace trace = new Trace(); trace.setId(\"btxnId\"); trace.setBusinessTransaction(\"btxnName\"); trace.setStartTime(100); Consumer c = new Consumer(); c.setUri(\"uri\"); c.setBaseTime(1); c.setDuration(200000000); c.getProperties().add(new Property(Constants.PROP_FAULT, \"myFault\")); c.setEndpointType(\"HTTP\"); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(\"Failed: \" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); <START> assertEquals(200000000, ct.getDuration()); <END> \/\/ expect 200000 - possibly source data needs converting microseconds assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }'","output":"public void testProcessSingle() { Trace trace = new Trace(); trace.setId(\"btxnId\"); trace.setBusinessTransaction(\"btxnName\"); trace.setStartTime(100000); Consumer c = new Consumer(); c.setUri(\"uri\"); c.setBaseTime(1); c.setDuration(200000); c.getProperties().add(new Property(Constants.PROP_FAULT, \"myFault\")); c.setEndpointType(\"HTTP\"); trace.getNodes().add(c); FragmentCompletionTimeDeriver deriver = new FragmentCompletionTimeDeriver(); CompletionTime ct = null; try { ct = deriver.processOneToOne(null, trace); } catch (Exception e) { fail(\"Failed: \" + e); } assertNotNull(ct); assertEquals(trace.getId(), ct.getId()); assertEquals(trace.getBusinessTransaction(), ct.getBusinessTransaction()); assertEquals(c.getEndpointType(), ct.getEndpointType()); assertFalse(ct.isInternal()); assertEquals(trace.getStartTime(), ct.getTimestamp()); assertEquals(c.getUri(), ct.getUri()); assertEquals(200000, ct.getDuration()); assertEquals(c.getProperties(Constants.PROP_FAULT), ct.getProperties(Constants.PROP_FAULT)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '< -> <='\nThe code is: 'public List<ResourceEntry> removeAndGet(ScalarResourceEntry scalarResourceEntry, ReservationType reservationType) throws ResourceNotAvailabeException { ScalarResourceEntry availableResource = availableResourcesByReservationType.get(reservationType); List<ResourceEntry> reservedResources = new ArrayList<>(); <START> if (scalarResourceEntry.getValue() < availableResource.getValue()) { <END> \/\/ < -> <= availableResourcesByReservationType.put(reservationType, availableResource.remove(scalarResourceEntry)); totalAvailableResource -= scalarResourceEntry.getValue(); reservedResources.add(new ScalarResourceEntry(scalarResourceEntry.getReservationType(), scalarResourceEntry.getValue())); return reservedResources; } String message = String.format(\"ResourceType '%s' of reservationType '%s' is not available. Requested value: %s Available: %s\", resourceType, reservationType.toString(), scalarResourceEntry.getValue(), availableResourcesByReservationType.get(reservationType)); throw new ResourceNotAvailabeException(message); }'","output":"public List<ResourceEntry> removeAndGet(ScalarResourceEntry scalarResourceEntry, ReservationType reservationType) throws ResourceNotAvailableException { ScalarResourceEntry availableResource = availableResourcesByReservationType.get(reservationType); List<ResourceEntry> reservedResources = new ArrayList<>(); if (scalarResourceEntry.getValue() <= availableResource.getValue()) { availableResourcesByReservationType.put(reservationType, availableResource.remove(scalarResourceEntry)); totalAvailableResource -= scalarResourceEntry.getValue(); reservedResources.add(new ScalarResourceEntry(scalarResourceEntry.getReservationType(), scalarResourceEntry.getValue())); return reservedResources; } String message = String.format(\"ResourceType '%s' of reservationType '%s' is not available. Requested value: %s Available: %s\", resourceType, reservationType.toString(), scalarResourceEntry.getValue(), availableResourcesByReservationType.get(reservationType)); throw new ResourceNotAvailableException(message); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: EnumSet.of'\nThe code is: 'public void handlePullRequestEvent(PullRequestEvent pullRequestEvent) throws IOException { <START> Set<PullRequestEvent.Action> openActions = Sets.newHashSet(PullRequestEvent.Action.opened, PullRequestEvent.Action.reopened); <END> \/\/ nit: EnumSet.of GitInfo gitInfo = branchService.upsert(gitInfo(pullRequestEvent, openActions.contains(pullRequestEvent.getAction()))); if (pullRequestEvent.getAction().equals(PullRequestEvent.Action.opened) || pullRequestEvent.getAction().equals(PullRequestEvent.Action.reopened)) { Set<Module> modules = moduleService.getByBranch(gitInfo.getId().get()); triggerBuilds(gitInfo, modules); recordEvents(modules, pullRequestEvent.getPullRequestOrBuilder().getUser().getUsername()); } else if (pullRequestEvent.getAction().equals(PullRequestEvent.Action.closed)) { branchService.delete(gitInfo); } else { LOG.info(\"Pull request action {} has no impact on builds, not doing anything\", pullRequestEvent.getAction()); } }'","output":"public void handlePullRequestEvent(PullRequestEvent pullRequestEvent) throws IOException { Set<PullRequestEvent.Action> openActions = EnumSet.of(PullRequestEvent.Action.opened, PullRequestEvent.Action.reopened); GitInfo gitInfo = branchService.upsert(gitInfo(pullRequestEvent, openActions.contains(pullRequestEvent.getAction()))); if (pullRequestEvent.getAction().equals(PullRequestEvent.Action.opened) || pullRequestEvent.getAction().equals(PullRequestEvent.Action.reopened)) { Set<Module> modules = moduleService.getByBranch(gitInfo.getId().get()); triggerBuilds(gitInfo, modules); recordEvents(modules, pullRequestEvent.getPullRequestOrBuilder().getUser().getUsername()); } else if (pullRequestEvent.getAction().equals(PullRequestEvent.Action.closed)) { branchService.delete(gitInfo); } else { LOG.info(\"Pull request action {} has no impact on builds, not doing anything\", pullRequestEvent.getAction()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a lot of logic in this method hard debug in future... work? management of currentWork, emitting next work in a single place, drainQueue method. java @Override protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }'\nThe code is: '<START> protected void hookOnNext(ServiceBusReceivedMessageContext message) { <END> \/\/ a lot of logic in this method hard debug in future... work? management of currentWork, emitting next work in a single place, drainQueue method. java @Override protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); } boolean delivered = false; if (currentWork == null) { currentWork = getNextWorkAndRequest(); logger.verbose(\"No current work, Picked up next receive request.\"); } if (currentWork != null) { currentWork.next(message); delivered = true; remaining.decrementAndGet(); if (currentWork.isTerminal()) { currentWork.complete(); if (timeoutOperation != null && !timeoutOperation.isDisposed()) { timeoutOperation.dispose(); } currentWork = getNextWorkAndRequest(); logger.verbose(\"Current work is terminal, Picked up next receive request.\"); } } if (currentWork == null) { if (wip.decrementAndGet() != 0) { logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\"); } if (!delivered) { bufferMessages.add(message); } } }'","output":"protected void hookOnNext(ServiceBusReceivedMessageContext message) { bufferMessages.add(message); drain(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I prefer onPollReady() operation arrival in OperationController passing in readyForPollCallback required (i.e. GetBlobOperation ChunkFiller)'\nThe code is: 'void submitGetBlobOperation(String blobId, FutureResult<ReadableStreamChannel> futureResult, Callback<ReadableStreamChannel> callback) { try { GetBlobOperation getBlobOperation = new GetBlobOperation(routerConfig, routerMetrics, clusterMap, responseHandler, blobId, futureResult, callback, operationCompleteCallback, readyForPollCallback, blobIdFactory, time); getOperations.add(getBlobOperation); <START> readyForPollCallback.onPollReady(); <END> \/\/ I prefer onPollReady() operation arrival in OperationController passing in readyForPollCallback required (i.e. GetBlobOperation ChunkFiller) } catch (RouterException e) { routerMetrics.getBlobErrorCount.inc(); routerMetrics.countError(e); routerMetrics.operationDequeuingRate.mark(); operationCompleteCallback.completeOperation(futureResult, callback, null, e); } }'","output":"void submitGetBlobOperation(String blobId, FutureResult<ReadableStreamChannel> futureResult, Callback<ReadableStreamChannel> callback) { try { GetBlobOperation getBlobOperation = new GetBlobOperation(routerConfig, routerMetrics, clusterMap, responseHandler, blobId, futureResult, callback, operationCompleteCallback, readyForPollCallback, blobIdFactory, time); getOperations.add(getBlobOperation); } catch (RouterException e) { routerMetrics.getBlobErrorCount.inc(); routerMetrics.countError(e); routerMetrics.operationDequeuingRate.mark(); operationCompleteCallback.completeOperation(futureResult, callback, null, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'default of timestamp -1, consistent KeyValue class'\nThe code is: 'public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); int mapSize = unpacker.unpackMapHeader(); long offset = 0; <START> long timestamp = 0; <END> \/\/ default of timestamp -1, consistent KeyValue class byte[] keyBytes = EMPTY_BYTES; for (int i = 0; i < mapSize; i++) { int key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: int keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }'","output":"public KeyValue next() throws IOException { if (mReader.next(mKey, mValue)) { MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(mKey.getBytes()); int mapSize = unpacker.unpackMapHeader(); long offset = 0; long timestamp = -1; byte[] keyBytes = EMPTY_BYTES; for (int i = 0; i < mapSize; i++) { int key = unpacker.unpackInt(); switch (key) { case KAFKA_MESSAGE_OFFSET: offset = unpacker.unpackLong(); break; case KAFKA_MESSAGE_TIMESTAMP: timestamp = unpacker.unpackLong(); break; case KAFKA_HASH_KEY: int keySize = unpacker.unpackBinaryHeader(); keyBytes = new byte[keySize]; unpacker.readPayload(keyBytes); break; } } unpacker.close(); return new KeyValue(offset, keyBytes, Arrays.copyOfRange(mValue.getBytes(), 0, mValue.getLength()), timestamp); } else { return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'throw InternalErrorException in of methods :)'\nThe code is: '<START> public Attribute getAttributeValue(PerunSessionImpl sess, User user, AttributeDefinition attributeDefinition) throws InternalErrorException { <END> \/\/ throw InternalErrorException in of methods :) Attribute attribute = new Attribute(attributeDefinition); SortedSet<String> tcsMailsValue = new TreeSet<>(); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_preferredMail)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_ISMail)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_o365EmailAddressesMU)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_publicAliasMails)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_privateAliasMails)); attribute.setValue(new ArrayList(tcsMailsValue)); return attribute; }'","output":"public Attribute getAttributeValue(PerunSessionImpl sess, User user, AttributeDefinition attributeDefinition) { Attribute attribute = new Attribute(attributeDefinition); SortedSet<String> tcsMailsValue = new TreeSet<>(); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_preferredMail)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_ISMail)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_o365EmailAddressesMU)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_publicAliasMails)); tcsMailsValue.addAll(getEmailValues(sess, user, A_U_D_privateAliasMails)); attribute.setValue(new ArrayList<>(tcsMailsValue)); return attribute; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'setCommit takes a capital-B Boolean, need for this check, if null set null'\nThe code is: 'public Transfer sell(Money amount, String paymentMethodId, Boolean commit) throws CoinbaseException, IOException { URL sellsUrl; try { sellsUrl = new URL(_baseApiUrl, \"sells\"); } catch (MalformedURLException ex) { throw new AssertionError(ex); } Request request = newAccountSpecificRequest(); request.setQty(amount.getAmount().doubleValue()); request.setPaymentMethodId(paymentMethodId); request.setCurrency(amount.getCurrencyUnit().getCurrencyCode()); <START> if(commit != null) <END> \/\/ setCommit takes a capital-B Boolean, need for this check, if null set null request.setCommit(commit); return post(sellsUrl, request, TransferResponse.class).getTransfer(); }'","output":"public Transfer sell(Money amount, String paymentMethodId, Boolean commit) throws CoinbaseException, IOException { URL sellsUrl; try { sellsUrl = new URL(_baseApiUrl, \"sells\"); } catch (MalformedURLException ex) { throw new AssertionError(ex); } Request request = newAccountSpecificRequest(); request.setQty(amount.getAmount().doubleValue()); request.setPaymentMethodId(paymentMethodId); request.setCurrency(amount.getCurrencyUnit().getCurrencyCode()); request.setCommit(commit); return post(sellsUrl, request, TransferResponse.class).getTransfer(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Consider declaring variables class-scoped constants. I repeatedly declared\/used other methods'\nThe code is: 'public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(\"lt1\"); <START> final String ITEM = \"item1\"; final String ITEM_TO_REMOVE = \"item2\"; final String GROUP = \"group\"; <END> \/\/ Consider declaring variables class-scoped constants. I repeatedly declared\/used other methods builder.group(GROUP, GROUP, \"\", false); builder.item(ITEM, ITEM, \"\", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, \"\", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }'","output":"public void removeItemWithoutTemplateTest() { NavTreeBuilder builder = new NavTreeBuilder(); LayoutTemplate lt = new LayoutTemplate(\"lt1\"); final String ITEM_TO_REMOVE = \"item2\"; builder.group(GROUP, GROUP, \"\", false); builder.item(ITEM, ITEM, \"\", false, NavWorkbenchCtx.perspective(lt.getName())); builder.item(ITEM_TO_REMOVE, ITEM_TO_REMOVE, \"\", false); builder.endGroup(); NavTree originalTree = builder.build(); assertNotNull(originalTree.getItemById(ITEM_TO_REMOVE)); List<LayoutTemplate> templates = new ArrayList<>(); templates.add(lt); NavTree runtimeTree = runtimeNavigationBuilder.buildRuntimeTree(originalTree, templates); assertEquals(1, runtimeTree.getRootItems().size()); NavGroup group = (NavGroup) runtimeTree.getItemById(GROUP); assertNotNull(group); assertEquals(1, group.getChildren().size()); assertNull(runtimeTree.getItemById(ITEM_TO_REMOVE)); assertNotNull(runtimeTree.getItemById(ITEM)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'More weird union() usage for setting min-max values. min-max constructor. suggestion BlockRegion region = new BlockRegion(mins.get(i), max.get(i));'\nThe code is: 'public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(4, 4, 4), new Vector3i(11, 9, 7)); for (int i = 0; i < mins.size(); ++i) { <START> BlockRegion region = new BlockRegion().union(mins.get(i)).union(max.get(i)); <END> \/\/ More weird union() usage for setting min-max values. min-max constructor. suggestion BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }'","output":"public void testCreateRegionWithMinMax() { List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5)); List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2)); List<Vector3i> max = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6)); for (int i = 0; i < mins.size(); ++i) { BlockRegion region = new BlockRegion(mins.get(i), max.get(i)); assertEquals(mins.get(i), region.getMin(new Vector3i())); assertEquals(max.get(i), region.getMax(new Vector3i())); assertEquals(expectedSize.get(i), region.getSize(new Vector3i())); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'message: \"Hashing a column of type \" + column.getType() + \" is unsupported\"'\nThe code is: 'private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final int row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: <START> throw new UnsupportedOperationException(\"Hashing a column of type \" + column.getType()); <END> \/\/ message: \"Hashing a column of type \" + column.getType() + \" is unsupported\" } }'","output":"private static Hasher addValue(final Hasher hasher, final ReadableColumn column, final int row) { switch (column.getType()) { case BOOLEAN_TYPE: return hasher.putBoolean(column.getBoolean(row)); case DATETIME_TYPE: return hasher.putObject(column.getDateTime(row), TypeFunnel.INSTANCE); case DOUBLE_TYPE: return hasher.putDouble(column.getDouble(row)); case FLOAT_TYPE: return hasher.putFloat(column.getFloat(row)); case INT_TYPE: return hasher.putInt(column.getInt(row)); case LONG_TYPE: return hasher.putLong(column.getLong(row)); case STRING_TYPE: return hasher.putObject(column.getString(row), TypeFunnel.INSTANCE); default: throw new UnsupportedOperationException( \"Hashing a column of type \" + column.getType() + \" is unsupported\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename type'\nThe code is: 'private RefactoringStatus checkNonAbstractMembersInDestinationClasses(IMember[] membersToPushDown, IType[] destinationClassesForNonAbstract) throws JavaModelException { RefactoringStatus result= new RefactoringStatus(); List<IMember> list= new ArrayList<>(); list.addAll(Arrays.asList(membersToPushDown)); list.removeAll(Arrays.asList(getAbstractMembers(membersToPushDown))); IMember[] nonAbstractMembersToPushDown= list.toArray(new IMember[list.size()]); for (IType <START> t : <END> \/\/ rename type destinationClassesForNonAbstract) { result.merge(MemberCheckUtil.checkMembersInDestinationType(nonAbstractMembersToPushDown, t)); } return result; }'","output":"private RefactoringStatus checkNonAbstractMembersInDestinationClasses(IMember[] membersToPushDown, IType[] destinationClassesForNonAbstract) throws JavaModelException { RefactoringStatus result= new RefactoringStatus(); List<IMember> list= new ArrayList<>(); list.addAll(Arrays.asList(membersToPushDown)); list.removeAll(Arrays.asList(getAbstractMembers(membersToPushDown))); IMember[] nonAbstractMembersToPushDown= list.toArray(new IMember[list.size()]); for (IType type : destinationClassesForNonAbstract) { result.merge(MemberCheckUtil.checkMembersInDestinationType(nonAbstractMembersToPushDown, type)); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add empty string'\nThe code is: 'private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); int k = 0; for (int i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (int i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); <START> xVals.add(date + \"\"); <END> \/\/ add empty string } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }'","output":"private LineData generateWeightData() { List<String> xVals = new ArrayList<>(); List<Entry> yVals = new ArrayList<>(); int k = 0; for (int i = presenter.getWeightReadings().size() - 1; i >= 0; i--) { float val = Float.parseFloat(presenter.getWeightReadings().get(i).toString()); yVals.add(new Entry(k, val)); k++; } for (int i = presenter.getWeightReadingsDateTime().size() - 1; i >= 0; i--) { String date = presenter.convertDate(presenter.getWeightReadingsDateTime().get(i)); xVals.add(date); } xValues = xVals; return new LineData(generateLineDataSet(yVals, getResources().getColor(R.color.glucosio_fab_weight))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename occurrence'\nThe code is: 'private IJavaSearchScope getPackageAndOccurrencesWithoutNamesakesScope() { List<IJavaElement> scopeList= new ArrayList<>(); scopeList.add(fPackage); for (SearchResultGroup <START> fOccurrence : <END> \/\/ rename occurrence fOccurrences) { ICompilationUnit cu= fOccurrence.getCompilationUnit(); if (cu == null) continue; IPackageFragment pack= (IPackageFragment) cu.getParent(); if (! pack.getElementName().equals(fPackage.getElementName())) scopeList.add(cu); } return SearchEngine.createJavaSearchScope(scopeList.toArray(new IJavaElement[scopeList.size()])); }'","output":"private IJavaSearchScope getPackageAndOccurrencesWithoutNamesakesScope() { List<IJavaElement> scopeList= new ArrayList<>(); scopeList.add(fPackage); for (SearchResultGroup occurrence : fOccurrences) { ICompilationUnit cu= occurrence.getCompilationUnit(); if (cu == null) continue; IPackageFragment pack= (IPackageFragment) cu.getParent(); if (! pack.getElementName().equals(fPackage.getElementName())) scopeList.add(cu); } return SearchEngine.createJavaSearchScope(scopeList.toArray(new IJavaElement[scopeList.size()])); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion for (final Node node : graph.nodes()) {'\nThe code is: 'public void update(final DomainObject domainObject) { final CanvasHandler canvasHandler = session.getCanvasHandler(); final Diagram diagram = canvasHandler.getDiagram(); final Graph<?, Node> graph = diagram.getGraph(); <START> for (Node node : graph.nodes()) { <END> \/\/ suggestion for (final Node node : graph.nodes()) { if (node.getContent() instanceof Definition) { final Definition definition = (Definition) node.getContent(); if (definition.getDefinition() instanceof DomainObject) { final DomainObject d = (DomainObject) definition.getDefinition(); if (Objects.equals(d.getDomainObjectUUID(), domainObject.getDomainObjectUUID())) { canvasElementUpdatedEvent.fire(new CanvasElementUpdatedEvent(canvasHandler, node)); } } } } }'","output":"public void update(final DomainObject domainObject) { final CanvasHandler canvasHandler = session.getCanvasHandler(); final Diagram diagram = canvasHandler.getDiagram(); final Graph<?, Node> graph = diagram.getGraph(); for (final Node node : graph.nodes()) { if (node.getContent() instanceof Definition) { final Definition definition = (Definition) node.getContent(); if (definition.getDefinition() instanceof DomainObject) { final DomainObject d = (DomainObject) definition.getDefinition(); if (Objects.equals(d.getDomainObjectUUID(), domainObject.getDomainObjectUUID())) { canvasElementUpdatedEvent.fire(new CanvasElementUpdatedEvent(canvasHandler, node)); } } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'mind naming variable aggregatedFieldsQueryBuilder instead of builder'\nThe code is: 'public Query createQuery() { final int size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { <START> BooleanQuery.Builder builder = new BooleanQuery.Builder(); <END> \/\/ mind naming variable aggregatedFieldsQueryBuilder instead of builder for ( FieldContext fieldContext : fieldContexts ) { builder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( builder.build() ).createQuery(); } }'","output":"public Query createQuery() { final int size = fieldContexts.size(); final ConversionContext conversionContext = new ContextualExceptionBridgeHelper(); if ( size == 1 ) { return queryCustomizer.setWrappedQuery( createQuery( fieldContexts.get( 0 ), conversionContext ) ).createQuery(); } else { BooleanQuery.Builder aggregatedFieldsQueryBuilder = new BooleanQuery.Builder(); for ( FieldContext fieldContext : fieldContexts ) { aggregatedFieldsQueryBuilder.add( createQuery( fieldContext, conversionContext ), BooleanClause.Occur.SHOULD ); } return queryCustomizer.setWrappedQuery( aggregatedFieldsQueryBuilder.build() ).createQuery(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this assertion redundant 2 previous ones'\nThe code is: 'private static void assertEqualsWithoutUsages(ClassSymbolImpl classSymbol) { ClassSymbolImpl copied = classSymbol.copyWithoutUsages(); assertThat(copied.hasUnresolvedTypeHierarchy()).isEqualTo(classSymbol.hasUnresolvedTypeHierarchy()); List<String> copiedfqnSuperClasses = copied.superClasses().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); List<String> fqnSuperClasses = classSymbol.superClasses().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); assertThat(copiedfqnSuperClasses).isEqualTo(fqnSuperClasses); List<Symbol.Kind> copiedKindSuperClasses = copied.superClasses().stream().map(Symbol::kind).collect(Collectors.toList()); List<Symbol.Kind> kindSuperClasses = classSymbol.superClasses().stream().map(Symbol::kind).collect(Collectors.toList()); assertThat(copiedKindSuperClasses).isEqualTo(kindSuperClasses); List<String> copiedFqnMembers = copied.declaredMembers().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); List<String> fqnMembers = classSymbol.declaredMembers().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); assertThat(copiedFqnMembers).isEqualTo(fqnMembers); List<Symbol.Kind> copiedKindMembers = copied.declaredMembers().stream().map(Symbol::kind).collect(Collectors.toList()); List<Symbol.Kind> kindMembers = classSymbol.declaredMembers().stream().map(Symbol::kind).collect(Collectors.toList()); assertThat(copiedKindMembers).isEqualTo(kindMembers); <START> assertThat(copied.declaredMembers()).hasSize(classSymbol.declaredMembers().size()); <END> \/\/ this assertion redundant 2 previous ones assertThat(copied.usages()).isEmpty(); }'","output":"private static void assertEqualsWithoutUsages(ClassSymbolImpl classSymbol) { ClassSymbolImpl copied = classSymbol.copyWithoutUsages(); assertThat(copied.hasUnresolvedTypeHierarchy()).isEqualTo(classSymbol.hasUnresolvedTypeHierarchy()); List<String> copiedfqnSuperClasses = copied.superClasses().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); List<String> fqnSuperClasses = classSymbol.superClasses().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); assertThat(copiedfqnSuperClasses).isEqualTo(fqnSuperClasses); List<Symbol.Kind> copiedKindSuperClasses = copied.superClasses().stream().map(Symbol::kind).collect(Collectors.toList()); List<Symbol.Kind> kindSuperClasses = classSymbol.superClasses().stream().map(Symbol::kind).collect(Collectors.toList()); assertThat(copiedKindSuperClasses).isEqualTo(kindSuperClasses); List<String> copiedFqnMembers = copied.declaredMembers().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); List<String> fqnMembers = classSymbol.declaredMembers().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); assertThat(copiedFqnMembers).isEqualTo(fqnMembers); List<Symbol.Kind> copiedKindMembers = copied.declaredMembers().stream().map(Symbol::kind).collect(Collectors.toList()); List<Symbol.Kind> kindMembers = classSymbol.declaredMembers().stream().map(Symbol::kind).collect(Collectors.toList()); assertThat(copiedKindMembers).isEqualTo(kindMembers); assertThat(copied.usages()).isEmpty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'intend leave this in'\nThe code is: 'public void shortCircuitingEnabledWithExplicitModuleCounts() throws InterruptedException { String streamName = \"shortCircuitingEnabledWithExplicitModuleCounts\"; StreamDefinition sd = new StreamDefinition(streamName, \"http | log\"); integrationSupport.streamDefinitionRepository().save(sd); Map<String, String> props = new HashMap<String, String>(); props.put(\"module.http.count\", \"0\"); props.put(\"module.log.count\", \"0\"); integrationSupport.deployStream(sd, props); List<Binding> bindings = getMessageBusBindingsForStream(streamName); <START> System.out.println(bindings); <END> \/\/ intend leave this in assertEquals(2, bindings.size()); Binding consumerBinding = bindings.get(0); Binding producerBinding = bindings.get(1); assertEquals(\"consumer\", consumerBinding.getType()); assertEquals(\"direct\", producerBinding.getType()); }'","output":"public void shortCircuitingEnabledWithExplicitModuleCounts() throws InterruptedException { String streamName = \"shortCircuitingEnabledWithExplicitModuleCounts\"; StreamDefinition sd = new StreamDefinition(streamName, \"http | log\"); integrationSupport.streamDefinitionRepository().save(sd); Map<String, String> props = new HashMap<String, String>(); props.put(\"module.http.count\", \"0\"); props.put(\"module.log.count\", \"0\"); integrationSupport.deployStream(sd, props); List<Binding> bindings = getMessageBusBindingsForStream(streamName); assertEquals(2, bindings.size()); Binding consumerBinding = bindings.get(0); Binding producerBinding = bindings.get(1); assertEquals(\"consumer\", consumerBinding.getType()); assertEquals(\"direct\", producerBinding.getType()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'No, this method throw interrupted exceptions'\nThe code is: '<START> public void testStateChangeWithTransitiveState() throws InterruptedException { <END> \/\/ No, this method throw interrupted exceptions AgentMessageProcessor processor = (AgentMessageProcessor) this.agent.getMessagingClient().getMessageProcessor(); TestApplicationTemplate app = new TestApplicationTemplate(); processor.scopedInstance = app.getMySqlVm(); for( InstanceStatus status : InstanceStatus.values()) { if( status.isStable()) continue; app.getMySql().setStatus( status ); processor.processMessage( new MsgCmdChangeInstanceState( app.getMySql(), InstanceStatus.DEPLOYED_STARTED )); Assert.assertEquals( status, app.getMySql().getStatus()); } }'","output":"public void testStateChangeWithTransitiveState() { AgentMessageProcessor processor = (AgentMessageProcessor) this.agent.getMessagingClient().getMessageProcessor(); TestApplicationTemplate app = new TestApplicationTemplate(); processor.scopedInstance = app.getMySqlVm(); for( InstanceStatus status : InstanceStatus.values()) { if( status.isStable()) continue; app.getMySql().setStatus( status ); processor.processMessage( new MsgCmdChangeInstanceState( app.getMySql(), InstanceStatus.DEPLOYED_STARTED )); Assert.assertEquals( status, app.getMySql().getStatus()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Arg a shape. some place holder logic want put in here. checking for null shapes do this good'\nThe code is: 'public List<SDVariable> doDiff(List<SDVariable> i_v1) { SDVariable prod = outputVariables()[0]; <START> SDVariable broadcastableGrad = sameDiff.f().reductionBroadcastableWithOrigShape(arg().getShape().length, dimensions, i_v1.get(0)); <END> \/\/ Arg a shape. some place holder logic want put in here. checking for null shapes do this good SDVariable broadcastableProd = sameDiff.f().reductionBroadcastableWithOrigShape(arg().getShape().length, dimensions, prod); SDVariable mul = broadcastableGrad.div(broadcastableProd); SDVariable ret = arg().mul(mul); return Collections.singletonList(ret); }'","output":"public List<SDVariable> doDiff(List<SDVariable> i_v1) { SDVariable prod = outputVariables()[0]; int origRank = Shape.rankFromShape(arg().getShape()); SDVariable broadcastableGrad = sameDiff.f().reductionBroadcastableWithOrigShape(origRank, dimensions, i_v1.get(0)); SDVariable broadcastableProd = sameDiff.f().reductionBroadcastableWithOrigShape(origRank, dimensions, prod); SDVariable mul = broadcastableGrad.div(broadcastableProd); SDVariable ret = arg().mul(mul); return Collections.singletonList(ret); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this required? this true'\nThe code is: 'private void onDeleteSnapshot() { if (getConfirmWindow() == null) { return; } ConfirmationModel model = (ConfirmationModel) getConfirmWindow(); if <START> (model.getProgress() != null) { <END> \/\/ Is this required? this true return; } List<VdcActionParametersBase> paramsList = new ArrayList<>(); for (GlusterVolumeSnapshotEntity snapshot : (List<GlusterVolumeSnapshotEntity>) getSelectedItems()) { GlusterVolumeSnapshotActionParameters param = new GlusterVolumeSnapshotActionParameters(getEntity().getId(), snapshot.getSnapshotName(), true); paramsList.add(param); } model.startProgress(null); Frontend.getInstance().runMultipleAction(VdcActionType.DeleteGlusterVolumeSnapshot, paramsList, new IFrontendMultipleActionAsyncCallback() { @Override public void executed(FrontendMultipleActionAsyncResult result) { ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow(); localModel.stopProgress(); setConfirmWindow(null); } }, model); }'","output":"private void onDeleteSnapshot() { if (getConfirmWindow() == null) { return; } ConfirmationModel model = (ConfirmationModel) getConfirmWindow(); List<VdcActionParametersBase> paramsList = new ArrayList<>(); for (GlusterVolumeSnapshotEntity snapshot : (List<GlusterVolumeSnapshotEntity>) getSelectedItems()) { GlusterVolumeSnapshotActionParameters param = new GlusterVolumeSnapshotActionParameters(getEntity().getId(), snapshot.getSnapshotName(), true); paramsList.add(param); } model.startProgress(null); Frontend.getInstance().runMultipleAction(VdcActionType.DeleteGlusterVolumeSnapshot, paramsList, new IFrontendMultipleActionAsyncCallback() { @Override public void executed(FrontendMultipleActionAsyncResult result) { ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow(); localModel.stopProgress(); setConfirmWindow(null); } }, model); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Drop logging line'\nThe code is: 'public void start() { <START> System.out.println(\"ServerSideSession Start\"); <END> \/\/ Drop logging line instruments.startSession(getSessionId(), application, device, capabilities); final int sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(\"forcing stop session that has been running for \" + sessionTimeoutMillis \/ 1000 + \" seconds\"); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(\"http:\/\/localhost:\" + driver.getHostInfo().getPort() + \"\/wd\/hub\"); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (\"Safari\".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(\"about:blank\"); } }'","output":"public void start() { instruments.startSession(getSessionId(), application, device, capabilities); final int sessionTimeoutMillis = options.getSessionTimeoutMillis(); stopSessionTimer.schedule(new TimerTask() { @Override public void run() { log.warning(\"forcing stop session that has been running for \" + sessionTimeoutMillis \/ 1000 + \" seconds\"); hardForceStop(); } }, sessionTimeoutMillis); URL url = null; try { url = new URL(\"http:\/\/localhost:\" + driver.getHostInfo().getPort() + \"\/wd\/hub\"); } catch (Exception e) { e.printStackTrace(); } nativeDriver = new ServerSideNativeDriver(url, new SessionId(instruments.getSessionId())); if (\"Safari\".equals(capabilities.getBundleName())) { setMode(WorkingMode.Web); getRemoteWebDriver().get(\"about:blank\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I verifying this patch. vdsUpEvent called. called host status is UP. host status glusterd service is started. I move this logic ActivcateVdsCommand'\nThe code is: 'public boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(\"Failed to initialize Vds on up: {}\", e.getMessage()); log.error(\"Exception\", e); } } }); } <START> if (isSucceeded && vds.getVdsGroupSupportsGlusterService()) { <END> \/\/ I verifying this patch. vdsUpEvent called. called host status is UP. host status glusterd service is started. I move this logic ActivcateVdsCommand isSucceeded = resourceManagerProvider.get().runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList(\"glusterd\"), \"restart\")).getSucceeded(); } return isSucceeded; }'","output":"public boolean vdsUpEvent(final VDS vds) { HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds); boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded(); if (isSucceeded) { ThreadPoolUtil.execute(new Runnable() { @Override public void run() { try { List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId()); if (!vmsToMigrate.isEmpty()) { CommandContext ctx = new CommandContext(new EngineContext()); ctx.getExecutionContext().setMonitored(true); backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx); } } catch (RuntimeException e) { log.error(\"Failed to initialize Vds on up: {}\", e.getMessage()); log.error(\"Exception\", e); } } }); } return isSucceeded; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertTrue instead'\nThe code is: 'private void testCancelNewOrEditQuestion() { ______TS(\"Testing cancelling adding or editing questions\"); feedbackEditPage.selectNewQuestionType(\"Multiple-choice (single answer) question\"); feedbackEditPage.clickNewQuestionButton(); ______TS(\"MCQ: click and cancel 'cancel new question'\"); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(\"MCQ: click and confirm 'cancel new question'\"); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(\"MCQ: click and cancel 'editing question'\"); feedbackEditPage.selectNewQuestionType(\"Multiple-choice (single answer) question\"); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(\"mcq qn\"); feedbackEditPage.fillMcqOption(0, \"Choice 1\"); feedbackEditPage.fillMcqOption(1, \"Choice 2\"); feedbackEditPage.clickAddQuestionButton(); <START> assertEquals(true, feedbackEditPage.clickEditQuestionButton(1)); <END> \/\/ assertTrue instead feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(\"MCQ: click and confirm 'editing question'\"); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }'","output":"private void testCancelNewOrEditQuestion() { ______TS(\"Testing cancelling adding or editing questions\"); feedbackEditPage.selectNewQuestionType(\"Multiple-choice (single answer) question\"); feedbackEditPage.clickNewQuestionButton(); ______TS(\"MCQ: click and cancel 'cancel new question'\"); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(-1)); assertTrue(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(\"MCQ: click and confirm 'cancel new question'\"); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(-1)); assertFalse(feedbackEditPage.verifyNewMcqQuestionFormIsDisplayed()); ______TS(\"MCQ: click and cancel 'editing question'\"); feedbackEditPage.selectNewQuestionType(\"Multiple-choice (single answer) question\"); feedbackEditPage.clickNewQuestionButton(); feedbackEditPage.fillQuestionBox(\"mcq qn\"); feedbackEditPage.fillMcqOption(0, \"Choice 1\"); feedbackEditPage.fillMcqOption(1, \"Choice 2\"); feedbackEditPage.clickAddQuestionButton(); assertTrue(feedbackEditPage.clickEditQuestionButton(1)); feedbackEditPage.clickAndCancel(feedbackEditPage.getCancelQuestionLink(1)); assertTrue(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); ______TS(\"MCQ: click and confirm 'editing question'\"); feedbackEditPage.clickAndConfirm(feedbackEditPage.getCancelQuestionLink(1)); assertFalse(feedbackEditPage.checkCancelEditQuestionButtonVisibility(1)); feedbackEditPage.clickAndConfirm(feedbackEditPage.getDeleteQuestionLink(1)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@NielsCharlier is this a resource leak? fixed a try-with-resources block'\nThe code is: 'void configureDataSource(Resource dbprops, Resource monitoringDir) throws Exception { Properties db = new Properties(); if (dbprops == null) { dbprops = monitoringDir.get(\"db.properties\"); InputStream in = getClass().getResourceAsStream(\"db.properties\"); IOUtils.copy(in, dbprops.out()); db.load(getClass().getResourceAsStream(\"db.properties\")); } else { InputStream in = dbprops.in(); db.load(in); <START> in.close(); <END> \/\/ @NielsCharlier is this a resource leak? fixed a try-with-resources block } logDbProperties(db); setDriverClassName(db.getProperty(\"driver\")); setUrl(getURL(db)); if (db.containsKey(\"username\")) { setUsername(db.getProperty(\"username\")); } if (db.containsKey(\"password\")) { setPassword(db.getProperty(\"password\")); } setDefaultAutoCommit(Boolean.valueOf(db.getProperty(\"defaultAutoCommit\", \"true\"))); setMinIdle(1); setMaxActive(4); super.getConnection(); }'","output":"void configureDataSource(Resource dbprops, Resource monitoringDir) throws Exception { Properties db = new Properties(); if (dbprops == null) { dbprops = monitoringDir.get(\"db.properties\"); InputStream in = getClass().getResourceAsStream(\"db.properties\"); IOUtils.copy(in, dbprops.out()); db.load(getClass().getResourceAsStream(\"db.properties\")); } else { try (InputStream in = dbprops.in()) { db.load(in); } } logDbProperties(db); setDriverClassName(db.getProperty(\"driver\")); setUrl(getURL(db)); if (db.containsKey(\"username\")) { setUsername(db.getProperty(\"username\")); } if (db.containsKey(\"password\")) { setPassword(db.getProperty(\"password\")); } setDefaultAutoCommit(Boolean.valueOf(db.getProperty(\"defaultAutoCommit\", \"true\"))); setMinIdle(1); setMaxActive(4); super.getConnection(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Replace Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size());'\nThe code is: 'private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(\"pluginDescription\").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(\"sectionDescriptions\").isObject(); <START> Map<Integer, String> sectionDescriptions = new HashMap<>(); <END> \/\/ Replace Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { int sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(\"configurableFields\").isArray(); for (int j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(\"name\").isString().stringValue(); String value = field.get(\"value\").isString().stringValue(); JSONObject meta = field.get(\"meta\").isObject(); String metaType = meta.get(\"type\").isString().stringValue(); String descr = meta.get(\"description\").isString().stringValue(); boolean dynamic = meta.get(\"dynamic\").isBoolean().booleanValue(); int sectionSelector = (int) meta.get(\"sectionSelector\").isNumber().doubleValue(); boolean password = false; boolean credentials = false; boolean file = false; boolean textArea = false; if (metaType.equalsIgnoreCase(\"password\")) { password = true; } else if (metaType.equalsIgnoreCase(\"fileBrowser\")) { file = true; } else if (metaType.equalsIgnoreCase(\"credential\")) { credentials = true; } else if (metaType.equalsIgnoreCase(\"textArea\")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }'","output":"private PluginDescriptor getPluginDescriptor(JSONObject p, String pluginName) { String pluginDescription = p.get(\"pluginDescription\").isString().stringValue(); JSONObject jsonSectionDescriptions = p.get(\"sectionDescriptions\").isObject(); Map<Integer, String> sectionDescriptions = new HashMap<>(jsonSectionDescriptions.size()); for (String key : jsonSectionDescriptions.keySet()) { int sectionSelector = Integer.parseInt(key); String sectionDescription = jsonSectionDescriptions.get(key).isString().stringValue(); sectionDescriptions.put(sectionSelector, sectionDescription); } PluginDescriptor desc = new PluginDescriptor(pluginName, pluginDescription, sectionDescriptions); JSONArray fields = p.get(\"configurableFields\").isArray(); for (int j = 0; j < fields.size(); j++) { JSONObject field = fields.get(j).isObject(); String name = field.get(\"name\").isString().stringValue(); String value = field.get(\"value\").isString().stringValue(); JSONObject meta = field.get(\"meta\").isObject(); String metaType = meta.get(\"type\").isString().stringValue(); String descr = meta.get(\"description\").isString().stringValue(); boolean dynamic = meta.get(\"dynamic\").isBoolean().booleanValue(); int sectionSelector = (int) meta.get(\"sectionSelector\").isNumber().doubleValue(); boolean password = false; boolean credentials = false; boolean file = false; boolean textArea = false; if (metaType.equalsIgnoreCase(\"password\")) { password = true; } else if (metaType.equalsIgnoreCase(\"fileBrowser\")) { file = true; } else if (metaType.equalsIgnoreCase(\"credential\")) { credentials = true; } else if (metaType.equalsIgnoreCase(\"textArea\")) { textArea = true; } PluginDescriptor.Field f = new PluginDescriptor.Field(name, value, descr, password, credentials, file, textArea, dynamic, sectionSelector); desc.getConfigurableFields().add(f); } return desc; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replaced '==' this field is of type 'int''\nThe code is: 'public boolean equals(Object obj) { if (this == obj) { return true; } if (!(obj instanceof VdsStatic)) { return false; } VdsStatic other = (VdsStatic) obj; return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineBlacklistNouveau, other.kernelCmdlineBlacklistNouveau) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts) && reinstallRequired == other.reinstallRequired && <START> Objects.equals(vgpuPlacement, other.vgpuPlacement); <END> \/\/ replaced '==' this field is of type 'int' }'","output":"public boolean equals(Object obj) { if (this == obj) { return true; } if (!(obj instanceof VdsStatic)) { return false; } VdsStatic other = (VdsStatic) obj; return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineBlacklistNouveau, other.kernelCmdlineBlacklistNouveau) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts) && reinstallRequired == other.reinstallRequired && vgpuPlacement == other.vgpuPlacement; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Small note: User quux is in this test removed'\nThe code is: 'public void shouldFindUserSubscribingForAnyPipelineAndThatHasPermission() { User foo = new User(\"foo\", Arrays.asList(\"fOO\", \"Foo\"), \"foo@cruise.com\", false); foo.addNotificationFilter(new NotificationFilter(GoConstants.ANY_PIPELINE, GoConstants.ANY_STAGE, StageEvent.Passes, true)); User bar = new User(\"bar\", Arrays.asList(\"bAR\", \"Bar\"), \"bar@go.com\", true); bar.addNotificationFilter(new NotificationFilter(GoConstants.ANY_PIPELINE, GoConstants.ANY_STAGE, StageEvent.Passes, true)); <START> User quux = new User(\"quux\", Arrays.asList(\"qUUX\", \"Quux\"), \"quux@cruise.go\", false); <END> \/\/ Small note: User quux is in this test removed quux.addNotificationFilter(new NotificationFilter(\"p2\", \"s2\", StageEvent.Passes, true)); when(userDao.findNotificationSubscribingUsers()).thenReturn(new Users(Arrays.asList(foo, bar))); when(securityService.hasViewPermissionForPipeline(foo.getName(), \"p1\")).thenReturn(true); when(securityService.hasViewPermissionForPipeline(bar.getName(), \"p1\")).thenReturn(false); assertThat(userService.findValidSubscribers(new StageConfigIdentifier(\"p1\", \"s1\")), contains(foo)); }'","output":"public void shouldFindUserSubscribingForAnyPipelineAndThatHasPermission() { User foo = new User(\"foo\", Arrays.asList(\"fOO\", \"Foo\"), \"foo@cruise.com\", false); foo.addNotificationFilter(new NotificationFilter(GoConstants.ANY_PIPELINE, GoConstants.ANY_STAGE, StageEvent.Passes, true)); User bar = new User(\"bar\", Arrays.asList(\"bAR\", \"Bar\"), \"bar@go.com\", true); bar.addNotificationFilter(new NotificationFilter(GoConstants.ANY_PIPELINE, GoConstants.ANY_STAGE, StageEvent.Passes, true)); when(userDao.findNotificationSubscribingUsers()).thenReturn(new Users(Arrays.asList(foo, bar))); when(securityService.hasViewPermissionForPipeline(foo.getName(), \"p1\")).thenReturn(true); when(securityService.hasViewPermissionForPipeline(bar.getName(), \"p1\")).thenReturn(false); assertThat(userService.findValidSubscribers(new StageConfigIdentifier(\"p1\", \"s1\")), contains(foo)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need call Integer.parseInt(getUuid()) more in a method'\nThe code is: 'public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { assertTrue( <START> identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); <END> \/\/ do need call Integer.parseInt(getUuid()) more in a method assertTrue(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(\"manualEntryEnabled\", false); autoGenerationOption.add(\"automaticGenerationEnabled\", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + \"\/\" + getUuid()); req.setContent(json.getBytes()); handle(req); assertFalse( identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isAutomaticGenerationEnabled()); assertFalse(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())).isManualEntryEnabled()); }'","output":"public void shouldEditAnAutoGenerationOptionByAnyNumberOFArguments() throws Exception { AutoGenerationOption autogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertTrue(autogenerationOption.isAutomaticGenerationEnabled()); assertTrue(autogenerationOption.isManualEntryEnabled()); SimpleObject autoGenerationOption = new SimpleObject(); autoGenerationOption.add(\"manualEntryEnabled\", false); autoGenerationOption.add(\"automaticGenerationEnabled\", false); String json = new ObjectMapper().writeValueAsString(autoGenerationOption); MockHttpServletRequest req = request(RequestMethod.POST, getURI() + \"\/\" + getUuid()); req.setContent(json.getBytes()); handle(req); AutoGenerationOption updatedAutogenerationOption = identifierSourceService.getAutoGenerationOption(getId()); assertFalse(updatedAutogenerationOption.isAutomaticGenerationEnabled()); assertFalse(updatedAutogenerationOption.isManualEntryEnabled()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Cleanup: Remove **throws MiddlewareQueryException** clauses'\nThe code is: 'public DmsProject getParentStudyByDataset(Integer datasetId) throws MiddlewareQueryException { try { Criteria criteria = this.getSession().createCriteria(this.getPersistentClass()); criteria.createAlias(\"relatedTos\", \"pr\"); criteria.add(Restrictions.eq(\"pr.typeId\", TermId.BELONGS_TO_STUDY.getId())); criteria.add(Restrictions.eq(\"pr.subjectProject.projectId\", datasetId)); criteria.setProjection(Projections.property(\"pr.objectProject\")); return (DmsProject) criteria.uniqueResult(); <START> <END> \/\/ Cleanup: Remove **throws MiddlewareQueryException** clauses } catch (HibernateException e) { this.logAndThrowException(\"Error in getParentStudyByDataset= \" + datasetId + \" query in DmsProjectDao: \" + e.getMessage(), e); } return null; }'","output":"public DmsProject getParentStudyByDataset(Integer datasetId) { try { Criteria criteria = this.getSession().createCriteria(this.getPersistentClass()); criteria.createAlias(\"relatedTos\", \"pr\"); criteria.add(Restrictions.eq(\"pr.typeId\", TermId.BELONGS_TO_STUDY.getId())); criteria.add(Restrictions.eq(\"pr.subjectProject.projectId\", datasetId)); criteria.setProjection(Projections.property(\"pr.objectProject\")); return (DmsProject) criteria.uniqueResult(); } catch (HibernateException e) { this.logAndThrowException(\"Error in getParentStudyByDataset= \" + datasetId + \" query in DmsProjectDao: \" + e.getMessage(), e); } return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '> find'\nThe code is: 'public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, \"taskid\"); Preconditions.checkNotNull(taskLockToRemove, \"taskLockToRemove\"); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(\"Deleting TaskLock with id[%d]: %s\", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { <START> log.error(\"Did not found any TaskLock [%s] to remove\", taskLockToRemove); <END> \/\/ > find } }'","output":"public void removeLock(String taskid, TaskLock taskLockToRemove) { Preconditions.checkNotNull(taskid, \"taskid\"); Preconditions.checkNotNull(taskLockToRemove, \"taskLockToRemove\"); final Map<Long, TaskLock> taskLocks = getLocksWithIds(taskid); boolean removed = false; for (final Map.Entry<Long, TaskLock> taskLockWithId : taskLocks.entrySet()) { final long id = taskLockWithId.getKey(); final TaskLock taskLock = taskLockWithId.getValue(); if (taskLock.equals(taskLockToRemove)) { log.info(\"Deleting TaskLock with id[%d]: %s\", id, taskLock); handler.removeLock(id); removed = true; } } if (!removed) { log.error(\"Did not find any TaskLock [%s] to remove\", taskLockToRemove); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this package-private'\nThe code is: '<START> List<JsonObject> getLanguageMap(Locale locale) { <END> \/\/ this package-private if (!languageMaps.containsKey(locale)) { try { List<JsonObject> set = new ArrayList<>(); for (String namespace : config.getLanguageNamespaces()) { String filename = locale.getLanguage() + \"_\" + locale.getCountry() + File.separator + namespace + \".json\"; Resource r = getBaseDirectory().createRelative(filename); if (!r.exists()) { logger.debug(\"Fallback locale to language only.\"); filename = locale.getLanguage() + File.separator + namespace + \".json\"; r = getBaseDirectory().createRelative(filename); } logger.info(\"No locale loaded, trying to load from {}\", r); JsonParser parser = new JsonParser(); JsonObject obj = (JsonObject) parser.parse(new InputStreamReader(r.getInputStream(), \"UTF-8\")); set.add(obj); } languageMaps.put(locale, set); } catch (FileNotFoundException e) { logger.info(\"Unable to load locale because no messages file was found for locale {}\", locale.getDisplayName()); languageMaps.put(locale, null); } catch (JsonIOException | JsonSyntaxException | IOException e) { logger.error(\"Unable to load locale\", e); } } return languageMaps.get(locale); }'","output":"private List<JsonObject> getLanguageMap(Locale locale) { if (!languageMaps.containsKey(locale)) { try { List<JsonObject> set = new ArrayList<>(); for (String namespace : config.getLanguageNamespaces()) { String filename = locale.getLanguage() + \"_\" + locale.getCountry() + File.separator + namespace + \".json\"; Resource r = getBaseDirectory().createRelative(filename); if (!r.exists()) { logger.debug(\"Fallback locale to language only.\"); filename = locale.getLanguage() + File.separator + namespace + \".json\"; r = getBaseDirectory().createRelative(filename); } logger.info(\"No locale loaded, trying to load from {}\", r); JsonParser parser = new JsonParser(); JsonObject obj = (JsonObject) parser.parse(new InputStreamReader(r.getInputStream(), \"UTF-8\")); set.add(obj); } languageMaps.put(locale, set); } catch (FileNotFoundException e) { logger.info(\"Unable to load locale because no messages file was found for locale {}\", locale.getDisplayName()); languageMaps.put(locale, null); } catch (JsonIOException | JsonSyntaxException | IOException e) { logger.error(\"Unable to load locale\", e); } } return languageMaps.get(locale); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do fileListView.getItems().addAll(file) loop list. Also, a list of files, want rename list files singular file'\nThe code is: 'private void onSelectFileClicked() { FileChooser chooser = new FileChooser(); chooser.setTitle(\"Select Files\"); chooser.getExtensionFilters().addAll( new FileChooser.ExtensionFilter(\"Java JARs\", \"*.jar\"), new FileChooser.ExtensionFilter(\"Java WARs\", \"*.war\"), new FileChooser.ExtensionFilter(\"Java EARs\", \"*.ear\"), new FileChooser.ExtensionFilter(\"Java class files\", \"*.class\") ); List<File> file = chooser.showOpenMultipleDialog(designerRoot.getMainStage()); for (File f : file) { <START> fileListView.getItems().add(f); <END> \/\/ do fileListView.getItems().addAll(file) loop list. Also, a list of files, want rename list files singular file } }'","output":"private void onSelectFileClicked() { FileChooser chooser = new FileChooser(); chooser.setTitle(\"Select Files\"); chooser.getExtensionFilters().addAll( new FileChooser.ExtensionFilter(\"Java JARs\", \"*.jar\"), new FileChooser.ExtensionFilter(\"Java WARs\", \"*.war\"), new FileChooser.ExtensionFilter(\"Java EARs\", \"*.ear\"), new FileChooser.ExtensionFilter(\"Java class files\", \"*.class\") ); List<File> files = chooser.showOpenMultipleDialog(designerRoot.getMainStage()); fileListView.getItems().addAll(files); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'be: java logger.error(\"Cannot publish topic: {}\", topic, e);'\nThe code is: 'private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); float setPoint = 0; float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(\"temperatureInternal\", this.temperature); payload.addMetric(\"temperatureExternal\", 5.0F); payload.addMetric(\"temperatureExhaust\", 30.0F); int code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(\"errorCode\", code); } else { payload.addMetric(\"errorCode\", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(\"Published to {} message: {}\", topic, payload); } catch (Exception e) { <START> logger.error(\"Cannot publish topic: {}\" + topic, e); <END> \/\/ be: java logger.error(\"Cannot publish topic: {}\", topic, e); } }'","output":"private void doPublish() { String topic = (String) this.properties.get(PUBLISH_TOPIC_PROP_NAME); Integer qos = (Integer) this.properties.get(PUBLISH_QOS_PROP_NAME); Boolean retain = (Boolean) this.properties.get(PUBLISH_RETAIN_PROP_NAME); String mode = (String) this.properties.get(MODE_PROP_NAME); float setPoint = 0; float tempIncr = (Float) this.properties.get(TEMP_INCREMENT_PROP_NAME); if (MODE_PROP_PROGRAM.equals(mode)) { setPoint = (Float) this.properties.get(PROGRAM_SETPOINT_NAME); } else if (MODE_PROP_MANUAL.equals(mode)) { setPoint = (Float) this.properties.get(MANUAL_SETPOINT_NAME); } else if (MODE_PROP_VACATION.equals(mode)) { setPoint = 6.0F; } if (this.temperature + tempIncr < setPoint) { this.temperature += tempIncr; } else { this.temperature -= 4 * tempIncr; } KuraPayload payload = new KuraPayload(); payload.setTimestamp(new Date()); payload.addMetric(\"temperatureInternal\", this.temperature); payload.addMetric(\"temperatureExternal\", 5.0F); payload.addMetric(\"temperatureExhaust\", 30.0F); int code = this.random.nextInt(); if (this.random.nextInt() % 5 == 0) { payload.addMetric(\"errorCode\", code); } else { payload.addMetric(\"errorCode\", 0); } try { this.cloudClient.publish(topic, payload, qos, retain); logger.info(\"Published to {} message: {}\", topic, payload); } catch (Exception e) { logger.error(\"Cannot publish topic: {}\", topic, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method private others in this file'\nThe code is: '<START> protected Supplier<BsonValue> getReader(final T t) { <END> \/\/ this method private others in this file final Class<?> documentClass = t.getClass(); final Optional<Method> maybeIdGetter = getIdGetter(documentClass); if (maybeIdGetter.isPresent()) { Method getter = maybeIdGetter.get(); getter.setAccessible(true); return () -> { try { return constructValue(getter.invoke(t)); } catch (Exception e) { e.printStackTrace(); return BsonNull.VALUE; } }; } else { final Optional<Field> maybeField = getIdField(documentClass); if (maybeField.isPresent()) { Field field = maybeField.get(); field.setAccessible(true); return () -> { try { return constructValue(field.get(t)); } catch (Exception e) { e.printStackTrace(); return BsonNull.VALUE; } }; } else { return () -> BsonNull.VALUE; } } }'","output":"private Supplier<BsonValue> getReader(final T t) { final Class<?> documentClass = t.getClass(); final Optional<Method> maybeIdGetter = getIdGetter(documentClass); if (maybeIdGetter.isPresent()) { Method getter = maybeIdGetter.get(); getter.setAccessible(true); return () -> { try { return constructValue(getter.invoke(t)); } catch (Exception e) { e.printStackTrace(); return BsonNull.VALUE; } }; } else { final Optional<Field> maybeField = getIdField(documentClass); if (maybeField.isPresent()) { Field field = maybeField.get(); field.setAccessible(true); return () -> { try { return constructValue(field.get(t)); } catch (Exception e) { e.printStackTrace(); return BsonNull.VALUE; } }; } else { return () -> BsonNull.VALUE; } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this fromString'\nThe code is: 'public void testSimplestMessage() throws Exception { RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class); ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.InnerMessage.class, readConsumerMock); TestProtobuf.InnerMessage.Builder msg = TestProtobuf.InnerMessage.newBuilder(); msg.setOne(\"oneValue\"); instance.write(msg.build()); InOrder inOrder = Mockito.inOrder(readConsumerMock); inOrder.verify(readConsumerMock).startMessage(); inOrder.verify(readConsumerMock).startField(\"one\", 0); <START> inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray(\"oneValue\".getBytes())); <END> \/\/ this fromString inOrder.verify(readConsumerMock).endField(\"one\", 0); inOrder.verify(readConsumerMock).endMessage(); Mockito.verifyNoMoreInteractions(readConsumerMock); }'","output":"public void testSimplestMessage() throws Exception { RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class); ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.InnerMessage.class, readConsumerMock); TestProtobuf.InnerMessage.Builder msg = TestProtobuf.InnerMessage.newBuilder(); msg.setOne(\"oneValue\"); instance.write(msg.build()); InOrder inOrder = Mockito.inOrder(readConsumerMock); inOrder.verify(readConsumerMock).startMessage(); inOrder.verify(readConsumerMock).startField(\"one\", 0); inOrder.verify(readConsumerMock).addBinary(Binary.fromString(\"oneValue\")); inOrder.verify(readConsumerMock).endField(\"one\", 0); inOrder.verify(readConsumerMock).endMessage(); Mockito.verifyNoMoreInteractions(readConsumerMock); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here. method defined in interface Node'\nThe code is: 'public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(\"\/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2\")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return \"Hello\"; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(\"UniqueId\", \"_575A78C8-C34A-445E-8B2F-BB990B513A03\"); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } <START> @Override public String getUniqueId() { return null; } <END> \/\/ here. method defined in interface Node @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }'","output":"public void testReadProbabilitySimulationProperties() { SimulationDataProvider provider = new BPMN2SimulationDataProvider(this.getClass().getResourceAsStream(\"\/BPMN2-ExclusiveSplitWithSimulationProps.bpmn2\")); Map<String, Object> data = provider.getSimulationDataForNode(new Node() { public List<Connection> getOutgoingConnections(String type) { return null; } public Map<String, List<Connection>> getOutgoingConnections() { return null; } public NodeContainer getNodeContainer() { return null; } public String getName() { return \"Hello\"; } public Object getMetaData(String name) { return null; } public Map<String, Object> getMetaData() { Map<String, Object> metaData = new HashMap<String, Object>(); metaData.put(\"UniqueId\", \"_575A78C8-C34A-445E-8B2F-BB990B513A03\"); return metaData; } public List<Connection> getIncomingConnections(String type) { return null; } public Map<String, List<Connection>> getIncomingConnections() { return null; } public long getId() { return 2; } @Override public String getNodeUniqueId() { return null; } }); assertNotNull(data); assertEquals(1, data.size()); assertTrue(data.containsKey(SimulationConstants.PROBABILITY)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser());'\nThe code is: 'public void testInputValidation() { ______TS(\"CONST SUM:input validation\"); feedbackEditPage.fillQuestionTextBoxForNewQuestion(\"ConstSum-recipient qn\"); feedbackEditPage.fillQuestionDescriptionForNewQuestion(\"more details\"); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(\"\"); assertEquals(\"1\", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(\"\"); assertEquals(\"1\", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(\"constSumOptionTable--1\")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); <START> assertTrue(feedbackEditPage.getTextsForAllStatusMessagesToUser().isEmpty()); <END> \/\/ assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }'","output":"public void testInputValidation() { ______TS(\"CONST SUM:input validation\"); feedbackEditPage.fillQuestionTextBoxForNewQuestion(\"ConstSum-recipient qn\"); feedbackEditPage.fillQuestionDescriptionForNewQuestion(\"more details\"); feedbackEditPage.fillConstSumPointsBoxForNewQuestion(\"\"); assertEquals(\"1\", feedbackEditPage.getConstSumPointsBoxForNewQuestion()); feedbackEditPage.fillConstSumPointsForEachRecipientBoxForNewQuestion(\"\"); assertEquals(\"1\", feedbackEditPage.getConstSumPointsForEachRecipientBoxForNewQuestion()); assertFalse(feedbackEditPage.isElementVisible(\"constSumOptionTable--1\")); feedbackEditPage.clickDiscardChangesLinkForNewQuestion(); feedbackEditPage.waitForConfirmationModalAndClickOk(); assertEquals(Collections.emptyList(), feedbackEditPage.getTextsForAllStatusMessagesToUser()); assertNull(BackDoor.getFeedbackQuestion(courseId, feedbackSessionName, 1)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Enclose in if (log.isDebugEnabled())'\nThe code is: 'public LogOffset commit(LogPartition partition) { TopicPartition topicPartition = new TopicPartition(prefix + partition.name(), partition.partition()); Long offset = lastOffsets.get(topicPartition); if (offset == null) { <START> log.debug(\"unchanged partition, nothing to commit: \" + partition); <END> \/\/ Enclose in if (log.isDebugEnabled()) return null; } offset += 1; consumer.commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(offset))); LogOffset ret = new LogOffsetImpl(partition, offset); if (log.isDebugEnabled()) { log.info(\"Committed: \" + offset + \"\/\" + group); } return ret; }'","output":"public LogOffset commit(LogPartition partition) { TopicPartition topicPartition = new TopicPartition(prefix + partition.name(), partition.partition()); Long offset = lastOffsets.get(topicPartition); if (offset == null) { if (log.isDebugEnabled()) { log.debug(\"unchanged partition, nothing to commit: \" + partition); } return null; } offset += 1; consumer.commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(offset))); LogOffset ret = new LogOffsetImpl(partition, offset); if (log.isInfoEnabled()) { log.info(\"Committed: \" + offset + \"\/\" + group); } return ret; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This variable is unnecessary now'\nThe code is: 'public void postEvents(int id) throws Exception { final ServerDiscoverySelector eventReceiverSelector = factory.createSelector(EVENT_RECEIVER_SERVICE_PREFIX + id); eventReceiverSelector.start(); try { ServerDiscoveryUtil.waitUntilInstanceReady(eventReceiverSelector, \"Event Receiver\"); String host = config.getMiddleManagerHost() + \":\" + eventReceiverSelector.pick().getPort(); LOG.info(\"Event Receiver Found at host [%s]\", host); LOG.info(\"Checking worker \/status\/health for [%s]\", host); <START> final StatusResponseHandler handler = StatusResponseHandler.getInstance(); <END> \/\/ This variable is unnecessary now RetryUtil.retryUntilTrue( () -> { try { StatusResponseHolder response = httpClient.go( new Request(HttpMethod.GET, new URL(StringUtils.format(\"https:\/\/%s\/status\/health\", host))), handler ).get(); return response.getStatus().equals(HttpResponseStatus.OK); } catch (Throwable e) { LOG.error(e, \"\"); return false; } }, StringUtils.format(\"Checking \/status\/health for worker [%s]\", host) ); LOG.info(\"Finished checking worker \/status\/health for [%s], success\", host); EventReceiverFirehoseTestClient client = new EventReceiverFirehoseTestClient( host, EVENT_RECEIVER_SERVICE_PREFIX + id, jsonMapper, httpClient, smileMapper ); client.postEventsFromFile(UNION_DATA_FILE); } finally { eventReceiverSelector.stop(); } }'","output":"public void postEvents(int id) throws Exception { final ServerDiscoverySelector eventReceiverSelector = factory.createSelector(EVENT_RECEIVER_SERVICE_PREFIX + id); eventReceiverSelector.start(); try { ServerDiscoveryUtil.waitUntilInstanceReady(eventReceiverSelector, \"Event Receiver\"); String host = config.getMiddleManagerHost() + \":\" + eventReceiverSelector.pick().getPort(); LOG.info(\"Event Receiver Found at host [%s]\", host); LOG.info(\"Checking worker \/status\/health for [%s]\", host); RetryUtil.retryUntilTrue( () -> { try { StatusResponseHolder response = httpClient.go( new Request(HttpMethod.GET, new URL(StringUtils.format(\"https:\/\/%s\/status\/health\", host))), StatusResponseHandler.getInstance() ).get(); return response.getStatus().equals(HttpResponseStatus.OK); } catch (Throwable e) { LOG.error(e, \"\"); return false; } }, StringUtils.format(\"Checking \/status\/health for worker [%s]\", host) ); LOG.info(\"Finished checking worker \/status\/health for [%s], success\", host); EventReceiverFirehoseTestClient client = new EventReceiverFirehoseTestClient( host, EVENT_RECEIVER_SERVICE_PREFIX + id, jsonMapper, httpClient, smileMapper ); client.postEventsFromFile(UNION_DATA_FILE); } finally { eventReceiverSelector.stop(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'orElse(Duration.seconds(5))'\nThe code is: 'public final void run(T configuration, Environment environment) throws Exception { final PooledDataSourceFactory dbConfig = getDataSourceFactory(configuration); this.sessionFactory = sessionFactoryFactory.build(this, environment, dbConfig, entities, name()); registerUnitOfWorkListerIfAbsent(environment).registerSessionFactory(name(), sessionFactory); environment.healthChecks().register(name(), new SessionFactoryHealthCheck( environment.getHealthCheckExecutorService(), <START> dbConfig.getValidationQueryTimeout().orElseGet(() -> Duration.seconds(5)), <END> \/\/ orElse(Duration.seconds(5)) sessionFactory, dbConfig.getValidationQuery())); }'","output":"public final void run(T configuration, Environment environment) throws Exception { final PooledDataSourceFactory dbConfig = getDataSourceFactory(configuration); this.sessionFactory = sessionFactoryFactory.build(this, environment, dbConfig, entities, name()); registerUnitOfWorkListerIfAbsent(environment).registerSessionFactory(name(), sessionFactory); environment.healthChecks().register(name(), new SessionFactoryHealthCheck( environment.getHealthCheckExecutorService(), dbConfig.getValidationQueryTimeout().orElse(Duration.seconds(5)), sessionFactory, dbConfig.getValidationQuery())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'writeLong(Double.doubleToLongBits(v)) avoid code duplication'\nThe code is: 'public void writeDouble(double v) { <START> final long bits = Double.doubleToLongBits(v); <END> \/\/ writeLong(Double.doubleToLongBits(v)) avoid code duplication int newcount = ensureCapacity(8); final int s = pos; bytes[s] = (byte) (bits >> 56L); bytes[s+1] = (byte) (bits >> 48L); bytes[s+2] = (byte) (bits >> 40L); bytes[s+3] = (byte) (bits >> 32L); bytes[s+4] = (byte) (bits >> 24L); bytes[s+5] = (byte) (bits >> 16L); bytes[s+6] = (byte) (bits >> 8L); bytes[s+7] = (byte) bits; pos = newcount; }'","output":"public void writeDouble(double v) { writeLong(Double.doubleToLongBits(v)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Exception is thrown'\nThe code is: '<START> public void testOnSwitch() throws Exception { <END> \/\/ Exception is thrown final Diagram diagram = mock(Diagram.class); final String defSetId = \"defSetId\"; final String shapeDefId = \"shapeDefId\"; tested.onSwitch(diagram, defSetId, shapeDefId); verify(view, times(1)).showLoading(); verify(view, times(1)).hideBusyIndicator(); verify(sessionEditorPresenter, times(1)).destroy(); verify(sessionEditorPresenter, times(1)).open(any(ProjectDiagram.class), any(SessionPresenter.SessionPresenterCallback.class)); }'","output":"public void testOnSwitch() { final Diagram diagram = mock(Diagram.class); final String defSetId = \"defSetId\"; final String shapeDefId = \"shapeDefId\"; tested.onSwitch(diagram, defSetId, shapeDefId); verify(view, times(1)).showLoading(); verify(view, times(1)).hideBusyIndicator(); verify(sessionEditorPresenter, times(1)).destroy(); verify(sessionEditorPresenter, times(1)).open(any(ProjectDiagram.class), any(SessionPresenter.SessionPresenterCallback.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'String'\nThe code is: 'protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); int lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; <START> StringBuilder category = new StringBuilder(); <END> \/\/ String if (matcher.group(4).equalsIgnoreCase(\"err\")) { priority = Priority.HIGH; category.append(\"ERROR\"); } else { priority = Priority.NORMAL; category.append(\"Warning\"); } Warning warning = createWarning(fileName, lineNumber, category.toString(), message, priority); return warning; }'","output":"protected Warning createWarning(final Matcher matcher) { String fileName = matcher.group(1); int lineNumber = getLineNumber(matcher.group(2)); String message = matcher.group(7); Priority priority; String category; if (\"err\".equalsIgnoreCase(matcher.group(4))) { priority = Priority.HIGH; category = \"ERROR\"; } else { priority = Priority.NORMAL; category = \"Warning\"; } return createWarning(fileName, lineNumber, category, message, priority); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'DateTimeUtils.dateToLong'\nThe code is: 'public CalibrationSet getMostRecentCalibrations(DataSource dataSource, long instrumentId, LocalDateTime date) throws CalibrationException, DatabaseException, MissingParamException, RecordNotFoundException { CalibrationSet result = new CalibrationSet(instrumentId, getCalibrationType(), getTargets(dataSource, instrumentId)); Connection conn = null; PreparedStatement stmt = null; ResultSet records = null; try { conn = dataSource.getConnection(); stmt = conn.prepareStatement(GET_RECENT_CALIBRATIONS_QUERY); stmt.setLong(1, instrumentId); stmt.setString(2, getCalibrationType()); <START> stmt.setLong(3, date.toEpochSecond(ZoneOffset.UTC) * 1000); <END> \/\/ DateTimeUtils.dateToLong records = stmt.executeQuery(); while (!result.isComplete() && records.next()) { String target = records.getString(1); if (!result.containsTarget(target)) { LocalDateTime deploymentDate = DateTimeUtils.longToDate(records.getLong(2)); List<Double> coefficients = StringUtils.delimitedToDoubleList(records.getString(3)); String calibrationClass = records.getString(4); Calibration calibration = CalibrationFactory.createCalibration(getCalibrationType(), calibrationClass, instrumentId, deploymentDate, target, coefficients); result.add(calibration); } } } catch (SQLException e) { throw new DatabaseException(\"Error while retrieving calibrations\", e); } finally { DatabaseUtils.closeResultSets(records); DatabaseUtils.closeStatements(stmt); DatabaseUtils.closeConnection(conn); } return result; }'","output":"public CalibrationSet getMostRecentCalibrations(DataSource dataSource, long instrumentId, LocalDateTime date) throws CalibrationException, DatabaseException, MissingParamException, RecordNotFoundException { CalibrationSet result = new CalibrationSet(instrumentId, getCalibrationType(), getTargets(dataSource, instrumentId)); Connection conn = null; PreparedStatement stmt = null; ResultSet records = null; try { conn = dataSource.getConnection(); stmt = conn.prepareStatement(GET_RECENT_CALIBRATIONS_QUERY); stmt.setLong(1, instrumentId); stmt.setString(2, getCalibrationType()); stmt.setLong(3, DateTimeUtils.dateToLong(date)); records = stmt.executeQuery(); while (!result.isComplete() && records.next()) { String target = records.getString(1); if (!result.containsTarget(target)) { LocalDateTime deploymentDate = DateTimeUtils.longToDate(records.getLong(2)); List<Double> coefficients = StringUtils.delimitedToDoubleList(records.getString(3)); String calibrationClass = records.getString(4); Calibration calibration = CalibrationFactory.createCalibration(getCalibrationType(), calibrationClass, instrumentId, deploymentDate, target, coefficients); result.add(calibration); } } } catch (SQLException e) { throw new DatabaseException(\"Error while retrieving calibrations\", e); } finally { DatabaseUtils.closeResultSets(records); DatabaseUtils.closeStatements(stmt); DatabaseUtils.closeConnection(conn); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'initial commit created in setUp() method'\nThe code is: 'public void markAsMerged() throws Exception { <START> new Git(repo).commit().setAuthor(\"JUnit\", \"junit@egit.org\") <END> \/\/ initial commit created in setUp() method .setMessage(\"Initial commit\").call(); GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = \"src\/Main.java\"; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, \"class Main {}\", \"some file\"); testRepo.addToIndex(iProject.getFile(\".classpath\")); testRepo.addToIndex(iProject.getFile(\".project\")); testRepo.commit(\"project files\"); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(\"Scope\", inputMappings, subscriber, true); testRepo.appendFileContent(file, \"some changes\"); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(\"src\"), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }'","output":"public void markAsMerged() throws Exception { GitSynchronizeData gsd = new GitSynchronizeData(repo, HEAD, HEAD, false); GitSynchronizeDataSet gsds = new GitSynchronizeDataSet(gsd); GitResourceVariantTreeSubscriber subscriber = new GitResourceVariantTreeSubscriber( gsds); String fileName = \"src\/Main.java\"; File file = testRepo.createFile(iProject, fileName); testRepo.appendContentAndCommit(iProject, file, \"class Main {}\", \"some file\"); testRepo.addToIndex(iProject.getFile(\".classpath\")); testRepo.addToIndex(iProject.getFile(\".project\")); testRepo.commit(\"project files\"); IFile workspaceFile = testRepo.getIFile(iProject, file); ResourceMapping mapping = new SimpleResourceMapping(workspaceFile); ResourceMapping[] inputMappings = new ResourceMapping[] { mapping }; SubscriberScopeManager manager = new SubscriberScopeManager(\"Scope\", inputMappings, subscriber, true); testRepo.appendFileContent(file, \"some changes\"); Status status = new Git(repo).status().call(); assertEquals(0, status.getAdded().size()); assertEquals(1, status.getModified().size()); String repoRelativePath = testRepo.getRepoRelativePath(workspaceFile.getLocation().toPortableString()); assertTrue(status.getModified().contains(repoRelativePath)); GitSubscriberMergeContext mergeContext = new GitSubscriberMergeContext( subscriber, manager, gsds); IDiff node = new ResourceDiff(iProject.getFolder(\"src\"), IDiff.CHANGE); mergeContext.markAsMerged(node, true, null); status = new Git(repo).status().call(); assertEquals(1, status.getChanged().size()); assertEquals(0, status.getModified().size()); assertTrue(status.getChanged().contains(repoRelativePath)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I do need explicitly call toString method'\nThe code is: 'public List<UserExtSource> getActiveUserExtSources(PerunSession sess, User user) throws InternalErrorException { LocalDate date = LocalDate.now(); date = date.minusMonths(MAX_OLD_OF_ACTIVE_USER_EXTSOURCE); try { String query = \"select \" + userExtSourceMappingSelectQuery + \", \" + ExtSourcesManagerImpl.extSourceMappingSelectQuery + \" from user_ext_sources left join ext_sources on user_ext_sources.ext_sources_id=ext_sources.id where \" + \" user_ext_sources.user_id=? and \" + <START> \" user_ext_sources.last_access > \" + Compatibility.toDate(\"'\" + date.toString() + \"'\", \"'YYYY-MM-DD'\"); <END> \/\/ I do need explicitly call toString method return jdbc.query(query, USEREXTSOURCE_MAPPER, user.getId()); } catch(EmptyResultDataAccessException ex) { return new ArrayList<>(); } catch (RuntimeException ex) { throw new InternalErrorException(ex); } }'","output":"public List<UserExtSource> getActiveUserExtSources(PerunSession sess, User user) throws InternalErrorException { LocalDate date = LocalDate.now(); date = date.minusMonths(MAX_OLD_OF_ACTIVE_USER_EXTSOURCE); try { String query = \"select \" + userExtSourceMappingSelectQuery + \", \" + ExtSourcesManagerImpl.extSourceMappingSelectQuery + \" from user_ext_sources left join ext_sources on user_ext_sources.ext_sources_id=ext_sources.id where \" + \" user_ext_sources.user_id=? and \" + \" user_ext_sources.last_access > \" + Compatibility.toDate(\"'\" + date + \"'\", \"'YYYY-MM-DD'\"); return jdbc.query(query, USEREXTSOURCE_MAPPER, user.getId()); } catch(EmptyResultDataAccessException ex) { return new ArrayList<>(); } catch (RuntimeException ex) { throw new InternalErrorException(ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List instead of ArrayList java public List<RemoteXBeeDevice> getDevices() {'\nThe code is: '<START> public ArrayList<RemoteXBeeDevice> getDevices(String id) { <END> \/\/ List instead of ArrayList java public List<RemoteXBeeDevice> getDevices() { if (id == null) throw new NullPointerException(\"Device identifier cannot be null.\"); if (id.length() == 0) throw new IllegalArgumentException(\"Device identifier cannot be an empty string.\"); ArrayList<RemoteXBeeDevice> devices = new ArrayList<RemoteXBeeDevice>(); for (RemoteXBeeDevice remote : remotesBy64BitAddr.values()) { if (remote.getNodeID().equals(id)) devices.add(remote); } for (RemoteXBeeDevice remote : remotesBy16BitAddr.values()) { if (remote.getNodeID().equals(id)) devices.add(remote); } return devices; }'","output":"public List<RemoteXBeeDevice> getDevices(String id) { if (id == null) throw new NullPointerException(\"Device identifier cannot be null.\"); if (id.length() == 0) throw new IllegalArgumentException(\"Device identifier cannot be an empty string.\"); List<RemoteXBeeDevice> devices = new ArrayList<RemoteXBeeDevice>(); for (RemoteXBeeDevice remote : remotesBy64BitAddr.values()) { if (remote.getNodeID().equals(id)) devices.add(remote); } for (RemoteXBeeDevice remote : remotesBy16BitAddr.values()) { if (remote.getNodeID().equals(id)) devices.add(remote); } return devices; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'spelling'\nThe code is: 'public SaProposal getVerifiedNegotiatedProposal(IkeSaPayload reqSaPayload) throws NoValidProposalChosenException { if (!isSaResponse) { throw new UnsupportedOperationException( \"Cannot get negotiated SA proposal from a request message.\"); } Proposal respProposal = proposalList.get(0); if (respProposal.hasUnrecognizedTransform) { throw new NoValidProposalChosenException( \"Negotiated proposal has unrecognized Transform.\"); } int negotiatedProposalNum = proposalList.get(0).number; List<Proposal> reqProposalList = reqSaPayload.proposalList; if (negotiatedProposalNum < 1 || negotiatedProposalNum > reqProposalList.size()) { throw new NoValidProposalChosenException( \"Negotiated proposal has invalid proposal number.\"); } Proposal reqProposal = reqProposalList.get(negotiatedProposalNum - 1); if (!respProposal.isNegotiatedFrom(reqProposal)) { throw new NoValidProposalChosenException(\"Invalid <START> negotaited proposal.\"); <END> \/\/ spelling } return respProposal.saProposal; }'","output":"public SaProposal getVerifiedNegotiatedProposal(IkeSaPayload reqSaPayload) throws NoValidProposalChosenException { if (!isSaResponse) { throw new UnsupportedOperationException( \"Cannot get negotiated SA proposal from a request message.\"); } Proposal respProposal = proposalList.get(0); if (respProposal.hasUnrecognizedTransform) { throw new NoValidProposalChosenException( \"Negotiated proposal has unrecognized Transform.\"); } int negotiatedProposalNum = proposalList.get(0).number; List<Proposal> reqProposalList = reqSaPayload.proposalList; if (negotiatedProposalNum < 1 || negotiatedProposalNum > reqProposalList.size()) { throw new NoValidProposalChosenException( \"Negotiated proposal has invalid proposal number.\"); } Proposal reqProposal = reqProposalList.get(negotiatedProposalNum - 1); if (!respProposal.isNegotiatedFrom(reqProposal)) { throw new NoValidProposalChosenException(\"Invalid negotiated proposal.\"); } return respProposal.saProposal; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I need initialize this right? do in method it'\nThe code is: 'public void writeTo(IndentingWriter writer, MavenBuild build) { MavenBuildSettings settings = build.getSettings(); <START> MavenDistributionManagement distributionManagement = build.getDistributionManagement(); <END> \/\/ I need initialize this right? do in method it writeProject(writer, () -> { writeParent(writer, build); writeProjectCoordinates(writer, settings); writePackaging(writer, settings); writeProjectName(writer, settings); writeProperties(writer, build.properties()); writeDependencies(writer, build); writeDependencyManagement(writer, build); writeBuild(writer, build); writeRepositories(writer, build); writeDistributionManagement(writer, distributionManagement); }); }'","output":"public void writeTo(IndentingWriter writer, MavenBuild build) { MavenBuildSettings settings = build.getSettings(); writeProject(writer, () -> { writeParent(writer, build); writeProjectCoordinates(writer, settings); writePackaging(writer, settings); writeProjectName(writer, settings); writeProperties(writer, build.properties()); writeDependencies(writer, build); writeDependencyManagement(writer, build); writeBuild(writer, build); writeRepositories(writer, build); writeDistributionManagement(writer, build); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'bit nicer assertThatThrownBy'\nThe code is: 'public void test_load() throws Exception { int[] loadRefOpcodes = new int[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (int loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); try { <START> programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE); <END> \/\/ bit nicer assertThatThrownBy fail(\"No sv indexed should not generate a program state for \"); } catch (NullPointerException npe) { assertThat(npe).hasMessage(\"Loading a symbolic value unindexed\"); } } }'","output":"public void test_load() throws Exception { int[] loadRefOpcodes = new int[] {Opcodes.ILOAD, Opcodes.LLOAD, Opcodes.FLOAD, Opcodes.DLOAD, Opcodes.ALOAD}; for (int loadRefOpcode : loadRefOpcodes) { SymbolicValue loadRef = new SymbolicValue(); ProgramState programState = execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE.put(0, loadRef)); assertThat(programState.peekValue()).isEqualTo(loadRef); assertThatThrownBy(() -> execute(new Instruction(loadRefOpcode, 0), ProgramState.EMPTY_STATE)).hasMessage(\"Loading a symbolic value unindexed\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please move this clearProperty call @After guarantee cleanup if test fails'\nThe code is: 'public void checkRegularExecution() { System.setProperty(\"kie.maven.offline.force\", \"false\"); final M2ServletContextListener listener = spy(new M2ServletContextListener()); final ServletContextEvent contextEvent = mock(ServletContextEvent.class); final ServletContext servletContext = mock(ServletContext.class); when(servletContext.getRealPath(any())).thenReturn(\".\"); when(contextEvent.getServletContext()).thenReturn(servletContext); listener.contextInitialized(contextEvent); <START> System.clearProperty(\"kie.maven.offline.force\"); <END> \/\/ Please move this clearProperty call @After guarantee cleanup if test fails verify(listener, times(0)).deployJarsFromWar(any()); }'","output":"public void checkRegularExecution() { System.setProperty(\"kie.maven.offline.force\", \"false\"); final M2ServletContextListener listener = spy(new M2ServletContextListener()); final ServletContextEvent contextEvent = mock(ServletContextEvent.class); final ServletContext servletContext = mock(ServletContext.class); when(servletContext.getRealPath(any())).thenReturn(\".\"); when(contextEvent.getServletContext()).thenReturn(servletContext); listener.contextInitialized(contextEvent); verify(listener, times(0)).deployJarsFromWar(any()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Null check'\nThe code is: 'public CloseableIterable<RyaStatement> query(final BatchRyaQuery batchRyaQuery) throws RyaDAOException { <START> final Map<RyaStatement, BindingSet> queries = new HashMap<>(); <END> \/\/ Null check for (final RyaStatement stmt : batchRyaQuery.getQueries()) { queries.put(stmt, new MapBindingSet()); } Iterator<RyaStatement> iterator = new RyaStatementCursorIterator(queryWithBindingSet(queries.entrySet(), getConf())); return CloseableIterables.wrap((Iterable<RyaStatement>) () -> iterator); }'","output":"public CloseableIterable<RyaStatement> query(final BatchRyaQuery batchRyaQuery) throws RyaDAOException { Preconditions.checkNotNull(batchRyaQuery); final Map<RyaStatement, BindingSet> queries = new HashMap<>(); for (final RyaStatement stmt : batchRyaQuery.getQueries()) { queries.put(stmt, new MapBindingSet()); } Iterator<RyaStatement> iterator = new RyaStatementCursorIterator(queryWithBindingSet(queries.entrySet(), getConf())); return CloseableIterables.wrap((Iterable<RyaStatement>) () -> iterator); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'be: java helper.waitForRegistrationAtServerSide(1);'\nThe code is: 'public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); <START> helper.waitForRegistrationAtServerSide(1000); <END> \/\/ be: java helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }'","output":"public void registered_device_with_x509cert_to_server_with_x509cert_rootca_certificate_usage_taa_intca_given() throws NonUniqueSecurityInfoException, CertificateEncodingException { helper.createServerWithX509Cert(helper.serverIntX509CertChain, helper.serverIntPrivateKeyFromCert, helper.trustedCertificates, true); helper.server.start(); helper.setEndpointNameFromX509(helper.clientX509Cert); helper.createX509CertClient(new X509Certificate[] { helper.clientX509Cert }, helper.clientPrivateKeyFromCert, helper.clientTrustStore, helper.serverIntX509CertChain[1], CertificateUsage.TRUST_ANCHOR_ASSERTION); helper.getSecurityStore().add(SecurityInfo.newX509CertInfo(helper.getCurrentEndpoint())); helper.assertClientNotRegisterered(); helper.client.start(); helper.waitForRegistrationAtServerSide(1); assertNotNull(helper.getCurrentRegistration()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List.of (master only)'\nThe code is: 'public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, \"Task assigned to user1\", <START> Collections.singletonList(user1.getName()), false, null, null, null, null, null); <END> \/\/ List.of (master only) session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }'","output":"public void testUserTasksAsUser() { DocumentModel document = getDocument(); assertNotNull(document); taskService.createTask(session, administrator, document, \"Task assigned to user1\", List.of(user1.getName()), false, null, null, null, null, null); session.save(); List<Task> tasks = taskService.getTaskInstances(document, user1, session); assertNotNull(tasks); assertEquals(1, tasks.size()); Task task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); List<String> pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session); assertNotNull(tasks); assertEquals(1, tasks.size()); try (CloseableCoreSession session1 = coreFeature.openCoreSession(user1.getName())) { tasks = taskService.getTaskInstances(document, user1, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session1); assertNotNull(tasks); assertEquals(1, tasks.size()); } try (CloseableCoreSession session2 = coreFeature.openCoreSession(user2.getName())) { tasks = taskService.getTaskInstances(document, user1, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); task = tasks.get(0); assertEquals(\"Task assigned to user1\", task.getName()); pooledActorIds = task.getActors(); assertEquals(1, pooledActorIds.size()); assertTrue(pooledActorIds.contains(user1.getName())); tasks = taskService.getTaskInstances(document, (NuxeoPrincipal) null, session2); assertNotNull(tasks); assertEquals(1, tasks.size()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'random a member variable of this class instead of constructed in methods'\nThe code is: 'private void induceDeleteFailure(int count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); <START> Random random = new Random(); <END> \/\/ random a member variable of this class instead of constructed in methods for (int i = 0; i < count; i++) { int nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }'","output":"private void induceDeleteFailure(int count, ServerErrorCode errorCode) { List<Integer> hostPorts = (ArrayList<Integer>) exceptionHostPorts.clone(); for (int i = 0; i < count; i++) { int nextRandom = random.nextInt(hostPorts.size()); MockDataNode mockDataNode = MockConnectionPool.mockCluster.getMockDataNode(host, hostPorts.get(nextRandom)); mockDataNode.setDeleteException(errorCode); hostPorts.remove(nextRandom); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'expected assertEquals(4096, connection.getChunkLength());'\nThe code is: 'public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(\"POST\"); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(\"file.txt\"); HttpContent content = new InputStreamContent(\"text\/plain\", is); request.setStreamingContent(content); request.setContentEncoding(\"gzip\"); request.execute(); <START> assertEquals(connection.getChunkLength(), 4096); <END> \/\/ expected assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(\"Content-Length\")); }'","output":"public void testChunkedLengthSet() throws Exception { MockHttpURLConnection connection = new MockHttpURLConnection(new URL(HttpTesting.SIMPLE_URL)); connection.setRequestMethod(\"POST\"); NetHttpRequest request = new NetHttpRequest(connection); InputStream is = NetHttpRequestTest.class.getClassLoader().getResourceAsStream(\"file.txt\"); HttpContent content = new InputStreamContent(\"text\/plain\", is); request.setStreamingContent(content); request.setContentEncoding(\"gzip\"); request.execute(); assertEquals(4096, connection.getChunkLength()); assertNull(request.getRequestProperty(\"Content-Length\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'try case consistent other endpoint, camelCase suggestion species, assembly, response)).toUri().toString(), \"coreVariant\");'\nThe code is: 'public ResponseEntity getAnnotations(@PathVariable(\"variantCoreString\") String variantCoreString, @RequestParam(name = \"species\") String species, @RequestParam(name = \"assembly\") String assembly, @RequestParam(name = \"annot-vep-version\", required = false) String annotationVepVersion, @RequestParam(name = \"annot-vep-cache-version\", required = false) String annotationVepCacheVersion, HttpServletResponse response) throws IllegalArgumentException { try { checkParameters(variantCoreString, annotationVepVersion, annotationVepCacheVersion, species, assembly); } catch (IllegalArgumentException e) { return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST); } MultiMongoDbFactory.setDatabaseNameForCurrentThread(DBAdaptorConnector.getDBName(species + \"_\" + assembly)); Optional<VariantWithSamplesAndAnnotation> variantEntity; try { variantEntity = getVariantByCoordinatesAndAnnotationVersion(variantCoreString, annotationVepVersion, annotationVepCacheVersion); } catch (AnnotationMetadataNotFoundException | IllegalArgumentException ex) { return new ResponseEntity(ex.getMessage(), HttpStatus.BAD_REQUEST); } if (!variantEntity.isPresent() || variantEntity.get().getAnnotation() == null) { return new ResponseEntity(null, HttpStatus.NOT_FOUND); } Link coreVariantLink = new Link(linkTo(methodOn(VariantWSServerV2.class).getCoreInfo(variantCoreString, <START> species, assembly, response)).toUri().toString(), \"CoreVariant\"); <END> \/\/ try case consistent other endpoint, camelCase suggestion species, assembly, response)).toUri().toString(), \"coreVariant\"); return new ResponseEntity(new Resource<>(variantEntity.get().getAnnotation(), coreVariantLink), HttpStatus.OK); }'","output":"public ResponseEntity getAnnotations(@PathVariable(\"variantCoreString\") String variantCoreString, @RequestParam(name = \"species\") String species, @RequestParam(name = \"assembly\") String assembly, @RequestParam(name = \"annot-vep-version\", required = false) String annotationVepVersion, @RequestParam(name = \"annot-vep-cache-version\", required = false) String annotationVepCacheVersion, HttpServletResponse response) throws IllegalArgumentException { try { checkParameters(variantCoreString, annotationVepVersion, annotationVepCacheVersion, species, assembly); } catch (IllegalArgumentException e) { return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST); } MultiMongoDbFactory.setDatabaseNameForCurrentThread(DBAdaptorConnector.getDBName(species + \"_\" + assembly)); Optional<VariantWithSamplesAndAnnotation> variantEntity; try { variantEntity = getVariantByCoordinatesAndAnnotationVersion(variantCoreString, annotationVepVersion, annotationVepCacheVersion); } catch (AnnotationMetadataNotFoundException | IllegalArgumentException ex) { return new ResponseEntity(ex.getMessage(), HttpStatus.BAD_REQUEST); } if (!variantEntity.isPresent() || variantEntity.get().getAnnotation() == null) { return new ResponseEntity(null, HttpStatus.NOT_FOUND); } Link coreVariantLink = new Link(linkTo(methodOn(VariantWSServerV2.class).getCoreInfo(variantCoreString, species, assembly, response)).toUri().toString(), \"coreVariant\"); return new ResponseEntity(new Resource<>(variantEntity.get().getAnnotation(), coreVariantLink), HttpStatus.OK); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add message \"renewer in \" + ids'\nThe code is: 'public void testSessionTokenIdentifierRoundTripNoRenewer() throws Throwable { SessionTokenIdentifier id = new SessionTokenIdentifier( SESSION_TOKEN_KIND, new Text(), null, landsatUri, new MarshalledCredentials(\"a\", \"b\", \"c\"), new EncryptionSecrets(), \"\"); SessionTokenIdentifier result = S3ATestUtils.roundTrip(id, null); String ids = id.toString(); assertEquals(\"URI in \" + ids, id.getUri(), result.getUri()); assertEquals(\"credentials in \" + ids, id.getMarshalledCredentials(), result.getMarshalledCredentials()); <START> assertEquals(new Text(), id.getRenewer()); <END> \/\/ add message \"renewer in \" + ids }'","output":"public void testSessionTokenIdentifierRoundTripNoRenewer() throws Throwable { SessionTokenIdentifier id = new SessionTokenIdentifier( SESSION_TOKEN_KIND, new Text(), null, landsatUri, new MarshalledCredentials(\"a\", \"b\", \"c\"), new EncryptionSecrets(), \"\"); SessionTokenIdentifier result = S3ATestUtils.roundTrip(id, null); String ids = id.toString(); assertEquals(\"URI in \" + ids, id.getUri(), result.getUri()); assertEquals(\"credentials in \" + ids, id.getMarshalledCredentials(), result.getMarshalledCredentials()); assertEquals(\"renewer in \" + ids, new Text(), id.getRenewer()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"next\"'\nThe code is: 'protected void performDefaults() { for (int i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore <START> nextStore = <END> \/\/ \"next\" (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(nextStore.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (int i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (int i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }'","output":"protected void performDefaults() { for (int i= 0; i < fCheckBoxes.size(); i++) { Button button= fCheckBoxes.get(i); String key= (String) button.getData(); IPreferenceStore buttonPreferenceStore = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(buttonPreferenceStore.getDefaultBoolean(key)); } IPreferenceStore store= getPreferenceStore(); for (int i= 0; i < fRadioButtons.size(); i++) { Button button= fRadioButtons.get(i); String[] info= (String[]) button.getData(); button.setSelection(info[1].equals(store.getDefaultString(info[0]))); } for (int i= 0; i < fTextControls.size(); i++) { Text text= fTextControls.get(i); String key= (String) text.getData(); text.setText(store.getDefaultString(key)); } super.performDefaults(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Integer.valueOf(100) purely for consistency reasons'\nThe code is: 'public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(\"JpaOutboundGatewayParserTests.xml\", getClass(), \"updatingJpaOutboundGateway\"); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, \"inputChannel\", AbstractMessageChannel.class); assertEquals(\"in\", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, \"handler\", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, \"gatewayType\", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, \"messagingTemplate.sendTimeout\", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, \"requiresReply\", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, \"handler.jpaExecutor\", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, \"entityClass\", Class.class); assertEquals(\"org.springframework.integration.jpa.test.entity.StudentDomain\", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, \"jpaOperations\", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, \"usePayloadAsParameterSource\", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, \"order\", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, \"persistMode\", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); <START> assertEquals(new Integer(100), TestUtils.getPropertyValue(jpaExecutor, \"flushSize\", Integer.class)); <END> \/\/ Integer.valueOf(100) purely for consistency reasons assertTrue(TestUtils.getPropertyValue(jpaExecutor, \"cleanOnFlush\", Boolean.class)); }'","output":"public void testUpdatingJpaOutboundGatewayParser() throws Exception { setUp(\"JpaOutboundGatewayParserTests.xml\", getClass(), \"updatingJpaOutboundGateway\"); final AbstractMessageChannel inputChannel = TestUtils.getPropertyValue(this.consumer, \"inputChannel\", AbstractMessageChannel.class); assertEquals(\"in\", inputChannel.getComponentName()); final JpaOutboundGateway jpaOutboundGateway = TestUtils.getPropertyValue(this.consumer, \"handler\", JpaOutboundGateway.class); final OutboundGatewayType gatewayType = TestUtils.getPropertyValue(jpaOutboundGateway, \"gatewayType\", OutboundGatewayType.class); assertEquals(OutboundGatewayType.UPDATING, gatewayType); long sendTimeout = TestUtils.getPropertyValue(jpaOutboundGateway, \"messagingTemplate.sendTimeout\", Long.class); assertEquals(100, sendTimeout); assertFalse(TestUtils.getPropertyValue(jpaOutboundGateway, \"requiresReply\", Boolean.class)); final JpaExecutor jpaExecutor = TestUtils.getPropertyValue(this.consumer, \"handler.jpaExecutor\", JpaExecutor.class); assertNotNull(jpaExecutor); final Class<?> entityClass = TestUtils.getPropertyValue(jpaExecutor, \"entityClass\", Class.class); assertEquals(\"org.springframework.integration.jpa.test.entity.StudentDomain\", entityClass.getName()); final JpaOperations jpaOperations = TestUtils.getPropertyValue(jpaExecutor, \"jpaOperations\", JpaOperations.class); assertNotNull(jpaOperations); final Boolean usePayloadAsParameterSource = TestUtils.getPropertyValue(jpaExecutor, \"usePayloadAsParameterSource\", Boolean.class); assertTrue(usePayloadAsParameterSource); final Integer order = TestUtils.getPropertyValue(jpaOutboundGateway, \"order\", Integer.class); assertEquals(Integer.valueOf(2), order); final PersistMode persistMode = TestUtils.getPropertyValue(jpaExecutor, \"persistMode\", PersistMode.class); assertEquals(PersistMode.PERSIST, persistMode); assertEquals(Integer.valueOf(100), TestUtils.getPropertyValue(jpaExecutor, \"flushSize\", Integer.class)); assertTrue(TestUtils.getPropertyValue(jpaExecutor, \"clearOnFlush\", Boolean.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove catch block'\nThe code is: 'public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); <START> } catch (Exception e) { <END> \/\/ remove catch block fail(\"EXECUTE UPGRADE should not fail\"); } finally { conn.close(); } }'","output":"public void testUpgradeNotAllowed() throws Exception { setOldTimestampToInduceUpgrade = true; SystemCatalogCreationOnConnectionIT.PhoenixSysCatCreationTestingDriver driver = firstConnectionNSMappingServerEnabledClientEnabled(); driver.resetCQS(); Properties clientProps = getClientProperties(true, true); UpgradeUtil.doNotUpgradeOnFirstConnection(clientProps); setOldTimestampToInduceUpgrade = false; try { driver.getConnectionQueryServices(getJdbcUrl(), clientProps); } catch (Exception e) { assertTrue(e instanceof UpgradeRequiredException); } assertEquals(hbaseTables, getHBaseTables()); assertEquals(1, countUpgradeAttempts); assertEquals(0, actualSysCatUpgrades); Connection conn = driver.getConnectionQueryServices(getJdbcUrl(), new Properties()).connect(getJdbcUrl(), new Properties()); try { conn.createStatement().execute(EXECUTE_UPGRADE_COMMAND); assertEquals(1, actualSysCatUpgrades); } finally { conn.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'orElse(\"failed\")'\nThe code is: 'public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> \"timeout\", new Duration(0, MILLISECONDS), executorService); <START> assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).get(), \"timeout\"); <END> \/\/ orElse(\"failed\") assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }'","output":"public void testListenableTimeout() throws Exception { SettableFuture<String> rootFuture = SettableFuture.create(); ListenableFuture<String> timeoutFuture = addTimeout(rootFuture, () -> \"timeout\", new Duration(0, MILLISECONDS), executorService); assertEquals(tryGetFutureValue(timeoutFuture, 10, SECONDS).orElse(\"failed\"), \"timeout\"); assertTrue(timeoutFuture.isDone()); assertFalse(timeoutFuture.isCancelled()); assertFailure(() -> rootFuture.get(10, SECONDS), e -> assertInstanceOf(e, CancellationException.class)); assertTrue(rootFuture.isDone()); assertTrue(rootFuture.isCancelled()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'breaks format'\nThe code is: 'public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"Record {\"); sb.append(\"id = \").append(id).append(\", \"); sb.append(\"title = \").append(title).append(\", \"); sb.append(\"type = \"); switch (type) { case TYPE_EXPENSE: sb.append(\"expense\"); break; case TYPE_INCOME: sb.append(\"income\"); break; default: sb.append(\"unknown\"); break; } sb.append(\", \"); <START> sb.append(\"date = \").append(time).append(\", \"); <END> \/\/ breaks format sb.append(\"category = \").append(category).append(\", \"); sb.append(\"price = \").append(price).append(\", \"); sb.append(\"account = \").append(account).append(\", \"); sb.append(\"currency = \").append(currency).append(\", \"); sb.append(\"decimals = \").append(decimals); sb.append(\"}\"); return sb.toString(); }'","output":"public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"Record {\"); sb.append(\"id = \").append(id).append(\", \"); sb.append(\"title = \").append(title).append(\", \"); sb.append(\"type = \"); switch (type) { case TYPE_EXPENSE: sb.append(\"expense\"); break; case TYPE_INCOME: sb.append(\"income\"); break; default: sb.append(\"unknown\"); break; } sb.append(\", \"); sb.append(\"time = \").append(time).append(\", \"); sb.append(\"category = \").append(category).append(\", \"); sb.append(\"price = \").append(price).append(\", \"); sb.append(\"account = \").append(account).append(\", \"); sb.append(\"currency = \").append(currency).append(\", \"); sb.append(\"decimals = \").append(decimals); sb.append(\"}\"); return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'delete'\nThe code is: 'public ProjectHandleResolverDTO mapProjectHandleResolver(IProjectHandleResolver resolver) { ProjectHandleResolverDTO dto = new ProjectHandleResolverDTO(); dto.setDescription(resolver.getDescription()); dto.setHandleExample(resolver.getHandleExample()); dto.setHandlePattern(resolver.getHandlePattern()); dto.setId(resolver.getId()); dto.setProjectName(resolver.getProjectName()); dto.setProjectUrl(resolver.getProjectUrl()); dto.setResolvedHandlePattern(resolver.getResolvedHandlePattern()); dto.setUsername(resolver.getUsername()); dto.setResolvedHandleExample(resolver.getResolvedHandleExample()); dto.setValidation(resolver.getValidation().toString()); <START> System.out.println(resolver.getValidation().toString()); <END> \/\/ delete return dto; }'","output":"public ProjectHandleResolverDTO mapProjectHandleResolver(IProjectHandleResolver resolver) { ProjectHandleResolverDTO dto = new ProjectHandleResolverDTO(); dto.setDescription(resolver.getDescription()); dto.setHandleExample(resolver.getHandleExample()); dto.setHandlePattern(resolver.getHandlePattern()); dto.setId(resolver.getId()); dto.setProjectName(resolver.getProjectName()); dto.setProjectUrl(resolver.getProjectUrl()); dto.setResolvedHandlePattern(resolver.getResolvedHandlePattern()); dto.setUsername(resolver.getUsername()); dto.setResolvedHandleExample(resolver.getResolvedHandleExample()); dto.setValidation(resolver.getValidation()); return dto; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'spare this null check'\nThe code is: 'private void comparePlanTree(AbstractPlanNode calcitePlanNode, AbstractPlanNode voltdbPlanNode, Map<String, String> ignoreMap) { PlanNodeTree calcitePlanTree = new PlanNodeTree(calcitePlanNode); PlanNodeTree voltdbPlanTree = new PlanNodeTree(voltdbPlanNode); String calcitePlanTreeJSON = calcitePlanTree.toJSONString(); String voltdbPlanTreeJSON = voltdbPlanTree.toJSONString(); <START> if (ignoreMap != null) { <END> \/\/ spare this null check for (Map.Entry<String, String> ignore : ignoreMap.entrySet()) { calcitePlanTreeJSON = calcitePlanTreeJSON.replace(ignore.getKey(), ignore.getValue()); } } assertEquals(voltdbPlanTreeJSON, calcitePlanTreeJSON); }'","output":"private void comparePlanTree(AbstractPlanNode calcitePlanNode, AbstractPlanNode voltdbPlanNode, Map<String, String> ignoreMap) { PlanNodeTree calcitePlanTree = new PlanNodeTree(calcitePlanNode); PlanNodeTree voltdbPlanTree = new PlanNodeTree(voltdbPlanNode); String calcitePlanTreeJSON = calcitePlanTree.toJSONString(); String voltdbPlanTreeJSON = voltdbPlanTree.toJSONString(); for (Map.Entry<String, String> ignore : ignoreMap.entrySet()) { calcitePlanTreeJSON = calcitePlanTreeJSON.replace(ignore.getKey(), ignore.getValue()); } assertEquals(voltdbPlanTreeJSON, calcitePlanTreeJSON); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'hiding issue'\nThe code is: 'public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); <START> assertTrue(arrival.await(20, TimeUnit.SECONDS)); <END> \/\/ hiding issue installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }'","output":"public void testBothOwnersSuspected(Method m) throws ExecutionException, InterruptedException { initAndCheck(m); CountDownLatch arrival = new CountDownLatch(2); CountDownLatch release = new CountDownLatch(1); AtomicInteger thrown = new AtomicInteger(); AtomicInteger retried = new AtomicInteger(); cache(0).getAdvancedCache().getAsyncInterceptorChain().addInterceptorAfter(new CheckOTEInterceptor(thrown, retried), StateTransferInterceptor.class); cache(1).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); cache(2).getAdvancedCache().getAsyncInterceptorChain().addInterceptor(new DelayingInterceptor(arrival, release), 0); Future<Object> future = fork(() -> cache(0).get(key)); assertTrue(arrival.await(10, TimeUnit.SECONDS)); installNewView(cache(0), cache(0)); assertNull(future.get()); assertEquals(1, thrown.get()); assertEquals(0, retried.get()); release.countDown(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Generics: Iterable<Object>'\nThe code is: 'public static void toStringBuilder(Object object, StringBuilder builder) { if (object == null) { return; } if (object instanceof Iterable) { <START> toStringBuilder((Iterable) object, <END> \/\/ Generics: Iterable<Object> builder); } else if (object instanceof Object[]) { toStringBuilder(Arrays.asList((Object[]) object), builder); } else if (object instanceof Map) { toStringBuilder((Map<String, Object>) object, builder); } else { builder.append(object.toString()); } }'","output":"public static void toStringBuilder(Object object, StringBuilder builder) { if (object == null) { return; } if (object instanceof Iterable) { toStringBuilder((Iterable<Object>) object, builder); } else if (object instanceof Object[]) { toStringBuilder(Arrays.asList((Object[]) object), builder); } else if (object instanceof Map) { toStringBuilder((Map<String, Object>) object, builder); } else { builder.append(object.toString()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplified streamName = getPhysicalName().orElse(getStreamId());'\nThe code is: 'public Map<String, String> toConfig() { HashMap<String, String> configs = new HashMap<>(super.toConfig()); String streamName; <START> if (getPhysicalName().isPresent()) { <END> \/\/ simplified streamName = getPhysicalName().orElse(getStreamId()); streamName = getPhysicalName().get(); } else { streamName = getStreamId(); } String systemName = getSystemName(); consumerAutoOffsetResetOptional.ifPresent(autoOffsetReset -> configs.put(String.format(CONSUMER_AUTO_OFFSET_RESET_CONFIG_KEY, systemName, streamName), autoOffsetReset)); consumerFetchMessageMaxBytesOptional.ifPresent(fetchMessageMaxBytes -> configs.put(String.format(CONSUMER_FETCH_MESSAGE_MAX_BYTES_CONFIG_KEY, systemName, streamName), Long.toString(fetchMessageMaxBytes))); return configs; }'","output":"public Map<String, String> toConfig() { HashMap<String, String> configs = new HashMap<>(super.toConfig()); String streamName = getPhysicalName().orElse(getStreamId()); String systemName = getSystemName(); consumerAutoOffsetResetOptional.ifPresent(autoOffsetReset -> configs.put(String.format(CONSUMER_AUTO_OFFSET_RESET_CONFIG_KEY, systemName, streamName), autoOffsetReset)); consumerFetchMessageMaxBytesOptional.ifPresent(fetchMessageMaxBytes -> configs.put(String.format(CONSUMER_FETCH_MESSAGE_MAX_BYTES_CONFIG_KEY, systemName, streamName), Long.toString(fetchMessageMaxBytes))); return configs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove else clause (but code block) remove level of nesting'\nThe code is: 'public Metric(Class<?> tableClass, String fieldName, AggregationDictionary dictionary) { super(tableClass, fieldName, dictionary); com.yahoo.elide.datastores.aggregation.annotation.Metric metric = dictionary.getAttributeOrRelationAnnotation( tableClass, com.yahoo.elide.datastores.aggregation.annotation.Metric.class, fieldName); if (metric == null) { throw new IllegalArgumentException(getId() + \" is not a metric field\"); } else { try { this.metricFunction = metric.function().newInstance(); <START> metricFunction.setName(getId() + \"[\" + metricFunction.getName() + \"]\"); <END> \/\/ remove else clause (but code block) remove level of nesting metricFunction.setExpression(String.format( metricFunction.getExpression(), dictionary.getColumnName(tableClass, fieldName))); } catch (InstantiationException | IllegalAccessException e) { throw new IllegalArgumentException(\"Can't initialize function for metric \" + getId()); } } }'","output":"public Metric(Class<?> tableClass, String fieldName, AggregationDictionary dictionary) { super(tableClass, fieldName, dictionary); com.yahoo.elide.datastores.aggregation.annotation.Metric metric = dictionary.getAttributeOrRelationAnnotation( tableClass, com.yahoo.elide.datastores.aggregation.annotation.Metric.class, fieldName); try { this.metricFunction = metric.function().newInstance(); metricFunction.setName(getId() + \"[\" + metricFunction.getName() + \"]\"); metricFunction.setExpression(String.format( metricFunction.getExpression(), dictionary.getColumnName(tableClass, fieldName))); } catch (InstantiationException | IllegalAccessException e) { throw new IllegalArgumentException(\"Can't initialize function for metric \" + getId()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'VmGuestContainerListModel is longer generic need TypeLiteral anymore. A simple bind(VmGuestContainerListModel.class).in(Singleton.class) is sufficient'\nThe code is: 'void bindModels() { bind(AdElementListModel.class).to(UserPortalAdElementListModel.class); bind(UserPortalBasicListModel.class).in(Singleton.class); bind(VmBasicDiskListModel.class).in(Singleton.class); bind(UserPortalListModel.class).in(Singleton.class); bind(VmGeneralModel.class).in(Singleton.class); bind(PoolGeneralModel.class).in(Singleton.class); bind(VmInterfaceListModel.class).in(Singleton.class); bind(VmDiskListModel.class).in(Singleton.class); bind(PoolDiskListModel.class).in(Singleton.class); bind(UserPortalVmSnapshotListModel.class).in(Singleton.class); bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>(){}).in(Singleton.class); bind(UserPortalVmEventListModel.class).in(Singleton.class); bind(new TypeLiteral<VmAppListModel<VM>>() {}).in(Singleton.class); <START> bind(new TypeLiteral<VmGuestContainerListModel>() {}).in(Singleton.class); <END> \/\/ VmGuestContainerListModel is longer generic need TypeLiteral anymore. A simple bind(VmGuestContainerListModel.class).in(Singleton.class) is sufficient bind(VmMonitorModel.class).in(Singleton.class); bind(PoolInterfaceListModel.class).in(Singleton.class); bind(VmGuestInfoModel.class).in(Singleton.class); bind(UserPortalTemplateListModel.class).in(Singleton.class); bind(TemplateGeneralModel.class).in(Singleton.class); bind(TemplateInterfaceListModel.class).in(Singleton.class); bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>(){}).in(Singleton.class); bind(UserPortalTemplateDiskListModel.class).in(Singleton.class); bind(UserPortalTemplateEventListModel.class).in(Singleton.class); bind(ResourcesModel.class).in(Singleton.class); }'","output":"void bindModels() { bind(AdElementListModel.class).to(UserPortalAdElementListModel.class); bind(UserPortalBasicListModel.class).in(Singleton.class); bind(VmBasicDiskListModel.class).in(Singleton.class); bind(UserPortalListModel.class).in(Singleton.class); bind(VmGeneralModel.class).in(Singleton.class); bind(PoolGeneralModel.class).in(Singleton.class); bind(VmInterfaceListModel.class).in(Singleton.class); bind(VmDiskListModel.class).in(Singleton.class); bind(PoolDiskListModel.class).in(Singleton.class); bind(UserPortalVmSnapshotListModel.class).in(Singleton.class); bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>(){}).in(Singleton.class); bind(UserPortalVmEventListModel.class).in(Singleton.class); bind(new TypeLiteral<VmAppListModel<VM>>() {}).in(Singleton.class); bind(VmGuestContainerListModel.class).in(Singleton.class); bind(VmMonitorModel.class).in(Singleton.class); bind(PoolInterfaceListModel.class).in(Singleton.class); bind(VmGuestInfoModel.class).in(Singleton.class); bind(UserPortalTemplateListModel.class).in(Singleton.class); bind(TemplateGeneralModel.class).in(Singleton.class); bind(TemplateInterfaceListModel.class).in(Singleton.class); bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>(){}).in(Singleton.class); bind(UserPortalTemplateDiskListModel.class).in(Singleton.class); bind(UserPortalTemplateEventListModel.class).in(Singleton.class); bind(ResourcesModel.class).in(Singleton.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'new TajoRuntimeException(new UnsupportedDataType(...)'\nThe code is: 'public static Class<? extends Datum> getDatumClass(Type type) { switch (type) { case BOOLEAN: return BooleanDatum.class; case INT2: return Int2Datum.class; case INT4: return Int4Datum.class; case INT8: return Int8Datum.class; case FLOAT4: return Float4Datum.class; case FLOAT8: return Float8Datum.class; case CHAR: return CharDatum.class; case TEXT: return TextDatum.class; case TIMESTAMP: return TimestampDatum.class; case INTERVAL: return IntervalDatum.class; case DATE: return DateDatum.class; case TIME: return TimeDatum.class; case BIT: return BitDatum.class; case BLOB: return BlobDatum.class; case INET4: return Inet4Datum.class; case ANY: return AnyDatum.class; case NULL_TYPE: return NullDatum.class; default: <START> throw new TajoRuntimeException(Errors.ResultCode.UNSUPPORTED_DATATYPE, type.name()); <END> \/\/ new TajoRuntimeException(new UnsupportedDataType(...) } }'","output":"public static Class<? extends Datum> getDatumClass(Type type) { switch (type) { case BOOLEAN: return BooleanDatum.class; case INT2: return Int2Datum.class; case INT4: return Int4Datum.class; case INT8: return Int8Datum.class; case FLOAT4: return Float4Datum.class; case FLOAT8: return Float8Datum.class; case CHAR: return CharDatum.class; case TEXT: return TextDatum.class; case TIMESTAMP: return TimestampDatum.class; case INTERVAL: return IntervalDatum.class; case DATE: return DateDatum.class; case TIME: return TimeDatum.class; case BIT: return BitDatum.class; case BLOB: return BlobDatum.class; case INET4: return Inet4Datum.class; case ANY: return AnyDatum.class; case NULL_TYPE: return NullDatum.class; default: throw new TajoRuntimeException(new UnsupportedDataTypeException(type.name())); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'other stores registration done in provider... is this different'\nThe code is: 'public XAStore(Class<K> keyType, Class<V> valueType, Store<K, SoftLock<V>> underlyingStore, TransactionManagerWrapper transactionManagerWrapper, TimeSource timeSource, Journal<K> journal, String uniqueXAResourceId, StatisticsService statisticsService) { super(keyType, valueType, true, statisticsService); this.underlyingStore = underlyingStore; this.transactionManagerWrapper = transactionManagerWrapper; this.timeSource = timeSource; this.journal = journal; this.uniqueXAResourceId = uniqueXAResourceId; this.transactionContextFactory = new XATransactionContextFactory<>(timeSource); this.recoveryXaResource = new EhcacheXAResource<>(underlyingStore, journal, transactionContextFactory); this.eventSourceWrapper = new StoreEventSourceWrapper<>(underlyingStore.getStoreEventSource()); <START> this.statisticsService.registerWithParent(underlyingStore, this); <END> \/\/ other stores registration done in provider... is this different }'","output":"public XAStore(Class<K> keyType, Class<V> valueType, Store<K, SoftLock<V>> underlyingStore, TransactionManagerWrapper transactionManagerWrapper, TimeSource timeSource, Journal<K> journal, String uniqueXAResourceId, StatisticsService statisticsService) { super(keyType, valueType, true, statisticsService); this.underlyingStore = underlyingStore; this.transactionManagerWrapper = transactionManagerWrapper; this.timeSource = timeSource; this.journal = journal; this.uniqueXAResourceId = uniqueXAResourceId; this.transactionContextFactory = new XATransactionContextFactory<>(timeSource); this.recoveryXaResource = new EhcacheXAResource<>(underlyingStore, journal, transactionContextFactory); this.eventSourceWrapper = new StoreEventSourceWrapper<>(underlyingStore.getStoreEventSource()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move new test'\nThe code is: 'public void shouldScheduleDailyReportJob() throws SchedulerException { ebodacScheduler.unscheduleDailyReportJob(); <START> verify(motechSchedulerService).safeUnscheduleAllJobs(EbodacConstants.DAILY_REPORT_EVENT); <END> \/\/ move new test DateTime startDate = DateTime.parse(DateTime.now().plusDays(1).toString(DateTimeFormat.forPattern(EbodacConstants.REPORT_DATE_FORMAT)) + EbodacConstants.DAILY_REPORT_EVENT_START_HOUR, DateTimeFormat.forPattern(EbodacConstants.REPORT_START_DATE_FORMAT)); ebodacScheduler.scheduleDailyReportJob(startDate); Period period = Period.days(1); Map<String, Object> eventParameters = new HashMap<>(); eventParameters.put(EbodacConstants.DAILY_REPORT_EVENT_START_DATE, startDate); MotechEvent event = new MotechEvent(EbodacConstants.DAILY_REPORT_EVENT, eventParameters); RepeatingPeriodSchedulableJob job = new RepeatingPeriodSchedulableJob(event, startDate.toDate(), null, period, true); verify(motechSchedulerService).safeScheduleRepeatingPeriodJob(job); }'","output":"public void shouldScheduleDailyReportJob() { DateTime startDate = DateTime.parse(DateTime.now().plusDays(1).toString(DateTimeFormat.forPattern(EbodacConstants.REPORT_DATE_FORMAT)) + EbodacConstants.DAILY_REPORT_EVENT_START_HOUR, DateTimeFormat.forPattern(EbodacConstants.REPORT_START_DATE_FORMAT)); ebodacScheduler.scheduleDailyReportJob(startDate); Period period = Period.days(1); Map<String, Object> eventParameters = new HashMap<>(); eventParameters.put(EbodacConstants.DAILY_REPORT_EVENT_START_DATE, startDate); MotechEvent event = new MotechEvent(EbodacConstants.DAILY_REPORT_EVENT, eventParameters); RepeatingPeriodSchedulableJob job = new RepeatingPeriodSchedulableJob(event, startDate.toDate(), null, period, true); verify(motechSchedulerService).safeScheduleRepeatingPeriodJob(job); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simply return tid'\nThe code is: 'public @Nullable Integer getThreadOnCpuAtTime(int cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { int cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } <START> if (tid != null) { <END> \/\/ simply return tid return tid; } return null; }'","output":"public @Nullable Integer getThreadOnCpuAtTime(int cpu, long time) { ITmfStateSystem stateSystem = getStateSystem(); if (stateSystem == null) { return null; } Integer tid = null; try { int cpuQuark = stateSystem.getQuarkAbsolute(Integer.toString(cpu)); ITmfStateValue value = stateSystem.querySingleState(time, cpuQuark).getStateValue(); if (value.getType().equals(Type.INTEGER)) { tid = value.unboxInt(); } } catch (AttributeNotFoundException | StateSystemDisposedException e) { Activator.getDefault().logError(NonNullUtils.nullToEmptyString(e.getMessage()), e); } return tid; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I prefer formatter, message easily readable reviewing: java String.format(\"Split this %d characters long line (which is greater %d authorized).\", length, maximumLineLength)'\nThe code is: 'public void scanFile(XmlFile file) { int lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); int length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, <START> \"Split this \" + length + \" characters long line (which is greater than \" + maximumLineLength + \" authorized).\", <END> \/\/ I prefer formatter, message easily readable reviewing: java String.format(\"Split this %d characters long line (which is greater %d authorized).\", length, maximumLineLength) Collections.emptyList()); } lineNumber++; } }'","output":"public void scanFile(XmlFile file) { int lineNumber = 1; for (String line : Utils.splitLines(file.getContents())) { String trimLine = trimEndOfLine(line); int length = trimLine.length(); if (length > maximumLineLength) { XmlTextRange textRange = new XmlTextRange(lineNumber, 0, lineNumber, trimLine.length()); reportIssue(textRange, String.format(\"Split this %d characters long line (which is greater than %d authorized).\", length, maximumLineLength), Collections.emptyList()); } lineNumber++; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a try-with-resource pattern here'\nThe code is: 'private <T> List<T> testReflectDatumRead(String testType, byte[] bytes, T... entityObjs) throws IOException { ReflectDatumReader<T> datumReader = new ReflectDatumReader<>(); SeekableByteArrayInput avroInputStream = new SeekableByteArrayInput(bytes); DataFileReader<T> fileReader = new DataFileReader<>(avroInputStream, datumReader); Schema schema = fileReader.getSchema(); T record = null; List<T> records = new ArrayList<>(); while (fileReader.hasNext()) { records.add(fileReader.next(record)); } <START> fileReader.close(); <END> \/\/ a try-with-resource pattern here return records; }'","output":"private <T> List<T> testReflectDatumRead(String testType, byte[] bytes, T... entityObjs) throws IOException { ReflectDatumReader<T> datumReader = new ReflectDatumReader<>(); SeekableByteArrayInput avroInputStream = new SeekableByteArrayInput(bytes); List<T> records = new ArrayList<>(); try (DataFileReader<T> fileReader = new DataFileReader<>(avroInputStream, datumReader)) { Schema schema = fileReader.getSchema(); T record = null; while (fileReader.hasNext()) { records.add(fileReader.next(record)); } } return records; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is debug logging provide e.getMessage() instead re-add placeholder'\nThe code is: 'protected void openConnection() { if (!this.thing.getStatus().equals(ThingStatus.ONLINE)) { for (IpNode receiverNode : receiverNodes.keySet()) { Socket socket = receiverNodes.get(receiverNode); if (socket == null) { try { socket = new Socket(receiverNode.getAddressString(), receiverNode.getPort()); } catch (IOException e) { <START> logger.debug(\"Could not connect to {} in {}: \", receiverNode, this.thing.getUID(), e); <END> \/\/ this is debug logging provide e.getMessage() instead re-add placeholder updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"could not connect to \" + receiverNode.toString()); return; } } if (socket.isConnected()) { receiverNodes.put(receiverNode, socket); } else { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR); receiverNodes.put(receiverNode, null); return; } } updateStatus(ThingStatus.ONLINE); } }'","output":"protected void openConnection() { if (!this.thing.getStatus().equals(ThingStatus.ONLINE)) { for (IpNode receiverNode : receiverNodes.keySet()) { Socket socket = receiverNodes.get(receiverNode); if (socket == null) { try { socket = new Socket(receiverNode.getAddressString(), receiverNode.getPort()); } catch (IOException e) { logger.debug(\"Could not connect to {} in {}: {}\", receiverNode, this.thing.getUID(), e.getMessage()); updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"could not connect to \" + receiverNode.toString()); return; } } if (socket.isConnected()) { receiverNodes.put(receiverNode, socket); } else { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR); receiverNodes.put(receiverNode, null); return; } } updateStatus(ThingStatus.ONLINE); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant'\nThe code is: 'public void setupRoutes() { path(controllerBasePath(), () -> { before(\"\", mimeType, this::setContentType); <START> before(\"\/*\", mimeType, this::setContentType); <END> \/\/ redundant before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserOrGroupAdminUserAnd403); get(\"\", mimeType, this::index); post(\"\", mimeType, this::createOrUpdate); put(\"\", mimeType, this::createOrUpdate); exception(RuntimeException.class, (RuntimeException exception, Request request, Response response) -> { response.status(HttpStatus.UNPROCESSABLE_ENTITY.value()); response.body(MessageJson.create(exception.getMessage())); }); }); }'","output":"public void setupRoutes() { path(controllerBasePath(), () -> { before(\"\", mimeType, this::setContentType); before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserOrGroupAdminUserAnd403); get(\"\", mimeType, this::index); post(\"\", mimeType, this::createOrUpdate); put(\"\", mimeType, this::createOrUpdate); exception(RuntimeException.class, (RuntimeException exception, Request request, Response response) -> { response.status(HttpStatus.UNPROCESSABLE_ENTITY.value()); response.body(MessageJson.create(exception.getMessage())); }); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this checkBasicAPIs(strings, deserialized, true);'\nThe code is: 'public void testSortedSerialization() throws Exception { final String[] strings = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"}; GenericIndexed<String> deserialized = serializeAndDeserialize( GenericIndexed.fromArray( strings, GenericIndexed.STRING_STRATEGY ) ); <START> checkBasicAPIs(strings, deserialized, deserialized.isAllowReverseLookup()); <END> \/\/ this checkBasicAPIs(strings, deserialized, true); Assert.assertEquals(-13, deserialized.indexOf(\"q\")); Assert.assertEquals(-9, deserialized.indexOf(\"howdydo\")); Assert.assertEquals(-1, deserialized.indexOf(\"1111\")); }'","output":"public void testSortedSerialization() throws Exception { final String[] strings = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"}; GenericIndexed<String> deserialized = serializeAndDeserialize( GenericIndexed.fromArray( strings, GenericIndexed.STRING_STRATEGY ) ); checkBasicAPIs(strings, deserialized, true); Assert.assertEquals(-13, deserialized.indexOf(\"q\")); Assert.assertEquals(-9, deserialized.indexOf(\"howdydo\")); Assert.assertEquals(-1, deserialized.indexOf(\"1111\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@neonailol I this pattern private static final, produces immutable Pattern object (like a constant) degrade performance if called outside'\nThe code is: 'private static List<String> tokens(final Request req) throws IOException { <START> final Pattern pattern = Pattern.compile(\"(\\\\w+)\\\\\/([\\\\d\\\\.]+)\"); <END> \/\/ @neonailol I this pattern private static final, produces immutable Pattern object (like a constant) degrade performance if called outside final List<String> tokens = new LinkedList<>(); final Iterable<String> headers = new RqHeaders.Base(req).header(\"User-Agent\"); for (final String header : headers) { final Matcher matcher = pattern.matcher(header); if (matcher.matches()) { tokens.add(matcher.group()); } } return tokens; }'","output":"private static List<String> tokens(final Request req) throws IOException { final List<String> tokens = new LinkedList<>(); final Iterable<String> headers = new RqHeaders.Base(req).header(\"User-Agent\"); for (final String header : headers) { final Matcher matcher = PATTERN.matcher(header); if (matcher.matches()) { tokens.add(matcher.group()); } } return tokens; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'instead like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin if is filter node'\nThe code is: 'public void testPushDownConstantFilterPredicate() { assertPlan( \"SELECT sum(totalprice) FILTER(WHERE FALSE) FROM orders\", anyTree( aggregation( ImmutableMap.of(\"sum_6\", functionCall(\"sum\", ImmutableList.of(\"totalprice\"))), project( values(\"totalprice\"))))); assertPlan( \"SELECT sum(totalprice) FILTER(WHERE TRUE) FROM orders\", <START> anyTree( <END> \/\/ instead like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin if is filter node aggregation( ImmutableMap.of(\"sum\", functionCall(\"sum\", ImmutableList.of(\"sum_6\"))), exchange( aggregation( ImmutableMap.of(\"sum_6\", functionCall(\"sum\", ImmutableList.of(\"totalprice\"))), project( tableScan( \"orders\", ImmutableMap.of(\"totalprice\", \"totalprice\")))))))); }'","output":"public void testPushDownConstantFilterPredicate() { assertPlanContainsNoFilter(\"SELECT sum(totalprice) FILTER(WHERE FALSE) FROM orders\"); assertPlanContainsNoFilter(\"SELECT sum(totalprice) FILTER(WHERE TRUE) FROM orders\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I stringUtils.isEmpty returns true for null string. check condition skipped'\nThe code is: 'private String removeSpacesAroundRDN(String dn) { <START> if (dn == null || StringUtils.isEmpty(dn)) { <END> \/\/ I stringUtils.isEmpty returns true for null string. check condition skipped return dn; } List<String> strings = new ArrayList<>(); String[] splitted = dn.split(\",\"); for (String aSplitted : splitted) { String element = aSplitted.trim(); strings.add(element); } StringBuilder sb = new StringBuilder(); Iterator<String> idIterator = strings.iterator(); while (idIterator.hasNext()){ sb.append(idIterator.next().trim()); if (idIterator.hasNext()) sb.append(','); } return sb.toString(); }'","output":"private String removeSpacesAroundRDN(String dn) { if (StringUtils.isEmpty(dn)) { return dn; } List<String> strings = new ArrayList<>(); String[] splitted = dn.split(\",\"); for (String aSplitted : splitted) { String element = aSplitted.trim(); strings.add(element); } StringBuilder sb = new StringBuilder(); Iterator<String> idIterator = strings.iterator(); while (idIterator.hasNext()){ sb.append(idIterator.next().trim()); if (idIterator.hasNext()) sb.append(','); } return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'done expensively (and more simply) built-ins: Map<StackId, Set<String>> mpackServices = topology.getComponents().collect( groupingBy(ResolvedComponent::stackId, mapping(comp -> comp.serviceInfo().getName(), toSet())));'\nThe code is: 'private Set<MpackInstance> copyAndEnrichMpackInstances(ClusterTopology topology) { Set<MpackInstance> mpacks = topology.getMpacks().stream().map(MpackInstance::copy).collect(toSet()); Map<StackId, Set<String>> mpackServices = topology.getComponents().collect(toMap( ResolvedComponent::stackId, comp -> ImmutableSet.of(comp.serviceInfo().getName()), <START> (set1, set2) -> ImmutableSet.copyOf(Sets.union(set1, set2)) <END> \/\/ done expensively (and more simply) built-ins: Map<StackId, Set<String>> mpackServices = topology.getComponents().collect( groupingBy(ResolvedComponent::stackId, mapping(comp -> comp.serviceInfo().getName(), toSet()))); )); for (MpackInstance mpack: mpacks) { if (!mpackServices.containsKey(mpack.getStackId())) { LOG.warn(\"No services declared for mpack {}.\", mpack.getStackId()); } else { Set<String> existingMpackServices = mpack.getServiceInstances().stream().map(ServiceInstance::getType).collect(toSet()); for(String service: mpackServices.get(mpack.getStackId())) { if (existingMpackServices.contains(service)) { LOG.debug(\"Mpack instance {} already contains service {}\", mpack.getStackId(), service); } else { LOG.debug(\"Adding service {} to mpack instance {}\", service, mpack.getStackId()); mpack.getServiceInstances().add(new ServiceInstance(service, service, null, mpack)); } } } } return mpacks; }'","output":"private Set<MpackInstance> copyAndEnrichMpackInstances(ClusterTopology topology) { Set<MpackInstance> mpacks = topology.getMpacks().stream().map(MpackInstance::copy).collect(toSet()); Map<StackId, Set<String>> mpackServices = topology.getComponents().collect( groupingBy(ResolvedComponent::stackId, mapping(comp -> comp.serviceInfo().getName(), toSet()))); for (MpackInstance mpack: mpacks) { if (!mpackServices.containsKey(mpack.getStackId())) { LOG.warn(\"No services declared for mpack {}.\", mpack.getStackId()); } else { Set<String> existingMpackServices = mpack.getServiceInstances().stream().map(ServiceInstance::getType).collect(toSet()); for(String service: mpackServices.get(mpack.getStackId())) { if (existingMpackServices.contains(service)) { LOG.debug(\"Mpack instance {} already contains service {}\", mpack.getStackId(), service); } else { LOG.debug(\"Adding service {} to mpack instance {}\", service, mpack.getStackId()); mpack.getServiceInstances().add(new ServiceInstance(service, service, null, mpack)); } } } } return mpacks; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'switch + a , get a stack trace in logs'\nThe code is: 'private boolean findAssignments() { try { return assignmentsExport.getAssignmentsInSite(siteId); } catch (TypeException te) { <START> log.error(\"export-common-cartridge type error outputting assignments\" + te); <END> \/\/ switch + a , get a stack trace in logs setErrMessage(\"Error outputting forum attachments: \" + te.getMessage()); return false; } catch (PermissionException pe) { log.error(\"export-common-cartridge permission error outputting assignments\" + pe); setErrMessage(\"Error outputting forum attachments: \" + pe.getMessage()); return false; } catch (IdUnusedException ide) { log.error(\"export-common-cartridge ID unuse error outputting assignments\" + ide); setErrMessage(\"Error outputting forum attachments: \" + ide.getMessage()); return false; } catch (ServerOverloadException soe) { log.error(\"export-common-cartridge server overload error outputting assignments\" + soe); setErrMessage(\"Error outputting selected files: \" + soe.getMessage()); return false; } }'","output":"private boolean findAssignments() { return assignmentsExport.getAssignmentsInSite(siteId); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '(optional)'\nThe code is: 'public int parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); <START> try (final ObjectReader curs = clp.getRepository().newObjectReader()) { <END> \/\/ (optional) p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }'","output":"public int parseArguments(final Parameters params) throws CmdLineException { final String name = params.getParameter(0); if (new File(name).isDirectory()) { setter.addValue(new FileTreeIterator( new File(name), FS.DETECTED, clp.getRepository().getConfig().get(WorkingTreeOptions.KEY))); return 1; } if (new File(name).isFile()) { final DirCache dirc; try { dirc = DirCache.read(new File(name), FS.DETECTED); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notAnIndexFile, name), e); } setter.addValue(new DirCacheIterator(dirc)); return 1; } final ObjectId id; try { id = clp.getRepository().resolve(name); } catch (IOException e) { throw new CmdLineException(e.getMessage()); } if (id == null) throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); final CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader curs = clp.getRepository().newObjectReader()) { p.reset(curs, clp.getRevWalk().parseTree(id)); } catch (MissingObjectException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IncorrectObjectTypeException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().notATree, name)); } catch (IOException e) { throw new CmdLineException(MessageFormat.format(CLIText.get().cannotReadBecause, name, e.getMessage())); } setter.addValue(p); return 1; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I do pass db in'\nThe code is: 'public void setUp() throws SQLException { super.setUp(); if (testType.equals(SQL_ONLY_EXECUTION)) { im = new MockSQLOnlyIndexManager(ds); } else if (testType.equals(MATCHER_EXECUTION)) { im = new MockMatcherIndexManager(ds); } else if (testType.equals(STANDARD_EXECUTION)) { im = new IndexManager(ds); } assertThat(im, is(notNullValue())); db = TestUtils.getDatabaseConnectionToExistingDb(im.getDatabase()); assertThat(db, is(notNullValue())); assertThat(im.getQueue(), is(notNullValue())); String[] metadataTableList = new String[] { IndexManager.INDEX_METADATA_TABLE_NAME }; SQLDatabaseTestUtils.assertTablesExist(TestUtils.getDatabaseConnectionToExistingDb(db), <START> metadataTableList); <END> \/\/ I do pass db in }'","output":"public void setUp() throws SQLException { super.setUp(); if (testType.equals(SQL_ONLY_EXECUTION)) { im = new MockSQLOnlyIndexManager(ds); } else if (testType.equals(MATCHER_EXECUTION)) { im = new MockMatcherIndexManager(ds); } else if (testType.equals(STANDARD_EXECUTION)) { im = new IndexManager(ds); } assertThat(im, is(notNullValue())); db = TestUtils.getDatabaseConnectionToExistingDb(im.getDatabase()); assertThat(db, is(notNullValue())); assertThat(im.getQueue(), is(notNullValue())); String[] metadataTableList = new String[] { IndexManager.INDEX_METADATA_TABLE_NAME }; SQLDatabaseTestUtils.assertTablesExist(db, metadataTableList); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This implicit behavior updating global state a weird I put a lot of thought - expect issues in practice smell a weird. I right do wrong place do'\nThe code is: 'protected Collection<String> getInAppFrames(Dsn dsn) { String inAppFramesOption = Lookup.lookup(IN_APP_FRAMES_OPTION, dsn); if (Util.isNullOrEmpty(inAppFramesOption)) { logger.warn(\"No '\" + IN_APP_FRAMES_OPTION + \"' was configured, this option is highly recommended \" + \"as it affects stacktrace grouping and display on Sentry. See documentation: \" + \"<LINK_0>\"); return Collections.emptyList(); } List<String> inAppPackages = new ArrayList<>(); for (String inAppPackage : inAppFramesOption.split(\",\")) { if (!inAppPackage.trim().equals(\"\")) { inAppPackages.add(inAppPackage); } } for (String inAppPackage : inAppPackages) { FrameCache.addAppPackage(inAppPackage); <START> } <END> \/\/ This implicit behavior updating global state a weird I put a lot of thought - expect issues in practice smell a weird. I right do wrong place do return inAppPackages; }'","output":"protected Collection<String> getInAppFrames(Dsn dsn) { String inAppFramesOption = Lookup.lookup(IN_APP_FRAMES_OPTION, dsn); if (Util.isNullOrEmpty(inAppFramesOption)) { logger.warn(\"No '\" + IN_APP_FRAMES_OPTION + \"' was configured, this option is highly recommended \" + \"as it affects stacktrace grouping and display on Sentry. See documentation: \" + \"<LINK_0>\"); return Collections.emptyList(); } List<String> inAppPackages = new ArrayList<>(); for (String inAppPackage : inAppFramesOption.split(\",\")) { if (!inAppPackage.trim().equals(\"\")) { inAppPackages.add(inAppPackage); } } return inAppPackages; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add a check verify broadcastSerialDataReceived method called'\nThe code is: 'public void testUnicastSerialDataReceiveSubscribedRx64() throws Exception { dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx64Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_NOT_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).serialDataReceived(XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); <START> <END> \/\/ Add a check verify broadcastSerialDataReceived method called assertEquals(XBEE_64BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }'","output":"public void testUnicastSerialDataReceiveSubscribedRx64() throws Exception { dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx64Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_NOT_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).serialDataReceived(XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); Mockito.verify(receiveSerialDataListener, Mockito.never()).broadcastSerialDataReceived(Mockito.anyString(), (byte[])Mockito.any()); assertEquals(XBEE_64BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Strings.isNullOrEmpty'\nThe code is: 'public static VirtualColumns create(List<VirtualColumn> virtualColumns) { if (virtualColumns == null || virtualColumns.isEmpty()) { return EMPTY; } Map<String, VirtualColumn> withDotSupport = Maps.newHashMap(); Map<String, VirtualColumn> withoutDotSupport = Maps.newHashMap(); for (VirtualColumn vc : virtualColumns) { <START> if (vc.getOutputName() == null || vc.getOutputName().isEmpty()) { <END> \/\/ Strings.isNullOrEmpty throw new IAE(\"Empty or null virtualColumn name\"); } if (vc.getOutputName().equals(Column.TIME_COLUMN_NAME)) { throw new IAE(\"virtualColumn name[%s] not allowed\", vc.getOutputName()); } if (withDotSupport.containsKey(vc.getOutputName()) || withoutDotSupport.containsKey(vc.getOutputName())) { throw new IAE(\"Duplicate virtualColumn name[%s]\", vc.getOutputName()); } if (vc.usesDotNotation()) { withDotSupport.put(vc.getOutputName(), vc); } else { withoutDotSupport.put(vc.getOutputName(), vc); } } return new VirtualColumns(ImmutableList.copyOf(virtualColumns), withDotSupport, withoutDotSupport); }'","output":"public static VirtualColumns create(List<VirtualColumn> virtualColumns) { if (virtualColumns == null || virtualColumns.isEmpty()) { return EMPTY; } Map<String, VirtualColumn> withDotSupport = Maps.newHashMap(); Map<String, VirtualColumn> withoutDotSupport = Maps.newHashMap(); for (VirtualColumn vc : virtualColumns) { if (Strings.isNullOrEmpty(vc.getOutputName())) { throw new IAE(\"Empty or null virtualColumn name\"); } if (vc.getOutputName().equals(Column.TIME_COLUMN_NAME)) { throw new IAE(\"virtualColumn name[%s] not allowed\", vc.getOutputName()); } if (withDotSupport.containsKey(vc.getOutputName()) || withoutDotSupport.containsKey(vc.getOutputName())) { throw new IAE(\"Duplicate virtualColumn name[%s]\", vc.getOutputName()); } if (vc.usesDotNotation()) { withDotSupport.put(vc.getOutputName(), vc); } else { withoutDotSupport.put(vc.getOutputName(), vc); } } return new VirtualColumns(ImmutableList.copyOf(virtualColumns), withDotSupport, withoutDotSupport); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion List<RestEntry> entries = new ArrayList<>();'\nThe code is: 'public void execute(DiagnosticContext context) { try { <START> List<RestEntry> entries = new ArrayList(); <END> \/\/ suggestion List<RestEntry> entries = new ArrayList<>(); entries.addAll(context.getLogstashRestCalls().values()); runQueries(context.getEsRestClient(), entries, context.getTempDir(), 0, 0); String temp = context.getTempDir(); JsonNode nodeData = JsonYamlUtils.createJsonNodeFromFileName(temp, \"logstash_node.json\"); JsonNode jvm = nodeData.path(\"jvm\"); String pid = jvm.path(\"pid\").asText(); context.setPid(pid); } catch (Throwable t) { logger.log(SystemProperties.DIAG, \"Logstash Query error:\", t); throw new DiagnosticException(String.format(\"Error obtaining logstash output and\/or process id - exiting. %s\", Constants.CHECK_LOG)); } }'","output":"public void execute(DiagnosticContext context) { try { List<RestEntry> entries = new ArrayList<>(); entries.addAll(context.getLogstashRestCalls().values()); runQueries(context.getEsRestClient(), entries, context.getTempDir(), 0, 0); String temp = context.getTempDir(); JsonNode nodeData = JsonYamlUtils.createJsonNodeFromFileName(temp, \"logstash_node.json\"); JsonNode jvm = nodeData.path(\"jvm\"); String pid = jvm.path(\"pid\").asText(); context.setPid(pid); } catch (Throwable t) { logger.log(SystemProperties.DIAG, \"Logstash Query error:\", t); throw new DiagnosticException(String.format(\"Error obtaining logstash output and\/or process id - exiting. %s\", Constants.CHECK_LOG)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'reading is logic flows if (requested resources fit resources) remove requested resources form resources reduce total resources requested resources reserve requested resources return reserved resources else if (there resources, requested resources available) add \"empty\" resource list of resources for this reservation type reduce total resources amount of resources reserve resource positive I understand remove entire resource calling availableResource.remove(new ScalarResourceEntry(availableResourceValue)) (as is similar is done in if) else if requires pay special attention reservationType (where if ignore reservationType reserve resources)'\nThe code is: 'private List<ResourceEntry> removeAndGet(ScalarResourceEntry scalarResourceEntry, Collection<ReservationType> reservationTypesListByPriority) throws ResourceNotAvailabeException { Double requiredValue = scalarResourceEntry.getValue(); List<ResourceEntry> reservedResources = new ArrayList<>(); if (requiredValue > totalAvailableResource) { String message = String.format(\"ResourceType '%s' is not available. Requested value: %s Available: %s\", resourceType, requiredValue, totalAvailableResource); throw new ResourceNotAvailabeException(message); } for (ReservationType reservationType : reservationTypesListByPriority) { ScalarResourceEntry availableResource = availableResourcesByReservationType.get(reservationType); Double availableResourceValue = availableResource.getValue(); if (availableResourceValue >= requiredValue) { availableResource.remove(new ScalarResourceEntry(requiredValue)); totalAvailableResource -= requiredValue; reservedResources.add(new ScalarResourceEntry(reservationType, requiredValue)); return reservedResources; } else if (availableResourceValue > 0) { <START> availableResourcesByReservationType.put(reservationType, new ScalarResourceEntry(reservationType, 0.0)); <END> \/\/ reading is logic flows if (requested resources fit resources) remove requested resources form resources reduce total resources requested resources reserve requested resources return reserved resources else if (there resources, requested resources available) add \"empty\" resource list of resources for this reservation type reduce total resources amount of resources reserve resource positive I understand remove entire resource calling availableResource.remove(new ScalarResourceEntry(availableResourceValue)) (as is similar is done in if) else if requires pay special attention reservationType (where if ignore reservationType reserve resources) requiredValue -= availableResourceValue; totalAvailableResource -= availableResourceValue; reservedResources.add(new ScalarResourceEntry(reservationType, availableResourceValue)); } } return reservedResources; }'","output":"private List<ResourceEntry> removeAndGet(ScalarResourceEntry scalarResourceEntry, Collection<ReservationType> reservationTypesListByPriority) throws ResourceNotAvailableException { Double requiredValue = scalarResourceEntry.getValue(); List<ResourceEntry> reservedResources = new ArrayList<>(); if (requiredValue > totalAvailableResource) { String message = String.format(\"ResourceType '%s' is not available. Requested value: %s Available: %s\", resourceType, requiredValue, totalAvailableResource); throw new ResourceNotAvailableException(message); } for (ReservationType reservationType : reservationTypesListByPriority) { ScalarResourceEntry availableResource = availableResourcesByReservationType.get(reservationType); Double availableResourceValue = availableResource.getValue(); if (availableResourceValue >= requiredValue) { availableResource.remove(new ScalarResourceEntry(requiredValue)); totalAvailableResource -= requiredValue; reservedResources.add(new ScalarResourceEntry(reservationType, requiredValue)); return reservedResources; } else if (availableResourceValue > 0) { availableResourcesByReservationType.put(reservationType, new ScalarResourceEntry(reservationType, 0.0)); requiredValue -= availableResourceValue; totalAvailableResource -= availableResourceValue; reservedResources.add(new ScalarResourceEntry(reservationType, availableResourceValue)); } } return reservedResources; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This bit required. If UnixSHACryptPassword extends AbstractPasswordImpl (as should), method convert a key spec right class'\nThe code is: 'protected <S extends KeySpec> S engineGetKeySpec(final String algorithm, final Password password, final Class<S> keySpecType) throws InvalidKeySpecException { if (password instanceof AbstractPasswordImpl) { final AbstractPasswordImpl abstractPassword = (AbstractPasswordImpl) password; if (algorithm.equals(abstractPassword.getAlgorithm())) { return abstractPassword.getKeySpec(keySpecType); } } <START> switch (algorithm) { <END> \/\/ This bit required. If UnixSHACryptPassword extends AbstractPasswordImpl (as should), method convert a key spec right class case ALGORITHM_SHA256CRYPT: case ALGORITHM_SHA512CRYPT: { if (password instanceof UnixSHACryptPassword) { if (keySpecType == UnixSHACryptPasswordSpec.class) { UnixSHACryptPassword p = ((UnixSHACryptPassword) password); return keySpecType.cast(new UnixSHACryptPasswordSpec(p.getId(), p.getEncoded(), p.getSalt(), p.getIterationCount())); } } else { break; } } } throw new InvalidKeySpecException(); }'","output":"protected <S extends KeySpec> S engineGetKeySpec(final String algorithm, final Password password, final Class<S> keySpecType) throws InvalidKeySpecException { if (password instanceof AbstractPasswordImpl) { final AbstractPasswordImpl abstractPassword = (AbstractPasswordImpl) password; if (algorithm.equals(abstractPassword.getAlgorithm())) { return abstractPassword.getKeySpec(keySpecType); } } throw new InvalidKeySpecException(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: previously this function returned a string; returning null? safer change usages of .charAt() here'\nThe code is: 'private String descForStatus(String str) { if (str.length() < 2) <START> return null; <END> \/\/ nit: previously this function returned a string; returning null? safer change usages of .charAt() here String indexDesc = descForStatus(str.charAt(0)); String treeDesc = descForStatus(str.charAt(1)); if (indexDesc.length() > 0 && treeDesc.length() > 0) return indexDesc + \"\/\" + treeDesc; else if (indexDesc.length() > 0) return indexDesc; else if (treeDesc.length() > 0) return treeDesc; else return \"\"; }'","output":"private String descForStatus(String str) { if (str.length() < 2) return \"\"; String indexDesc = descForStatus(str.charAt(0)); String treeDesc = descForStatus(str.charAt(1)); if (indexDesc.length() > 0 && treeDesc.length() > 0) return indexDesc + \"\/\" + treeDesc; else if (indexDesc.length() > 0) return indexDesc; else if (treeDesc.length() > 0) return treeDesc; else return \"\"; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"true\" Boolean.TRUE here'\nThe code is: 'public void onRequestSuggestions(final Request req, final Callback callback) { RpcStatus.hide(new Runnable() { public void run() { <START> SuggestUtil.SVC.suggestAccount(req.getQuery(), new Boolean(true), <END> \/\/ \"true\" Boolean.TRUE here req.getLimit(), new GerritCallback<List<AccountInfo>>() { public void onSuccess(final List<AccountInfo> result) { final ArrayList<AccountSuggestion> r = new ArrayList<AccountSuggestion>(result.size()); for (final AccountInfo p : result) { r.add(new AccountSuggestion(p)); } callback.onSuggestionsReady(req, new Response(r)); } }); } }); }'","output":"public void onRequestSuggestions(final Request req, final Callback callback) { RpcStatus.hide(new Runnable() { public void run() { SuggestUtil.SVC.suggestAccount(req.getQuery(), Boolean.TRUE, req.getLimit(), new GerritCallback<List<AccountInfo>>() { public void onSuccess(final List<AccountInfo> result) { final ArrayList<AccountSuggestion> r = new ArrayList<AccountSuggestion>(result.size()); for (final AccountInfo p : result) { r.add(new AccountSuggestion(p)); } callback.onSuggestionsReady(req, new Response(r)); } }); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'If more thread waiting in take() blockingPeek(), this wake of them. signalAll()'\nThe code is: 'public void flushInputBuffer() { boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(\"Buffered queue interrupted\", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { <START> fNotEmpty.signal(); <END> \/\/ If more thread waiting in take() blockingPeek(), this wake of them. signalAll() } finally { fOutputLock.unlock(); } } }'","output":"public void flushInputBuffer() { boolean signal = false; fInputLock.lock(); try { if (!fInputBuffer.isEmpty()) { fInnerQueue.put(fInputBuffer); fInputBuffer = new ConcurrentLinkedDeque<>(); fInputBufferSize = 0; signal = true; } } catch (InterruptedException e) { Activator.instance().logError(\"Buffered queue interrupted\", e); } finally { fInputLock.unlock(); } if (signal) { fOutputLock.lock(); try { fNotEmpty.signalAll(); } finally { fOutputLock.unlock(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'destination.getParent() return is more readable in this context I'\nThe code is: 'public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(\"code\", \"Model\", \"Entity\"); DocumentReference destination = new DocumentReference(\"code\", Arrays.asList(\"Model\", \"Entity\"), \"WebHome\"); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); <START> assertEquals(destination.getLastSpaceReference(), copyRequest.getDestination()); <END> \/\/ destination.getParent() return is more readable in this context I assertEquals(Arrays.asList(RefactoringJobs.GROUP, \"copy\"), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }'","output":"public void createCopyRequest() throws Exception { DocumentReference source = new DocumentReference(\"code\", \"Model\", \"Entity\"); DocumentReference destination = new DocumentReference(\"code\", Arrays.asList(\"Model\", \"Entity\"), \"WebHome\"); CopyRequest copyRequest = requestFactory.createCopyRequest(source, destination); assertEquals(Arrays.asList(source), copyRequest.getEntityReferences()); assertEquals(destination.getParent(), copyRequest.getDestination()); assertEquals(Arrays.asList(RefactoringJobs.GROUP, \"copy\"), copyRequest.getId().subList(0, 2)); assertEquals(RefactoringJobs.COPY, copyRequest.getJobType()); assertEquals(this.userReference, copyRequest.getUserReference()); assertFalse(copyRequest.isDeep()); assertTrue(copyRequest.isUpdateLinks()); assertFalse(copyRequest.isInteractive()); assertTrue(copyRequest.isCheckRights()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'notebook instance'\nThe code is: 'public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(\"hello world\"); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), \"clone note\", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(\"user1\"); Note cloneNote2 = notebook.cloneNote(note.getId(), \"clone note2\", subject); <START> Notebook notebook = new Notebook( <END> \/\/ notebook instance conf, notebookRepo, schedulerFactory, new InterpreterFactory(conf, null, null, null, depResolver), this, null, notebookAuthorization, null); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(\"user1\"); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }'","output":"public void testCloneNote() throws IOException, CloneNotSupportedException, InterruptedException, InterpreterException, SchedulerException, RepositoryException { Note note = notebook.createNote(null); factory.setInterpreters(note.getId(), factory.getDefaultInterpreterSettingList()); final Paragraph p = note.addParagraph(); p.setText(\"hello world\"); note.runAll(); while(p.isTerminated()==false || p.getResult()==null) Thread.yield(); p.setStatus(Status.RUNNING); Note cloneNote = notebook.cloneNote(note.getId(), \"clone note\", null); Paragraph cp = cloneNote.paragraphs.get(0); assertEquals(cp.getStatus(), Status.READY); assertEquals(cp.getId(), p.getId()); assertEquals(cp.text, p.text); assertEquals(cp.getResult().message(), p.getResult().message()); AuthenticationInfo subject = new AuthenticationInfo(\"user1\"); Note cloneNote2 = notebook.cloneNote(note.getId(), \"clone note2\", subject); assertNotNull(notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); assertEquals(1, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()); Set<String> owners = new HashSet<>(); owners.add(\"user1\"); assertEquals(owners, notebook.getNotebookAuthorization().getOwners(cloneNote2.getId())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I another exception specific this case, LocalTargetUrlProxyException'\nThe code is: 'protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String requestUri = request.getRequestURI(); logger.debug(\"Starting execution of proxy request for {}\", requestUri); SiteContext siteContext = SiteContext.getCurrent(); if (siteContext == null) { throw new IllegalStateException(\"Can't resolve site context for current request\"); } String siteName = siteContext.getSiteName(); logger.debug(\"Resolved site {} for proxy request {}\", siteName, requestUri); String targetUrl = getTargetUrl(siteContext, requestUri); logger.debug(\"Resolved target url {} for proxy request {}\", targetUrl, requestUri); if (request.getRequestURL().toString().contains(targetUrl)) { logger.debug(\"Resolved target url for request {} is local, will skip proxy\", requestUri); <START> throw new HttpProxyException(\"Local target url detected\"); <END> \/\/ I another exception specific this case, LocalTargetUrlProxyException } request.setAttribute(ATTR_TARGET_URI, targetUrl); request.setAttribute(ATTR_TARGET_HOST, URIUtils.extractHost(URI.create(targetUrl))); super.service(request, response); }'","output":"protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String requestUri = request.getRequestURI(); logger.debug(\"Starting execution of proxy request for {}\", requestUri); SiteContext siteContext = SiteContext.getCurrent(); if (siteContext == null) { throw new IllegalStateException(\"Can't resolve site context for current request\"); } String siteName = siteContext.getSiteName(); logger.debug(\"Resolved site {} for proxy request {}\", siteName, requestUri); String targetUrl = getTargetUrl(siteContext, requestUri); logger.debug(\"Resolved target url {} for proxy request {}\", targetUrl, requestUri); if (request.getRequestURL().toString().contains(targetUrl)) { logger.debug(\"Resolved target url for request {} is local, will skip proxy\", requestUri); throw new LocalTargetUrlProxyException(\"Local target url detected\"); } request.setAttribute(ATTR_TARGET_URI, targetUrl); request.setAttribute(ATTR_TARGET_HOST, URIUtils.extractHost(URI.create(targetUrl))); super.service(request, response); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Rolling this suggestion assertValidAudienceClaim(jwt.getAudience(), (List<String>) entry.getValue());'\nThe code is: 'private void verifyClaims(DecodedJWT jwt, Map<String, Object> claims) throws TokenExpiredException, InvalidClaimException { for (Map.Entry<String, Object> entry : claims.entrySet()) { switch (entry.getKey()) { case PublicClaims.AUDIENCE: <START> assertValidAudienceClaim(jwt.getAudience(), Arrays.asList((String[]) entry.getValue())); <END> \/\/ Rolling this suggestion assertValidAudienceClaim(jwt.getAudience(), (List<String>) entry.getValue()); break; case PublicClaims.EXPIRES_AT: assertValidDateClaim(jwt.getExpiresAt(), (Long) entry.getValue(), true); break; case PublicClaims.ISSUED_AT: assertValidDateClaim(jwt.getIssuedAt(), (Long) entry.getValue(), false); break; case PublicClaims.NOT_BEFORE: assertValidDateClaim(jwt.getNotBefore(), (Long) entry.getValue(), false); break; case PublicClaims.ISSUER: assertValidIssuerClaim(jwt.getIssuer(), Arrays.asList((String[]) entry.getValue())); break; case PublicClaims.JWT_ID: assertValidStringClaim(entry.getKey(), jwt.getId(), (String) entry.getValue()); break; case PublicClaims.SUBJECT: assertValidStringClaim(entry.getKey(), jwt.getSubject(), (String) entry.getValue()); break; default: assertValidClaim(jwt.getClaim(entry.getKey()), entry.getKey(), entry.getValue()); break; } } }'","output":"private void verifyClaims(DecodedJWT jwt, Map<String, Object> claims) throws TokenExpiredException, InvalidClaimException { for (Map.Entry<String, Object> entry : claims.entrySet()) { switch (entry.getKey()) { case PublicClaims.AUDIENCE: assertValidAudienceClaim(jwt.getAudience(), (List<String>) entry.getValue()); break; case PublicClaims.EXPIRES_AT: assertValidDateClaim(jwt.getExpiresAt(), (Long) entry.getValue(), true); break; case PublicClaims.ISSUED_AT: assertValidDateClaim(jwt.getIssuedAt(), (Long) entry.getValue(), false); break; case PublicClaims.NOT_BEFORE: assertValidDateClaim(jwt.getNotBefore(), (Long) entry.getValue(), false); break; case PublicClaims.ISSUER: assertValidIssuerClaim(jwt.getIssuer(), (List<String>) entry.getValue()); break; case PublicClaims.JWT_ID: assertValidStringClaim(entry.getKey(), jwt.getId(), (String) entry.getValue()); break; case PublicClaims.SUBJECT: assertValidStringClaim(entry.getKey(), jwt.getSubject(), (String) entry.getValue()); break; default: assertValidClaim(jwt.getClaim(entry.getKey()), entry.getKey(), entry.getValue()); break; } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: spaces \/'\nThe code is: 'public void adjustCost(ResultSetNode rsn) throws StandardException { if (fetchFirst==-1 && offset ==-1) return; CostEstimate costEstimate = rsn.getFinalCostEstimate(false); long totalRowCount = costEstimate.getEstimatedRowCount(); long currentOffset = offset==-1?0:offset; long currentFetchFirst = fetchFirst==-1?totalRowCount:fetchFirst; scaleFactor = (double) currentFetchFirst\/(double) totalRowCount; if (scaleFactor >= 1.0d) { } else { costEstimate.setEstimatedRowCount(currentOffset+currentFetchFirst); costEstimate.setRemoteCost(scaleFactor*costEstimate.getRemoteCost()); int numPartitions = costEstimate.partitionCount(); if (numPartitions <= 0) numPartitions = 1; <START> costEstimate.setRemoteCostPerPartition(costEstimate.remoteCost()\/numPartitions); <END> \/\/ nit: spaces \/ } }'","output":"public void adjustCost(ResultSetNode rsn) throws StandardException { if (fetchFirst==-1 && offset ==-1) return; CostEstimate costEstimate = rsn.getFinalCostEstimate(false); long totalRowCount = costEstimate.getEstimatedRowCount(); long currentOffset = offset==-1?0:offset; long currentFetchFirst = fetchFirst==-1?totalRowCount:fetchFirst; scaleFactor = (double) currentFetchFirst\/(double) totalRowCount; if (scaleFactor >= 1.0d) { } else { costEstimate.setEstimatedRowCount(currentOffset+currentFetchFirst); costEstimate.setRemoteCost(scaleFactor*costEstimate.getRemoteCost()); costEstimate.setRemoteCostPerPartition(costEstimate.remoteCost(), costEstimate.partitionCount()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this in RequestActionSupport'\nThe code is: 'protected void addResponseHandlers(ChannelPipeline p, Fulfiller<? super StreamedResponse> fulfiller) { <START> if (requestSpecBacking.isDecompressResponse()) { <END> \/\/ this in RequestActionSupport p.addLast(new HttpContentDecompressor()); } p.addLast(\"httpResponseHandler\", new SimpleChannelInboundHandler<HttpResponse>(false) { @Override public void channelRead0(ChannelHandlerContext ctx, HttpResponse msg) throws Exception { p.channel().config().setAutoRead(false); execution.onCleanup(() -> { if (!subscribedTo.get() && ctx.channel().isOpen()) { ctx.close(); } }); final Headers headers = new NettyHeadersBackedHeaders(msg.headers()); final Status status = new DefaultStatus(msg.status()); success(fulfiller, new DefaultStreamedResponse(p, status, headers)); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.close(); error(fulfiller, cause); } }); }'","output":"protected void addResponseHandlers(ChannelPipeline p, Fulfiller<? super StreamedResponse> fulfiller) { p.addLast(\"httpResponseHandler\", new SimpleChannelInboundHandler<HttpResponse>(false) { @Override public void channelRead0(ChannelHandlerContext ctx, HttpResponse msg) throws Exception { p.channel().config().setAutoRead(false); execution.onCleanup(() -> { if (!subscribedTo.get() && ctx.channel().isOpen()) { ctx.close(); } }); final Headers headers = new NettyHeadersBackedHeaders(msg.headers()); final Status status = new DefaultStatus(msg.status()); success(fulfiller, new DefaultStreamedResponse(p, status, headers)); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.close(); error(fulfiller, cause); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'checkState'\nThe code is: 'public CloseableIterator<byte[]> keys(byte[] firstKey, byte[] lastKey) { final RocksIterator iterator = db.newIterator(optionCache); iterator.seek(firstKey); return new CloseableIterator<byte[]>() { @Override public boolean hasNext() { return iterator.isValid() && ByteComparator.compare(iterator.key(), lastKey) < 0; } @Override public byte[] next() { <START> checkArgument(iterator.isValid()); <END> \/\/ checkState byte[] key = iterator.key(); iterator.next(); return key; } @Override public void close() { iterator.close(); } }; }'","output":"public CloseableIterator<byte[]> keys(byte[] firstKey, byte[] lastKey) { final RocksIterator iterator = db.newIterator(optionCache); iterator.seek(firstKey); return new CloseableIterator<byte[]>() { @Override public boolean hasNext() { return iterator.isValid() && ByteComparator.compare(iterator.key(), lastKey) < 0; } @Override public byte[] next() { checkState(iterator.isValid()); byte[] key = iterator.key(); iterator.next(); return key; } @Override public void close() { iterator.close(); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Extra semicolon'\nThe code is: 'public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(\"Unexpected editor: \" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(\"No element selected\"); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), \"Unable to retrieve diagram service\"); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), \"Unable to retrieve component implementation\"); <START> ; <END> \/\/ Extra semicolon diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }'","output":"public Object execute(final ExecutionEvent event) throws ExecutionException { final IEditorPart activeEditor = HandlerUtil.getActiveEditor(event); if (!(activeEditor instanceof AgeDiagramEditor)) { throw new RuntimeException(\"Unexpected editor: \" + activeEditor); } final List<DiagramElement> selectedDiagramElements = AgeHandlerUtil.getSelectedDiagramElements(event); if (selectedDiagramElements.size() == 0) { throw new RuntimeException(\"No element selected\"); } final DiagramElement selectedElement = selectedDiagramElements.get(0); final Object bo = selectedElement.getBusinessObject(); final DiagramService diagramService = Objects.requireNonNull(Adapters.adapt(activeEditor, DiagramService.class), \"Unable to retrieve diagram service\"); final ComponentImplementation ci = Objects.requireNonNull(getComponentImplementation(bo), \"Unable to retrieve component implementation\"); diagramService.openOrCreateDiagramForBusinessObject(ci); return null; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '{}'\nThe code is: 'private LinkedBlockingQueue<ForceWriteRequest> enableForceWriteThreadSuspension( CountDownLatch forceWriteThreadSuspendedLatch, Journal journal) throws InterruptedException { LinkedBlockingQueue<ForceWriteRequest> supportQueue = new LinkedBlockingQueue<>(); BlockingQueue<ForceWriteRequest> forceWriteRequests = mock(BlockingQueue.class); doAnswer((Answer) (InvocationOnMock iom) -> { <START> log.error(\"something put \" + iom.getArgument(0) + \" on journal queue\", <END> \/\/ {} new Exception().fillInStackTrace()); supportQueue.put(iom.getArgument(0)); return null; }).when(forceWriteRequests).put(any(ForceWriteRequest.class)); when(forceWriteRequests.take()).thenAnswer(i -> { forceWriteThreadSuspendedLatch.await(); return supportQueue.take(); }); Whitebox.setInternalState(journal, \"forceWriteRequests\", forceWriteRequests); return supportQueue; }'","output":"private LinkedBlockingQueue<ForceWriteRequest> enableForceWriteThreadSuspension( CountDownLatch forceWriteThreadSuspendedLatch, Journal journal) throws InterruptedException { LinkedBlockingQueue<ForceWriteRequest> supportQueue = new LinkedBlockingQueue<>(); BlockingQueue<ForceWriteRequest> forceWriteRequests = mock(BlockingQueue.class); doAnswer((Answer) (InvocationOnMock iom) -> { log.error(\"something put {} on journal queue\", iom.getArgument(0), new Exception().fillInStackTrace()); supportQueue.put(iom.getArgument(0)); return null; }).when(forceWriteRequests).put(any(ForceWriteRequest.class)); when(forceWriteRequests.take()).thenAnswer(i -> { forceWriteThreadSuspendedLatch.await(); return supportQueue.take(); }); Whitebox.setInternalState(journal, \"forceWriteRequests\", forceWriteRequests); return supportQueue; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change debug level'\nThe code is: 'private static CompletionParams getCompletionParams(String buf, int cursor) { final int actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final int line = countLines(beforeCursor) - 1; final int character = beforeCursor.length() - beforeCursor.lastIndexOf(\"\\n\") - 1; <START> Logger.info(\"Line: {}, character: {} from actual cursor: \", line, character, cursor); <END> \/\/ change debug level return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }'","output":"private static CompletionParams getCompletionParams(String buf, int cursor) { final int actualCursor = Math.min(cursor, buf.length()); final String beforeCursor = buf.substring(0, actualCursor); final int line = countLines(beforeCursor) - 1; final int character = beforeCursor.length() - beforeCursor.lastIndexOf(\"\\n\") - 1; Logger.debug(\"Line: {}, character: {} from actual cursor: \", line, character, cursor); return new CompletionParams( new TextDocumentIdentifier(ANY_URI), new Position(line, character)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Needs a return statement'\nThe code is: 'public void swap(INDArray x, INDArray y) { if (Nd4j.getExecutioner().getProfilingMode() == OpExecutioner.ProfilingMode.ALL) OpProfiler.getInstance().processBlasCall(false, x, y); if(x.isSparse() || y.isSparse()) { <START> Nd4j.getSparseBlasWrapper().level1().swap(x, y); <END> \/\/ Needs a return statement } if (x.data().dataType() == DataBuffer.Type.DOUBLE) { DefaultOpExecutioner.validateDataType(DataBuffer.Type.DOUBLE, x, y); dswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } else { DefaultOpExecutioner.validateDataType(DataBuffer.Type.FLOAT, x, y); sswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } }'","output":"public void swap(INDArray x, INDArray y) { if (Nd4j.getExecutioner().getProfilingMode() == OpExecutioner.ProfilingMode.ALL) OpProfiler.getInstance().processBlasCall(false, x, y); if (x.isSparse() || y.isSparse()) { Nd4j.getSparseBlasWrapper().level1().swap(x, y); return; } if (x.data().dataType() == DataBuffer.Type.DOUBLE) { DefaultOpExecutioner.validateDataType(DataBuffer.Type.DOUBLE, x, y); dswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } else { DefaultOpExecutioner.validateDataType(DataBuffer.Type.FLOAT, x, y); sswap(x.length(), x, BlasBufferUtil.getBlasStride(x), y, BlasBufferUtil.getBlasStride(y)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This cancel entire worker, recursive action. If a scheduler for general scheduling tasks (instead of Executor) this disrupt worker. This is step better, for 100% correct version, a new subscription type is required. java public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) { final long periodInNanos = unit.toNanos(period); final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay); final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription(); final Action0 recursiveAction = new Action0() { long count = 0; @Override public void call() { if (!mas.isUnsubscribed()) { action.call(); long nextTick = startInNanos + (++count * periodInNanos); mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS)); } } }; mas.set(schedule(recursiveAction, initialDelay, unit)); return mas; }'\nThe code is: 'public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) { final long periodInNanos = unit.toNanos(period); final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay); final Action0 recursiveAction = new Action0() { long count = 0; @Override public void call() { if (!isUnsubscribed()) { action.call(); long nextTick = startInNanos + (++count * periodInNanos); schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS); } } }; <START> return Subscriptions.from(this, schedule(recursiveAction, initialDelay, unit)); <END> \/\/ This cancel entire worker, recursive action. If a scheduler for general scheduling tasks (instead of Executor) this disrupt worker. This is step better, for 100% correct version, a new subscription type is required. java public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) { final long periodInNanos = unit.toNanos(period); final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay); final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription(); final Action0 recursiveAction = new Action0() { long count = 0; @Override public void call() { if (!mas.isUnsubscribed()) { action.call(); long nextTick = startInNanos + (++count * periodInNanos); mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS)); } } }; mas.set(schedule(recursiveAction, initialDelay, unit)); return mas; } }'","output":"public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) { final long periodInNanos = unit.toNanos(period); final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay); final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription(); final Action0 recursiveAction = new Action0() { long count = 0; @Override public void call() { if (!mas.isUnsubscribed()) { action.call(); long nextTick = startInNanos + (++count * periodInNanos); mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS)); } } }; mas.set(schedule(recursiveAction, initialDelay, unit)); return mas; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'marking @Nullablewhenever is possible. IDE a lot warn null check in invokers'\nThe code is: '<START> private DataBuffer readChunk() throws IOException { <END> \/\/ marking @Nullablewhenever is possible. IDE a lot warn null check in invokers Preconditions.checkState(!mClient.get().isShutdown(), \"Data reader is closed while reading data chunks.\"); DataBuffer buffer = null; ReadResponse response = null; response = mStream.receive(mDataTimeoutMs); if (response != null) { Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(), \"response should always contain chunk\"); ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer(); buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining()); } else { return null; } mPosToRead += buffer.readableBytes(); try { mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build()); } catch (Exception e) { LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress, mReadRequest, e.getMessage()); } Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength()); return buffer; }'","output":"private DataBuffer readChunk() throws IOException { Preconditions.checkState(!mClient.get().isShutdown(), \"Data reader is closed while reading data chunks.\"); DataBuffer buffer = null; ReadResponse response = null; response = mStream.receive(mDataTimeoutMs); if (response == null) { return null; } Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(), \"response should always contain chunk\"); ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer(); buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining()); mPosToRead += buffer.readableBytes(); try { mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build()); } catch (Exception e) { LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress, mReadRequest, e.getMessage()); } Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength()); return buffer; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'include a baz here, too'\nThe code is: 'public void testGetDocContent_excludedMetadata() throws Exception { options = TestObjectFactory.newConfigOptions( ImmutableMap.of(\"filenet.includedMetadata\", \"foo, bar\", \"filenet.excludedMetadata\", \"bar\")); String id = \"{AAAAAAAA-0000-0000-0000-000000000000}\"; DocId docId = newDocId(new Id(id)); MockObjectStore os = getObjectStore(); mockDocument(os, id, DOCUMENT_TIMESTAMP, RELEASED, 42d, \"text\/plain\", ImmutableList.<Property>of( mockProperty(\"foo\", \"fooValue\"), <START> mockProperty(\"bar\", \"barValue\")), <END> \/\/ include a baz here, too new AccessPermissionListMock(), new ActiveMarkingListMock()); DocumentTraverser traverser = new DocumentTraverser(options); Request request = new MockRequest(docId); RecordingResponse response = new RecordingResponse(); traverser.getDocContent(new Id(id), request, response); assertEquals( new Metadata(ImmutableMap.of(\"foo\", \"fooValue\").entrySet()), response.getMetadata()); }'","output":"public void testGetDocContent_excludedMetadata() throws Exception { options = TestObjectFactory.newConfigOptions( ImmutableMap.of(\"filenet.includedMetadata\", \"foo, bar\", \"filenet.excludedMetadata\", \"bar\")); String id = \"{AAAAAAAA-0000-0000-0000-000000000000}\"; DocId docId = newDocId(new Id(id)); MockObjectStore os = getObjectStore(); mockDocument(os, id, DOCUMENT_TIMESTAMP, RELEASED, 42d, \"text\/plain\", ImmutableList.<Property>of( mockProperty(\"foo\", \"fooValue\"), mockProperty(\"bar\", \"barValue\"), mockProperty(\"baz\", \"bazValue\")), new AccessPermissionListMock(), new ActiveMarkingListMock()); DocumentTraverser traverser = new DocumentTraverser(options); Request request = new MockRequest(docId); RecordingResponse response = new RecordingResponse(); traverser.getDocContent(new Id(id), request, response); assertEquals( new Metadata(ImmutableMap.of(\"foo\", \"fooValue\").entrySet()), response.getMetadata()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet());'\nThe code is: 'public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = \"key_\"; String prefixValue = \"val_\"; List<String> unsetList = client.getAllSessionVariables().entrySet().stream() <START> .map(Map.Entry<String, String>::getKey).collect(Collectors.toList()); <END> \/\/ I next is more readable: java List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }'","output":"public final void testSessionVariables() throws IOException, TajoException, InterruptedException { String prefixName = \"key_\"; String prefixValue = \"val_\"; List<String> unsetList = new ArrayList<>(client.getAllSessionVariables().keySet()); client.unsetSessionVariables(unsetList); for (int i = 0; i < 10; i++) { String key = prefixName + i; String val = prefixValue + i; assertEquals(i + 4, client.getAllSessionVariables().size()); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); Map<String, String> map = Maps.newHashMap(); map.put(key, val); client.updateSessionVariables(map); assertEquals(i + 5, client.getAllSessionVariables().size()); assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); } int totalSessionVarNum = client.getAllSessionVariables().size(); for (int i = 0; i < 10; i++) { String key = prefixName + i; assertTrue(client.getAllSessionVariables().containsKey(key)); assertTrue(client.existSessionVariable(key)); client.unsetSessionVariables(Lists.newArrayList(key)); assertFalse(client.getAllSessionVariables().containsKey(key)); assertFalse(client.existSessionVariable(key)); } assertEquals(totalSessionVarNum - 10, client.getAllSessionVariables().size()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unnecessary casting'\nThe code is: 'public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, \"application argument cannot be null.\"); Assert.notNull(httpRequest, \"httpRequest argument cannot be null.\"); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { <START> this.httpRequest = (HttpRequest) httpRequest; <END> \/\/ unnecessary casting } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, \"The specified httpRequest argument must be an instance of \" + HttpRequest.class.getName() + \" or \" + ServletHttpRequest.class.getName()); this.httpRequest = (ServletHttpRequest) httpRequest; } }'","output":"public DefaultApiRequestAuthenticator(Application application, HttpRequest httpRequest) { Assert.notNull(application, \"application argument cannot be null.\"); Assert.notNull(httpRequest, \"httpRequest argument cannot be null.\"); this.application = application; if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) { this.httpRequest = httpRequest; } else { Assert.isInstanceOf(com.stormpath.sdk.impl.http.ServletHttpRequest.class, httpRequest, \"The specified httpRequest argument must be an instance of \" + HttpRequest.class.getName() + \" or \" + ServletHttpRequest.class.getName()); this.httpRequest = httpRequest; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'file separator? BTW here'\nThe code is: 'private TestResult runAll4x() throws Exception { List<String> testClassNames = new ArrayList<>(); Files.walk(Paths.get(projectPath, \"target\", \"test-classes\")).forEach(filePath -> { if (Files.isRegularFile(filePath) && filePath.toString().toLowerCase().endsWith(\".class\")) { String path = Paths.get(projectPath, \"target\", \"test-classes\").relativize(filePath).toString(); <START> String className = path.replace('\/', '.'); <END> \/\/ file separator? BTW here className = className.replace('\\\\', '.'); className = className.substring(0, className.length() - 6); testClassNames.add(className); } }); List<Class> testableClasses = new ArrayList<>(); for (String className : testClassNames) { Class<?> clazz = Class.forName(className, false, projectClassLoader); if (isTestable4x(clazz)) { testableClasses.add(clazz); } } return run4xTestClasses(testableClasses.toArray(new Class[testableClasses.size()])); }'","output":"private TestResult runAll4x() throws Exception { List<String> testClassNames = new ArrayList<>(); Files.walk(Paths.get(projectPath, \"target\", \"test-classes\")).forEach(filePath -> { if (Files.isRegularFile(filePath) && filePath.toString().toLowerCase().endsWith(\".class\")) { String path = Paths.get(projectPath, \"target\", \"test-classes\").relativize(filePath).toString(); String className = path.replace(File.separatorChar, '.'); className = className.substring(0, className.length() - 6); testClassNames.add(className); } }); List<Class> testableClasses = new ArrayList<>(); for (String className : testClassNames) { Class<?> clazz = Class.forName(className, false, projectClassLoader); if (isTestable4x(clazz)) { testableClasses.add(clazz); } } return run4xTestClasses(testableClasses.toArray(new Class[testableClasses.size()])); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this. This suppresses test failures'\nThe code is: 'public void planCanPointToPublishedSurvey() { GuidCreatedOnVersionHolder surveyKeys = null; GuidVersionHolder keys = null; try { Survey survey = TestSurvey.getSurvey(SchedulePlanTest.class); surveyKeys = developerClient.createSurvey(survey); SchedulePlan plan = Tests.getSimpleSchedulePlan(); SimpleScheduleStrategy strategy = (SimpleScheduleStrategy) plan.getStrategy(); Activity activity = new Activity(\"Test\", null, new SurveyReference(surveyKeys.getGuid(), surveyKeys.getCreatedOn())); assertEquals(ActivityType.SURVEY, activity.getActivityType()); strategy.getSchedule().getActivities().clear(); strategy.getSchedule().getActivities().add(activity); keys = developerClient.createSchedulePlan(plan); SchedulePlan newPlan = developerClient.getSchedulePlan(keys.getGuid()); plan.setGuid(newPlan.getGuid()); plan.setModifiedOn(newPlan.getModifiedOn()); Tests.getActivitiesFromSimpleStrategy(plan).set(0, Tests.getActivityFromSimpleStrategy(newPlan)); assertEquals(plan, newPlan); } catch(Exception e) { <START> e.printStackTrace(); <END> \/\/ Remove this. This suppresses test failures } finally { developerClient.deleteSchedulePlan(keys.getGuid()); admin.getSession().getAdminClient().deleteSurveyPermanently(surveyKeys); } }'","output":"public void planCanPointToPublishedSurvey() { GuidCreatedOnVersionHolder surveyKeys = null; GuidVersionHolder keys = null; try { Survey survey = TestSurvey.getSurvey(SchedulePlanTest.class); surveyKeys = developerClient.createSurvey(survey); SchedulePlan plan = Tests.getSimpleSchedulePlan(); SimpleScheduleStrategy strategy = (SimpleScheduleStrategy) plan.getStrategy(); Activity activity = new Activity(\"Test\", null, new SurveyReference(surveyKeys.getGuid(), surveyKeys.getCreatedOn())); assertEquals(ActivityType.SURVEY, activity.getActivityType()); strategy.getSchedule().getActivities().clear(); strategy.getSchedule().getActivities().add(activity); keys = developerClient.createSchedulePlan(plan); SchedulePlan newPlan = developerClient.getSchedulePlan(keys.getGuid()); plan.setGuid(newPlan.getGuid()); plan.setModifiedOn(newPlan.getModifiedOn()); Tests.getActivitiesFromSimpleStrategy(plan).set(0, Tests.getActivityFromSimpleStrategy(newPlan)); assertEquals(plan, newPlan); } finally { developerClient.deleteSchedulePlan(keys.getGuid()); admin.getSession().getAdminClient().deleteSurveyPermanently(surveyKeys); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add more indent for parameters if start a new line'\nThe code is: 'private JsonToRowDataConverter createMapConverter( <START> String typeSummary, LogicalType keyType, LogicalType valueType) { <END> \/\/ Add more indent for parameters if start a new line if (!LogicalTypeChecks.hasFamily(keyType, LogicalTypeFamily.CHARACTER_STRING)) { throw new UnsupportedOperationException( \"JSON format doesn't support non-string as key type of map. \" + \"The map type is: \" + typeSummary); } final JsonToRowDataConverter keyConverter = createConverter(keyType); final JsonToRowDataConverter valueConverter = createConverter(valueType); return jsonNode -> { Iterator<Map.Entry<String, JsonNode>> fields = jsonNode.fields(); Map<Object, Object> result = new HashMap<>(); while (fields.hasNext()) { Map.Entry<String, JsonNode> entry = fields.next(); Object key = keyConverter.convert(TextNode.valueOf(entry.getKey())); Object value = valueConverter.convert(entry.getValue()); result.put(key, value); } return new GenericMapData(result); }; }'","output":"private JsonToRowDataConverter createMapConverter( String typeSummary, LogicalType keyType, LogicalType valueType) { if (!LogicalTypeChecks.hasFamily(keyType, LogicalTypeFamily.CHARACTER_STRING)) { throw new UnsupportedOperationException( \"JSON format doesn't support non-string as key type of map. \" + \"The type is: \" + typeSummary); } final JsonToRowDataConverter keyConverter = createConverter(keyType); final JsonToRowDataConverter valueConverter = createConverter(valueType); return jsonNode -> { Iterator<Map.Entry<String, JsonNode>> fields = jsonNode.fields(); Map<Object, Object> result = new HashMap<>(); while (fields.hasNext()) { Map.Entry<String, JsonNode> entry = fields.next(); Object key = keyConverter.convert(TextNode.valueOf(entry.getKey())); Object value = valueConverter.convert(entry.getValue()); result.put(key, value); } return new GenericMapData(result); }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a cache mechanism here'\nThe code is: 'private void flatMap(IndexedRecord input, ProcessContext context) throws IOException { python.set(\"inputJSON\", new PyString(input.toString())); python.exec(\"input = json.loads(inputJSON)\"); python.exec(\"outputList = []\"); python.exec(properties.pythonCode.getValue()); python.exec(\"outputJSON = [ json.dumps(outputElement) for outputElement in outputList ]\"); PyObject outputList = python.get(\"outputJSON\"); if (outputList instanceof PyList) { PyList list = (PyList) outputList; for (Object output : list) { <START> JsonSchemaInferrer jsonSchemaInferrer = new JsonSchemaInferrer(new ObjectMapper()); <END> \/\/ a cache mechanism here Schema jsonSchema = jsonSchemaInferrer.inferSchema(output.toString()); JsonGenericRecordConverter jsonGenericRecordConverter = new JsonGenericRecordConverter(jsonSchema); GenericRecord outputRecord = jsonGenericRecordConverter.convertToAvro(output.toString()); context.output(outputRecord); } } }'","output":"private void flatMap(IndexedRecord input, ProcessContext context) throws IOException { python.set(\"inputJSON\", new PyString(input.toString())); python.exec(\"input = json.loads(inputJSON)\"); python.exec(\"outputList = []\"); python.exec(properties.pythonCode.getValue()); python.exec(\"outputJSON = [ json.dumps(outputElement) for outputElement in outputList ]\"); PyObject outputList = python.get(\"outputJSON\"); if (outputList instanceof PyList) { PyList list = (PyList) outputList; for (Object output : list) { if (jsonGenericRecordConverter == null) { JsonSchemaInferrer jsonSchemaInferrer = new JsonSchemaInferrer(new ObjectMapper()); Schema jsonSchema = jsonSchemaInferrer.inferSchema(output.toString()); jsonGenericRecordConverter = new JsonGenericRecordConverter(jsonSchema); } GenericRecord outputRecord = jsonGenericRecordConverter.convertToAvro(output.toString()); context.output(outputRecord); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove this. Tests intent a string a constant here'\nThe code is: 'public void testLength() { testingClient.server(\"passwordPolicy\").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); <START> realmModel.setPasswordPolicy(PasswordPolicy.parse(session, LengthPasswordPolicyProviderFactory.ID)); <END> \/\/ Please remove this. Tests intent a string a constant here Assert.assertEquals(\"invalidPasswordMinLengthMessage\", policyManager.validate(\"jdoe\", \"1234567\").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(\"jdoe\", \"1234567\").getParameters()); assertNull(policyManager.validate(\"jdoe\", \"12345678\")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, \"length(4)\")); Assert.assertEquals(\"invalidPasswordMinLengthMessage\", policyManager.validate(\"jdoe\", \"123\").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(\"jdoe\", \"123\").getParameters()); assertNull(policyManager.validate(\"jdoe\", \"1234\")); }); }'","output":"public void testLength() { testingClient.server(\"passwordPolicy\").run(session -> { RealmModel realmModel = session.getContext().getRealm(); PasswordPolicyManagerProvider policyManager = session.getProvider(PasswordPolicyManagerProvider.class); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, \"length\")); Assert.assertEquals(\"invalidPasswordMinLengthMessage\", policyManager.validate(\"jdoe\", \"1234567\").getMessage()); Assert.assertArrayEquals(new Object[]{8}, policyManager.validate(\"jdoe\", \"1234567\").getParameters()); assertNull(policyManager.validate(\"jdoe\", \"12345678\")); realmModel.setPasswordPolicy(PasswordPolicy.parse(session, \"length(4)\")); Assert.assertEquals(\"invalidPasswordMinLengthMessage\", policyManager.validate(\"jdoe\", \"123\").getMessage()); Assert.assertArrayEquals(new Object[]{4}, policyManager.validate(\"jdoe\", \"123\").getParameters()); assertNull(policyManager.validate(\"jdoe\", \"1234\")); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Attribute handling git transports? Is this required'\nThe code is: 'WalkFetchConnection(final WalkTransport t, final WalkRemoteObjectDatabase w) { Transport wt = (Transport)t; local = wt.local; objCheck = wt.getObjectChecker(); inserter = local.newObjectInserter(); reader = local.newObjectReader(); remotes = new ArrayList<WalkRemoteObjectDatabase>(); remotes.add(w); unfetchedPacks = new LinkedList<RemotePack>(); packsConsidered = new HashSet<String>(); noPacksYet = new LinkedList<WalkRemoteObjectDatabase>(); noPacksYet.add(w); noAlternatesYet = new LinkedList<WalkRemoteObjectDatabase>(); noAlternatesYet.add(w); fetchErrors = new HashMap<ObjectId, List<Throwable>>(); packLocks = new ArrayList<PackLock>(4); revWalk = new RevWalk(reader); revWalk.setRetainBody(false); <START> treeWalk = new TreeWalk(local, reader); <END> \/\/ Attribute handling git transports? Is this required COMPLETE = revWalk.newFlag(\"COMPLETE\"); IN_WORK_QUEUE = revWalk.newFlag(\"IN_WORK_QUEUE\"); LOCALLY_SEEN = revWalk.newFlag(\"LOCALLY_SEEN\"); localCommitQueue = new DateRevQueue(); workQueue = new LinkedList<ObjectId>(); }'","output":"WalkFetchConnection(final WalkTransport t, final WalkRemoteObjectDatabase w) { Transport wt = (Transport)t; local = wt.local; objCheck = wt.getObjectChecker(); inserter = local.newObjectInserter(); reader = local.newObjectReader(); remotes = new ArrayList<WalkRemoteObjectDatabase>(); remotes.add(w); unfetchedPacks = new LinkedList<RemotePack>(); packsConsidered = new HashSet<String>(); noPacksYet = new LinkedList<WalkRemoteObjectDatabase>(); noPacksYet.add(w); noAlternatesYet = new LinkedList<WalkRemoteObjectDatabase>(); noAlternatesYet.add(w); fetchErrors = new HashMap<ObjectId, List<Throwable>>(); packLocks = new ArrayList<PackLock>(4); revWalk = new RevWalk(reader); revWalk.setRetainBody(false); treeWalk = new TreeWalk(reader); COMPLETE = revWalk.newFlag(\"COMPLETE\"); IN_WORK_QUEUE = revWalk.newFlag(\"IN_WORK_QUEUE\"); LOCALLY_SEEN = revWalk.newFlag(\"LOCALLY_SEEN\"); localCommitQueue = new DateRevQueue(); workQueue = new LinkedList<ObjectId>(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tumorSample is'\nThe code is: 'public void onTraversalStart() { final VCFHeader inputHeader = getHeaderForVariants(); <START> final String tumorSample = inputHeader.getMetaDataLine(Mutect2Engine.TUMOR_SAMPLE_KEY_IN_VCF_HEADER).getValue(); <END> \/\/ tumorSample is final Set<VCFHeaderLine> headerLines = new HashSet<>(inputHeader.getMetaDataInSortedOrder()); Mutect2FilteringEngine.M_2_FILTER_NAMES.stream().map(GATKVCFHeaderLines::getFilterLine).forEach(headerLines::add); headerLines.add(new VCFFilterHeaderLine(Mutect2FilteringEngine.ARTIFACT_IN_NORMAL_FILTER_NAME, \"artifact_in_normal\")); headerLines.add(new VCFFilterHeaderLine(Mutect2FilteringEngine.CONTAMINATION_FILTER_NAME, \"contamination\")); final VCFHeader vcfHeader = new VCFHeader(headerLines, inputHeader.getGenotypeSamples()); vcfWriter = createVCFWriter(new File(outputVcf)); vcfWriter.writeHeader(vcfHeader); }'","output":"public void onTraversalStart() { final VCFHeader inputHeader = getHeaderForVariants(); final Set<VCFHeaderLine> headerLines = new HashSet<>(inputHeader.getMetaDataInSortedOrder()); Mutect2FilteringEngine.M_2_FILTER_NAMES.stream().map(GATKVCFHeaderLines::getFilterLine).forEach(headerLines::add); headerLines.add(new VCFFilterHeaderLine(Mutect2FilteringEngine.ARTIFACT_IN_NORMAL_FILTER_NAME, \"artifact_in_normal\")); headerLines.add(new VCFFilterHeaderLine(Mutect2FilteringEngine.CONTAMINATION_FILTER_NAME, \"contamination\")); final VCFHeader vcfHeader = new VCFHeader(headerLines, inputHeader.getGenotypeSamples()); vcfWriter = createVCFWriter(new File(outputVcf)); vcfWriter.writeHeader(vcfHeader); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this added? replaceTextBox_ accessible label FormLabel replaceLabel'\nThe code is: 'protected SecondaryToolbar createSecondaryToolbar() { SecondaryToolbar replaceToolbar = new SecondaryToolbar(\"Replace\"); replaceMode_ = true; replaceTextBox_ = new TextBox(); replaceTextBox_.addKeyUpHandler(new KeyUpHandler() { public void onKeyUp(KeyUpEvent event) { displayPreview_.nudge(); } }); FormLabel replaceLabel = new FormLabel(\"Replace with: \", replaceTextBox_); replaceToolbar.addLeftWidget(replaceLabel); replaceToolbar.addLeftWidget(replaceTextBox_); <START> Roles.getButtonRole().setAriaLabelProperty(replaceTextBox_.getElement(), \"Replace with\"); <END> \/\/ this added? replaceTextBox_ accessible label FormLabel replaceLabel stopReplace_ = new ToolbarButton( ToolbarButton.NoText, \"Stop replace\", commands_.interruptR().getImageResource()); stopReplace_.setVisible(false); replaceToolbar.addRightWidget(stopReplace_); replaceAllButton_ = new ToolbarButton(\"Replace All\", \"Replace All\", null); replaceToolbar.addRightWidget(replaceAllButton_); replaceProgress_ = new ProgressBar(); replaceProgress_.setHeight(\"10px\"); replaceProgress_.setWidth(\"195px\"); replaceProgress_.setVisible(false); replaceToolbar.addLeftWidget(replaceProgress_); return replaceToolbar; }'","output":"protected SecondaryToolbar createSecondaryToolbar() { SecondaryToolbar replaceToolbar = new SecondaryToolbar(\"Replace\"); replaceMode_ = true; replaceTextBox_ = new TextBox(); replaceTextBox_.addKeyUpHandler(new KeyUpHandler() { public void onKeyUp(KeyUpEvent event) { displayPreview_.nudge(); } }); FormLabel replaceLabel = new FormLabel(\"Replace with: \", replaceTextBox_); replaceToolbar.addLeftWidget(replaceLabel); replaceToolbar.addLeftWidget(replaceTextBox_); stopReplace_ = new ToolbarButton( ToolbarButton.NoText, \"Stop replace\", commands_.interruptR().getImageResource()); stopReplace_.setVisible(false); replaceToolbar.addRightWidget(stopReplace_); replaceAllButton_ = new ToolbarButton(\"Replace All\", \"Replace All\", null); replaceToolbar.addRightWidget(replaceAllButton_); replaceProgress_ = new ProgressBar(); replaceProgress_.setHeight(\"10px\"); replaceProgress_.setWidth(\"195px\"); replaceProgress_.setVisible(false); replaceToolbar.addLeftWidget(replaceProgress_); return replaceToolbar; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@jrmartin check if a exception catch'\nThe code is: 'public void sendFile(Path path) { try { long startTime = System.currentTimeMillis(); byte[] name = path.getFileName().toString().getBytes(\"UTF-8\"); byte[] data = Files.readAllBytes(path); byte[] array = BigInteger.valueOf(1).toByteArray(); byte[] array2 = BigInteger.valueOf(name.length).toByteArray(); int bufferSize = (array.length + array2.length + name.length + data.length) * 2; ByteBuffer buffer = ByteBuffer.allocate(bufferSize); buffer.put(array); buffer.put(array2); buffer.put(name); buffer.put(data); buffer.flip(); System.out.println(\"Last Session Binary size >> \" + wsOutbound.getMaxBinaryMessageBufferSize()); System.out.println(\"Last Session Text size >> \" + wsOutbound.getMaxTextMessageBufferSize()); synchronized(wsOutbound) { if (wsOutbound.isOpen()) { wsOutbound.getBasicRemote().sendBinary(buffer); } } String debug = ((long) System.currentTimeMillis() - startTime) + \"ms were spent sending a file of \" + bufferSize \/ 1024 + \"KB to the client\"; logger.info(debug); } <START> catch(Exception e) <END> \/\/ @jrmartin check if a exception catch { logger.warn(\"Failed to send file, \" + path, e); notifyListeners(MessageSenderEvent.Type.MESSAGE_SEND_FAILED); } }'","output":"public void sendFile(Path path) { try { long startTime = System.currentTimeMillis(); byte[] name = path.getFileName().toString().getBytes(\"UTF-8\"); byte[] data = Files.readAllBytes(path); byte[] array = BigInteger.valueOf(1).toByteArray(); byte[] array2 = BigInteger.valueOf(name.length).toByteArray(); int bufferSize = (array.length + array2.length + name.length + data.length) * 2; ByteBuffer buffer = ByteBuffer.allocate(bufferSize); buffer.put(array); buffer.put(array2); buffer.put(name); buffer.put(data); buffer.flip(); System.out.println(\"Last Session Binary size >> \" + wsOutbound.getMaxBinaryMessageBufferSize()); System.out.println(\"Last Session Text size >> \" + wsOutbound.getMaxTextMessageBufferSize()); synchronized(wsOutbound) { if (wsOutbound.isOpen()) { wsOutbound.getBasicRemote().sendBinary(buffer); } } String debug = ((long) System.currentTimeMillis() - startTime) + \"ms were spent sending a file of \" + bufferSize \/ 1024 + \"KB to the client\"; logger.info(debug); } catch(IOException e) { logger.warn(\"Failed to send file, \" + path, e); notifyListeners(MessageSenderEvent.Type.MESSAGE_SEND_FAILED); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Huh?!?!? wrong before? (Well, logic is a bit weird is fault do need extract out a local variable first?)'\nThe code is: 'public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(\"Card operation task spent {} ms in queue\", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(\"CardExecutor Service delay - queue_wait_time={}\", totalWaitTime); } metricRegistry.histogram(\"card-executor.delay\").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { <START> Throwable cause = exception.getCause(); <END> \/\/ Huh?!?!? wrong before? (Well, logic is a bit weird is fault do need extract out a local variable first?) if (cause instanceof WebApplicationException) { throw (WebApplicationException) cause; } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }'","output":"public Pair<ExecutionStatus, T> execute(Supplier<T> callable) { Callable<T> task = callable::get; final long startTime = System.currentTimeMillis(); Future<T> futureObject = executor.submit(() -> { xrayUtils.beginSegment(); long totalWaitTime = System.currentTimeMillis() - startTime; logger.debug(\"Card operation task spent {} ms in queue\", totalWaitTime); if (totalWaitTime > QUEUE_WAIT_WARN_THRESHOLD_MILLIS) { logger.warn(\"CardExecutor Service delay - queue_wait_time={}\", totalWaitTime); } metricRegistry.histogram(\"card-executor.delay\").update(totalWaitTime); try { return task.call(); } finally { xrayUtils.endSegment(); } }); try { return Pair.of(COMPLETED, futureObject.get(config.getTimeoutInSeconds(), TimeUnit.SECONDS)); } catch (ExecutionException | InterruptedException exception) { if (exception.getCause() instanceof WebApplicationException) { throw (WebApplicationException) exception.getCause(); } return Pair.of(FAILED, null); } catch (TimeoutException timeoutException) { return Pair.of(IN_PROGRESS, null); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This removed now'\nThe code is: 'private void migrateLabelsToAllProjects(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException, RepositoryNotFoundException, IOException, ConfigInvalidException { Repository git = mgr.openRepository(allProjects); try { MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjects, git); md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); ProjectConfig config = ProjectConfig.read(md); Map<String, LabelType> configTypes = config.getLabelSections(); List<LabelType> newTypes = Lists.newArrayList(); for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) { <START> type.setId(null); <END> \/\/ This removed now if (!configTypes.containsKey(type.getName())) { newTypes.add(type); } } newTypes.addAll(configTypes.values()); configTypes.clear(); for (LabelType type : newTypes) { configTypes.put(type.getName(), type); } md.setMessage(\"Upgrade to Gerrit Code Review schema 77\\n\"); config.commit(md); } finally { git.close(); } }'","output":"private void migrateLabelsToAllProjects(ReviewDb db, LegacyLabelTypes labelTypes) throws SQLException, RepositoryNotFoundException, IOException, ConfigInvalidException { Repository git = mgr.openRepository(allProjects); try { MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjects, git); md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); ProjectConfig config = ProjectConfig.read(md); Map<String, LabelType> configTypes = config.getLabelSections(); List<LabelType> newTypes = Lists.newArrayList(); for (LegacyLabelType type : labelTypes.getLegacyLabelTypes()) { if (!configTypes.containsKey(type.getName())) { newTypes.add(type); } } newTypes.addAll(configTypes.values()); configTypes.clear(); for (LabelType type : newTypes) { configTypes.put(type.getName(), type); } md.setMessage(\"Upgrade to Gerrit Code Review schema 77\\n\"); config.commit(md); } finally { git.close(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add curly braces else block. Also, falling a default-constructed ReferenceSource (I believe) eventually produce a NullPointerException deep in cram parsing code provided Defaults.USE_CRAM_REF_DOWNLOAD is false (which is default). I throw if referenceSource is null Defaults.USE_CRAM_REF_DOWNLOAD is false'\nThe code is: 'public CRAMIterator(final InputStream inputStream, final ReferenceSource referenceSource) throws IOException { if (null == referenceSource) { this.referenceSource = new ReferenceSource(); } else <START> this.referenceSource = referenceSource; <END> \/\/ Add curly braces else block. Also, falling a default-constructed ReferenceSource (I believe) eventually produce a NullPointerException deep in cram parsing code provided Defaults.USE_CRAM_REF_DOWNLOAD is false (which is default). I throw if referenceSource is null Defaults.USE_CRAM_REF_DOWNLOAD is false this.countingInputStream = new CountingInputStream(inputStream); final CramContainerIterator containerIterator = new CramContainerIterator(this.countingInputStream); cramHeader = containerIterator.getCramHeader(); this.containerIterator = containerIterator; firstContainerOffset = this.countingInputStream.getCount(); records = new ArrayList<SAMRecord>(10000); normalizer = new CramNormalizer(cramHeader.getSamFileHeader(), referenceSource); parser = new ContainerParser(cramHeader.getSamFileHeader()); }'","output":"public CRAMIterator(final InputStream inputStream, final ReferenceSource referenceSource) throws IOException { if (null == referenceSource) { throw new CRAMException(\"A reference source is required for CRAM files\"); } this.countingInputStream = new CountingInputStream(inputStream); this.referenceSource = referenceSource; final CramContainerIterator containerIterator = new CramContainerIterator(this.countingInputStream); cramHeader = containerIterator.getCramHeader(); this.containerIterator = containerIterator; firstContainerOffset = this.countingInputStream.getCount(); records = new ArrayList<SAMRecord>(10000); normalizer = new CramNormalizer(cramHeader.getSamFileHeader(), referenceSource); parser = new ContainerParser(cramHeader.getSamFileHeader()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a debugging print removed'\nThe code is: 'public void testDoPost() throws IOException, ServletException { when(request.getParameter(\"connectionName\")).thenReturn(\"test-db-name\"); when(request.getParameter(\"databaseType\")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(\"databaseServer\")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(\"databasePort\")).thenReturn(\"\" + testDbConfig.getDatabasePort()); when(request.getParameter(\"databaseUser\")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(\"databasePassword\")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(\"initialDatabase\")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), \"Valid response Message expected!\"); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); <START> System.out.println(\"json:\" + json); <END> \/\/ This a debugging print removed ArrayNode savedConnections = (ArrayNode) json.get(\"savedConnections\"); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }'","output":"public void testDoPost() throws IOException, ServletException { when(request.getParameter(\"connectionName\")).thenReturn(\"test-db-name\"); when(request.getParameter(\"databaseType\")).thenReturn(MySQLDatabaseService.DB_NAME); when(request.getParameter(\"databaseServer\")).thenReturn(testDbConfig.getDatabaseHost()); when(request.getParameter(\"databasePort\")).thenReturn(\"\" + testDbConfig.getDatabasePort()); when(request.getParameter(\"databaseUser\")).thenReturn(testDbConfig.getDatabaseUser()); when(request.getParameter(\"databasePassword\")).thenReturn(testDbConfig.getDatabasePassword()); when(request.getParameter(\"initialDatabase\")).thenReturn(testDbConfig.getDatabaseName()); StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); when(response.getWriter()).thenReturn(pw); SUT.doPost(request, response); String result = sw.getBuffer().toString().trim(); assertNotNull(result); assertFalse(result.isEmpty(), \"Valid response Message expected!\"); ObjectNode json = ParsingUtilities.mapper.readValue(result, ObjectNode.class); ArrayNode savedConnections = (ArrayNode) json.get(\"savedConnections\"); Assert.assertNotNull(savedConnections); int len = savedConnections.size(); Assert.assertEquals(len, 1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this needed? this evaluate true menu is built this point in time'\nThe code is: 'private void addComponentDescriptorButtons(JToolBar toolBar) { final DescriptorProvider descriptorProvider = _analysisJobBuilder.getConfiguration().getDescriptorProvider(); final Set<ComponentSuperCategory> superCategories = descriptorProvider.getComponentSuperCategories(); for (ComponentSuperCategory superCategory : superCategories) { final String name = superCategory.getName(); final String description = \"<html><b>\" + name + \"<\/b><br\/>\" + superCategory.getDescription() + \"<\/html>\"; final PopupButton popupButton = new PopupButton(name); applyMenuPopupButttonStyling(popupButton); DCPopupBubble popupBubble = new DCPopupBubble(_glassPane, description, 0, 0, IconUtils.getComponentSuperCategoryIcon(superCategory)); popupBubble.attachTo(popupButton, new DCPopupBubble.PopupCallback() { @Override public boolean onBeforeShow() { for(PopupButton scButton : _superCategoryButtons) { if(scButton.isSelected()){ return false; } } return true; } }); final JPopupMenu menu = popupButton.getMenu(); final DescriptorMenuBuilder menuBuilder = new DescriptorMenuBuilder(_analysisJobBuilder, _usageLogger, superCategory, null); menuBuilder.addItemsToPopupMenu(menu); <START> if (menu.isVisible()) { <END> \/\/ Is this needed? this evaluate true menu is built this point in time popupBubble.hide(); } toolBar.add(popupButton); _superCategoryButtons.add(popupButton); } }'","output":"private void addComponentDescriptorButtons(JToolBar toolBar) { final DescriptorProvider descriptorProvider = _analysisJobBuilder.getConfiguration().getDescriptorProvider(); final Set<ComponentSuperCategory> superCategories = descriptorProvider.getComponentSuperCategories(); for (ComponentSuperCategory superCategory : superCategories) { final String name = superCategory.getName(); final String description = \"<html><b>\" + name + \"<\/b><br\/>\" + superCategory.getDescription() + \"<\/html>\"; final PopupButton popupButton = new PopupButton(name); applyMenuPopupButttonStyling(popupButton); DCPopupBubble popupBubble = new DCPopupBubble(_glassPane, description, 0, 0, IconUtils.getComponentSuperCategoryIcon(superCategory)); popupBubble.attachTo(popupButton, new DCPopupBubble.PopupCallback() { @Override public boolean onBeforeShow() { for(PopupButton scButton : _superCategoryButtons) { if(scButton.isSelected()){ return false; } } return true; } }); final JPopupMenu menu = popupButton.getMenu(); final DescriptorMenuBuilder menuBuilder = new DescriptorMenuBuilder(_analysisJobBuilder, _usageLogger, superCategory, null); menuBuilder.addItemsToPopupMenu(menu); toolBar.add(popupButton); _superCategoryButtons.add(popupButton); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this UnchargedIdentityDisk'\nThe code is: 'private void placeItemsOnBoard() { int numberOfItems = 0; while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_GRENADES) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { ((Square) grid.get(position)).addItem(new LightGrenade()); numberOfItems++; } } numberOfItems = 0; List<Teleporter> teleporters = new ArrayList<>(); while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_TELEPORTERS) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { Teleporter teleporter = new Teleporter(getTeleporterDestination(teleporters), grid.get(position)); ((Square) grid.get(position)).addItem(teleporter); teleporters.add(teleporter); numberOfItems++; } } teleporters.remove(0); teleporters.get(0).setDestination(getTeleporterDestination(teleporters)); numberOfItems = 0; while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_IDENTITY_DISKS) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { <START> ((Square) grid.get(position)).addItem(new ChargedIdentityDisk()); <END> \/\/ this UnchargedIdentityDisk numberOfItems++; } } }'","output":"private void placeItemsOnBoard() { int numberOfItems = 0; while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_GRENADES) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { ((Square) grid.get(position)).addItem(new LightGrenade()); numberOfItems++; } } numberOfItems = 0; List<Teleporter> teleporters = new ArrayList<>(); while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_TELEPORTERS) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { Teleporter teleporter = new Teleporter(getTeleporterDestination(teleporters), grid.get(position)); ((Square) grid.get(position)).addItem(teleporter); teleporters.add(teleporter); numberOfItems++; } } teleporters.remove(0); teleporters.get(0).setDestination(getTeleporterDestination(teleporters)); numberOfItems = 0; while (((double) numberOfItems) \/ grid.size() < NUMBER_OF_IDENTITY_DISKS) { Coordinate position = Coordinate.random(width, height); if (canPlaceItem(position)) { ((Square) grid.get(position)).addItem(new UnchargedIdentityDisk()); numberOfItems++; } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this null, empty string'\nThe code is: 'public Response deleteToken(@ApiParam(hidden = true) @Auth User user, @ApiParam(value = \"Token id to delete\", required = true) @PathParam(\"tokenId\") Long tokenId) { Token token = tokenDAO.findById(tokenId); checkUser(user, token.getUserId()); cachingAuthenticator.invalidate(token.getContent()); tokenDAO.delete(token); if (token.getTokenSource() == TokenType.ORCID_ORG) { User byId = userDAO.findById(user.getId()); <START> byId.setOrcid(\"\"); <END> \/\/ I this null, empty string } token = tokenDAO.findById(tokenId); if (token == null) { return Response.noContent().build(); } else { return Response.serverError().build(); } }'","output":"public Response deleteToken(@ApiParam(hidden = true) @Auth User user, @ApiParam(value = \"Token id to delete\", required = true) @PathParam(\"tokenId\") Long tokenId) { Token token = tokenDAO.findById(tokenId); checkUser(user, token.getUserId()); cachingAuthenticator.invalidate(token.getContent()); tokenDAO.delete(token); if (token.getTokenSource() == TokenType.ORCID_ORG) { User byId = userDAO.findById(user.getId()); byId.setOrcid(null); } token = tokenDAO.findById(tokenId); if (token == null) { return Response.noContent().build(); } else { return Response.serverError().build(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'able pass m here'\nThe code is: 'static Map<String, Consumer<Object>> setAttributeConsumers(AzureBlobFileAttributeView view) { Map<String, Consumer<Object>> map = new HashMap<>(); map.put(\"blobHttpHeaders\", obj -> { try { view.setBlobHttpHeaders((BlobHttpHeaders) obj); } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); map.put(\"metadata\", obj -> { try { Map<String, String> m = (Map<String, String>) obj; if (m == null) { throw LoggingUtility.logError(view.logger, new ClassCastException()); } <START> view.setMetadata((Map<String, String>) obj); <END> \/\/ able pass m here } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); map.put(\"tier\", obj -> { try { view.setTier((AccessTier) obj); } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); return map; }'","output":"static Map<String, Consumer<Object>> setAttributeConsumers(AzureBlobFileAttributeView view) { Map<String, Consumer<Object>> map = new HashMap<>(); map.put(\"blobHttpHeaders\", obj -> { try { view.setBlobHttpHeaders((BlobHttpHeaders) obj); } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); map.put(\"metadata\", obj -> { try { Map<String, String> m = (Map<String, String>) obj; if (m == null) { throw LoggingUtility.logError(view.logger, new ClassCastException()); } view.setMetadata(m); } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); map.put(\"tier\", obj -> { try { view.setTier((AccessTier) obj); } catch (IOException e) { throw LoggingUtility.logError(view.logger, new UncheckedIOException(ATTR_CONSUMER_ERROR, e)); } }); return map; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ditto, missing fail() call'\nThe code is: 'public void shouldRecordOnlyFirstErrorBeforeGetOnFailedCompletion() throws Exception { final Throwable expectedError = new Throwable(); TestConvertingFutureCallback testCallback = new TestConvertingFutureCallback(); testCallback.onCompletion(expectedError, null); testCallback.onCompletion(new RuntimeException(), null); testCallback.cancel(true); testCallback.onCompletion(null, \"420\"); assertEquals(0, testCallback.numberOfConversions()); try { <START> testCallback.get(); <END> \/\/ ditto, missing fail() call } catch (ExecutionException e) { assertEquals(expectedError, e.getCause()); } }'","output":"public void shouldRecordOnlyFirstErrorBeforeGetOnFailedCompletion() throws Exception { final Throwable expectedError = new Throwable(); TestConvertingFutureCallback testCallback = new TestConvertingFutureCallback(); testCallback.onCompletion(expectedError, null); testCallback.onCompletion(new RuntimeException(), null); testCallback.cancel(true); testCallback.onCompletion(null, \"420\"); assertEquals(0, testCallback.numberOfConversions()); try { testCallback.get(); fail(\"Expected ExecutionException\"); } catch (ExecutionException e) { assertEquals(expectedError, e.getCause()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: a line'\nThe code is: '<START> @Test public void test() { <END> \/\/ nit: a line byte[] key = new byte[1024]; int[] position = new int[slots.size()]; int offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }'","output":"public void test() { byte[] key = new byte[1024]; int[] position = new int[slots.size()]; int offset = ScanUtil.setKey(schema, slots, ScanUtil.getDefaultSlotSpans(slots.size()), position, bound, key, 0, 0, slots.size()); byte[] actualKey = new byte[offset]; System.arraycopy(key, 0, actualKey, 0, offset); assertArrayEquals(expectedKey, actualKey); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplify this part a bit: java String name = author.map(TurboUser::getRealName) .orElse(\"\").toLowerCase();'\nThe code is: 'private boolean authorSatisfies(IModel model, TurboIssue issue) { if (!content.isPresent()) return false; Optional<TurboUser> author = model.getAuthorOfIssue(issue); String content = this.content.get().toLowerCase(); String login = issue.getCreator().toLowerCase(); String name = \"\"; if (author.isPresent()) { name = author.get().getRealName() == null ? \"\" : author.get().getRealName().toLowerCase(); <START> } <END> \/\/ simplify this part a bit: java String name = author.map(TurboUser::getRealName) .orElse(\"\").toLowerCase(); return login.contains(content) || name.contains(content); }'","output":"private boolean authorSatisfies(IModel model, TurboIssue issue) { if (!content.isPresent()) return false; Optional<TurboUser> author = model.getAuthorOfIssue(issue); String content = this.content.get().toLowerCase(); String login = issue.getCreator().toLowerCase(); String name = author.map(TurboUser::getRealName).orElse(\"\").toLowerCase(); return login.contains(content) || name.contains(content); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I rewrite in more Single Responsibility Principle style java private Map<String, String> toMachineAttributes(String pluginId, Map<String, String> wsAttributes) { Map<String, String> attributes = new HashMap<>(); Optional<String> pluginAlias = findPluginAlias(pluginId, wsAttributes); pluginAlias.ifPresent(s -> attributes.put(DEVFILE_COMPONENT_ALIAS_ATTRIBUTE, s)); return attributes; } private Optional<String> findPluginAlias(String pluginId, Map<String, String> wsAttributes) { List<String> aliases = new ArrayList<>(); String pluginComponentAliases = wsAttributes.get(PLUGINS_COMPONENTS_ALIASES_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(pluginComponentAliases)) { aliases.addAll(asList(pluginComponentAliases.split(\",\"))); } String editorComponentAlias = wsAttributes.get(EDITOR_COMPONENT_ALIAS_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(editorComponentAlias)) { aliases.add(editorComponentAlias); } if (aliases.isEmpty()) { return Optional.empty(); } return aliases .stream() .map(value -> value.split(\"=\")) .filter(arr -> arr[0].equals(pluginId)) .map(arr -> arr[1]) .findAny(); }'\nThe code is: '<START> private Map<String, String> toMachineAttributes( <END> \/\/ I rewrite in more Single Responsibility Principle style java private Map<String, String> toMachineAttributes(String pluginId, Map<String, String> wsAttributes) { Map<String, String> attributes = new HashMap<>(); Optional<String> pluginAlias = findPluginAlias(pluginId, wsAttributes); pluginAlias.ifPresent(s -> attributes.put(DEVFILE_COMPONENT_ALIAS_ATTRIBUTE, s)); return attributes; } private Optional<String> findPluginAlias(String pluginId, Map<String, String> wsAttributes) { List<String> aliases = new ArrayList<>(); String pluginComponentAliases = wsAttributes.get(PLUGINS_COMPONENTS_ALIASES_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(pluginComponentAliases)) { aliases.addAll(asList(pluginComponentAliases.split(\",\"))); } String editorComponentAlias = wsAttributes.get(EDITOR_COMPONENT_ALIAS_WORKSPACE_ATTRIBUTE); if (!isNullOrEmpty(editorComponentAlias)) { aliases.add(editorComponentAlias); } if (aliases.isEmpty()) { return Optional.empty(); } return aliases .stream() .map(value -> value.split(\"=\")) .filter(arr -> arr[0].equals(pluginId)) .map(arr -> arr[1]) .findAny(); } String pluginId, Map<String, String> wsAttributes) { String pluginComponentAliases = wsAttributes.get(PLUGINS_COMPONENTS_ALIASES_WORKSPACE_ATTRIBUTE); String editorComponentAlias = wsAttributes.get(EDITOR_COMPONENT_ALIAS_WORKSPACE_ATTRIBUTE); List<String> aliases = new ArrayList<>(); if (!isNullOrEmpty(pluginComponentAliases)) { aliases.addAll(asList(pluginComponentAliases.split(\",\"))); } if (!isNullOrEmpty(editorComponentAlias)) { aliases.add(editorComponentAlias); } if (!aliases.isEmpty()) { return aliases .stream() .map(value -> value.split(\"=\")) .filter(arr -> arr[0].equals(pluginId)) .map(arr -> arr[1]) .collect(toMap(alias -> DEVFILE_COMPONENT_ALIAS_ATTRIBUTE, Function.identity())); } return null; }'","output":"private Map<String, String> toMachineAttributes( String pluginId, Map<String, String> wsAttributes) { Map<String, String> attributes = new HashMap<>(); Optional<String> pluginAlias = findPluginAlias(pluginId, wsAttributes); pluginAlias.ifPresent(s -> attributes.put(DEVFILE_COMPONENT_ALIAS_ATTRIBUTE, s)); return attributes; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's == null'\nThe code is: 'public static boolean isNormalSequence(final String s) { <START> if (s.length() == 0) { <END> \/\/ s == null return false; } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }'","output":"public static boolean isNormalSequence(final String s) { if (s == null || s.length() == 0) { return false; } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); if (ch == A || ch == T || ch == C || ch == G || ch == a || ch == t || ch == c || ch == g || ch == n || ch == N) { ; } else { return false; } } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I want containsOnly containsExactly'\nThe code is: '@Test public void basicInjectionWithExtension() { ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule()); RealSingleton rs = root.get(RealSingleton.class); <START> assertThat(rs.ints).contains(0, 1); <END> \/\/ I want containsOnly containsExactly ObjectGraph extension = root.plus(new ExtensionModule()); Main main = extension.get(Main.class); assertThat(main.ints).contains(0, 1, 2, 3); ObjectGraph extension2 = root.plus(new ExtensionModule()); Main main2 = extension2.get(Main.class); assertThat(main2.ints).contains(0, 1, 4, 5); }'","output":"@Test public void basicInjectionWithExtension() { ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule()); RealSingleton rs = root.get(RealSingleton.class); assertThat(rs.ints).containsOnly(0, 1); ObjectGraph extension = root.plus(new ExtensionModule()); Main main = extension.get(Main.class); assertThat(main.ints).containsOnly(0, 1, 2, 3); ObjectGraph extension2 = root.plus(new ExtensionModule()); Main main2 = extension2.get(Main.class); assertThat(main2.ints).containsOnly(0, 1, 4, 5); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'skip loop now'\nThe code is: 'private boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); boolean match = false; for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + \"\/geoserver.action\")) { <START> match = true; <END> \/\/ skip loop now } } } return match; }'","output":"private boolean isAllowed(MutableHttpServletRequest request, String paramName) { String layersParam = request.getParameterIgnoreCase(paramName); List<Layer> all = layerService.findAll(); boolean match = false; for (Layer layer : all) { if (layer.getSource() instanceof ImageWmsLayerDataSource) { ImageWmsLayerDataSource source = (ImageWmsLayerDataSource) layer.getSource(); if (source.getLayerNames().equalsIgnoreCase(layersParam) && source.getUrl().equalsIgnoreCase(request.getContextPath() + \"\/geoserver.action\")) { match = true; break; } } } return match; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change lambda's arg name more expressive 'file''\nThe code is: 'private static List<File> search(File[] mounts, boolean isDirectChild) { List<File> candidates = new ArrayList<>(); for ( File f : mounts ) { if ( f.exists() && f.isDirectory() ) { if ( isDirectChild ) { if ( hasOdkInstancesDirectory(f) ) { candidates.add(f); } } else { <START> File[] subdirs = f.listFiles(f1 -> f1.isDirectory()); <END> \/\/ Change lambda's arg name more expressive 'file' for ( File s : subdirs ) { if ( hasOdkInstancesDirectory(s) ) { candidates.add(s); } } } } } return candidates; }'","output":"private static List<File> search(File[] mounts, boolean isDirectChild) { List<File> candidates = new ArrayList<>(); for ( File f : mounts ) { if ( f.exists() && f.isDirectory() ) { if ( isDirectChild ) { if ( hasOdkInstancesDirectory(f) ) { candidates.add(f); } } else { File[] subdirs = f.listFiles(file -> file.isDirectory()); for ( File s : subdirs ) { if ( hasOdkInstancesDirectory(s) ) { candidates.add(s); } } } } } return candidates; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a logger.info instead of a System.out.println'\nThe code is: 'public void execute() throws Exception { try { DataModel model = getParser().getDataModels().get(0); DataLoadTimeSummary dataLoadTimeSummary = new DataLoadTimeSummary(); DataLoadThreadTime dataLoadThreadTime = new DataLoadThreadTime(); for (Scenario scenario : getParser().getScenarios()) { List<Future> writeBatches = new ArrayList<Future>(); logger.info(\"\\nLoading \" + scenario.getRowCount() + \" rows for \" + scenario.getTableName()); long start = System.currentTimeMillis(); RowCalculator rowCalculator = new RowCalculator(getThreadPoolSize(), scenario.getRowCount()); for (int i = 0; i < getThreadPoolSize(); i++) { List<Column> phxMetaCols = pUtil.getColumnsFromPhoenix( scenario.getSchemaName(), scenario.getTableNameWithoutSchemaName(), pUtil.getConnection()); int threadRowCount = rowCalculator.getNext(); logger.info(\"Kick off thread (#\" + i + \")for upsert with (\" + threadRowCount + \") rows.\"); Future<Info> write = upsertData(scenario, phxMetaCols, scenario.getTableName(), threadRowCount, dataLoadThreadTime); writeBatches.add(write); } if (writeBatches.isEmpty()) { throw new PherfException( \"Holy shit snacks! Throwing up hands in disbelief and exiting. Could not write data for some unknown reason.\"); } int sumRows = 0, sumDuration = 0; for (Future<Info> write : writeBatches) { Info writeInfo = write.get(); sumRows += writeInfo.getRowCount(); sumDuration += writeInfo.getDuration(); <START> System.out <END> \/\/ this a logger.info instead of a System.out.println .println(\"Executor writes complete with row count (\" + writeInfo.getRowCount() + \") in Ms (\" + writeInfo.getDuration() + \")\"); } logger.info(\"Writes completed with total row count (\" + sumRows + \") with total time of(\" + sumDuration + \") Ms\"); dataLoadTimeSummary.add(scenario.getTableName(), sumRows, (int) (System.currentTimeMillis() - start)); updatePhoenixStats(scenario.getTableName()); } resultUtil.write(dataLoadTimeSummary); resultUtil.write(dataLoadThreadTime); } finally { pool.shutdown(); } }'","output":"public void execute() throws Exception { try { DataModel model = getParser().getDataModels().get(0); DataLoadTimeSummary dataLoadTimeSummary = new DataLoadTimeSummary(); DataLoadThreadTime dataLoadThreadTime = new DataLoadThreadTime(); for (Scenario scenario : getParser().getScenarios()) { List<Future> writeBatches = new ArrayList<Future>(); logger.info(\"\\nLoading \" + scenario.getRowCount() + \" rows for \" + scenario.getTableName()); long start = System.currentTimeMillis(); RowCalculator rowCalculator = new RowCalculator(getThreadPoolSize(), scenario.getRowCount()); for (int i = 0; i < getThreadPoolSize(); i++) { List<Column> phxMetaCols = pUtil.getColumnsFromPhoenix( scenario.getSchemaName(), scenario.getTableNameWithoutSchemaName(), pUtil.getConnection()); int threadRowCount = rowCalculator.getNext(); logger.info(\"Kick off thread (#\" + i + \")for upsert with (\" + threadRowCount + \") rows.\"); Future<Info> write = upsertData(scenario, phxMetaCols, scenario.getTableName(), threadRowCount, dataLoadThreadTime); writeBatches.add(write); } if (writeBatches.isEmpty()) { throw new PherfException( \"Holy shit snacks! Throwing up hands in disbelief and exiting. Could not write data for some unknown reason.\"); } int sumRows = 0, sumDuration = 0; for (Future<Info> write : writeBatches) { Info writeInfo = write.get(); sumRows += writeInfo.getRowCount(); sumDuration += writeInfo.getDuration(); logger.info(\"Executor writes complete with row count (\" + writeInfo.getRowCount() + \") in Ms (\" + writeInfo.getDuration() + \")\"); } logger.info(\"Writes completed with total row count (\" + sumRows + \") with total time of(\" + sumDuration + \") Ms\"); dataLoadTimeSummary.add(scenario.getTableName(), sumRows, (int) (System.currentTimeMillis() - start)); updatePhoenixStats(scenario.getTableName()); } resultUtil.write(dataLoadTimeSummary); resultUtil.write(dataLoadThreadTime); } finally { pool.shutdown(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Recently, explicit new Object[]{ ... }'\nThe code is: 'private byte[] receivedClientKeyExchange(final PSKClientKeyExchange message) throws HandshakeException { clientKeyExchange = message; String identity = message.getIdentity(); byte[] psk = pskStore.getKey(getIndicatedServerNames(), identity); String virtualHost = null; if (getIndicatedServerNames() == null) { LOGGER.debug(\"Client [{}] uses PSK identity [{}]\", <START> new Object[]{getPeerAddress(), identity}); <END> \/\/ Recently, explicit new Object[]{ ... } } else { ServerName serverName = getIndicatedServerNames().getServerName(NameType.HOST_NAME); if (serverName == null) { LOGGER.debug(\"client provided invalid SNI extension which doesn't include a hostname\"); } else { virtualHost = new String(serverName.getName(), ServerName.CHARSET); LOGGER.debug(\"Client [{}] uses PSK identity [{}] for server [{}]\", new Object[]{getPeerAddress(), identity, virtualHost}); } } if (psk == null) { throw new HandshakeException( String.format(\"Cannot authenticate client, identity [%s] is unknown\", identity), new AlertMessage(AlertLevel.FATAL, AlertDescription.UNKNOWN_PSK_IDENTITY, session.getPeer())); } else { session.setPeerIdentity(new PreSharedKeyIdentity(virtualHost, identity)); return generatePremasterSecretFromPSK(psk); } }'","output":"private byte[] receivedClientKeyExchange(final PSKClientKeyExchange message) throws HandshakeException { clientKeyExchange = message; String identity = message.getIdentity(); byte[] psk = pskStore.getKey(getIndicatedServerNames(), identity); String virtualHost = null; if (getIndicatedServerNames() == null) { LOGGER.debug(\"Client [{}] uses PSK identity [{}]\", getPeerAddress(), identity); } else { ServerName serverName = getIndicatedServerNames().getServerName(NameType.HOST_NAME); if (serverName == null) { LOGGER.debug(\"client provided invalid SNI extension which doesn't include a hostname\"); } else { virtualHost = new String(serverName.getName(), ServerName.CHARSET); LOGGER.debug(\"Client [{}] uses PSK identity [{}] for server [{}]\", getPeerAddress(), identity, virtualHost); } } if (psk == null) { throw new HandshakeException( String.format(\"Cannot authenticate client, identity [%s] is unknown\", identity), new AlertMessage(AlertLevel.FATAL, AlertDescription.UNKNOWN_PSK_IDENTITY, session.getPeer())); } else { session.setPeerIdentity(new PreSharedKeyIdentity(virtualHost, identity)); return generatePremasterSecretFromPSK(psk); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Method name, entityHasExtensionJobTag, is good enough'\nThe code is: 'public APIResult submit( @Context HttpServletRequest request, @Dimension(\"entityType\") @PathParam(\"type\") final String type, @Dimension(\"colo\") @QueryParam(\"colo\") final String ignore) { final HttpServletRequest bufferedRequest = getBufferedRequest(request); final Entity entity = getEntity(bufferedRequest, type); Map<String, APIResult> results = new HashMap<String, APIResult>(); final Set<String> colos = getApplicableColos(type, entity); <START> doesEntityHasExtensionJobTag(entity); <END> \/\/ Method name, entityHasExtensionJobTag, is good enough validateEntity(entity, colos); results.put(FALCON_TAG, new EntityProxy(type, entity.getName()) { @Override protected Set<String> getColosToApply() { return colos; } @Override protected APIResult doExecute(String colo) throws FalconException { return getConfigSyncChannel(colo).invoke(\"submit\", bufferedRequest, type, colo); } }.execute()); if (!embeddedMode) { results.put(PRISM_TAG, super.submit(bufferedRequest, type, currentColo)); } return consolidateResult(results, APIResult.class); }'","output":"public APIResult submit( @Context HttpServletRequest request, @Dimension(\"entityType\") @PathParam(\"type\") final String type, @Dimension(\"colo\") @QueryParam(\"colo\") final String ignore) { final HttpServletRequest bufferedRequest = getBufferedRequest(request); final Entity entity = getEntity(bufferedRequest, type); Map<String, APIResult> results = new HashMap<String, APIResult>(); final Set<String> colos = getApplicableColos(type, entity); entityHasExtensionJobTag(entity); validateEntity(entity, colos); results.put(FALCON_TAG, new EntityProxy(type, entity.getName()) { @Override protected Set<String> getColosToApply() { return colos; } @Override protected APIResult doExecute(String colo) throws FalconException { return getConfigSyncChannel(colo).invoke(\"submit\", bufferedRequest, type, colo); } }.execute()); if (!embeddedMode) { results.put(PRISM_TAG, super.submit(bufferedRequest, type, currentColo)); } return consolidateResult(results, APIResult.class); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'unexpected'\nThe code is: 'private HttpClient getDeleteHttpClient() { return new HttpClient() { @Override public CompletionStage<HttpResponse> execute(final HttpRequest httpRequest) { if (httpRequest.getUrl().contains(\"version=5\")) { return CompletableFuture.completedFuture(HttpResponse.of(409, \"{\\n\" + \" \\\"statusCode\\\" : 409,\\n\" + \" \\\"message\\\" : \\\"Version mismatch. Concurrent modification.\\\",\\n\" + \" \\\"errors\\\" : [ {\\n\" + \" \\\"code\\\" : \\\"ConcurrentModification\\\",\\n\" + \" \\\"message\\\" : \\\"Version mismatch. Concurrent modification.\\\",\\n\" + \" \\\"currentVersion\\\" : 7\\n\" + \" } ]\\n\" + \"}\")); } else if (httpRequest.getUrl().contains(\"version=7\")) { return CompletableFuture.completedFuture(HttpResponse.of(200, \"{\\\"id\\\": \\\"some-id\\\", \\\"version\\\": 7}\")); } else { <START> throw new IllegalArgumentException(\"unexcpected input\"); <END> \/\/ unexpected } } @Override public void close() { } }; }'","output":"private HttpClient getDeleteHttpClient() { return new HttpClient() { @Override public CompletionStage<HttpResponse> execute(final HttpRequest httpRequest) { if (httpRequest.getUrl().contains(\"version=5\")) { return CompletableFuture.completedFuture(HttpResponse.of(409, \"{\\n\" + \" \\\"statusCode\\\" : 409,\\n\" + \" \\\"message\\\" : \\\"Version mismatch. Concurrent modification.\\\",\\n\" + \" \\\"errors\\\" : [ {\\n\" + \" \\\"code\\\" : \\\"ConcurrentModification\\\",\\n\" + \" \\\"message\\\" : \\\"Version mismatch. Concurrent modification.\\\",\\n\" + \" \\\"currentVersion\\\" : 7\\n\" + \" } ]\\n\" + \"}\")); } else if (httpRequest.getUrl().contains(\"version=7\")) { return CompletableFuture.completedFuture(HttpResponse.of(200, \"{\\\"id\\\": \\\"some-id\\\", \\\"version\\\": 7}\")); } else { throw new IllegalArgumentException(\"unexpected input\"); } } @Override public void close() { } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This needs remain IReverseToggleHandler for other changes break things'\nThe code is: 'protected List<Class<?>> getModelAdapters() { return new ArrayList<>(Arrays.asList( SteppingController.class, IViewerInputProvider.class, ISteppingModeTarget.class, ISourceDisplay.class, IStepIntoHandler.class, IStepIntoSelectionHandler.class, IReverseStepIntoHandler.class, IStepOverHandler.class, IReverseStepOverHandler.class, IStepReturnHandler.class, IUncallHandler.class, ISuspendHandler.class, IResumeHandler.class, IReverseResumeHandler.class, IResumeWithoutSignalHandler.class, IRestartHandler.class, ITerminateHandler.class, IDebugNewExecutableHandler.class, IConnectHandler.class, IDisconnectHandler.class, IModelSelectionPolicyFactory.class, IRefreshAllTarget.class, <START> IChangeReverseMethodHandler.class, <END> \/\/ This needs remain IReverseToggleHandler for other changes break things IStartTracingHandler.class, IStopTracingHandler.class, ISaveTraceDataHandler.class, ISelectNextTraceRecordHandler.class, ISelectPrevTraceRecordHandler.class, IPinProvider.class, IDebugModelProvider.class, ILaunch.class, ICEditorTextHover.class)); }'","output":"protected List<Class<?>> getModelAdapters() { return new ArrayList<>(Arrays.asList( SteppingController.class, IViewerInputProvider.class, ISteppingModeTarget.class, ISourceDisplay.class, IStepIntoHandler.class, IStepIntoSelectionHandler.class, IReverseStepIntoHandler.class, IStepOverHandler.class, IReverseStepOverHandler.class, IStepReturnHandler.class, IUncallHandler.class, ISuspendHandler.class, IResumeHandler.class, IReverseResumeHandler.class, IResumeWithoutSignalHandler.class, IRestartHandler.class, ITerminateHandler.class, IDebugNewExecutableHandler.class, IConnectHandler.class, IDisconnectHandler.class, IModelSelectionPolicyFactory.class, IRefreshAllTarget.class, IReverseToggleHandler.class, IStartTracingHandler.class, IStopTracingHandler.class, ISaveTraceDataHandler.class, ISelectNextTraceRecordHandler.class, ISelectPrevTraceRecordHandler.class, IPinProvider.class, IDebugModelProvider.class, ILaunch.class, ICEditorTextHover.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'typing is fixed do need this casting'\nThe code is: 'public Map createVolume(String sdUUID, String spUUID, String imgUUID, String size, Integer volFormat, Integer preallocate, Integer diskType, String volUUID, String desc, String srcImgUUID, String srcVolUUID) { try { DataCenter dataCenter = getDataCenterById(spUUID); StorageDomain storageDomain = dataCenter.getStorageDomainMap().get(sdUUID); final Volume volume = new Volume(); volume.setId(volUUID); volume.setSize(size); volume.setVolFormat(volFormat); volume.setPreallocate(preallocate); volume.setDiskType(diskType); volume.setImgUUID(imgUUID); volume.setDesc(desc); volume.setSrcImgUUID(srcImgUUID); volume.setSrcVolUUID(srcVolUUID); log.info(\"Adding volume: {} for sp: {}, sd: {}\", new Object[] { volUUID, spUUID, sdUUID }); storageDomain.getVolumes().put(volUUID, volume); updateDataCenter(dataCenter); final Map resultMap = getOKStatus(); final Task task = new Task(getUuid()); resultMap.put(\"uuid\", task.getId()); <START> syncTask((Host) <END> \/\/ typing is fixed do need this casting VdsmManager.getInstance().getSpmHost(spUUID), task); TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_CREATE_VOLUME, 3000l, task)); return resultMap; } catch (Exception e) { throw error(e); } }'","output":"public Map createVolume(String sdUUID, String spUUID, String imgUUID, String size, Integer volFormat, Integer preallocate, Integer diskType, String volUUID, String desc, String srcImgUUID, String srcVolUUID) { try { DataCenter dataCenter = getDataCenterById(spUUID); StorageDomain storageDomain = dataCenter.getStorageDomainMap().get(sdUUID); final Volume volume = new Volume(); volume.setId(volUUID); volume.setSize(size); volume.setVolFormat(volFormat); volume.setPreallocate(preallocate); volume.setDiskType(diskType); volume.setImgUUID(imgUUID); volume.setDesc(desc); volume.setSrcImgUUID(srcImgUUID); volume.setSrcVolUUID(srcVolUUID); log.info(\"Adding volume: {} for sp: {}, sd: {}\", new Object[] { volUUID, spUUID, sdUUID }); storageDomain.getVolumes().put(volUUID, volume); updateDataCenter(dataCenter); final Map resultMap = getOKStatus(); final Task task = new Task(getUuid()); resultMap.put(\"uuid\", task.getId()); syncTask(VdsmManager.getInstance().getSpmHost(spUUID), task); TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_CREATE_VOLUME, 3000l, task)); return resultMap; } catch (Exception e) { throw error(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace java if (optionalBlobName.isPresent()) { uploadFile(file, optionalBlobName.get()); } else { uploadFile(file, file.getName()); } java uploadFile(file, optionalBlobName.orElse(file.getName());'\nThe code is: 'public Serializable execute(TaskResult... results) throws IOException, ExecutionException, InterruptedException { List<String> filesRelativePathName = new ArrayList<>(); File file = new File(inputPath); containerURL = AzureStorageConnectorUtils.createContainerURL(accountName, accountKey, containerName); if (file.exists()) { if (file.isDirectory()) { if (optionalBlobName.isPresent()) { filesRelativePathName = recursiveFolderUpload(inputPath, optionalBlobName.get(), true); } else { filesRelativePathName = recursiveFolderUpload(inputPath, \"\", false); } } else { if (optionalBlobName.isPresent()) { uploadFile(file, optionalBlobName.get()); } else { uploadFile(file, file.getName()); <START> } <END> \/\/ replace java if (optionalBlobName.isPresent()) { uploadFile(file, optionalBlobName.get()); } else { uploadFile(file, file.getName()); } java uploadFile(file, optionalBlobName.orElse(file.getName()); filesRelativePathName.add(file.getPath()); } } else { throw new FileNotFoundException(\"The input file cannot be found at \" + inputPath); } return (Serializable) filesRelativePathName; }'","output":"public Serializable execute(TaskResult... results) throws IOException, ExecutionException, InterruptedException { List<String> filesRelativePathName = new ArrayList<>(); File file = new File(inputPath); containerURL = AzureStorageConnectorUtils.createContainerURL(storageAccount, accountKey, containerName); if (file.exists()) { if (file.isDirectory()) { if (optionalBlobName.isPresent()) { filesRelativePathName = recursiveFolderUpload(inputPath, optionalBlobName.get(), true); } else { filesRelativePathName = recursiveFolderUpload(inputPath, \"\", false); } } else { uploadFile(file, optionalBlobName.orElse(file.getName())); filesRelativePathName.add(file.getPath()); } } else { throw new FileNotFoundException(\"The input file cannot be found at \" + inputPath); } return (Serializable) filesRelativePathName; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suppress exception here'\nThe code is: 'public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(\"Submitting persist runnable for dataSource[%s]\", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(\"%s-incremental-persist\", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { <START> metrics.incrementFailedPersists(); <END> \/\/ suppress exception here } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(\"Ingestion was throttled for [%,d] millis because persists were pending.\", startDelay); } runExecStopwatch.stop(); }'","output":"public void persist(final Runnable commitRunnable) { final List<Pair<FireHydrant, Interval>> indexesToPersist = Lists.newArrayList(); for (Sink sink : sinks.values()) { if (sink.swappable()) { indexesToPersist.add(Pair.of(sink.swap(), sink.getInterval())); } } log.info(\"Submitting persist runnable for dataSource[%s]\", schema.getDataSource()); final Stopwatch runExecStopwatch = Stopwatch.createStarted(); final Stopwatch persistStopwatch = Stopwatch.createStarted(); persistExecutor.execute( new ThreadRenamingRunnable(String.format(\"%s-incremental-persist\", schema.getDataSource())) { @Override public void doRun() { try { for (Pair<FireHydrant, Interval> pair : indexesToPersist) { metrics.incrementRowOutputCount(persistHydrant(pair.lhs, schema, pair.rhs)); } commitRunnable.run(); } catch (Exception e) { metrics.incrementFailedPersists(); throw e; } finally { metrics.incrementNumPersists(); metrics.incrementPersistTimeMillis(persistStopwatch.elapsed(TimeUnit.MILLISECONDS)); persistStopwatch.stop(); } } } ); final long startDelay = runExecStopwatch.elapsed(TimeUnit.MILLISECONDS); metrics.incrementPersistBackPressureMillis(startDelay); if (startDelay > WARN_DELAY) { log.warn(\"Ingestion was throttled for [%,d] millis because persists were pending.\", startDelay); } runExecStopwatch.stop(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'turn-around equal check for avoiding NPEs ? For ex: \"something\".equals(string)'\nThe code is: 'public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key + \"is not a String value\"); } logger.info(\"Undeploying : \" + key); File fileToUndeploy; <START> if (key.equals(\"sample1.txt\")) { <END> \/\/ turn-around equal check for avoiding NPEs ? For ex: \"something\".equals(string) fileToUndeploy = new File(testDir + File.separator + key); } else if (key.equals(\"sample2.txt\")) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key); } logger.info(\"File to undeploy : \" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { int x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(\"sample1\")) { sample1Deployed = false; } else if (content.contains(\"sample2\")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key, e); } }'","output":"public void undeploy(Object key) throws CarbonDeploymentException { if (!(key instanceof String)) { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key + \"is not a String value\"); } logger.info(\"Undeploying : \" + key); File fileToUndeploy; if (\"sample1.txt\".equals(key)) { fileToUndeploy = new File(testDir + File.separator + key); } else if (\"sample2.txt\".equals(key)) { fileToUndeploy = new File(testDir2 + File.separator + key); } else { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key); } logger.info(\"File to undeploy : \" + fileToUndeploy.getAbsolutePath()); try (FileInputStream fis = new FileInputStream(fileToUndeploy)) { int x = fis.available(); byte b[] = new byte[x]; fis.read(b); String content = new String(b); if (content.contains(\"sample1\")) { sample1Deployed = false; } else if (content.contains(\"sample2\")) { sample2Deployed = false; } } catch (IOException e) { throw new CarbonDeploymentException(\"Error while Un Deploying : \" + key, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this removed'\nThe code is: 'public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false, NEVER_SKIP)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); encoderChannel.writeOutbound(frame); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); <START> assertNotNull(newFrame); <END> \/\/ this removed assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }'","output":"public void testAlreadyCompressedFrame() { EmbeddedChannel encoderChannel = new EmbeddedChannel(new PerFrameDeflateEncoder(9, 15, false)); byte[] payload = new byte[300]; random.nextBytes(payload); BinaryWebSocketFrame frame = new BinaryWebSocketFrame(true, WebSocketExtension.RSV3 | WebSocketExtension.RSV1, Unpooled.wrappedBuffer(payload)); assertTrue(encoderChannel.writeOutbound(frame)); BinaryWebSocketFrame newFrame = encoderChannel.readOutbound(); assertNotNull(newFrame); assertNotNull(newFrame.content()); assertEquals(WebSocketExtension.RSV3 | WebSocketExtension.RSV1, newFrame.rsv()); assertEquals(300, newFrame.content().readableBytes()); byte[] finalPayload = new byte[300]; newFrame.content().readBytes(finalPayload); assertArrayEquals(finalPayload, payload); newFrame.release(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this'\nThe code is: 'private void insertWrongReference() throws NamingException, SQLException, AssertionFailedError { DataSource ds = DataSourceHelper.getDataSource(\"jdbc\/canrollback\"); try (Connection db = ds.getConnection()) { try (Statement st = db.createStatement()) { st.execute(\"INSERT INTO footest (a) VALUES (0)\"); st.execute(\"INSERT INTO footest (a) VALUES (1)\"); st.execute(\"INSERT INTO footest (a) VALUES (1)\"); } } catch (SQLException cause) { <START> cause.printStackTrace(); <END> \/\/ Remove this TransactionHelper.setTransactionRollbackOnly(); throw cause; } finally { TransactionHelper.commitOrRollbackTransaction(); TransactionHelper.startTransaction(); try (Connection db = ds.getConnection()) { try (Statement st = db.createStatement()) { try (ResultSet rs = st.executeQuery(\"SELECT a FROM footest WHERE a = 0\")) { if (rs.next()) { throw new AssertionFailedError(\"connection was not rollbacked\"); } } } } } }'","output":"private void insertWrongReference() throws NamingException, SQLException, AssertionFailedError { DataSource ds = DataSourceHelper.getDataSource(\"jdbc\/canrollback\"); try (Connection db = ds.getConnection()) { try (Statement st = db.createStatement()) { st.execute(\"INSERT INTO footest (a) VALUES (0)\"); st.execute(\"INSERT INTO footest (a) VALUES (1)\"); st.execute(\"INSERT INTO footest (a) VALUES (1)\"); } } catch (SQLException cause) { TransactionHelper.setTransactionRollbackOnly(); throw cause; } finally { TransactionHelper.commitOrRollbackTransaction(); TransactionHelper.startTransaction(); try (Connection db = ds.getConnection()) { try (Statement st = db.createStatement()) { try (ResultSet rs = st.executeQuery(\"SELECT a FROM footest WHERE a = 0\")) { if (rs.next()) { throw new AssertionFailedError(\"connection was not rollbacked\"); } } } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this storageQos'\nThe code is: 'public DiskProfilePopupView(EventBus eventBus, ApplicationResources resources, ApplicationConstants constants) { super(eventBus, resources); storageDomainEditor = new ListModelListBoxEditor<StorageDomain>(new NullSafeRenderer<StorageDomain>() { @Override public String renderNullSafe(StorageDomain storageDomain) { return storageDomain.getName(); } }); qosEditor = new ListModelListBoxEditor<StorageQos>(new NullSafeRenderer<StorageQos>() { @Override <START> public String renderNullSafe(StorageQos StorageQos) { <END> \/\/ this storageQos return StorageQos.getName(); } }); initWidget(ViewUiBinder.uiBinder.createAndBindUi(this)); localize(constants); ViewIdHandler.idHandler.generateAndSetIds(this); driver.initialize(this); }'","output":"public DiskProfilePopupView(EventBus eventBus, ApplicationResources resources, ApplicationConstants constants) { super(eventBus, resources); storageDomainEditor = new ListModelListBoxEditor<StorageDomain>(new NullSafeRenderer<StorageDomain>() { @Override public String renderNullSafe(StorageDomain storageDomain) { return storageDomain.getName(); } }); qosEditor = new ListModelListBoxEditor<StorageQos>(new NullSafeRenderer<StorageQos>() { @Override public String renderNullSafe(StorageQos storageQos) { return storageQos.getName(); } }); initWidget(ViewUiBinder.uiBinder.createAndBindUi(this)); localize(constants); ViewIdHandler.idHandler.generateAndSetIds(this); driver.initialize(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logger.debug'\nThe code is: 'public List<Comment> parseComments(int id) throws IOException { CommentVaultHtmlContentHandler commentVaultHtmlContentHandler = new CommentVaultHtmlContentHandler(); URL url = new URL(String.format(environment.getProperty(\"vault.mapCommentUrl\"), id)); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); <START> logger.info(\"Fetching comments from {}\", url); <END> \/\/ logger.debug try (BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()))) { JsonReader jsonReader = new JsonReader(reader); jsonReader.beginObject(); while (jsonReader.hasNext()) { String key = jsonReader.nextName(); if (!\"comments\".equals(key)) { jsonReader.skipValue(); continue; } String comments = jsonReader.nextString(); return htmlParser.parse(comments, commentVaultHtmlContentHandler); } jsonReader.endObject(); } throw new IllegalStateException(\"Comment vault could not be read from \" + url); }'","output":"public List<Comment> parseComments(int id) throws IOException { CommentVaultHtmlContentHandler commentVaultHtmlContentHandler = new CommentVaultHtmlContentHandler(); URL url = new URL(String.format(environment.getProperty(\"vault.mapCommentUrl\"), id)); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); logger.debug(\"Fetching comments from {}\", url); try (BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()))) { JsonReader jsonReader = new JsonReader(reader); jsonReader.beginObject(); while (jsonReader.hasNext()) { String key = jsonReader.nextName(); if (!\"comments\".equals(key)) { jsonReader.skipValue(); continue; } String comments = jsonReader.nextString(); return htmlParser.parse(comments, commentVaultHtmlContentHandler); } jsonReader.endObject(); } throw new IllegalStateException(\"Comment vault could not be read from \" + url); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IllegalArgumentException a fit here'\nThe code is: 'private Object convertValue(Object value, Type type) { if (value == null) { return null; } if (BOOLEAN.equals(type) || Varchars.isVarcharType(type)) { return value; } if (BIGINT.equals(type)) { return ((Number) value).longValue(); } if (INTEGER.equals(type)) { return ((Number) value).intValue(); } if (DOUBLE.equals(type)) { return ((Number) value).doubleValue(); } if (DATE.equals(type)) { return value; } <START> throw new AssertionError(\"unhandled type: \" + type); <END> \/\/ IllegalArgumentException a fit here }'","output":"private Object convertValue(Object value, Type type) { if (value == null) { return null; } if (BOOLEAN.equals(type) || Varchars.isVarcharType(type)) { return value; } if (BIGINT.equals(type)) { return ((Number) value).longValue(); } if (INTEGER.equals(type)) { return ((Number) value).intValue(); } if (DOUBLE.equals(type)) { return ((Number) value).doubleValue(); } if (DATE.equals(type)) { return value; } throw new IllegalArgumentException(\"unhandled type: \" + type); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion Map<String, Class<?>> extensionClasses = new HashMap<>(); this'\nThe code is: 'private Map<String, Class<?>> loadExtensionClasses() { cacheDefaultExtensionName(); <START> Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>(); <END> \/\/ suggestion Map<String, Class<?>> extensionClasses = new HashMap<>(); this loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName()); loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName()); loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName()); loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); return extensionClasses; }'","output":"private Map<String, Class<?>> loadExtensionClasses() { cacheDefaultExtensionName(); Map<String, Class<?>> extensionClasses = new HashMap<>(); loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName()); loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName()); loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName()); loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\")); return extensionClasses; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this status permanently 99%. I want Math.min(progress, 99.9)'\nThe code is: 'public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { double progress = entries.getValue().getBytesCopied() \/ walBlockSize; <START> status.progress = Math.max(progress, 99.0); <END> \/\/ I this status permanently 99%. I want Math.min(progress, 99.9) } catch (IOException ex) { log.warn(\"Error getting bytes read\"); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }'","output":"public List<RecoveryStatus> getLogSorts() { List<RecoveryStatus> result = new ArrayList<>(); synchronized (currentWork) { for (Entry<String,LogProcessor> entries : currentWork.entrySet()) { RecoveryStatus status = new RecoveryStatus(); status.name = entries.getKey(); try { double progress = entries.getValue().getBytesCopied() \/ walBlockSize; status.progress = Math.min(progress, 99.9); } catch (IOException ex) { log.warn(\"Error getting bytes read\"); } status.runtime = (int) entries.getValue().getSortTime(); result.add(status); } return result; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove'\nThe code is: 'public Process runServer() throws IOException { <START> final String serverConsoleLogPath = \"\/Users\/amartinezman\/Desktop\/gm\" + File.separator + host + \"_\" + port + \"_consolelog\"; <END> \/\/ remove File logPath = new File(getCorfuServerLogPath(host, port)); if (!logPath.exists()) { logPath.mkdir(); } ProcessBuilder builder = new ProcessBuilder(); builder.command(\"sh\", \"-c\", \"bin\/corfu_replication_server \" + getOptionsString()); builder.directory(new File(CORFU_PROJECT_DIR)); Process corfuReplicationServerProcess = builder.start(); StreamGobbler streamGobbler = new StreamGobbler(corfuReplicationServerProcess.getInputStream(), serverConsoleLogPath); Executors.newSingleThreadExecutor().submit(streamGobbler); return corfuReplicationServerProcess; }'","output":"public Process runServer() throws IOException { final String serverConsoleLogPath = CORFU_LOG_PATH + File.separator + host + \"_\" + port + \"_consolelog\"; File logPath = new File(getCorfuServerLogPath(host, port)); if (!logPath.exists()) { logPath.mkdir(); } ProcessBuilder builder = new ProcessBuilder(); builder.command(\"sh\", \"-c\", \"bin\/corfu_replication_server \" + getOptionsString()); builder.directory(new File(CORFU_PROJECT_DIR)); Process corfuReplicationServerProcess = builder.start(); StreamGobbler streamGobbler = new StreamGobbler(corfuReplicationServerProcess.getInputStream(), serverConsoleLogPath); Executors.newSingleThreadExecutor().submit(streamGobbler); return corfuReplicationServerProcess; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Minor typo in variable name; extra unneeded \"m\"'\nThe code is: 'void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); <START> String actualErrorMmessage = foreignAchErrorMessages.get(0); <END> \/\/ Minor typo in variable name; extra unneeded \"m\" assertEquals(\"The bank has a country code of Canada. We can only create ACH records for banks that have a US address\", actualErrorMmessage); }'","output":"void testIsUsAchBankForeignFormCanadaBank() { achService.setPaymentWorksFormModeService(buildMockPaymentWorksFormModeService(true)); pmwVendor.setBankAddressCountry(PaymentWorksConstants.PaymentWorksPurchaseOrderCountryFipsOption.CANADA.getPmwCountryOptionAsString()); boolean actualIsUsBankAccount = achService.isUsAchBank(pmwVendor, reportData); assertFalse(actualIsUsBankAccount); assertEquals(0, reportData.getRecordsThatCouldNotBeProcessedSummary().getRecordCount()); assertEquals(0, reportData.getPmwVendorAchsThatCouldNotBeProcessed().size()); assertEquals(1, reportData.getRecordsWithForeignAchSummary().getRecordCount()); List<PaymentWorksBatchReportVendorItem> foreignAchItems = reportData.getForeignAchItems(); assertEquals(1, foreignAchItems.size()); List<String> foreignAchErrorMessages = foreignAchItems.get(0).getErrorMessages(); assertEquals(1, foreignAchErrorMessages.size()); String actualErrorMessage = foreignAchErrorMessages.get(0); assertEquals(\"The bank has a country code of Canada. We can only create ACH records for banks that have a US address\", actualErrorMessage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This if do'\nThe code is: 'public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } <START> if (!recentlyCompletedDriverGroups.isEmpty()) { <END> \/\/ This if do for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } int driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } } return newDriverGroupReady; }'","output":"public SettableFuture schedule(SourcePartitionedScheduler scheduler) { checkState(initialScheduled); List<Lifespan> recentlyCompletedDriverGroups; synchronized (this) { recentlyCompletedDriverGroups = ImmutableList.copyOf(this.recentlyCompletedDriverGroups); this.recentlyCompletedDriverGroups.clear(); newDriverGroupReady = SettableFuture.create(); } for (Lifespan driverGroup : recentlyCompletedDriverGroups) { IntListIterator driverGroupsIterator = nodeToDriverGroupsMap.get(driverGroupToNodeMap.get(driverGroup.getId())); if (!driverGroupsIterator.hasNext()) { continue; } int driverGroupId = driverGroupsIterator.nextInt(); scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId)); } return newDriverGroupReady; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simplify this a bit: suggestion return supplier.get();'\nThe code is: 'private static ClientRegistration.Builder getBuilder(String issuer, Supplier<ClientRegistration.Builder>... suppliers) { String errorMessage = \"Unable to resolve Configuration with the provided Issuer of \\\"\" + issuer + \"\\\"\"; for (Supplier<ClientRegistration.Builder> supplier : suppliers) { try { <START> ClientRegistration.Builder builder = supplier.get(); <END> \/\/ simplify this a bit: suggestion return supplier.get(); return builder; } catch (HttpClientErrorException e) { if (!e.getStatusCode().is4xxClientError()) { throw e; } } catch (IllegalArgumentException | IllegalStateException e) { throw e; } catch (RuntimeException e) { throw new IllegalArgumentException(errorMessage, e); } } throw new IllegalArgumentException(errorMessage); }'","output":"private static ClientRegistration.Builder getBuilder(String issuer, Supplier<ClientRegistration.Builder>... suppliers) { String errorMessage = \"Unable to resolve Configuration with the provided Issuer of \\\"\" + issuer + \"\\\"\"; for (Supplier<ClientRegistration.Builder> supplier : suppliers) { try { return supplier.get(); } catch (HttpClientErrorException e) { if (!e.getStatusCode().is4xxClientError()) { throw e; } } catch (IllegalArgumentException | IllegalStateException e) { throw e; } catch (RuntimeException e) { throw new IllegalArgumentException(errorMessage, e); } } throw new IllegalArgumentException(errorMessage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing'\nThe code is: 'public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); <START> assertFalse(cell.getType() == Cell.EMPTY); <END> \/\/ assertNotEquals instead of == operator combined assertFalse, == work properly for non-objects. <testing }'","output":"public void slightlyOccupiedAABBTest() { Level check = new Level(emptyPlayer, emptyUnit, new Grid<>(Arrays.asList( Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL, Cell.EMPTY, Cell.WALL, Cell.WALL, Cell.WALL, Cell.WALL), 3, 3)); CollisionHandler handler = new CollisionHandler(check); Cell cell = handler.checkLevelAABB( new AABB(new Point(1.5, 1.5), new Point(2.5, 2.5)), new Point(0, 0)); assertNotEquals(cell, Cell.EMPTY); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'separator for slashes in \/stor\/multipart string well'\nThe code is: 'private static void multipartUpload(EncryptedServerSideMultipartManager multipart) { <START> String uploadObject = MantaClient.SEPARATOR + mantaUsername + \"\/stor\/multipart\"; <END> \/\/ separator for slashes in \/stor\/multipart string well try { MantaMetadata metadata = new MantaMetadata(); metadata.put(\"e-secretkey\", \"My Secret Value\"); EncryptedMultipartUpload<ServerSideMultipartUpload> upload = multipart.initiateUpload(uploadObject, metadata); MantaMultipartUploadPart part1 = multipart.uploadPart(upload, 1, RandomUtils.nextBytes(5242880)); MantaMultipartUploadPart part2 = multipart.uploadPart(upload, 2, RandomUtils.nextBytes(1000000)); MantaMultipartUploadTuple[] parts = new MantaMultipartUploadTuple[] { part1, part2 }; Stream<MantaMultipartUploadTuple> partsStream = Arrays.stream(parts); multipart.complete(upload, partsStream); System.out.println(uploadObject + \" is now assembled!\"); } catch (IOException e) { ContextedRuntimeException exception = new ContextedRuntimeException( \"A network error occurred when doing a multipart upload to Manta.\"); exception.setContextValue(\"path\", uploadObject); throw exception; } }'","output":"private static void multipartUpload(EncryptedServerSideMultipartManager multipart) { String uploadObject = SEPARATOR + mantaUsername + SEPARATOR + \"stor\" + SEPARATOR + \"multipart\"; try { MantaMetadata metadata = new MantaMetadata(); metadata.put(\"e-secretkey\", \"My Secret Value\"); EncryptedMultipartUpload<ServerSideMultipartUpload> upload = multipart.initiateUpload(uploadObject, metadata); MantaMultipartUploadPart part1 = multipart.uploadPart(upload, 1, RandomUtils.nextBytes(5242880)); MantaMultipartUploadPart part2 = multipart.uploadPart(upload, 2, RandomUtils.nextBytes(1000000)); MantaMultipartUploadTuple[] parts = new MantaMultipartUploadTuple[] { part1, part2 }; Stream<MantaMultipartUploadTuple> partsStream = Arrays.stream(parts); multipart.complete(upload, partsStream); System.out.println(uploadObject + \" is now assembled!\"); } catch (IOException e) { ContextedRuntimeException exception = new ContextedRuntimeException( \"A network error occurred when doing a multipart upload to Manta.\"); exception.setContextValue(\"path\", uploadObject); throw exception; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'original exception propagate logged; drop this catch clause'\nThe code is: 'private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, \"Refusing to record with environment = -1.\"); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final int updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(\"env\", env); v.put(\"field\", field); v.put(\"date\", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(\"Event did not reference existing an environment or field.\", e); } catch (Exception e) { <START> Logger.error(LOG_TAG, \"Unknown exception thrown while recording daily last value.\", e); <END> \/\/ original exception propagate logged; drop this catch clause } } }'","output":"private void recordDailyLast(int env, int day, int field, Object value, String table) { if (env == -1) { Logger.warn(LOG_TAG, \"Refusing to record with environment = -1.\"); return; } final SQLiteDatabase db = this.helper.getWritableDatabase(); final String envString = Integer.toString(env); final String fieldIDString = Integer.toString(field, 10); final String dayString = Integer.toString(day, 10); final ContentValues v = new ContentValues(); putValue(v, value); final int updated = db.update(table, v, WHERE_DATE_AND_ENV_AND_FIELD, new String[] {dayString, envString, fieldIDString}); if (0 == updated) { v.put(\"env\", env); v.put(\"field\", field); v.put(\"date\", day); try { db.insertOrThrow(table, null, v); } catch (SQLiteConstraintException e) { throw new IllegalStateException(\"Event did not reference existing an environment or field.\", e); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this is'\nThe code is: 'public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); <START> final Map<Resource, Set<Resource>> enumerations = new HashMap<>(); <END> \/\/ this is enumerations.put(SUITS, CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); enumerations.put(RANKS, CARD_RANK_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(\"s\"), new Var(\"p\", RDF.TYPE), new Var(\"o\", SUITS)), new ProjectionElemList(new ProjectionElem(\"s\", \"subject\"))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(\"s\"), new Var(\"p\", RDF.TYPE), new Var(\"o\", RANKS)), new ProjectionElemList(new ProjectionElem(\"s\", \"subject\"))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }'","output":"public void testOneOf() throws Exception { final InferenceEngine inferenceEngine = mock(InferenceEngine.class); when(inferenceEngine.isEnumeratedType(SUITS)).thenReturn(true); when(inferenceEngine.getEnumeration(SUITS)).thenReturn(CARD_SUIT_ENUMERATION); when(inferenceEngine.isEnumeratedType(RANKS)).thenReturn(true); when(inferenceEngine.getEnumeration(RANKS)).thenReturn(CARD_RANK_ENUMERATION); final Projection query = new Projection( new StatementPattern(new Var(\"s\"), new Var(\"p\", RDF.TYPE), new Var(\"o\", SUITS)), new ProjectionElemList(new ProjectionElem(\"s\", \"subject\"))); query.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa = (BindingSetAssignment) query.getArg(); final Iterable<BindingSet> iterable = bsa.getBindingSets(); final Iterator<BindingSet> iter = iterable.iterator(); assertBindingSet(iter, CARD_SUIT_ENUMERATION.iterator()); final Projection query2 = new Projection( new StatementPattern(new Var(\"s\"), new Var(\"p\", RDF.TYPE), new Var(\"o\", RANKS)), new ProjectionElemList(new ProjectionElem(\"s\", \"subject\"))); query2.visit(new OneOfVisitor(conf, inferenceEngine)); assertTrue(query2.getArg() instanceof BindingSetAssignment); final BindingSetAssignment bsa2 = (BindingSetAssignment) query2.getArg(); final Iterable<BindingSet> iterable2 = bsa2.getBindingSets(); final Iterator<BindingSet> iter2 = iterable2.iterator(); assertBindingSet(iter2, CARD_RANK_ENUMERATION.iterator()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a test error'\nThe code is: 'public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() { Trace trace1 = new Trace(); trace1.setId(\"1_2ip2pasync\"); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(\"testuri\"); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(\"testuri2\"); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(\"cid1_2ip2pasync\"); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(\"2_2ip2pasync\"); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(\"testuri2\"); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(\"cid1_2ip2pasync\"); trace2.getNodes().add(c2); try { publisher.publish(null, Arrays.asList(trace1, trace2)); } catch (Exception e1) { <START> fail(\"Failed to store: \" + e1); <END> \/\/ This a test error } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }'","output":"public void testGetCompletionTimesTwoFragmentInteractionP2PAsync() throws Exception { Trace trace1 = new Trace(); trace1.setId(\"1_2ip2pasync\"); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(\"testuri\"); c1.setDuration(TimeUnit.NANOSECONDS.convert(3000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Producer p1 = new Producer(); p1.setUri(\"testuri2\"); p1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); p1.addInteractionCorrelationId(\"cid1_2ip2pasync\"); c1.getNodes().add(p1); Trace trace2 = new Trace(); trace2.setId(\"2_2ip2pasync\"); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(\"testuri2\"); c2.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c2.addInteractionCorrelationId(\"cid1_2ip2pasync\"); trace2.getNodes().add(c2); publisher.publish(null, Arrays.asList(trace1, trace2)); Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 2); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(4500, times.get(0).getDuration()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'obvious 102L is 0B1100110L..'\nThe code is: 'public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, <START> Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 102L}; <END> \/\/ obvious 102L is 0B1100110L.. int i = 0; int j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(\"x\")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(\"y\")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }'","output":"public void test_int_and_long_value() throws Exception { Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110}; Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 0b1100110L}; int i = 0; int j = 0; for (VariableTree variableTree : variables) { if (variableTree.simpleName().name().startsWith(\"x\")) { assertThat(LiteralUtils.intLiteralValue(variableTree.initializer())).isEqualTo(expectedIntegerValues[i++]); } else if (variableTree.simpleName().name().startsWith(\"y\")) { assertThat(LiteralUtils.longLiteralValue(variableTree.initializer())).isEqualTo(expectedLongValues[j++]); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change this List<PartitionId>'\nThe code is: 'public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(\"Alpha\"); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } <START> List<? extends PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); <END> \/\/ change this List<PartitionId> assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (int i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }'","output":"public void clusterMapInterface() throws JSONException { TestUtils.TestHardwareLayout testHardwareLayout = new TestUtils.TestHardwareLayout(\"Alpha\"); TestUtils.TestPartitionLayout testPartitionLayout = new TestUtils.TestPartitionLayout(testHardwareLayout); ClusterMapManager clusterMapManager = new ClusterMapManager(testPartitionLayout.getPartitionLayout()); for (String metricName : clusterMapManager.getMetricRegistry().getNames()) { System.out.println(metricName); } List<PartitionId> partitionIds = clusterMapManager.getWritablePartitionIds(); assertEquals(partitionIds.size(), testPartitionLayout.getPartitionCount()); for (int i = 0; i < partitionIds.size(); i++) { PartitionId partitionId = partitionIds.get(i); assertEquals(partitionId.getReplicaIds().size(), testPartitionLayout.getReplicaCount()); DataInputStream partitionStream = new DataInputStream(new ByteBufferInputStream(ByteBuffer.wrap(partitionId.getBytes()))); try { PartitionId fetchedPartitionId = clusterMapManager.getPartitionIdFromStream(partitionStream); assertEquals(partitionId, fetchedPartitionId); } catch (IOException e) { assertEquals(true, false); } } for (Datacenter datacenter : testHardwareLayout.getHardwareLayout().getDatacenters()) { for (DataNode dataNode : datacenter.getDataNodes()) { DataNodeId dataNodeId = clusterMapManager.getDataNodeId(dataNode.getHostname(), dataNode.getPort()); assertEquals(dataNodeId, dataNode); for (ReplicaId replicaId : clusterMapManager.getReplicaIds(dataNodeId)) { assertEquals(dataNodeId, replicaId.getDataNodeId()); } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '117 moved 59. this line needs done do cancelled\/completed. Remove 116'\nThe code is: 'public void refresh() { try { if (workItem.getCreatedBy() == null) { origLabel.setText(\"Error: No originator identified.\"); origLabel.setForeground(Displays.getSystemColor(SWT.COLOR_RED)); } else { User origUser = AtsClientService.get().getUserServiceClient().getOseeUser(workItem.getCreatedBy()); userIconLabel.setImage(FrameworkArtifactImageProvider.getUserImage(Arrays.asList(origUser))); origLabel.setText(workItem.getCreatedBy().getName()); origLabel.setForeground(Displays.getSystemColor(SWT.COLOR_BLACK)); } if (workItem.isCancelled() || workItem.isCompleted()) { <START> origLabel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); <END> \/\/ 117 moved 59. this line needs done do cancelled\/completed. Remove 116 } origLabel.getParent().getParent().layout(); } catch (OseeCoreException ex) { Label errorLabel = editor.getToolkit().createLabel(this, \"Error: \" + ex.getLocalizedMessage()); errorLabel.setForeground(Displays.getSystemColor(SWT.COLOR_RED)); OseeLog.log(Activator.class, Level.SEVERE, ex); } }'","output":"public void refresh() { try { if (workItem.getCreatedBy() == null) { origLabel.setText(\"Error: No originator identified.\"); origLabel.setForeground(Displays.getSystemColor(SWT.COLOR_RED)); } else { User origUser = AtsClientService.get().getUserServiceClient().getOseeUser(workItem.getCreatedBy()); userIconLabel.setImage(FrameworkArtifactImageProvider.getUserImage(Arrays.asList(origUser))); origLabel.setText(workItem.getCreatedBy().getName()); origLabel.setForeground(Displays.getSystemColor(SWT.COLOR_BLACK)); } origLabel.getParent().getParent().layout(); } catch (OseeCoreException ex) { Label errorLabel = editor.getToolkit().createLabel(this, \"Error: \" + ex.getLocalizedMessage()); errorLabel.setForeground(Displays.getSystemColor(SWT.COLOR_RED)); OseeLog.log(Activator.class, Level.SEVERE, ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add this consistent'\nThe code is: 'public BackgroundHiveSplitLoader( String connectorId, Table table, Iterable<HivePartitionMetadata> partitions, Optional<HiveBucketHandle> bucketHandle, List<HiveBucket> buckets, ConnectorSession session, HdfsEnvironment hdfsEnvironment, NamenodeStats namenodeStats, DirectoryLister directoryLister, Executor executor, int maxPartitionBatchSize, int maxInitialSplits, boolean recursiveDirWalkerEnabled) { this.connectorId = connectorId; this.table = table; this.bucketHandle = bucketHandle; this.buckets = buckets; this.maxSplitSize = getMaxSplitSize(session); this.maxPartitionBatchSize = maxPartitionBatchSize; this.session = session; this.hdfsEnvironment = hdfsEnvironment; this.namenodeStats = namenodeStats; this.directoryLister = directoryLister; this.maxInitialSplitSize = getMaxInitialSplitSize(session); this.remainingInitialSplits = new AtomicInteger(maxInitialSplits); this.recursiveDirWalkerEnabled = recursiveDirWalkerEnabled; this.executor = executor; this.partitions = new ConcurrentLazyQueue<>(partitions); <START> hdfsContext = new HdfsContext(session, table.getDatabaseName(), table.getTableName()); <END> \/\/ Add this consistent }'","output":"public BackgroundHiveSplitLoader( String connectorId, Table table, Iterable<HivePartitionMetadata> partitions, Optional<HiveBucketHandle> bucketHandle, List<HiveBucket> buckets, ConnectorSession session, HdfsEnvironment hdfsEnvironment, NamenodeStats namenodeStats, DirectoryLister directoryLister, Executor executor, int maxPartitionBatchSize, int maxInitialSplits, boolean recursiveDirWalkerEnabled) { this.connectorId = connectorId; this.table = table; this.bucketHandle = bucketHandle; this.buckets = buckets; this.maxSplitSize = getMaxSplitSize(session); this.maxPartitionBatchSize = maxPartitionBatchSize; this.session = session; this.hdfsEnvironment = hdfsEnvironment; this.namenodeStats = namenodeStats; this.directoryLister = directoryLister; this.maxInitialSplitSize = getMaxInitialSplitSize(session); this.remainingInitialSplits = new AtomicInteger(maxInitialSplits); this.recursiveDirWalkerEnabled = recursiveDirWalkerEnabled; this.executor = executor; this.partitions = new ConcurrentLazyQueue<>(partitions); this.hdfsContext = new HdfsContext(session, table.getDatabaseName(), table.getTableName()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this a RuntimeException? OFE a client mistake of some form. Server faults runtime exceptions get logged in server'\nThe code is: 'public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException { final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR)); Resource resource = context.getOriginalRootResource(); for (final PathElement element : address) { resource = resource.getChild(element); } byte[] contentHash = resource.getModel().get(CONTENT).asBytes(); try { TypedInputStream inputStream = contentRepository.readContent(contentHash, \"\"); String uuid = context.attachResultStream(inputStream.getContentType(), inputStream); context.getResult().get(UUID).set(uuid); } catch (ExplodedContentException ex) { <START> throw new OperationFailedException(ex.getMessage(), ex); <END> \/\/ this a RuntimeException? OFE a client mistake of some form. Server faults runtime exceptions get logged in server } }'","output":"public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException { final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR)); Resource resource = context.getOriginalRootResource(); for (final PathElement element : address) { resource = resource.getChild(element); } byte[] contentHash = resource.getModel().get(CONTENT).asBytes(); try { TypedInputStream inputStream = contentRepository.readContent(contentHash, \"\"); String uuid = context.attachResultStream(inputStream.getContentType(), inputStream); context.getResult().get(UUID).set(uuid); } catch (ExplodedContentException ex) { throw new RuntimeException(ex.getMessage(), ex); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant parentheses'\nThe code is: 'public boolean getScenes(VeluxBridge bridge) { logger.trace(\"getScenes() called.\"); GetScenes bcp = bridge.bridgeAPI().getScenes(); <START> if ((bridge.bridgeCommunicate(bcp)) && (bcp.isCommunicationSuccessful())) { <END> \/\/ redundant parentheses for (VeluxScene scene : bcp.getScenes()) { logger.trace(\"getScenes() found scene {}.\", scene.toString()); VeluxScene veluxScene = new VeluxScene(scene); logger.trace(\"getScenes() storing scene {}.\", veluxScene); if (!channel.existingScenes.isRegistered(veluxScene)) { channel.existingScenes.register(veluxScene); } logger.trace(\"getScenes() stored scene {}.\", veluxScene); } logger.debug(\"getScenes() finally has found scenes {}.\", channel.existingScenes); return true; } else { logger.trace(\"getScenes() finished with failure.\"); return false; } }'","output":"public boolean getScenes(VeluxBridge bridge) { logger.trace(\"getScenes() called.\"); GetScenes bcp = bridge.bridgeAPI().getScenes(); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { for (VeluxScene scene : bcp.getScenes()) { logger.trace(\"getScenes() found scene {}.\", scene.toString()); VeluxScene veluxScene = new VeluxScene(scene); logger.trace(\"getScenes() storing scene {}.\", veluxScene); if (!channel.existingScenes.isRegistered(veluxScene)) { channel.existingScenes.register(veluxScene); } logger.trace(\"getScenes() stored scene {}.\", veluxScene); } logger.debug(\"getScenes() finally has found scenes {}.\", channel.existingScenes); return true; } else { logger.trace(\"getScenes() finished with failure.\"); return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I final here, scope of variable is short. final obstruct reading more provide guidance'\nThe code is: 'public static Router loadGraph(GraphConfig config) { File graphFile = new File(config.getPath(), GRAPH_FILENAME); LOG.info(\"Loading graph from file '{}'\", graphFile.getPath()); try (InputStream is = new FileInputStream(graphFile)) { <START> final Graph newGraph = Graph.load(is); <END> \/\/ I final here, scope of variable is short. final obstruct reading more provide guidance JsonNode jsonConfig = config.routerConfig(newGraph.routerConfig); Router newRouter = new Router(newGraph); newRouter.startup(jsonConfig); return newRouter; } catch (Exception e) { LOG.error(\"Exception while loading graph: {}\", e); return null; } }'","output":"public static Router loadGraph(GraphConfig config) { File graphFile = new File(config.getPath(), GRAPH_FILENAME); LOG.info(\"Loading graph from file '{}'\", graphFile.getPath()); try (InputStream is = new FileInputStream(graphFile)) { Graph newGraph = Graph.load(is); JsonNode jsonConfig = config.routerConfig(newGraph.routerConfig); Router newRouter = new Router(newGraph); newRouter.startup(jsonConfig); return newRouter; } catch (Exception e) { LOG.error(\"Exception while loading graph: {}\", e); return null; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'useless. this is viewer, reason getViewer() method basically returns this'\nThe code is: 'public SwtXYChartViewer(Composite parent, ChartData data, ChartModel model) { <START> fViewer = this; <END> \/\/ useless. this is viewer, reason getViewer() method basically returns this fParent = parent; fData = data; fModel = model; fXInformation = new DescriptorsInformation(getXDescriptors()); fYInformation = new DescriptorsInformation(getYDescriptors()); validateChartData(); fChart = new Chart(parent, SWT.NONE); fXTitle = generateXTitle(); fYTitle = generateYTitle(); fChart.getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getYAxis(0).getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getYAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTick().setTickLabelAngle(90); refreshDisplayTitles(); Image close = PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_ELCL_REMOVE); fCloseButton = new Button(fChart, SWT.PUSH); fCloseButton.setSize(25, 25); fCloseButton.setLocation(fChart.getSize().x - fCloseButton.getSize().x - 5, 5); fCloseButton.setImage(close); fCloseButton.addSelectionListener(new CloseButtonEvent()); Listener mouseEnter = new MouseEnterEvent(); Listener mouseExit = new MouseExitEvent(); fChart.getDisplay().addFilter(SWT.MouseEnter, mouseEnter); fChart.getDisplay().addFilter(SWT.MouseExit, mouseExit); fChart.addDisposeListener(event -> { fChart.getDisplay().removeFilter(SWT.MouseEnter, mouseEnter); fChart.getDisplay().removeFilter(SWT.MouseExit, mouseExit); }); fChart.addControlListener(new ResizeEvent()); }'","output":"public SwtXYChartViewer(Composite parent, ChartData data, ChartModel model) { fParent = parent; fData = data; fModel = model; fXInformation = new DescriptorsInformation(getXDescriptors()); fYInformation = new DescriptorsInformation(getYDescriptors()); validateChartData(); fChart = new Chart(parent, SWT.NONE); fXTitle = generateXTitle(); fYTitle = generateYTitle(); fChart.getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getYAxis(0).getTitle().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getYAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getXAxis(0).getTick().setTickLabelAngle(90); refreshDisplayTitles(); Image close = PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_ELCL_REMOVE); fCloseButton = new Button(fChart, SWT.PUSH); fCloseButton.setSize(25, 25); fCloseButton.setLocation(fChart.getSize().x - fCloseButton.getSize().x - 5, 5); fCloseButton.setImage(close); fCloseButton.addSelectionListener(new CloseButtonEvent()); Listener mouseEnter = new MouseEnterEvent(); Listener mouseExit = new MouseExitEvent(); fChart.getDisplay().addFilter(SWT.MouseEnter, mouseEnter); fChart.getDisplay().addFilter(SWT.MouseExit, mouseExit); fChart.addDisposeListener(event -> { fChart.getDisplay().removeFilter(SWT.MouseEnter, mouseEnter); fChart.getDisplay().removeFilter(SWT.MouseExit, mouseExit); }); fChart.addControlListener(new ResizeEvent()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO();'\nThe code is: 'protected void executeQueryCommand() { <START> VmDeviceDAO dao = DbFacade.getInstance().getVmDeviceDAO(); <END> \/\/ please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceType.DISK.getName()); for (VmDevice disk: disks) { if (VmPayload.isPayload(disk.getSpecParams())) { VmPayload payload = new VmPayload(VmDeviceType.valueOf(disk.getType().toUpperCase()), disk.getSpecParams()); payload.setType(VmDeviceType.valueOf(disk.getDevice().toUpperCase())); payload.setContent(new String(Base64.decodeBase64(payload.getContent()))); getQueryReturnValue().setReturnValue(payload); } } }'","output":"protected void executeQueryCommand() { VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceType.DISK.getName()); for (VmDevice disk: disks) { if (VmPayload.isPayload(disk.getSpecParams())) { VmPayload payload = new VmPayload(VmDeviceType.valueOf(disk.getType().toUpperCase()), disk.getSpecParams()); payload.setType(VmDeviceType.valueOf(disk.getDevice().toUpperCase())); payload.setContent(new String(Base64.decodeBase64(payload.getContent()))); getQueryReturnValue().setReturnValue(payload); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ArgumentCaptor more removed'\nThe code is: 'public void shouldUpdateChargeToCaptured_IfEpdqStatusIs9AndChargeIsHistoric() throws QueueException { charge = getCharge(true); final String payload = notificationPayloadForTransaction(payId, EPDQ_PAYMENT_REQUESTED); when(mockGatewayAccountService.getGatewayAccount(charge.getGatewayAccountId())).thenReturn(Optional.of(gatewayAccountEntity)); when(mockChargeService.findByProviderAndTransactionIdFromDbOrLedger(EPDQ.getName(), payId)).thenReturn(Optional.of(charge)); <START> ArgumentCaptor<ZonedDateTime> eventTimeStamp = ArgumentCaptor.forClass(ZonedDateTime.class); <END> \/\/ ArgumentCaptor more removed notificationService.handleNotificationFor(payload); verify(mockChargeNotificationProcessor).processCaptureNotificationForExpungedCharge(gatewayAccountEntity, payId, charge, CAPTURED); }'","output":"public void shouldUpdateChargeToCaptured_IfEpdqStatusIs9AndChargeIsHistoric() throws QueueException { charge = getCharge(true); final String payload = notificationPayloadForTransaction(payId, EPDQ_PAYMENT_REQUESTED); when(mockGatewayAccountService.getGatewayAccount(charge.getGatewayAccountId())).thenReturn(Optional.of(gatewayAccountEntity)); when(mockChargeService.findByProviderAndTransactionIdFromDbOrLedger(EPDQ.getName(), payId)).thenReturn(Optional.of(charge)); notificationService.handleNotificationFor(payload); verify(mockChargeNotificationProcessor).processCaptureNotificationForExpungedCharge(gatewayAccountEntity, payId, charge, CAPTURED); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please use: Backend.getInstance().getResourceManager() .RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));'\nThe code is: 'private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) { for (VDS server : existingServers) { if (isRemovableStatus(server.getstatus()) && serverDetached(server, fetchedServers)) { RemoveVdsStatisticsFromDb(server); RemoveVdsDynamicFromDb(server); RemoveVdsStaticFromDb(server); <START> ResourceManager.getInstance().RemoveVds(server.getId()); <END> \/\/ please use: Backend.getInstance().getResourceManager() .RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId())); log.debugFormat(\"Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.\", server.getvds_name()); logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI); } } }'","output":"private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) { for (VDS server : existingServers) { if (isRemovableStatus(server.getstatus()) && serverDetached(server, fetchedServers)) { RemoveVdsStatisticsFromDb(server); RemoveVdsDynamicFromDb(server); RemoveVdsStaticFromDb(server); runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId())); log.debugFormat(\"Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.\", server.getvds_name()); logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'AFAICT this in tests, actual code need caching. refactor avoid that? Also, build this options class is immutable parsed everything? odd this change state hold file contents'\nThe code is: 'public List<String> readDepgraphs() { <START> if (depgraphs != null) { <END> \/\/ AFAICT this in tests, actual code need caching. refactor avoid that? Also, build this options class is immutable parsed everything? odd this change state hold file contents return depgraphs; } List<String> result = new ArrayList<>(); for (String file : depgraphFiles) { try { result.add(Files.toString(new File(file), UTF_8)); } catch (FileNotFoundException e) { throw new IllegalArgumentException(\"depgraph file not found: \" + file, e); } catch (IOException e) { throw new RuntimeException(\"error reading depgraph file \" + file, e); } } return result; }'","output":"public List<String> readDepgraphs() { List<String> result = new ArrayList<>(); for (String file : depgraphFiles) { try { result.add(Files.toString(new File(file), UTF_8)); } catch (FileNotFoundException e) { throw new IllegalArgumentException(\"depgraph file not found: \" + file, e); } catch (IOException e) { throw new RuntimeException(\"error reading depgraph file \" + file, e); } } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'special reason previous test Collections.singletonMap(\"key\", \"value\"); this empty HashMap'\nThe code is: 'public void testSaveAsXml() { final String xml = \"xml\"; final String comment = \"comment\"; <START> final Map<String, Object> attributes = new HashMap<>(); <END> \/\/ special reason previous test Collections.singletonMap(\"key\", \"value\"); this empty HashMap final Path path = mock(Path.class); final Metadata metadata = mock(Metadata.class); final CommentedOption options = mock(CommentedOption.class); when(metadataService.setUpAttributes(path, metadata)).thenReturn(attributes); when(commentedOptionFactory.makeCommentedOption(comment)).thenReturn(options); diagramService.saveAsXml(path, xml, metadata, comment); verify(diagramServiceController, times(1)).saveAsXml(eq(path), eq(xml), eq(attributes), eq(options)); }'","output":"public void testSaveAsXml() { final String xml = \"xml\"; final String comment = \"comment\"; final Map<String, Object> attributes = Collections.singletonMap(\"key\", \"value\"); final Path path = mock(Path.class); final Metadata metadata = mock(Metadata.class); final CommentedOption options = mock(CommentedOption.class); when(metadataService.setUpAttributes(path, metadata)).thenReturn(attributes); when(commentedOptionFactory.makeCommentedOption(comment)).thenReturn(options); diagramService.saveAsXml(path, xml, metadata, comment); verify(diagramServiceController, times(1)).saveAsXml(eq(path), eq(xml), eq(attributes), eq(options)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change static import'\nThe code is: 'public void equals() { Assert.assertEquals(new Version(), new Version()); Assert.assertEquals(new Version(1, 2), new Version(1, 2)); Assert.assertEquals(new Version(1, 2), new Version(\"1.2\")); Assert.assertEquals(new Version(1, 2, 3), new Version(\"1.2.3\")); Assert.assertEquals(new Version(1, 2, 3, 4), new Version(\"1.2.3.4\")); <START> Assert.assertNotNull(new Version()); <END> \/\/ change static import Assert.assertNotEquals(\"foo\", new Version()); Assert.assertNotEquals(1.0d, new Version()); }'","output":"public void equals() { assertEquals(new Version(), new Version()); assertEquals(new Version(1, 2), new Version(1, 2)); assertEquals(new Version(1, 2), new Version(\"1.2\")); assertEquals(new Version(1, 2, 3), new Version(\"1.2.3\")); assertEquals(new Version(1, 2, 3, 4), new Version(\"1.2.3.4\")); assertNotNull(new Version()); assertNotEquals(\"foo\", new Version()); assertNotEquals(1.0d, new Version()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'out of curiosity, is this public'\nThe code is: '<START> public void compile(ICompilationUnit[] sourceUnits, boolean lastRound) { <END> \/\/ out of curiosity, is this public this.stats.startTime = System.currentTimeMillis(); try { reportProgress(Messages.compilation_beginningToCompile); if (this.annotationProcessorManager == null) { beginToCompile(sourceUnits); } else { ICompilationUnit[] originalUnits = sourceUnits.clone(); try { beginToCompile(sourceUnits); if (!lastRound) { processAnnotations(); } if (!this.options.generateClassFiles) { return; } } catch (SourceTypeCollisionException e) { backupAptProblems(); reset(); int originalLength = originalUnits.length; int newProcessedLength = e.newAnnotationProcessorUnits.length; ICompilationUnit[] combinedUnits = new ICompilationUnit[originalLength + newProcessedLength]; System.arraycopy(originalUnits, 0, combinedUnits, 0, originalLength); System.arraycopy(e.newAnnotationProcessorUnits, 0, combinedUnits, originalLength, newProcessedLength); this.annotationProcessorStartIndex = originalLength; compile(combinedUnits, e.isLastRound); return; } } restoreAptProblems(); processCompiledUnits(0, lastRound); } catch (AbortCompilation e) { this.handleInternalException(e, null); } if (this.options.verbose) { if (this.totalUnits > 1) { this.out.println( Messages.bind(Messages.compilation_units, String.valueOf(this.totalUnits))); } else { this.out.println( Messages.bind(Messages.compilation_unit, String.valueOf(this.totalUnits))); } } }'","output":"private void compile(ICompilationUnit[] sourceUnits, boolean lastRound) { this.stats.startTime = System.currentTimeMillis(); try { reportProgress(Messages.compilation_beginningToCompile); if (this.annotationProcessorManager == null) { beginToCompile(sourceUnits); } else { ICompilationUnit[] originalUnits = sourceUnits.clone(); try { beginToCompile(sourceUnits); if (!lastRound) { processAnnotations(); } if (!this.options.generateClassFiles) { return; } } catch (SourceTypeCollisionException e) { backupAptProblems(); reset(); int originalLength = originalUnits.length; int newProcessedLength = e.newAnnotationProcessorUnits.length; ICompilationUnit[] combinedUnits = new ICompilationUnit[originalLength + newProcessedLength]; System.arraycopy(originalUnits, 0, combinedUnits, 0, originalLength); System.arraycopy(e.newAnnotationProcessorUnits, 0, combinedUnits, originalLength, newProcessedLength); this.annotationProcessorStartIndex = originalLength; compile(combinedUnits, e.isLastRound); return; } } restoreAptProblems(); processCompiledUnits(0, lastRound); } catch (AbortCompilation e) { this.handleInternalException(e, null); } if (this.options.verbose) { if (this.totalUnits > 1) { this.out.println( Messages.bind(Messages.compilation_units, String.valueOf(this.totalUnits))); } else { this.out.println( Messages.bind(Messages.compilation_unit, String.valueOf(this.totalUnits))); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'double wrap'\nThe code is: 'private void seekInternal() throws IOException { if (pos == nextPos) { return; } if (nextPos > pos) { long skipped = wrappedStream.skip(nextPos - pos); pos = pos + skipped; } if (nextPos < pos) { wrappedStream.close(); try { wrappedStream = channel.get(path.toUri().getPath()); pos = wrappedStream.skip(nextPos); } catch (SftpException e) { <START> throw new UncheckedIOException(new IOException(e)); <END> \/\/ double wrap } } }'","output":"private void seekInternal() throws IOException { if (pos == nextPos) { return; } if (nextPos > pos) { long skipped = wrappedStream.skip(nextPos - pos); pos = pos + skipped; } if (nextPos < pos) { wrappedStream.close(); try { wrappedStream = channel.get(path.toUri().getPath()); pos = wrappedStream.skip(nextPos); } catch (SftpException e) { throw new IOException(e); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I a fan of assertions in non-test code. Assertions disabled default anyway. please remove them? Thanks'\nThe code is: 'private WatermarkTracker( BlockingQueue<E> queue, long lowerWatermark, long upperWatermark, Function<E, S> classifier, Consumer<S> onLowerWatermarkCrossed, Consumer<S> onUpperWatermarkCrossed) { <START> assert lowerWatermark >= 0 && lowerWatermark < upperWatermark; <END> \/\/ I a fan of assertions in non-test code. Assertions disabled default anyway. please remove them? Thanks this.queue = queue; this.lowerWatermark = lowerWatermark; this.upperWatermark = upperWatermark; this.classifier = classifier; this.onLowerWatermarkCrossed = onLowerWatermarkCrossed; this.onUpperWatermarkCrossed = onUpperWatermarkCrossed; final Map<S, StreamTracker> trackerMap = new ConcurrentHashMap<>(); this.trackerSupplier = key -> trackerMap.computeIfAbsent(key, StreamTracker::new); }'","output":"private WatermarkTracker( BlockingQueue<E> queue, long lowerWatermark, long upperWatermark, Function<E, S> classifier, Consumer<S> onLowerWatermarkCrossed, Consumer<S> onUpperWatermarkCrossed) { this.queue = queue; this.lowerWatermark = lowerWatermark; this.upperWatermark = upperWatermark; this.classifier = classifier; this.onLowerWatermarkCrossed = onLowerWatermarkCrossed; this.onUpperWatermarkCrossed = onUpperWatermarkCrossed; final Map<S, StreamTracker> trackerMap = new ConcurrentHashMap<>(); this.trackerSupplier = key -> trackerMap.computeIfAbsent(key, StreamTracker::new); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consider idToTaskStatusMap.forEach((k, v) -> { ... } for coolness's sake'\nThe code is: 'public void doPolling(Guid cmdId, List<Guid> childCmdIds) { DestroyImageCommand<DestroyImageParameters> command = commandCoordinatorUtil.retrieveCommand(cmdId); Set<Guid> taskIds = new HashSet<>(command.getReturnValue().getVdsmTaskIdList()); Map<Guid, AsyncTaskStatus> idToTaskStatusMap = commandCoordinatorUtil.pollTasks(taskIds); for (Map.Entry<Guid, AsyncTaskStatus> idToTaskStatus : idToTaskStatusMap.entrySet()) { Guid id = idToTaskStatus.getKey(); AsyncTaskStatus status = idToTaskStatus.getValue(); if (status.getTaskIsRunning()) { log.info(\"Waiting on destroy image command to complete the task (taskId = {})\", id); return; } } List<Guid> failedTasks = new ArrayList<>(); <START> for (Map.Entry<Guid, AsyncTaskStatus> idToStatus : idToTaskStatusMap.entrySet()) { Guid id = idToStatus.getKey(); AsyncTaskStatus status = idToStatus.getValue(); if (!status.getTaskEndedSuccessfully()) { failedTasks.add(id); } } <END> \/\/ consider idToTaskStatusMap.forEach((k, v) -> { ... } for coolness's sake if (failedTasks.isEmpty()) { command.setSucceeded(true); command.setCommandStatus(CommandStatus.SUCCEEDED); command.persistCommand(command.getParameters().getParentCommand()); log.info(\"Destroy image command has completed successfully for images '{}' with async tasks '{}'.\", command.getParameters().getImageList(), taskIds); } else { command.setSucceeded(false); command.setCommandStatus(CommandStatus.FAILED); log.info(\"Destroy image command has failed for images '{}' with async tasks '{}'.\", command.getParameters().getImageList(), failedTasks); } command.persistCommand(command.getParameters().getParentCommand()); }'","output":"public void doPolling(Guid cmdId, List<Guid> childCmdIds) { DestroyImageCommand<DestroyImageParameters> command = commandCoordinatorUtil.retrieveCommand(cmdId); Set<Guid> taskIds = new HashSet<>(command.getReturnValue().getVdsmTaskIdList()); Map<Guid, AsyncTaskStatus> idToTaskStatusMap = commandCoordinatorUtil.pollTasks(taskIds); for (Map.Entry<Guid, AsyncTaskStatus> idToTaskStatus : idToTaskStatusMap.entrySet()) { Guid id = idToTaskStatus.getKey(); AsyncTaskStatus status = idToTaskStatus.getValue(); if (status.getTaskIsRunning()) { log.info(\"Waiting on destroy image command to complete the task (taskId = {})\", id); return; } } List<Guid> failedTasks = new ArrayList<>(); idToTaskStatusMap.forEach((id, status) -> { if (!status.getTaskEndedSuccessfully()) { failedTasks.add(id); } }); if (failedTasks.isEmpty()) { command.setSucceeded(true); command.setCommandStatus(CommandStatus.SUCCEEDED); command.persistCommand(command.getParameters().getParentCommand()); log.info(\"Destroy image command has completed successfully for images '{}' with async tasks '{}'.\", command.getParameters().getImageList(), taskIds); } else { command.setSucceeded(false); command.setCommandStatus(CommandStatus.FAILED); log.info(\"Destroy image command has failed for images '{}' with async tasks '{}'.\", command.getParameters().getImageList(), failedTasks); } command.persistCommand(command.getParameters().getParentCommand()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this defined this in plugin.xml? I builder ID. Please org.eclipse.core.tests.resources.regression.SimpleBuilder.BUILDER_ID'\nThe code is: 'private IProject createTestProject(IProgressMonitor monitor) throws CoreException { IProject project = getTestProject(); assertFalse(\"Expected test project to not exist at beginning of test\", project.exists()); ensureExistsInWorkspace(project, true); assertTrue(\"Expected test project to be open after creation\", project.isOpen()); IProjectDescription projectDescription = project.getDescription(); ICommand[] buildSpec = projectDescription.getBuildSpec(); ICommand command = projectDescription.newCommand(); <START> command.setBuilderName(\"Simple Builder\"); <END> \/\/ Is this defined this in plugin.xml? I builder ID. Please org.eclipse.core.tests.resources.regression.SimpleBuilder.BUILDER_ID Collection<ICommand> builders = new ArrayList<>(Arrays.asList(buildSpec)); builders.add(command); projectDescription.setBuildSpec(builders.toArray(new ICommand[] {})); project.setDescription(projectDescription, monitor); return project; }'","output":"private IProject createTestProject(IProgressMonitor monitor) throws CoreException { IProject project = getTestProject(); assertFalse(\"Expected test project to not exist at beginning of test\", project.exists()); ensureExistsInWorkspace(project, true); assertTrue(\"Expected test project to be open after creation\", project.isOpen()); IProjectDescription projectDescription = project.getDescription(); ICommand[] buildSpec = projectDescription.getBuildSpec(); ICommand command = projectDescription.newCommand(); command.setBuilderName(SimpleBuilder.BUILDER_ID); Collection<ICommand> builders = new ArrayList<>(Arrays.asList(buildSpec)); builders.add(command); projectDescription.setBuildSpec(builders.toArray(new ICommand[] {})); project.setDescription(projectDescription, monitor); return project; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'inputData'\nThe code is: 'protected void contextDisposed(IPresentationContext context) { List<InputData> removed = new ArrayList<>(1); synchronized (fInputToData) { for (Iterator<Entry<DefaultBreakpointsViewInput, InputData>> itr = fInputToData.entrySet().iterator(); itr.hasNext();) { Map.Entry<DefaultBreakpointsViewInput, InputData> entry = itr.next(); IPresentationContext entryContext = entry.getKey().getContext(); if (context.equals(entryContext)) { removed.add(entry.getValue()); itr.remove(); } } } for (InputData <START> element : <END> \/\/ inputData removed) { element.dispose(); } }'","output":"protected void contextDisposed(IPresentationContext context) { List<InputData> removed = new ArrayList<>(1); synchronized (fInputToData) { for (Iterator<Entry<DefaultBreakpointsViewInput, InputData>> itr = fInputToData.entrySet().iterator(); itr.hasNext();) { Map.Entry<DefaultBreakpointsViewInput, InputData> entry = itr.next(); IPresentationContext entryContext = entry.getKey().getContext(); if (context.equals(entryContext)) { removed.add(entry.getValue()); itr.remove(); } } } for (InputData inputData : removed) { inputData.dispose(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This variable is once, removed inlined in line 78'\nThe code is: 'public void edit(final VnicInstanceType model) { driver.edit(model); <START> String vnicName = model.getNetworkInterface().getName(); <END> \/\/ This variable is once, removed inlined in line 78 profileEditor.addLabelStyleName(style.noDisplay()); profileEditor.addContentWidgetStyleName(style.contentStyle()); profileEditor.setElementId(ElementIdUtils.createElementId(elementId, vnicName)); syncSelectedItemWithNetworkInterface(model); model.getSelectedItemChangedEvent().addListener(new IEventListener() { @Override public void eventRaised(Event ev, Object sender, EventArgs args) { syncSelectedItemWithNetworkInterface(model); ValueChangeEvent.fire(ProfileInstanceTypeEditor.this, model); } }); }'","output":"public void edit(final VnicInstanceType model) { driver.edit(model); profileEditor.addLabelStyleName(style.noDisplay()); profileEditor.addContentWidgetStyleName(style.contentStyle()); profileEditor.setElementId(ElementIdUtils.createElementId(elementId, model.getNetworkInterface().getName())); syncSelectedItemWithNetworkInterface(model); model.getSelectedItemChangedEvent().addListener(new IEventListener() { @Override public void eventRaised(Event ev, Object sender, EventArgs args) { syncSelectedItemWithNetworkInterface(model); ValueChangeEvent.fire(ProfileInstanceTypeEditor.this, model); } }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move error log condition body'\nThe code is: 'public void evaluate() throws Throwable { IBeforeTest before = null; log.debug(\"Run before test extensions for test class \" + testClass.getJavaClass().getName()); try { for (IBeforeTest bfr : befores) { before = bfr; if (before.hasToRun()){ log.debug(\"Run method runBeforeTest() of class \" + before.getClass().getCanonicalName()); before.runBeforeTest(config, target, frameworkMethod); } } } catch (Throwable e) { <START> log.error(\"Run method runBeforeTest() of class \" + before.getClass().getCanonicalName() + \" failed\", e); <END> \/\/ move error log condition body if (isScreenshotRequired(e)) { createScreenshot(\"BeforeTestExt\", before.getClass()); } throw e; } nextStatement.evaluate(); }'","output":"public void evaluate() throws Throwable { IBeforeTest before = null; log.debug(\"Run before test extensions for test class \" + testClass.getJavaClass().getName()); try { for (IBeforeTest bfr : befores) { before = bfr; if (before.hasToRun()){ log.debug(\"Run method runBeforeTest() of class \" + before.getClass().getCanonicalName()); before.runBeforeTest(config, target, frameworkMethod); } } } catch (Throwable e) { if(ScreenshotCapturer.shouldCaptureScreenshotOnException(e)){ log.error(\"Run method runBeforeTest() of class \" + before.getClass().getCanonicalName() + \" failed\", e); createScreenshot(\"BeforeTestExt\", before.getClass()); } throw e; } nextStatement.evaluate(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Java doc: total number of bytes read buffer, -1 if is more data end of stream reached. Is safer check for -1 >= 0'\nThe code is: 'private byte[] getBytesFromStream(@NonNull InputStream in) { final ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buff = new byte[MAX_CACHED_CONTENT_LENGTH]; try { int n; <START> while ((n = in.read(buff)) > 0) { out.write(buff, 0, n); } <END> \/\/ Java doc: total number of bytes read buffer, -1 if is more data end of stream reached. Is safer check for -1 >= 0 buff = out.toByteArray(); } catch (IOException e) { final String msg = \"Failed reading blob content stream: \" + in; Log.w(DOMAIN, msg, e); throw new IllegalStateException(msg, e); } finally { try { out.close(); } catch (IOException ignore) { } } blobLength = cacheContent(buff); return buff; }'","output":"private byte[] getBytesFromStream(@NonNull InputStream in) { final ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buff = new byte[MAX_CACHED_CONTENT_LENGTH]; try { int n; while ((n = in.read(buff)) >= 0) { out.write(buff, 0, n); } buff = out.toByteArray(); } catch (IOException e) { final String msg = \"Failed reading blob content stream: \" + in; Log.w(DOMAIN, msg, e); throw new IllegalStateException(msg, e); } finally { try { out.close(); } catch (IOException ignore) { } } blobLength = cacheContent(buff); return buff; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a test error'\nThe code is: 'public void testGetCompletionTimesThreeFragmentCausedBy() { String suffix=\"3cb\"; Trace trace1 = new Trace(); trace1.setId(\"1_\"+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(\"testuri\"); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(\"comp1\"); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(\"2_\"+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(\"testuri2\"); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+\":0:0\")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(\"comp2\"); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(\"3_\"+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(\"testuri3\"); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+\":0:0\")); trace3.getNodes().add(c3); try { publisher.publish(null, Arrays.asList(trace1, trace2, trace3)); } catch (Exception e1) { <START> fail(\"Failed to store: \" + e1); <END> \/\/ This a test error } Wait.until(() -> service.searchFragments(null, new Criteria()).size() == 3); Wait.until(() -> analytics.getTraceCompletionTimes(null, new Criteria()).size() == 1, 15, TimeUnit.SECONDS); List<CompletionTime> times = analytics.getTraceCompletionTimes(null, new Criteria()); assertNotNull(times); assertEquals(1, times.size()); assertEquals(5000, times.get(0).getDuration()); }'","output":" public void testGetCompletionTimesThreeFragmentCausedBy() throws Exception { String suffix=\"3cb\"; Trace trace1 = new Trace(); trace1.setId(\"1_\"+suffix); trace1.setStartTime(System.currentTimeMillis() - 60000); Consumer c1 = new Consumer(); c1.setUri(\"testuri\"); c1.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); trace1.getNodes().add(c1); Component comp1 = new Component(); comp1.setUri(\"comp1\"); comp1.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp1.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c1.getNodes().add(comp1); Trace trace2 = new Trace(); trace2.setId(\"2_\"+suffix); trace2.setStartTime(trace1.getStartTime() + 500); Consumer c2 = new Consumer(); c2.setUri(\"testuri2\"); c2.setDuration(TimeUnit.NANOSECONDS.convert(1000, TimeUnit.MILLISECONDS)); c2.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace1.getId()+\":0:0\")); trace2.getNodes().add(c2); Component comp2 = new Component(); comp2.setUri(\"comp2\"); comp2.setBaseTime(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); comp2.setDuration(TimeUnit.NANOSECONDS.convert(500, TimeUnit.MILLISECONDS)); c2.getNodes().add(comp2); Trace trace3 = new Trace(); trace3.setId(\"3_\"+suffix); trace3.setStartTime(trace2.getStartTime() + 500); Consumer c3 = new Consumer(); c3.setUri(\"testuri3\"); c3.setDuration(TimeUnit.NANOSECONDS.convert(4000, TimeUnit.MILLISECONDS)); c3.getCorrelationIds().add(new CorrelationIdentifier(Scope.CausedBy, trace2.getId()+\":0:0\")); trace3.getNodes().add(c3); publisher.publish(null, Arrays.asList(trace1, trace2,"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This method called (and I needed else). Here, repository is marked for deletion organizationalUnitService (with lock acquired), FileSystemDeleteWorker#removeRepository(final Repository repo) remove repository directory once, remove change requests it'\nThe code is: 'protected void doRemoveRepository(final OrganizationalUnit orgUnit, final String alias, final Optional<org.guvnor.structure.organizationalunit.config.RepositoryInfo> thisRepositoryConfig, final Consumer<Repository> notification, final boolean lock) { SpaceConfigStorage configStorage = this.spaceConfigStorage.get(orgUnit.getName()); try { if (lock) { configStorage.startBatch(); } Optional<Repository> repo = Optional.ofNullable(this.configuredRepositories.getRepositoryByRepositoryAlias(orgUnit.getSpace(), alias)); repo.ifPresent(r -> this.close(r.getDefaultBranch())); for (Repository repository : orgUnit.getRepositories()) { if (repository.getAlias().equals(alias)) { <START> configStorage.deleteRepository(alias); <END> \/\/ This method called (and I needed else). Here, repository is marked for deletion organizationalUnitService (with lock acquired), FileSystemDeleteWorker#removeRepository(final Repository repo) remove repository directory once, remove change requests it organizationalUnitService.removeRepository(orgUnit, repository); metadataStore.delete(alias); } } repo.ifPresent(r -> notification.accept(r)); } finally { if (lock) { configStorage.endBatch(); } } }'","output":"protected void doRemoveRepository(final OrganizationalUnit orgUnit, final String alias, final Optional<org.guvnor.structure.organizationalunit.config.RepositoryInfo> thisRepositoryConfig, final Consumer<Repository> notification, final boolean lock) { SpaceConfigStorage configStorage = this.spaceConfigStorage.get(orgUnit.getName()); try { if (lock) { configStorage.startBatch(); } Optional<Repository> repo = Optional.ofNullable(this.configuredRepositories.getRepositoryByRepositoryAlias(orgUnit.getSpace(), alias)); repo.ifPresent(r -> this.close(r.getDefaultBranch())); for (Repository repository : orgUnit.getRepositories()) { if (repository.getAlias().equals(alias)) { organizationalUnitService.removeRepository(orgUnit, repository); metadataStore.delete(alias); } } repo.ifPresent(r -> notification.accept(r)); } finally { if (lock) { configStorage.endBatch(); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'acc......'\nThe code is: 'public boolean checkAccount(HttpServletRequest request) { HttpSession session = request.getSession(); IProject project = (IProject) session.getAttribute(\"Project\"); IUserSession userSession = (IUserSession) session.getAttribute(\"UserSession\"); <START> AccountObject acc = userSession.getAccount(); <END> \/\/ acc...... if (!acc.getEnable()) { return false; } ScrumRole sr = SessionManager.getScrumRole(request, project, acc); if (sr == null) { return false; } if (sr.isGuest()) { return false; } if (sr.isAdmin()) { return true; } return true; }'","output":"public boolean checkAccount(HttpServletRequest request) { HttpSession session = request.getSession(); IProject project = (IProject) session.getAttribute(\"Project\"); IUserSession userSession = (IUserSession) session.getAttribute(\"UserSession\"); AccountObject account = userSession.getAccount(); if (!account.getEnable()) { return false; } ScrumRole sr = SessionManager.getScrumRole(request, project, account); if (sr == null) { return false; } if (sr.isGuest()) { return false; } if (sr.isAdmin()) { return true; } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Print statements reserved for local debugging - include this in core codebase'\nThe code is: 'public ResourceAssignment computeBestPossiblePartitionState( T cache, IdealState idealState, Resource resource, CurrentStateOutput currentStateOutput) { <START> System.out.println(\"Abstract computeBestPossiblePartitionState\"); <END> \/\/ Print statements reserved for local debugging - include this in core codebase if (LOG.isDebugEnabled()) { LOG.debug(\"Processing resource:\" + resource.getResourceName()); } String stateModelDefName = idealState.getStateModelDefRef(); StateModelDefinition stateModelDef = cache.getStateModelDef(stateModelDefName); ResourceAssignment partitionMapping = new ResourceAssignment(resource.getResourceName()); for (Partition partition : resource.getPartitions()) { Set<String> disabledInstancesForPartition = cache.getDisabledInstancesForPartition(resource.getResourceName(), partition.toString()); List<String> preferenceList = getPreferenceList(partition, idealState, Collections.unmodifiableSet(cache.getLiveInstances().keySet())); Map<String, String> bestStateForPartition = computeBestPossibleStateForPartition(cache.getLiveInstances().keySet(), stateModelDef, preferenceList, currentStateOutput, disabledInstancesForPartition, idealState, cache.getClusterConfig(), partition); partitionMapping.addReplicaMap(partition, bestStateForPartition); } return partitionMapping; }'","output":"public ResourceAssignment computeBestPossiblePartitionState( T cache, IdealState idealState, Resource resource, CurrentStateOutput currentStateOutput) { if (LOG.isDebugEnabled()) { LOG.debug(\"Processing resource:\" + resource.getResourceName()); } String stateModelDefName = idealState.getStateModelDefRef(); StateModelDefinition stateModelDef = cache.getStateModelDef(stateModelDefName); ResourceAssignment partitionMapping = new ResourceAssignment(resource.getResourceName()); for (Partition partition : resource.getPartitions()) { Set<String> disabledInstancesForPartition = cache.getDisabledInstancesForPartition(resource.getResourceName(), partition.toString()); List<String> preferenceList = getPreferenceList(partition, idealState, Collections.unmodifiableSet(cache.getLiveInstances().keySet())); Map<String, String> bestStateForPartition = computeBestPossibleStateForPartition(cache.getLiveInstances().keySet(), stateModelDef, preferenceList, currentStateOutput, disabledInstancesForPartition, idealState, cache.getClusterConfig(), partition); partitionMapping.addReplicaMap(partition, bestStateForPartition); } return partitionMapping; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ISE is thrown'\nThe code is: '<START> public void start() throws ISE <END> \/\/ ISE is thrown { synchronized (lifecycleLock) { if (!lifecycleLock.canStart()) { throw new ISE(\"can't start.\"); } log.info(\"Starting HttpServerInventoryView.\"); try { executor = ScheduledExecutors.fixed( config.getNumThreads(), \"HttpServerInventoryView-%s\" ); DruidNodeDiscovery druidNodeDiscovery = druidNodeDiscoveryProvider.getForService(DataNodeService.DISCOVERY_SERVICE_KEY); druidNodeDiscovery.registerListener( new DruidNodeDiscovery.Listener() { private final AtomicBoolean initialized = new AtomicBoolean(false); @Override public void nodesAdded(Collection<DiscoveryDruidNode> nodes) { nodes.forEach(node -> serverAdded(toDruidServer(node))); } @Override public void nodesRemoved(Collection<DiscoveryDruidNode> nodes) { nodes.forEach(node -> serverRemoved(toDruidServer(node))); } @Override public void nodeViewInitialized() { if (!initialized.getAndSet(true)) { executor.execute(HttpServerInventoryView.this::serverInventoryInitialized); } } private DruidServer toDruidServer(DiscoveryDruidNode node) { return new DruidServer( node.getDruidNode().getHostAndPortToUse(), node.getDruidNode().getHostAndPort(), node.getDruidNode().getHostAndTlsPort(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getMaxSize(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getType(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getTier(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getPriority() ); } } ); scheduleSyncMonitoring(); lifecycleLock.started(); } finally { lifecycleLock.exitStart(); } log.info(\"Started HttpServerInventoryView.\"); } }'","output":"public void start() { synchronized (lifecycleLock) { if (!lifecycleLock.canStart()) { throw new ISE(\"can't start.\"); } log.info(\"Starting HttpServerInventoryView.\"); try { executor = ScheduledExecutors.fixed( config.getNumThreads(), \"HttpServerInventoryView-%s\" ); DruidNodeDiscovery druidNodeDiscovery = druidNodeDiscoveryProvider.getForService(DataNodeService.DISCOVERY_SERVICE_KEY); druidNodeDiscovery.registerListener( new DruidNodeDiscovery.Listener() { private final AtomicBoolean initialized = new AtomicBoolean(false); @Override public void nodesAdded(Collection<DiscoveryDruidNode> nodes) { nodes.forEach(node -> serverAdded(toDruidServer(node))); } @Override public void nodesRemoved(Collection<DiscoveryDruidNode> nodes) { nodes.forEach(node -> serverRemoved(toDruidServer(node))); } @Override public void nodeViewInitialized() { if (!initialized.getAndSet(true)) { executor.execute(HttpServerInventoryView.this::serverInventoryInitialized); } } private DruidServer toDruidServer(DiscoveryDruidNode node) { return new DruidServer( node.getDruidNode().getHostAndPortToUse(), node.getDruidNode().getHostAndPort(), node.getDruidNode().getHostAndTlsPort(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getMaxSize(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getType(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getTier(), ((DataNodeService) node.getServices().get(DataNodeService.DISCOVERY_SERVICE_KEY)).getPriority() ); } } ); scheduleSyncMonitoring(); lifecycleLock.started(); } finally { lifecycleLock.exitStart(); } log.info(\"Started HttpServerInventoryView.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I 'AbstractRegistry.DOCKERHUB_REGISTRY' changes easier track'\nThe code is: 'private SelectionListener onAdd(Combo combo) { return new SelectionAdapter() { @Override public void widgetSelected(final SelectionEvent e) { String selected = combo.getText(); RegistryAccountDialog dialog = new RegistryAccountDialog( getShell(), WizardMessages.getString( \"ImagePullPushPage.login.title\"), <START> \"index.docker.io\", <END> \/\/ I 'AbstractRegistry.DOCKERHUB_REGISTRY' changes easier track WizardMessages.getString( \"RegistryAccountDialog.add.explanation\")); if (dialog.open() == Window.OK) { IRegistryAccount acc = dialog.getSignonInformation(); RegistryAccountManager.getInstance().add(acc); selected = acc.getUsername() + \"@\" + acc.getServerAddress(); } combo.setItems(getAccountComboItems()); combo.setText(selected); } }; }'","output":"private SelectionListener onAdd(Combo combo) { return new SelectionAdapter() { @Override public void widgetSelected(final SelectionEvent e) { String selected = combo.getText(); RegistryAccountDialog dialog = new RegistryAccountDialog( getShell(), WizardMessages.getString( \"ImagePullPushPage.login.title\"), AbstractRegistry.DOCKERHUB_REGISTRY, WizardMessages.getString( \"RegistryAccountDialog.add.explanation\")); if (dialog.open() == Window.OK) { IRegistryAccount acc = dialog.getSignonInformation(); RegistryAccountManager.getInstance().add(acc); selected = acc.getUsername() + \"@\" + acc.getServerAddress(); } combo.setItems(getAccountComboItems()); combo.setText(selected); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'vulnerable injection here. SQL arguments pass values over, construct a string manually'\nThe code is: 'public static PreparedStatement prepareTableSelectStatement(Connection c, String storageKey, String[] fields, String[] values, Persistable p) { org.commcare.modern.database.TableBuilder mTableBuilder = new org.commcare.modern.database.TableBuilder(storageKey); mTableBuilder.addData(p); Pair<String, String[]> mPair = DatabaseHelper.createWhere(fields, values, p); try { String queryString = <START> \"SELECT * FROM \" + storageKey + \" WHERE \" + mPair.first + \";\"; <END> \/\/ vulnerable injection here. SQL arguments pass values over, construct a string manually PreparedStatement preparedStatement = c.prepareStatement(queryString); for (int i = 0; i < mPair.second.length; i++) { preparedStatement.setString(i + 1, mPair.second[i]); } return preparedStatement; } catch (SQLException e) { e.printStackTrace(); return null; } }'","output":"public static PreparedStatement prepareTableSelectStatement(Connection c, String storageKey, String[] fields, String[] values, Persistable p) { org.commcare.modern.database.TableBuilder mTableBuilder = new org.commcare.modern.database.TableBuilder(storageKey); mTableBuilder.addData(p); Pair<String, String[]> mPair = DatabaseHelper.createWhere(fields, values, p); try { String queryString = \"SELECT * FROM \" + storageKey + \" WHERE \" + mPair.first + \";\"; PreparedStatement preparedStatement = c.prepareStatement(queryString); for (int i = 0; i < mPair.second.length; i++) { preparedStatement.setString(i + 1, mPair.second[i]); } return preparedStatement; } catch (SQLException e) { throw new RuntimeException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check luns list empty'\nThe code is: 'public Response add(Disk disk) { validateParameters(disk, \"format\", \"interface\"); <START> if (!disk.isSetLunStorage()) { END> validateParameters(disk, \"provisionedSize|size\"); } validateEnums(Disk.class, disk); AddDiskParameters params = new AddDiskParameters(); params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null)); if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) { params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId())); } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) { Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName()); if (storageDomainId == null) { notFound(StorageDomain.class); } else { params.setStorageDomainId(storageDomainId); } } return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class)); }'","output":"public Response add(Disk disk) { validateParameters(disk, \"format\", \"interface\"); if (!disk.isSetLunStorage() || disk.getLunStorage().getLogicalUnits().isEmpty()) { validateParameters(disk, \"provisionedSize|size\"); } validateEnums(Disk.class, disk); AddDiskParameters params = new AddDiskParameters(); params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null)); if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) { params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId())); } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) { Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName()); if (storageDomainId == null) { notFound(StorageDomain.class); } else { params.setStorageDomainId(storageDomainId); } } return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is reset if test failed before'\nThe code is: 'public void testEnforceValidityErrorsOnly() throws Exception { Dictionary<String, Object> markerPluginProps = configureValidationMarkerPlugin( Collections.singletonList(SAMPLE_VALIDATOR), true, false, getAdminConfig()); String warningId = ingestXmlFromResourceAndWait(WARNING_METACARD); String cleanId = ingestXmlFromResourceAndWait(CLEAN_METACARD); ingestXmlFromResourceWaitForFailure(ERROR_METACARD); query(cleanId, TRANSFORMER_XML, HttpStatus.SC_OK); query(warningId, TRANSFORMER_XML, HttpStatus.SC_OK); String warningData = getFileContent(WARNING_METACARD); String errorData = getFileContent(ERROR_METACARD); update(cleanId, warningData, MediaType.APPLICATION_XML, HttpStatus.SC_OK); update(cleanId, errorData, MediaType.APPLICATION_XML, HttpStatus.SC_BAD_REQUEST); <START> configureValidationMarkerPlugin(markerPluginProps, getAdminConfig()); <END> \/\/ is reset if test failed before }'","output":"public void testEnforceValidityErrorsOnly() throws Exception { Dictionary<String, Object> markerPluginProps = configureValidationMarkerPlugin( Collections.singletonList(SAMPLE_VALIDATOR), true, false, getAdminConfig()); try { String warningId = ingestXmlFromResourceAndWait(WARNING_METACARD); String cleanId = ingestXmlFromResourceAndWait(CLEAN_METACARD); ingestXmlFromResourceWaitForFailure(ERROR_METACARD); query(cleanId, TRANSFORMER_XML, HttpStatus.SC_OK); query(warningId, TRANSFORMER_XML, HttpStatus.SC_OK); String warningData = getFileContent(WARNING_METACARD); String errorData = getFileContent(ERROR_METACARD); update(cleanId, warningData, MediaType.APPLICATION_XML, HttpStatus.SC_OK); update(cleanId, errorData, MediaType.APPLICATION_XML, HttpStatus.SC_BAD_REQUEST); } finally { configureValidationMarkerPlugin(markerPluginProps, getAdminConfig()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move this check in GoogleCloudStorageReadChannel, determine initialization if opened file is GZIP encoded'\nThe code is: 'public SeekableByteChannel open( final StorageResourceId resourceId, GoogleCloudStorageReadOptions readOptions) throws IOException { logger.atFine().log(\"open(%s, %s)\", resourceId, readOptions); Preconditions.checkArgument( resourceId.isStorageObject(), \"Expected full StorageObject id, got %s\", resourceId); GoogleCloudStorageItemInfo info; if (readOptions.getFastFailOnNotFound()) { info = getItemInfo(resourceId); if (!info.exists()) { throw GoogleCloudStorageExceptions.getFileNotFoundException( resourceId.getBucketName(), resourceId.getObjectName()); } <START> if (readOptions.getFastFailOnGzipEncoding() <END> \/\/ move this check in GoogleCloudStorageReadChannel, determine initialization if opened file is GZIP encoded && (GZIP_ENCODING.equals(info.getContentEncoding()) || GZIP_TYPE.equals(info.getContentType()))) { throw new IOException(\"Gzip encoding is deprecated\"); } } else { info = null; } return new GoogleCloudStorageReadChannel( gcs, resourceId.getBucketName(), resourceId.getObjectName(), errorExtractor, clientRequestHelper, readOptions) { @Override @Nullable protected GoogleCloudStorageItemInfo getInitialMetadata() { return info; } @Override protected Storage.Objects.Get createRequest() throws IOException { return configureRequest(super.createRequest(), resourceId.getBucketName()); } }; }'","output":"public SeekableByteChannel open( final StorageResourceId resourceId, GoogleCloudStorageReadOptions readOptions) throws IOException { logger.atFine().log(\"open(%s, %s)\", resourceId, readOptions); Preconditions.checkArgument( resourceId.isStorageObject(), \"Expected full StorageObject id, got %s\", resourceId); GoogleCloudStorageItemInfo info; if (readOptions.getFastFailOnNotFound()) { info = getItemInfo(resourceId); if (!info.exists()) { throw GoogleCloudStorageExceptions.getFileNotFoundException( resourceId.getBucketName(), resourceId.getObjectName()); } } else { info = null; } return new GoogleCloudStorageReadChannel( gcs, resourceId.getBucketName(), resourceId.getObjectName(), errorExtractor, clientRequestHelper, readOptions) { @Override @Nullable protected GoogleCloudStorageItemInfo getInitialMetadata() { return info; } @Override protected Storage.Objects.Get createRequest() throws IOException { return configureRequest(super.createRequest(), resourceId.getBucketName()); } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This similar other method file name check in code. is good refactor avoid duplication. private byte[] getJarFileAsByteArray (File tarFile) { return getFileAsByteArray(tarFile, x -> x.endsWith(\".jar\")); } private byte[] getFileAsByteArray (File tarFile, final String fileName) { return getFileAsByteArray(tarFile, x -> x.equals(fileName)); } private byte[] getFileAsByteArray (File tarFile, Function<String, Boolean> filterFunc) { byte[] data = null; LOG.info(\"Looking file {}\", tarFile); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(tarFile)); TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(bis)) { TarArchiveEntry tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); while (tarArchiveEntry != null) { if (filterFunc.apply(tarArchiveEntry.getName())) { data = IOUtils.toByteArray(tarArchiveInputStream); break; } tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); } } catch (IOException e) { LOG.warn(\"Exception occurred while tar file [] \", filterFunc, tarFile, e); } return data; }'\nThe code is: '<START> private byte[] getJarFileAsByteArray (File tarFile) { <END> \/\/ This similar other method file name check in code. is good refactor avoid duplication. private byte[] getJarFileAsByteArray (File tarFile) { return getFileAsByteArray(tarFile, x -> x.endsWith(\".jar\")); } private byte[] getFileAsByteArray (File tarFile, final String fileName) { return getFileAsByteArray(tarFile, x -> x.equals(fileName)); } private byte[] getFileAsByteArray (File tarFile, Function<String, Boolean> filterFunc) { byte[] data = null; LOG.info(\"Looking file {}\", tarFile); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(tarFile)); TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(bis)) { TarArchiveEntry tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); while (tarArchiveEntry != null) { if (filterFunc.apply(tarArchiveEntry.getName())) { data = IOUtils.toByteArray(tarArchiveInputStream); break; } tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); } } catch (IOException e) { LOG.warn(\"Exception occurred while tar file [] \", filterFunc, tarFile, e); } return data; } byte[] data = null; LOG.info(\"Getting jar file from {}\", tarFile); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(tarFile)); TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(bis)) { TarArchiveEntry tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); while (tarArchiveEntry != null) { if (tarArchiveEntry.getName().endsWith(\".jar\")) { data = IOUtils.toByteArray(tarArchiveInputStream); break; } tarArchiveEntry = tarArchiveInputStream.getNextTarEntry(); } } catch (IOException e) { LOG.warn(\"Exception occured while getting jar file: from \" + tarFile, e); } return data; }'","output":"private byte[] getJarFileAsByteArray (File tarFile) { return getFileAsByteArray(tarFile, x -> x.endsWith(\".jar\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This case user presses escape (closing dialog). progress bar is cleared that'\nThe code is: 'public void testrunMultipleActions_ignored_failure_multiple() { ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>(); parameters.add(new VdcActionParametersBase()); testState = null; frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, null); verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture()); StatusCodeException exception = new StatusCodeException(0, \"0 status code\"); callbackMultipleActions.getValue().onFailure(exception); verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any()); verify(mockMultipleActionCallback, never()).executed(callbackMultipleParam.capture()); <START> verifyAsyncActionStarted(); <END> \/\/ This case user presses escape (closing dialog). progress bar is cleared that }'","output":"public void testrunMultipleActions_ignored_failure_multiple() { ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>(); parameters.add(new VdcActionParametersBase()); testState = null; frontend.runMultipleAction(VdcActionType.AddLocalStorageDomain, parameters, false, mockMultipleActionCallback, null); verify(mockService).runMultipleActions(eq(VdcActionType.AddLocalStorageDomain), eq(parameters), eq(false), eq(false), callbackMultipleActions.capture()); StatusCodeException exception = new StatusCodeException(0, \"0 status code\"); callbackMultipleActions.getValue().onFailure(exception); verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (FrontendFailureEventArgs) any()); verify(mockMultipleActionCallback, never()).executed(callbackMultipleParam.capture()); verifyAsyncActionStartedButNotCompleted(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringUtil.isEmpty'\nThe code is: 'public CreateXmlResourcePanel(@NotNull Module module, @NotNull ResourceType resourceType, @Nullable String predefinedName, @Nullable String predefinedValue, boolean chooseName, @Nullable VirtualFile defaultFile) { this(module, resourceType, defaultFile); if (chooseName) { predefinedName = ResourceHelper.prependResourcePrefix(module, predefinedName); } <START> if (predefinedName != null && predefinedName.length() > 0) { <END> \/\/ StringUtil.isEmpty if (chooseName) { myNameLabel.setVisible(true); myNameField.setVisible(true); } myNameField.setText(predefinedName); } else { myNameLabel.setVisible(true); myNameField.setVisible(true); } if (predefinedValue != null && predefinedValue.length() > 0) { myValueField.setText(predefinedValue); } else { myValueLabel.setVisible(true); myValueField.setVisible(true); } }'","output":"public CreateXmlResourcePanel(@NotNull Module module, @NotNull ResourceType resourceType, @Nullable String predefinedName, @Nullable String predefinedValue, boolean chooseName, @Nullable VirtualFile defaultFile) { this(module, resourceType, defaultFile); if (chooseName) { predefinedName = ResourceHelper.prependResourcePrefix(module, predefinedName); } if (!StringUtil.isEmpty(predefinedName)) { if (chooseName) { myNameLabel.setVisible(true); myNameField.setVisible(true); } myNameField.setText(predefinedName); } else { myNameLabel.setVisible(true); myNameField.setVisible(true); } if (!StringUtil.isEmpty(predefinedValue)) { myValueField.setText(predefinedValue); } else { myValueLabel.setVisible(true); myValueField.setVisible(true); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'createSafeXmlSource'\nThe code is: 'public static ScenarioModifierManifest Deserialize(String fileName) { ScenarioModifierManifest resultingList = null; try { JAXBContext context = JAXBContext.newInstance(ScenarioModifierManifest.class); Unmarshaller um = context.createUnmarshaller(); File xmlFile = new File(fileName); if(!xmlFile.exists()) { MekHQ.getLogger().warning(ScenarioModifierManifest.class, \"Deserialize\", String.format(\"Specified file %s does not exist\", fileName)); return null; } <START> JAXBElement<ScenarioModifierManifest> templateElement = um.unmarshal(new StreamSource(xmlFile), ScenarioModifierManifest.class); <END> \/\/ createSafeXmlSource resultingList = templateElement.getValue(); } catch(Exception e) { MekHQ.getLogger().error(ScenarioModifierManifest.class, \"Deserialize\", \"Error Deserializing Scenario Modifier List\", e); } return resultingList; }'","output":"public static ScenarioModifierManifest Deserialize(String fileName) { ScenarioModifierManifest resultingList = null; try { JAXBContext context = JAXBContext.newInstance(ScenarioModifierManifest.class); Unmarshaller um = context.createUnmarshaller(); File xmlFile = new File(fileName); if(!xmlFile.exists()) { MekHQ.getLogger().warning(ScenarioModifierManifest.class, \"Deserialize\", String.format(\"Specified file %s does not exist\", fileName)); return null; } Source inputSource = MekHqXmlUtil.createSafeXmlSource(new FileInputStream(xmlFile)); JAXBElement<ScenarioModifierManifest> templateElement = um.unmarshal(inputSource, ScenarioModifierManifest.class); resultingList = templateElement.getValue(); } catch(Exception e) { MekHQ.getLogger().error(ScenarioModifierManifest.class, \"Deserialize\", \"Error Deserializing Scenario Modifier List\", e); } return resultingList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'StringBuilder'\nThe code is: 'public String toString() { <START> StringBuffer sb = new StringBuffer( super.toString() ); <END> \/\/ StringBuilder sb.append( \"(GAVCE=\" ); sb.append( getGroupId() ); sb.append( \":\" ); sb.append( getArtifactId() ); sb.append( \":\" ); sb.append( getVersion() ); sb.append( \":c=\" ); sb.append( getClassifier() ); sb.append( \":e=\" ); sb.append( getExtension() ); sb.append( \", for \" ); sb.append( RepositoryStringUtils.getHumanizedNameString( getMavenRepository() ) ); sb.append( \") \" ); return sb.toString(); }'","output":"public String toString() { StringBuilder sb = new StringBuilder( super.toString() ); sb.append( \"(GAVCE=\" ); sb.append( getGroupId() ); sb.append( \":\" ); sb.append( getArtifactId() ); sb.append( \":\" ); sb.append( getVersion() ); sb.append( \":c=\" ); sb.append( getClassifier() ); sb.append( \":e=\" ); sb.append( getExtension() ); sb.append( \", for \" ); sb.append( RepositoryStringUtils.getHumanizedNameString( getMavenRepository() ) ); sb.append( \") \" ); return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I propose replace this ISA a IAE, a functional error'\nThe code is: 'public void handle(Request request, Response response) throws Exception { try (DbSession dbSession = dbClient.openSession(false)) { String componentKey = request.mandatoryParam(PARAM_KEY); ComponentDto component = componentFinder.getByKey(dbSession, componentKey); userSession.checkComponentPermission(USER, component); Map<String, String> keysByUUid = keysByUUid(dbSession, component); ScannerInput.ServerIssue.Builder responseBuilder = ScannerInput.ServerIssue.newBuilder(); response.stream().setMediaType(MediaTypes.PROTOBUF); OutputStream output = response.stream().output(); ResultHandler<IssueDto> handler = resultContext -> { IssueDto issue = resultContext.getResultObject(); handleIssue(issue, responseBuilder, keysByUUid, output); }; switch (component.scope()) { case Scopes.PROJECT: dbClient.issueDao().scrollNonClosedByModuleOrProject(dbSession, component, handler); break; case Scopes.FILE: dbClient.issueDao().scrollNonClosedByComponentUuid(dbSession, component.uuid(), handler); break; default: <START> throw new IllegalStateException(format(\"Component of scope '%s' is not allowed\", component.scope())); <END> \/\/ I propose replace this ISA a IAE, a functional error } } }'","output":"public void handle(Request request, Response response) throws Exception { try (DbSession dbSession = dbClient.openSession(false)) { String componentKey = request.mandatoryParam(PARAM_KEY); ComponentDto component = componentFinder.getByKey(dbSession, componentKey); userSession.checkComponentPermission(USER, component); Map<String, String> keysByUUid = keysByUUid(dbSession, component); ScannerInput.ServerIssue.Builder responseBuilder = ScannerInput.ServerIssue.newBuilder(); response.stream().setMediaType(MediaTypes.PROTOBUF); OutputStream output = response.stream().output(); ResultHandler<IssueDto> handler = resultContext -> { IssueDto issue = resultContext.getResultObject(); handleIssue(issue, responseBuilder, keysByUUid, output); }; switch (component.scope()) { case Scopes.PROJECT: dbClient.issueDao().scrollNonClosedByModuleOrProject(dbSession, component, handler); break; case Scopes.FILE: dbClient.issueDao().scrollNonClosedByComponentUuid(dbSession, component.uuid(), handler); break; default: throw new IllegalArgumentException(format(\"Component of scope '%s' is not allowed\", component.scope())); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Do need wrap unsafe args? a non-zero allocation & GC cost wrapping for logging in tight loops hot code paths (though this specific case is one). realize this this before, calling toString() log args kind of defeats point of lazy evaluation if logging log level'\nThe code is: 'public void cleanUpSchemaMutationLockTablesState() throws Exception { Set<TableReference> tables = lockTables.getAllLockTables(); java.util.Optional<TableReference> tableToKeep = tables.stream().findFirst(); if (!tableToKeep.isPresent()) { log.info(\"No lock tables to clean up.\"); return; } tables.remove(tableToKeep.get()); if (tables.size() > 0) { dropTablesInternal(tables); <START> log.info(\"Dropped tables [{}]\", UnsafeArg.of(\"table names\", tables.toString())); <END> \/\/ Do need wrap unsafe args? a non-zero allocation & GC cost wrapping for logging in tight loops hot code paths (though this specific case is one). realize this this before, calling toString() log args kind of defeats point of lazy evaluation if logging log level } schemaMutationLock.cleanLockState(); log.info(\"Reset the schema mutation lock in table [{}]\", UnsafeArg.of(\"table name\", tableToKeep.get().toString())); }'","output":"public void cleanUpSchemaMutationLockTablesState() throws Exception { Set<TableReference> tables = lockTables.getAllLockTables(); java.util.Optional<TableReference> tableToKeep = tables.stream().findFirst(); if (!tableToKeep.isPresent()) { log.info(\"No lock tables to clean up.\"); return; } tables.remove(tableToKeep.get()); if (tables.size() > 0) { dropTablesInternal(tables); log.info(\"Dropped tables [{}]\", UnsafeArg.of(\"table names\", tables)); } schemaMutationLock.cleanLockState(); log.info(\"Reset the schema mutation lock in table [{}]\", UnsafeArg.of(\"table name\", tableToKeep.get().toString())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ok move lines BBCTTestUtil.removeCard'\nThe code is: 'public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); <START> <END> \/\/ ok move lines BBCTTestUtil.removeCard View deleteMenu = this.activity.findViewById(R.id.delete_menu); Assert.assertNotNull(deleteMenu); TouchUtils.clickView(this, deleteMenu); BBCTTestUtil.waitForToast(this.solo, BBCTTestUtil.DELETE_MESSAGE); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }'","output":"public void testDeleteCardUsingFilter() throws Throwable { this.testYearFilter(); int cardIndex = 0; final int year = 1993; Predicate<BaseballCard> yearPred = new Predicate<BaseballCard>() { @Override public boolean doTest(BaseballCard card) { return card.getYear() == year; } }; this.expectedCards = BBCTTestUtil.filterList(this.allCards, yearPred); this.expectedCards.remove(cardIndex); Assert.assertTrue(this.solo.waitForView(R.id.select_all)); this.solo.clickOnCheckBox(cardIndex + 1); Assert.assertTrue(this.solo.waitForView(R.id.delete_menu)); deleteCards(); ListView lv = (ListView) this.solo.getCurrentActivity().findViewById(android.R.id.list); BBCTTestUtil.assertListViewContainsItems(this.expectedCards, lv); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'e.getMessage()'\nThe code is: 'private Map<String, String> retrieveByLocale(Locale locale, String messageSource, Map<String, String> messages) { try { ResourceBundle bundle = ResourceBundle.getBundle(messageSource, locale); for (String key : bundle.keySet()) { if (!messages.containsKey(key)) { messages.put(key, bundle.getString(key)); } else { log.warn(\"Code '{}' appears more than once in string table.\", key); } } } catch (RuntimeException e) { <START> log.error(\"File: '{}' could not be loaded: {}\", messageSource, e.toString()); <END> \/\/ e.getMessage() log.debug(\"Exception\", e); } return messages; }'","output":"private Map<String, String> retrieveByLocale(Locale locale, String messageSource, Map<String, String> messages) { try { ResourceBundle bundle = ResourceBundle.getBundle(messageSource, locale); for (String key : bundle.keySet()) { if (!messages.containsKey(key)) { messages.put(key, bundle.getString(key)); } else { log.warn(\"Code '{}' appears more than once in string table.\", key); } } } catch (RuntimeException e) { log.error(\"File: '{}' could not be loaded: {}\", messageSource, e.getMessage()); log.debug(\"Exception\", e); } return messages; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'tokens.stream().anyMatch() here'\nThe code is: 'public void setNodeTokens(String nodeUrl, List<String> tokens) throws RMException { <START> if (tokens.stream().filter(token -> token == null || token.isEmpty()).findFirst().isPresent()) { <END> \/\/ tokens.stream().anyMatch() here throw new RMException(\"Invalid empty token in list \" + tokens); } if (allNodes.containsKey(nodeUrl)) { RMNode rmNode = allNodes.get(nodeUrl); rmNode.setNodeTokens(nodeUrl, tokens); persistUpdatedRMNodeIfRecoveryEnabled(rmNode); registerAndEmitNodeEvent(rmNode.createNodeEvent(RMEventType.NODE_STATE_CHANGED, rmNode.getState(), rmNode.getProvider().getName())); } else { throw new RMException(\"Unknown node \" + nodeUrl); } }'","output":"public void setNodeTokens(String nodeUrl, List<String> tokens) throws RMException { if (tokens.stream().anyMatch(token -> token == null || token.isEmpty())) { throw new RMException(\"Invalid empty token in list \" + tokens); } if (allNodes.containsKey(nodeUrl)) { RMNode rmNode = allNodes.get(nodeUrl); rmNode.setNodeTokens(nodeUrl, tokens); persistUpdatedRMNodeIfRecoveryEnabled(rmNode); registerAndEmitNodeEvent(rmNode.createNodeEvent(RMEventType.NODE_STATE_CHANGED, rmNode.getState(), rmNode.getProvider().getName())); } else { throw new RMException(\"Unknown node \" + nodeUrl); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrong type. List<String>'\nThe code is: 'public static List<String> getReferencedTypes(final File file) { <START> ArrayList<String> <END> \/\/ Wrong type. List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(\"<LINK_0>\", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = \"\"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }'","output":"public static List<String> getReferencedTypes(final File file) { List<String> references = new ArrayList<>(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; dbf.setAttribute(\"<LINK_0>\", Boolean.FALSE); try { db = dbf.newDocumentBuilder(); Document document; document = db.parse(file); Node rootNode = document.getDocumentElement(); NodeList childNodes = rootNode.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node n = childNodes.item(i); if (n.getNodeName().equals(LibraryElementTags.RESOURCE_ELEMENT)) { String type = \"\"; type = n.getAttributes().getNamedItem(LibraryElementTags.TYPE_ATTRIBUTE).getNodeValue(); references.add(type); } } } catch (Exception e) { Activator.getDefault().logError(e.getMessage(), e); } return references; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'List<String> lines = Files.readAllLines(filePath);'\nThe code is: 'public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(\"large_polygon.txt\").getPath()); <START> List<String> lines = Files.lines(filePath).collect(Collectors.toList()); <END> \/\/ List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(\"\\\\|\"); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); long tileCount = Long.parseLong(parts[2]); assertFunction(\"cardinality(geometry_to_bing_tiles(ST_GeometryFromText('\" + wkt + \"'), \" + zoomLevel + \"))\", BIGINT, tileCount); } }'","output":"public void testLargeGeometryToBingTiles() throws Exception { Path filePath = Paths.get(this.getClass().getClassLoader().getResource(\"large_polygon.txt\").getPath()); List<String> lines = Files.readAllLines(filePath); for (String line : lines) { String[] parts = line.split(\"\\\\|\"); String wkt = parts[0]; int zoomLevel = Integer.parseInt(parts[1]); long tileCount = Long.parseLong(parts[2]); assertFunction(\"cardinality(geometry_to_bing_tiles(ST_GeometryFromText('\" + wkt + \"'), \" + zoomLevel + \"))\", BIGINT, tileCount); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success'\nThe code is: 'beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { try { Objects.requireNonNull(receipt, \"'receipt' is required and cannot be null.\"); recognizeOptions = getRecognizeOptionsProperties(recognizeOptions); final boolean isIncludeFieldElements = recognizeOptions.isIncludeFieldElements(); return new PollerFlux<>( recognizeOptions.getPollInterval(), streamActivationOperation( (contentType -> service.analyzeReceiptAsyncWithResponseAsync( contentType, receipt, length, isIncludeFieldElements).map(response -> new OperationResult( parseModelId(response.getDeserializedHeaders().getOperationLocation())))), receipt, recognizeOptions.getContentType()), pollingOperation(service::getAnalyzeReceiptResultWithResponseAsync), (activationResponse, context) -> monoError(logger, new RuntimeException(\"Cancellation is not supported\")), fetchingOperation(service::getAnalyzeReceiptResultWithResponseAsync) .andThen(after -> after.map(modelSimpleResponse -> { <START> throwIfAnalyzeStatusInvalid(modelSimpleResponse.getValue()); <END> \/\/ Throwing exception a map operator is odd. In this case, handle() operator sink.error() sink.next() depending response is error success return toRecognizedForm(modelSimpleResponse.getValue().getAnalyzeResult(), isIncludeFieldElements); }).onErrorMap(Utility::mapToHttpResponseExceptionIfExist))); } catch (RuntimeException ex) { return PollerFlux.error(ex); } }'","output":"beginRecognizeReceipts(Flux<ByteBuffer> receipt, long length, RecognizeOptions recognizeOptions) { return beginRecognizeReceipts(receipt, length, recognizeOptions, Context.NONE); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move this process() method of API need set cases'\nThe code is: 'private boolean identifyAPI(API api, MessageContext synCtx, List defaultStrategyApiSet) { API defaultAPI = null; api.setLogSetterValue(); if (\"\/\".equals(api.getContext())) { defaultAPI = api; } else if (api.getVersionStrategy().getClass().getName().equals(DefaultStrategy.class.getName())) { defaultStrategyApiSet.add(api); } else if (api.getVersionStrategy().getClass().getName().equals(ContextVersionStrategy.class.getName()) || api.getVersionStrategy().getClass().getName().equals(URLBasedVersionStrategy.class.getName())) { api.setLogSetterValue(); if (api.canProcess(synCtx)) { if (log.isDebugEnabled()) { log.debug(\"Located specific API: \" + api.getName() + \" for processing message\"); } apiProcessNonDefaultStrategy(synCtx, api); return true; } } else if (api.canProcess(synCtx)) { if (log.isDebugEnabled()) { log.debug(\"Located specific API: \" + api.getName() + \" for processing message\"); } <START> synCtx.setProperty(RESTConstants.PROCESSED_API, api); <END> \/\/ move this process() method of API need set cases api.process(synCtx); return true; } return false; }'","output":"private boolean identifyAPI(API api, MessageContext synCtx, List defaultStrategyApiSet) { API defaultAPI = null; api.setLogSetterValue(); if (\"\/\".equals(api.getContext())) { defaultAPI = api; } else if (api.getVersionStrategy().getClass().getName().equals(DefaultStrategy.class.getName())) { defaultStrategyApiSet.add(api); } else if (api.getVersionStrategy().getClass().getName().equals(ContextVersionStrategy.class.getName()) || api.getVersionStrategy().getClass().getName().equals(URLBasedVersionStrategy.class.getName())) { api.setLogSetterValue(); if (api.canProcess(synCtx)) { if (log.isDebugEnabled()) { log.debug(\"Located specific API: \" + api.getName() + \" for processing message\"); } apiProcessNonDefaultStrategy(synCtx, api); return true; } } else if (api.canProcess(synCtx)) { if (log.isDebugEnabled()) { log.debug(\"Located specific API: \" + api.getName() + \" for processing message\"); } api.process(synCtx); return true; } return false; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I forgot .build()'\nThe code is: 'public Response suggest(String vocabularyId, String input, @DefaultValue(\"10\") int maxResults, String sort, String customFilter) { if (StringUtils.isEmpty(input) || StringUtils.isEmpty(vocabularyId)) { throw new WebApplicationException(Response.Status.BAD_REQUEST); } Vocabulary vocabulary = this.vm.getVocabulary(vocabularyId); if (vocabulary == null) { throw new WebApplicationException(Response.Status.NOT_FOUND); } List<VocabularyTerm> termSuggestions = vocabulary.search(input, maxResults, sort, customFilter); JSONObject rep = new JSONObject(); JSONArray trms = new JSONArray(); for (VocabularyTerm term : termSuggestions) { JSONObject trm = term.toJSON(); <START> trm.put(\"links\", this.autolinker.get().forSecondaryResource(VocabularyTermResource.class, this.uriInfo)); <END> \/\/ I forgot .build() trms.put(trm); } rep.put(\"rows\", trms); rep.put(\"links\", this.autolinker.get().forResource(getClass(), this.uriInfo).build()); return Response.ok(rep, MediaType.APPLICATION_JSON_TYPE).build(); }'","output":"public Response suggest(String vocabularyId, String input, @DefaultValue(\"10\") int maxResults, String sort, String customFilter) { if (StringUtils.isEmpty(input) || StringUtils.isEmpty(vocabularyId)) { throw new WebApplicationException(Response.Status.BAD_REQUEST); } Vocabulary vocabulary = this.vm.getVocabulary(vocabularyId); if (vocabulary == null) { throw new WebApplicationException(Response.Status.NOT_FOUND); } List<VocabularyTerm> termSuggestions = vocabulary.search(input, maxResults, sort, customFilter); JSONObject rep = new JSONObject(); JSONArray trms = new JSONArray(); for (VocabularyTerm term : termSuggestions) { JSONObject trm = term.toJSON(); trm.put(\"links\", this.autolinker.get().forSecondaryResource(VocabularyTermResource.class, this.uriInfo).build()); trms.put(trm); } rep.put(\"rows\", trms); rep.put(\"links\", this.autolinker.get().forResource(getClass(), this.uriInfo).build()); return Response.ok(rep, MediaType.APPLICATION_JSON_TYPE).build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I test isVariable a strange semantic. I I prefer a test symbol usages'\nThe code is: 'public void variables() { setRootRule(PythonGrammar.ATOM); Name name = (Name) parse(\"foo\", treeMaker::expression); assertThat(name.isVariable()).isTrue(); setRootRule(PythonGrammar.ATTRIBUTE_REF); QualifiedExpression qualifiedExpressionTree = (QualifiedExpression) parse(\"a.b\", treeMaker::expression); assertThat(qualifiedExpressionTree.name().isVariable()).isFalse(); setRootRule(PythonGrammar.FUNCDEF); FunctionDef functionDefTree = parse(\"def func(x): pass\", treeMaker::funcDefStatement); assertThat(functionDefTree.name().isVariable()).isFalse(); setRootRule(PythonGrammar.FILE_INPUT); FileInput fileInput = parse(\"func(x = 2)\", treeMaker::fileInput); CallExpression callExpression = (CallExpression) ((ExpressionStatement) fileInput.statements().statements().get(0)).expressions().get(0); <START> assertThat(((RegularArgument) callExpression.arguments().get(0)).keywordArgument().isVariable()).isFalse(); <END> \/\/ I test isVariable a strange semantic. I I prefer a test symbol usages }'","output":"public void variables() { setRootRule(PythonGrammar.ATOM); Name name = (Name) parse(\"foo\", treeMaker::expression); assertThat(name.isVariable()).isTrue(); setRootRule(PythonGrammar.ATTRIBUTE_REF); QualifiedExpression qualifiedExpressionTree = (QualifiedExpression) parse(\"a.b\", treeMaker::expression); assertThat(qualifiedExpressionTree.name().isVariable()).isFalse(); setRootRule(PythonGrammar.FUNCDEF); FunctionDef functionDefTree = parse(\"def func(x): pass\", treeMaker::funcDefStatement); assertThat(functionDefTree.name().isVariable()).isFalse(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this return null - please verify'\nThe code is: 'public VmTemplate readVmTemplateFromOvf(String ovf) throws OvfReaderException { ArrayList<DiskImage> diskImages = new ArrayList<>(); ArrayList<VmNetworkInterface> interfaces = new ArrayList<>(); VmTemplate template = new VmTemplate(); ovfManager.importTemplate(ovf, template, diskImages, interfaces); template.setInterfaces(interfaces); for (DiskImage disk : diskImages) { template.getDiskTemplateMap().put(disk.getId(), disk); } if (template.getMaxMemorySizeMb() == 0) { template.setMaxMemorySizeMb( VmCommonUtils.maxMemorySizeWithHotplugInMb(template.getOsId(), <START> template.getCompatibilityVersion())); <END> \/\/ I this return null - please verify } return template; }'","output":"public VmTemplate readVmTemplateFromOvf(String ovf) throws OvfReaderException { ArrayList<DiskImage> diskImages = new ArrayList<>(); ArrayList<VmNetworkInterface> interfaces = new ArrayList<>(); VmTemplate template = new VmTemplate(); ovfManager.importTemplate(ovf, template, diskImages, interfaces); template.setInterfaces(interfaces); for (DiskImage disk : diskImages) { template.getDiskTemplateMap().put(disk.getId(), disk); } return template; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'avoid leaseManager class field coordinator get'\nThe code is: 'ShardConsumer(ShardInfo shardInfo, StreamConfig streamConfig, ICheckpoint checkpoint, IRecordProcessor recordProcessor, RecordProcessorCheckpointer recordProcessorCheckpointer, KinesisClientLibLeaseCoordinator leaseCoordinator, long parentShardPollIntervalMillis, boolean cleanupLeasesOfCompletedShards, ExecutorService executorService, IMetricsFactory metricsFactory, long backoffTimeMillis, boolean skipShardSyncAtWorkerInitializationIfLeasesExist, KinesisDataFetcher kinesisDataFetcher, Optional<Integer> retryGetRecordsInSeconds, Optional<Integer> maxGetRecordsThreadPool, KinesisClientLibConfiguration config, ShardSyncer shardSyncer, ShardSyncStrategy shardSyncStrategy) { this.shardInfo = shardInfo; this.streamConfig = streamConfig; this.checkpoint = checkpoint; this.recordProcessor = recordProcessor; this.recordProcessorCheckpointer = recordProcessorCheckpointer; <START> this.leaseManager = leaseCoordinator.getLeaseManager(); <END> \/\/ avoid leaseManager class field coordinator get this.leaseCoordinator = leaseCoordinator; this.parentShardPollIntervalMillis = parentShardPollIntervalMillis; this.cleanupLeasesOfCompletedShards = cleanupLeasesOfCompletedShards; this.executorService = executorService; this.metricsFactory = metricsFactory; this.taskBackoffTimeMillis = backoffTimeMillis; this.skipShardSyncAtWorkerInitializationIfLeasesExist = skipShardSyncAtWorkerInitializationIfLeasesExist; this.config = config; this.dataFetcher = kinesisDataFetcher; this.getRecordsCache = config.getRecordsFetcherFactory().createRecordsFetcher( makeStrategy(this.dataFetcher, retryGetRecordsInSeconds, maxGetRecordsThreadPool, this.shardInfo), this.getShardInfo().getShardId(), this.metricsFactory, this.config.getMaxRecords()); this.shardSyncer = shardSyncer; this.shardSyncStrategy = shardSyncStrategy; }'","output":"ShardConsumer(ShardInfo shardInfo, StreamConfig streamConfig, ICheckpoint checkpoint, IRecordProcessor recordProcessor, RecordProcessorCheckpointer recordProcessorCheckpointer, KinesisClientLibLeaseCoordinator leaseCoordinator, long parentShardPollIntervalMillis, boolean cleanupLeasesOfCompletedShards, ExecutorService executorService, IMetricsFactory metricsFactory, long backoffTimeMillis, boolean skipShardSyncAtWorkerInitializationIfLeasesExist, KinesisDataFetcher kinesisDataFetcher, Optional<Integer> retryGetRecordsInSeconds, Optional<Integer> maxGetRecordsThreadPool, KinesisClientLibConfiguration config, ShardSyncer shardSyncer, ShardSyncStrategy shardSyncStrategy) { this.shardInfo = shardInfo; this.streamConfig = streamConfig; this.checkpoint = checkpoint; this.recordProcessor = recordProcessor; this.recordProcessorCheckpointer = recordProcessorCheckpointer; this.leaseCoordinator = leaseCoordinator; this.parentShardPollIntervalMillis = parentShardPollIntervalMillis; this.cleanupLeasesOfCompletedShards = cleanupLeasesOfCompletedShards; this.executorService = executorService; this.metricsFactory = metricsFactory; this.taskBackoffTimeMillis = backoffTimeMillis; this.skipShardSyncAtWorkerInitializationIfLeasesExist = skipShardSyncAtWorkerInitializationIfLeasesExist; this.config = config; this.dataFetcher = kinesisDataFetcher; this.getRecordsCache = config.getRecordsFetcherFactory().createRecordsFetcher( makeStrategy(this.dataFetcher, retryGetRecordsInSeconds, maxGetRecordsThreadPool, this.shardInfo), this.getShardInfo().getShardId(), this.metricsFactory, this.config.getMaxRecords()); this.shardSyncer = shardSyncer; this.shardSyncStrategy = shardSyncStrategy; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'replace test (primeRefining == null) execute statements else block. return primeRefining field \"if\", main local variable is useful'\nThe code is: 'public Diff getPrimeRefining() { <START> Diff main = null; <END> \/\/ replace test (primeRefining == null) execute statements else block. return primeRefining field \"if\", main local variable is useful if (primeRefining != null) { main = primeRefining; } else { for (Diff refBy : this.getRefinedBy()) { if (refBy instanceof ReferenceChange) { ReferenceChange rc = (ReferenceChange)refBy; if (this.getView() == rc.getValue()) { main = rc; break; } } else if (refBy instanceof AttributeChange) { AttributeChange ac = (AttributeChange)refBy; if (this.getView() == ac.getValue()) { main = ac; break; } } } } return main; }'","output":"public Diff getPrimeRefining() { if (primeRefining == null) { for (Diff refBy : this.getRefinedBy()) { if (refBy instanceof ReferenceChange) { ReferenceChange rc = (ReferenceChange)refBy; if (this.getView() == rc.getValue()) { primeRefining = rc; break; } } else if (refBy instanceof AttributeChange) { AttributeChange ac = (AttributeChange)refBy; if (this.getView() == ac.getValue()) { primeRefining = ac; break; } } } } return primeRefining; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'logServerMessage internally calls logAuditMessage. in effect, calling this twice. I fix in GlusterAuditLogUtil - in logAuditMessage, if server is passed, server.getVdsGroupId setVdsGroupId in AuditLogableBase'\nThe code is: 'private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) { for (final VDS server : existingServers) { if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) { log.debugFormat(\"Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.\", server.getName()); logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI); <START> logUtil.logAuditMessage(server.getVdsGroupId(), null, server, <END> \/\/ logServerMessage internally calls logAuditMessage. in effect, calling this twice. I fix in GlusterAuditLogUtil - in logAuditMessage, if server is passed, server.getVdsGroupId setVdsGroupId in AuditLogableBase AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, new HashMap<String, String>() { { put(GlusterConstants.VDS_GROUP_NAME, server.getVdsGroupName()); } }); try { removeServerFromDb(server); runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId())); } catch (Exception e) { log.errorFormat(\"Error while removing server {0} from database!\", server.getName(), e); } } } }'","output":"private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) { for (final VDS server : existingServers) { if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) { log.debugFormat(\"Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.\", server.getName()); logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI); try { removeServerFromDb(server); runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId())); } catch (Exception e) { log.errorFormat(\"Error while removing server {0} from database!\", server.getName(), e); } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion org.molgenis.data.Query<Entity> findQuery = new QueryImpl<>(findAllQuery);'\nThe code is: 'public void testFindAll() { String entityTypeId = \"MyEntityType\"; Selection filter = Selection.FULL_SELECTION; Selection expand = Selection.EMPTY_SELECTION; Attribute idAttribute = mock(Attribute.class); EntityType entityType = mock(EntityType.class); Repository<Entity> repository = mock(Repository.class); when(repository.getEntityType()).thenReturn(entityType); Entity entity1 = mock(Entity.class); Entity entity2 = mock(Entity.class); Sort sort = Sort.create(\"field\", Direction.ASC); Fetch fetch = new Fetch().field(\"id\", new Fetch().field(\"refAttr\")); Query q = Query.builder().setOperator(Operator.MATCHES).setValue(\"value\").build(); org.molgenis.data.Query<Entity> findAllQuery = mock(org.molgenis.data.Query.class); org.molgenis.data.Sort dataSort = mock(org.molgenis.data.Sort.class); <START> org.molgenis.data.Query<Entity> findQuery = new QueryImpl(findAllQuery); <END> \/\/ suggestion org.molgenis.data.Query<Entity> findQuery = new QueryImpl<>(findAllQuery); findQuery.fetch(fetch); findQuery.offset(10); findQuery.pageSize(10); findQuery.sort(dataSort); org.molgenis.data.Query<Entity> countQuery = new QueryImpl(findAllQuery); countQuery.offset(0); countQuery.pageSize(Integer.MAX_VALUE); when(repository.findAll(findQuery)).thenReturn(Stream.of(entity1, entity2)); when(repository.count(countQuery)).thenReturn(100L); when(queryMapperV3.map(q, repository)).thenReturn(findAllQuery).thenReturn(countQuery); when(sortMapperV3.map(sort)).thenReturn(dataSort); when(metaDataService.getRepository(entityTypeId)).thenReturn(Optional.of(repository)); Entities actual = dataServiceV3Impl.findAll(entityTypeId, q, filter, expand, sort, 10, 1); assertEquals( actual, Entities.builder().setEntities(asList(entity1, entity2)).setTotal(100).build()); }'","output":"public void testFindAll() { String entityTypeId = \"MyEntityType\"; Selection filter = Selection.FULL_SELECTION; Selection expand = Selection.EMPTY_SELECTION; Attribute idAttribute = mock(Attribute.class); EntityType entityType = mock(EntityType.class); Repository<Entity> repository = mock(Repository.class); when(repository.getEntityType()).thenReturn(entityType); Entity entity1 = mock(Entity.class); Entity entity2 = mock(Entity.class); Sort sort = Sort.create(\"field\", Direction.ASC); Fetch fetch = new Fetch().field(\"id\", new Fetch().field(\"refAttr\")); Query q = Query.builder().setOperator(Operator.MATCHES).setValue(\"value\").build(); org.molgenis.data.Query<Entity> findAllQuery = mock(org.molgenis.data.Query.class); org.molgenis.data.Sort dataSort = mock(org.molgenis.data.Sort.class); org.molgenis.data.Query<Entity> findQuery = new QueryImpl<>(findAllQuery); findQuery.fetch(fetch); findQuery.offset(10); findQuery.pageSize(10); findQuery.sort(dataSort); org.molgenis.data.Query<Entity> countQuery = new QueryImpl<>(findAllQuery); countQuery.offset(0); countQuery.pageSize(Integer.MAX_VALUE); when(repository.findAll(findQuery)).thenReturn(Stream.of(entity1, entity2)); when(repository.count(countQuery)).thenReturn(100L); when(queryMapperV3.map(q, repository)).thenReturn(findAllQuery).thenReturn(countQuery); when(sortMapperV3.map(sort)).thenReturn(dataSort); when(metaDataService.getRepository(entityTypeId)).thenReturn(Optional.of(repository)); Entities actual = dataServiceV3Impl.findAll(entityTypeId, q, filter, expand, sort, 10, 1); assertEquals( actual, Entities.builder().setEntities(asList(entity1, entity2)).setTotal(100).build()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need this local variable, put String literal \"Test\" in thenReturn() method line 230'\nThe code is: 'public void testPublishWithNullVideoTitle() { byte[] testBytes = {}; <START> String testString = \"Test\"; <END> \/\/ need this local variable, put String literal \"Test\" in thenReturn() method line 230 when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(testString); Response response = resource.publish(key, \"Test\", inputStream, contentDisposition, \"photo\", \"Test\", null); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, \"Test\"); }'","output":"public void testPublishWithNullVideoTitle() { byte[] testBytes = {}; when(urlService.inputStreamToByteArray(inputStream)).thenReturn(testBytes); when(facebookService.publishToFacebook(any(byte[].class), any(String.class), any(String.class), any(String.class), any(String.class))).thenReturn(\"Test\"); Response response = resource.publish(key, \"Test\", inputStream, contentDisposition, \"photo\", \"Test\", null); String result = (String) response.getEntity(); assertEquals(response.getStatusInfo(), Response.Status.OK); assertEquals(result, \"Test\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null == adapter'\nThe code is: 'public Adapter getContentAdapter() { if <START> (adapter == null) { <END> \/\/ null == adapter adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { int type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }'","output":"public Adapter getContentAdapter() { if (null == adapter) { adapter = new AdapterImpl() { @Override public void notifyChanged(final Notification notification) { int type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(new Runnable() { @Override public void run() { refreshChildren(); } }); break; case Notification.SET: break; } } }; } return adapter; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'methods (cleanCachedNotifications cleanCachedUniqueOutcomeEventNotifications) thread definition'\nThe code is: 'synchronized static void cleanNotificationCache(final SQLiteDatabase writableDb) { new Thread(new Runnable() { @Override public void run() { Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND); cleanCachedNotifications(writableDb); cleanCachedUniqueOutcomeEventNotifications(writableDb); } <START> private void cleanCachedNotifications(SQLiteDatabase writableDb) { <END> \/\/ methods (cleanCachedNotifications cleanCachedUniqueOutcomeEventNotifications) thread definition String whereStr = NotificationTable.COLUMN_NAME_CREATED_TIME + \" < ?\"; String sevenDaysAgoInSeconds = String.valueOf((System.currentTimeMillis() \/ 1_000L) - ONE_WEEK_IN_MILLIS); String[] whereArgs = new String[]{ sevenDaysAgoInSeconds }; writableDb.delete( NotificationTable.TABLE_NAME, whereStr, whereArgs); } private void cleanCachedUniqueOutcomeEventNotifications(SQLiteDatabase writableDb) { String whereStr = \"NOT EXISTS(SELECT NULL FROM \" + NotificationTable.TABLE_NAME + \" n WHERE\" + \" n.\" + NotificationTable.COLUMN_NAME_NOTIFICATION_ID + \" = \" + CachedUniqueOutcomeNotificationTable.COLUMN_NAME_NOTIFICATION_ID + \")\"; writableDb.delete( CachedUniqueOutcomeNotificationTable.TABLE_NAME, whereStr, null); } }, OS_DELETE_CACHED_NOTIFICATIONS_THREAD).start(); }'","output":"synchronized static void cleanNotificationCache(final SQLiteDatabase writableDb) { new Thread(new Runnable() { @Override public void run() { Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND); cleanCachedNotifications(writableDb); cleanCachedUniqueOutcomeEventNotifications(writableDb); } }, OS_DELETE_CACHED_NOTIFICATIONS_THREAD).start(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Set interface'\nThe code is: 'public Set<Role> getRoles(final Project project) { notNull(project, \"project\"); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); <START> final HashSet<Role> result = new HashSet<>(); <END> \/\/ Set interface for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }'","output":"public Set<Role> getRoles(final Project project) { notNull(project, \"project\"); final Roles roles = restTemplate.getForObject(Roles.URI, Roles.class, project.getId()); final Set<Role> result = new HashSet<>(); for (String roleUri : roles.getRoles()) { final Role role = restTemplate.getForObject(roleUri, Role.class); role.setUri(roleUri); result.add(role); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Null check ryaInstance'\nThe code is: 'public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(kafkaHostname); <START> <END> \/\/ Null check ryaInstance final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, \"\" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, \"\" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(\"Couldn't close a QueryRepository.\", e); } } }; }'","output":"public static RyaStreamsClient make( final String ryaInstance, final String kafkaHostname, final int kafkaPort) { requireNonNull(ryaInstance); requireNonNull(kafkaHostname); final Producer<?, QueryChange> queryProducer = makeProducer(kafkaHostname, kafkaPort, StringSerializer.class, QueryChangeSerializer.class); final Consumer<?, QueryChange>queryConsumer = fromStartConsumer(kafkaHostname, kafkaPort, StringDeserializer.class, QueryChangeDeserializer.class); final String changeLogTopic = KafkaTopics.queryChangeLogTopic(ryaInstance); final QueryChangeLog changeLog = new KafkaQueryChangeLog(queryProducer, queryConsumer, changeLogTopic); final QueryRepository queryRepo = new InMemoryQueryRepository(changeLog); return new RyaStreamsClient( new DefaultAddQuery(queryRepo), new DefaultGetQuery(queryRepo), new DefaultDeleteQuery(queryRepo), new KafkaGetQueryResultStream<>(kafkaHostname, \"\" + kafkaPort, VisibilityStatementDeserializer.class), new KafkaGetQueryResultStream<>(kafkaHostname, \"\" + kafkaPort, VisibilityBindingSetDeserializer.class), new DefaultListQueries(queryRepo), new DefaultStartQuery(queryRepo), new DefaultStopQuery(queryRepo)) { @Override public void close() { try { queryRepo.close(); } catch (final Exception e) { log.warn(\"Couldn't close a QueryRepository.\", e); } } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this method member variables a static method'\nThe code is: '<START> protected Map<String, Object> getEntityFromResultSet(ResultSet resultSet) <END> \/\/ this method member variables a static method throws SQLException { ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); Map<String, Object> resultsMap = new HashMap<>(); for (int i = 1; i <= columnCount; ++i) { String columnName = metaData.getColumnName(i).toLowerCase(); Object object = resultSet.getObject(i); resultsMap.put(columnName, object); } return resultsMap; }'","output":"protected static Map<String, Object> getEntityFromResultSet(ResultSet resultSet) throws SQLException { ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); Map<String, Object> resultsMap = new HashMap<>(); for (int i = 1; i <= columnCount; ++i) { String columnName = metaData.getColumnName(i).toLowerCase(); Object object = resultSet.getObject(i); resultsMap.put(columnName, object); } return resultsMap; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'No, this method throw interrupted exceptions'\nThe code is: '<START> public void testStateAdvancedChange_startFails() throws InterruptedException { <END> \/\/ No, this method throw interrupted exceptions this.agent.stop(); this.agent = new Agent() { @Override public PluginInterface findPlugin( Instance instance ) { return new PluginMock() { @Override public void start( Instance instance ) throws PluginException { throw new PluginException( \"For tests...\" ); } }; } }; this.agent.setMessagingType(MessagingConstants.FACTORY_TEST); this.agent.start(); AgentMessageProcessor processor = (AgentMessageProcessor) this.agent.getMessagingClient().getMessageProcessor(); TestApplicationTemplate app = new TestApplicationTemplate(); processor.processMessage( new MsgCmdSetScopedInstance( app.getTomcatVm())); Assert.assertEquals( app.getTomcatVm(), processor.scopedInstance ); Assert.assertEquals( InstanceStatus.DEPLOYED_STARTED, processor.scopedInstance.getStatus()); Assert.assertEquals( InstanceStatus.NOT_DEPLOYED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.DEPLOYED_STARTED )); Assert.assertEquals( InstanceStatus.DEPLOYED_STOPPED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.DEPLOYED_STOPPED )); Assert.assertEquals( InstanceStatus.DEPLOYED_STOPPED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.NOT_DEPLOYED )); Assert.assertEquals( InstanceStatus.NOT_DEPLOYED, app.getTomcat().getStatus()); }'","output":"public void testStateAdvancedChange_startFails() { this.agent.stop(); this.agent = new Agent() { @Override public PluginInterface findPlugin( Instance instance ) { return new PluginMock() { @Override public void start( Instance instance ) throws PluginException { throw new PluginException( \"For tests...\" ); } }; } }; this.agent.setMessagingType(MessagingConstants.FACTORY_TEST); this.agent.start(); AgentMessageProcessor processor = (AgentMessageProcessor) this.agent.getMessagingClient().getMessageProcessor(); TestApplicationTemplate app = new TestApplicationTemplate(); processor.processMessage( new MsgCmdSetScopedInstance( app.getTomcatVm())); Assert.assertEquals( app.getTomcatVm(), processor.scopedInstance ); Assert.assertEquals( InstanceStatus.DEPLOYED_STARTED, processor.scopedInstance.getStatus()); Assert.assertEquals( InstanceStatus.NOT_DEPLOYED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.DEPLOYED_STARTED )); Assert.assertEquals( InstanceStatus.DEPLOYED_STOPPED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.DEPLOYED_STOPPED )); Assert.assertEquals( InstanceStatus.DEPLOYED_STOPPED, app.getTomcat().getStatus()); processor.processMessage( new MsgCmdChangeInstanceState( app.getTomcat(), InstanceStatus.NOT_DEPLOYED )); Assert.assertEquals( InstanceStatus.NOT_DEPLOYED, app.getTomcat().getStatus()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Nit: java able figure out is a String required type for GeneralTopologyContext'\nThe code is: 'public static Tuple generateTestTuple(final String source, final String index, final String type, final String id) { TopologyBuilder builder = new TopologyBuilder(); GeneralTopologyContext topologyContext = new GeneralTopologyContext( builder.createTopology(), new Config(), <START> new CustomIndexArray<String>(0,1), <END> \/\/ Nit: java able figure out is a String required type for GeneralTopologyContext new HashMap<>(), new HashMap<>(), \"\") { @Override public Fields getComponentOutputFields(final String componentId, final String streamId) { return new Fields(\"source\", \"index\", \"type\", \"id\"); } }; return new TupleImpl(topologyContext, new Values(source, index, type, id), source, 1, \"\"); }'","output":"public static Tuple generateTestTuple(final String source, final String index, final String type, final String id) { TopologyBuilder builder = new TopologyBuilder(); GeneralTopologyContext topologyContext = new GeneralTopologyContext( builder.createTopology(), new Config(), new CustomIndexArray<String>(0,0), new HashMap<>(), new HashMap<>(), \"\") { @Override public Fields getComponentOutputFields(final String componentId, final String streamId) { return new Fields(\"source\", \"index\", \"type\", \"id\"); } }; return new TupleImpl(topologyContext, new Values(source, index, type, id), source, 1, \"\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'redundant parentheses'\nThe code is: 'public boolean sendCommand(VeluxBridge bridge, int nodeId, VeluxProductPosition value) { logger.trace(\"sendCommand(nodeId={},value={}) called.\", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); int veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); <START> if ((bridge.bridgeCommunicate(bcp)) && (bcp.isCommunicationSuccessful())) { <END> \/\/ redundant parentheses logger.debug(\"sendCommand() finished successfully.\"); return true; } else { logger.trace(\"sendCommand() finished with failure.\"); return false; } }'","output":"public boolean sendCommand(VeluxBridge bridge, int nodeId, VeluxProductPosition value) { logger.trace(\"sendCommand(nodeId={},value={}) called.\", nodeId, value); SendCommand bcp = bridge.bridgeAPI().sendCommand(); int veluxValue = value.getPositionAsVeluxType(); bcp.setNodeAndMainParameter(nodeId, veluxValue); if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { logger.debug(\"sendCommand() finished successfully.\"); return true; } else { logger.trace(\"sendCommand() finished with failure.\"); return false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Minor nit, collapsed to: } catch (RuntimeException | OutOfMemoryError e) { AppLog.e(T.EDITOR, e); }'\nThe code is: 'private void addLastTakenPicture() { try { WPMediaUtils.scanMediaFile(this, mMediaCapturePath); File f = new File(mMediaCapturePath); Uri capturedImageUri = Uri.fromFile(f); if (addMedia(capturedImageUri, true)) { this.sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(\"file:\/\/\" + Environment.getExternalStorageDirectory()))); } else { ToastUtils.showToast(this, R.string.gallery_error, Duration.SHORT); } <START> } catch (RuntimeException e) { <END> \/\/ Minor nit, collapsed to: } catch (RuntimeException | OutOfMemoryError e) { AppLog.e(T.EDITOR, e); } AppLog.e(T.EDITOR, e); } catch (OutOfMemoryError e) { AppLog.e(T.EDITOR, e); } }'","output":"private void addLastTakenPicture() { try { WPMediaUtils.scanMediaFile(this, mMediaCapturePath); File f = new File(mMediaCapturePath); Uri capturedImageUri = Uri.fromFile(f); if (addMedia(capturedImageUri, true)) { this.sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse(\"file:\/\/\" + Environment.getExternalStorageDirectory()))); } else { ToastUtils.showToast(this, R.string.gallery_error, Duration.SHORT); } } catch (RuntimeException | OutOfMemoryError e) { AppLog.e(T.EDITOR, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ditto rename refactor'\nThe code is: 'private UpdateProgress processContent(Content content, Action action) { String contentCrid = idGenerator.generateContentCrid(content); log.debug(\"Processing Content {}\", contentCrid); try { if (!Action.DELETE.equals(action)) { Payload p = payloadCreator.payloadFrom(contentCrid, content); if (shouldSave(HashType.CONTENT, contentCrid, p)) { taskStore.save(taskCreator.taskFor(idGenerator.generateContentCrid(content), content, p, action)); payloadHashStore.saveHash(HashType.CONTENT, contentCrid, p.hash()); } else { log.debug(\"Existing hash found for Content {}, not updating\", contentCrid); } } return UpdateProgress.SUCCESS; } catch (Exception e) { <START> log.error(\"Failed to createDefault payload for content {}\", content.getCanonicalUri(), e); <END> \/\/ Ditto rename refactor Task task = taskStore.save(taskCreator.taskFor(idGenerator.generateContentCrid(content), content, action, Status.FAILED)); taskStore.updateWithLastError(task.id(), exceptionToString(e)); return UpdateProgress.FAILURE; } }'","output":"private UpdateProgress processContent(Content content, Action action) { String contentCrid = idGenerator.generateContentCrid(content); log.debug(\"Processing Content {}\", contentCrid); try { if (!Action.DELETE.equals(action)) { Payload p = payloadCreator.payloadFrom(contentCrid, content); if (shouldSave(HashType.CONTENT, contentCrid, p)) { taskStore.save(taskCreator.taskFor(idGenerator.generateContentCrid(content), content, p, action)); payloadHashStore.saveHash(HashType.CONTENT, contentCrid, p.hash()); } else { log.debug(\"Existing hash found for Content {}, not updating\", contentCrid); } } return UpdateProgress.SUCCESS; } catch (Exception e) { log.error(\"Failed to create payload for content {}\", content.getCanonicalUri(), e); Task task = taskStore.save(taskCreator.taskFor(idGenerator.generateContentCrid(content), content, action, Status.FAILED)); taskStore.updateWithLastError(task.id(), exceptionToString(e)); return UpdateProgress.FAILURE; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext'\nThe code is: 'public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, \"pagesIndexFactory is null\"); this.operatorContext = requireNonNull(operatorContext, \"operatorContext is null\"); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, \"outputChannels is null\")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, \"sortChannels is null\")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, \"sortOrder is null\")); this.sourceTypes = sourceTypes; <START> this.localUserMemoryContext = operatorContext.localUserMemoryContext(); <END> \/\/ rename to: pagesIndexUserMemoryContext pagesIndexRevocableMemoryContext this.localRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }'","output":"public OrderByOperator( OperatorContext operatorContext, List<Type> sourceTypes, List<Integer> outputChannels, int expectedPositions, List<Integer> sortChannels, List<SortOrder> sortOrder, PagesIndex.Factory pagesIndexFactory, boolean spillEnabled, Optional<SpillerFactory> spillerFactory) { requireNonNull(pagesIndexFactory, \"pagesIndexFactory is null\"); this.operatorContext = requireNonNull(operatorContext, \"operatorContext is null\"); this.outputChannels = Ints.toArray(requireNonNull(outputChannels, \"outputChannels is null\")); this.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, \"sortChannels is null\")); this.sortOrder = ImmutableList.copyOf(requireNonNull(sortOrder, \"sortOrder is null\")); this.sourceTypes = sourceTypes; this.pagesIndexUserMemoryContext = operatorContext.localUserMemoryContext(); this.pagesIndexRevocableMemoryContext = operatorContext.localRevocableMemoryContext(); this.spillerFactory = spillerFactory; this.pageIndex = pagesIndexFactory.newPagesIndex(sourceTypes, expectedPositions); this.spillEnabled = spillEnabled; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Change log level debug'\nThe code is: 'public String execute(final LnClientConnection conn, final DlmsDevice device, final DataObject object) throws IOException, TimeoutException, ProtocolAdapterException { final AttributeAddress attributeAddress = new AttributeAddress(CLASS_ID, OBIS_CODE, ATTRIBUTE_ID); LOGGER.info(\"Retrieving configuration objects for class id: {}, obis code: {}, attribute id: {}\", CLASS_ID, OBIS_CODE, ATTRIBUTE_ID); final List<GetResult> getResultList = conn.get(attributeAddress); if (getResultList.isEmpty()) { throw new ProtocolAdapterException(\"No GetResult received while retrieving configuration objects.\"); } if (getResultList.size() > 1 || getResultList.get(0) == null) { throw new ProtocolAdapterException(\"Expected 1 GetResult while retrieving configuration objects, got \" + getResultList.size()); } final DataObject resultData = getResultList.get(0).resultData(); if (!resultData.isComplex()) { this.throwUnexpectedTypeProtocolAdapterException(); } @SuppressWarnings(\"unchecked\") final List<DataObject> resultDataValue = (List<DataObject>) getResultList.get(0).resultData().value(); final List<ClassIdObisAttr> allObisCodes = this.getAllObisCodes(resultDataValue); this.logAllObisCodes(allObisCodes); final String output = this.createOutput(conn, allObisCodes); <START> LOGGER.info(\"Total output is: {}\", output); <END> \/\/ Change log level debug return output; }'","output":"public String execute(final LnClientConnection conn, final DlmsDevice device, final DataObject object) throws IOException, TimeoutException, ProtocolAdapterException { final AttributeAddress attributeAddress = new AttributeAddress(CLASS_ID, OBIS_CODE, ATTRIBUTE_ID); LOGGER.debug(\"Retrieving configuration objects for class id: {}, obis code: {}, attribute id: {}\", CLASS_ID, OBIS_CODE, ATTRIBUTE_ID); final List<GetResult> getResultList = conn.get(attributeAddress); if (getResultList.isEmpty()) { throw new ProtocolAdapterException(\"No GetResult received while retrieving configuration objects.\"); } if (getResultList.size() > 1 || getResultList.get(0) == null) { throw new ProtocolAdapterException(\"Expected 1 GetResult while retrieving configuration objects, got \" + getResultList.size()); } final DataObject resultData = getResultList.get(0).resultData(); if (!resultData.isComplex()) { this.throwUnexpectedTypeProtocolAdapterException(); } @SuppressWarnings(\"unchecked\") final List<DataObject> resultDataValue = (List<DataObject>) getResultList.get(0).resultData().value(); final List<ClassIdObisAttr> allObisCodes = this.getAllObisCodes(resultDataValue); this.logAllObisCodes(allObisCodes); final String output = this.createOutput(conn, allObisCodes); LOGGER.debug(\"Total output is: {}\", output); return output; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@kingthorin suggesting Constant.messages.getString(\"codedx.error.httpMessage\", alert.getAlertId()) require extra formatting caller'\nThe code is: 'private String getHTML(Alert alert) { StringBuilder httpMessage = new StringBuilder(); HttpMessage message = alert.getMessage(); if (message == null) { <START> LOGGER.warn(String.format(Constant.messages.getString(\"codedx.error.httpMessage\"), alert.getAlertId())); <END> \/\/ @kingthorin suggesting Constant.messages.getString(\"codedx.error.httpMessage\", alert.getAlertId()) require extra formatting caller return httpMessage.toString(); } String requestHeader = message.getRequestHeader().toString(); String requestBody = message.getRequestBody().toString(); String responseHeader = message.getResponseHeader().toString(); String responseBody = message.getResponseBody().toString(); httpMessage.append(\"<requestdata>\"); httpMessage.append(ReportGenerator.entityEncode(requestHeader)); httpMessage.append(ReportGenerator.entityEncode(requestBody)); httpMessage.append(\"\\n<\/requestdata>\\n\"); httpMessage.append(\"<responsedata>\"); httpMessage.append(ReportGenerator.entityEncode(responseHeader)); httpMessage.append(ReportGenerator.entityEncode(responseBody)); httpMessage.append(\"\\n<\/responsedata>\\n\"); return httpMessage.toString(); }'","output":"private String getHTML(Alert alert) { StringBuilder httpMessage = new StringBuilder(); HttpMessage message = alert.getMessage(); if (message == null) { LOGGER.warn(Constant.messages.getString(\"codedx.error.httpMessage\", alert.getAlertId())); return httpMessage.toString(); } String requestHeader = message.getRequestHeader().toString(); String requestBody = message.getRequestBody().toString(); String responseHeader = message.getResponseHeader().toString(); String responseBody = message.getResponseBody().toString(); httpMessage.append(\"<requestdata>\"); httpMessage.append(ReportGenerator.entityEncode(requestHeader)); httpMessage.append(ReportGenerator.entityEncode(requestBody)); httpMessage.append(\"\\n<\/requestdata>\\n\"); httpMessage.append(\"<responsedata>\"); httpMessage.append(ReportGenerator.entityEncode(responseHeader)); httpMessage.append(ReportGenerator.entityEncode(responseBody)); httpMessage.append(\"\\n<\/responsedata>\\n\"); return httpMessage.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'move toString() clickOrdersTableColumn() method for OrdersTable.ELEM.toString() calls'\nThe code is: 'public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); <START> orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); <END> \/\/ move toString() clickOrdersTableColumn() method for OrdersTable.ELEM.toString() calls List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE.toString()); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (int i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), \"Sorting by total price doesn't work.\"); } for (int i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), \"Sorting by total price doesn't work.\"); } }'","output":"public void testTotalPriceColumn(User user) { HomePage homePage = new HomePage(driver); UserInfoPage userInfoPage = homePage.logIn(user.getLogin(), user.getPassword()); OrderingPage orderingPage = userInfoPage.clickOrderingTab(); List<Order> tableFromView = orderingPage.getTableFromView(); tableFromView.sort(Comparator.comparing(Order::getTotalPrice)); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceAsc = orderingPage.getTableFromView(); orderingPage.clickOrdersTableColumn(OrdersTable.TOTAL_PRICE); List<Order> sortedTableByTotalPriceDesc = orderingPage.getTableFromView(); for (int i = 0; i < tableFromView.size(); i++) { Assert.assertTrue(sortedTableByTotalPriceAsc.get(i).getTotalPrice().equals(tableFromView.get(i).getTotalPrice()), \"Sorting by total price doesn't work.\"); } for (int i = 0, j = tableFromView.size() - 1; i < tableFromView.size(); i++, j--) { Assert.assertTrue(sortedTableByTotalPriceDesc.get(i).getTotalPrice().equals(tableFromView.get(j).getTotalPrice()), \"Sorting by total price doesn't work.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please delete this logging? need this anymore verified theory issue'\nThe code is: 'public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(\"businessKey\", \"low priority\"); ctxCMD.setData(\"priority\", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(\"org.jbpm.executor.commands.PrintOutCommand\", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(\"businessKey\", \"high priority\"); ctxCMD2.setData(\"priority\", 8); executorService.scheduleRequest(\"org.jbpm.executor.commands.PrintOutCommand\", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(\"high priority\", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(\"low priority\", executedLow.getKey()); logger.info(\"executedLow: {}\", executedLow.getTime().getTime()); logger.info(\"executedHigh: {}\", executedHigh.getTime().getTime()); <START> logger.info(\"exec difference: {}\", (executedLow.getTime().getTime() - executedHigh.getTime().getTime())); <END> \/\/ please delete this logging? need this anymore verified theory issue assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }'","output":"public void testPrioritizedJobsExecution() throws InterruptedException { CountDownAsyncJobListener countDownListener = configureListener(2); CommandContext ctxCMD = new CommandContext(); ctxCMD.setData(\"businessKey\", \"low priority\"); ctxCMD.setData(\"priority\", 2); Date futureDate = new Date(System.currentTimeMillis() + EXTRA_TIME); executorService.scheduleRequest(\"org.jbpm.executor.commands.PrintOutCommand\", futureDate, ctxCMD); CommandContext ctxCMD2 = new CommandContext(); ctxCMD2.setData(\"businessKey\", \"high priority\"); ctxCMD2.setData(\"priority\", 8); executorService.scheduleRequest(\"org.jbpm.executor.commands.PrintOutCommand\", futureDate, ctxCMD2); countDownListener.waitTillCompleted(); List<RequestInfo> inErrorRequests = executorService.getInErrorRequests(new QueryContext()); assertEquals(0, inErrorRequests.size()); List<RequestInfo> queuedRequests = executorService.getQueuedRequests(new QueryContext()); assertEquals(0, queuedRequests.size()); List<RequestInfo> executedRequests = executorService.getCompletedRequests(new QueryContext()); assertEquals(2, executedRequests.size()); RequestInfo executedHigh = executedRequests.get(1); assertNotNull(executedHigh); assertEquals(\"high priority\", executedHigh.getKey()); RequestInfo executedLow = executedRequests.get(0); assertNotNull(executedLow); assertEquals(\"low priority\", executedLow.getKey()); assertTrue(executedLow.getTime().getTime() >= executedHigh.getTime().getTime()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'considered : toDelete.addAll(Arrays.asList(fMembersToMove)); toDelete.retainAll(Arrays.asList(all)); retainAll() elements in a collection (toDelete) present in list passed in argument (all)'\nThe code is: 'private IMember[] getMembersToDelete(final IProgressMonitor monitor) throws JavaModelException { try { final IMember[] typesToDelete= getMembers(fMembersToMove, IJavaElement.TYPE); final IMember[] matchingElements= getMatchingElements(monitor, false); final IMember[] matchingFields= getMembers(matchingElements, IJavaElement.FIELD); List<IMember> toDelete= new ArrayList<>(); IMember[] all= JavaElementUtil.merge(matchingFields, typesToDelete); <START> for(IMember member : all) { for(IMember moveMember : fMembersToMove) { if(member.equals(moveMember)) { toDelete.add(moveMember); } } } <END> \/\/ considered : toDelete.addAll(Arrays.asList(fMembersToMove)); toDelete.retainAll(Arrays.asList(all)); retainAll() elements in a collection (toDelete) present in list passed in argument (all) return JavaElementUtil.merge(toDelete.toArray(new IMember[0]), fDeletedMethods); } finally { monitor.done(); } }'","output":"private IMember[] getMembersToDelete(final IProgressMonitor monitor) throws JavaModelException { try { final IMember[] typesToDelete= getMembers(fMembersToMove, IJavaElement.TYPE); final IMember[] matchingElements= getMatchingElements(monitor, false); final IMember[] matchingFields= getMembers(matchingElements, IJavaElement.FIELD); List<IMember> toDelete= new ArrayList<>(); IMember[] all= JavaElementUtil.merge(matchingFields, typesToDelete); toDelete.addAll(Arrays.asList(fMembersToMove)); toDelete.retainAll(Arrays.asList(all)); return JavaElementUtil.merge(toDelete.toArray(new IMember[0]), fDeletedMethods); } finally { monitor.done(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I noticed finishCommit is passed cd2. Of works fine because, cd cd2 same. This simplify code remove CommitData param OnSuccessInterface.onSuccess(). this code written : java addCallback(cfuture, cd, result -> finishCommit(cd, commitTs));'\nThe code is: 'private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); <START> addCallback(cfuture, cd, (cd2, result) -> finishCommit(cd, commitTs)); <END> \/\/ I noticed finishCommit is passed cd2. Of works fine because, cd cd2 same. This simplify code remove CommitData param OnSuccessInterface.onSuccess(). this code written : java addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }'","output":"private void deleteLocks(CommitData cd, final long commitTs) { ArrayList<Mutation> mutations = new ArrayList<>(updates.size() + 1); for (Entry<Bytes, Map<Column, Bytes>> rowUpdates : updates.entrySet()) { Flutation m = new Flutation(env, rowUpdates.getKey()); boolean isTriggerRow = isTriggerRow(rowUpdates.getKey()); for (Entry<Column, Bytes> colUpdates : rowUpdates.getValue().entrySet()) { ColumnUtil.commitColumn(env, isTriggerRow && colUpdates.getKey().equals(notification.getColumn()), false, colUpdates.getKey(), isWrite(colUpdates.getValue()), isDelete(colUpdates.getValue()), isReadLock(colUpdates.getValue()), startTs, commitTs, observedColumns, m); } mutations.add(m); } CompletableFuture<Void> cfuture = env.getSharedResources().getBatchWriter().writeMutationsAsyncFuture(mutations); addCallback(cfuture, cd, result -> finishCommit(cd, commitTs)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: need new Object[] for current version of slf4j'\nThe code is: 'public void checkTimeoutOnPendingOperations() { int timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(\"Timed-out {} operations to channel {} for {}\", <START> new Object[] { timedOutOperations, channel, addr }); <END> \/\/ nit: need new Object[] for current version of slf4j } }'","output":"public void checkTimeoutOnPendingOperations() { int timedOutOperations = completionObjects.removeIf(timeoutCheck); synchronized (this) { Iterator<CompletionValue> iterator = completionObjectsV2Conflicts.values().iterator(); while (iterator.hasNext()) { CompletionValue value = iterator.next(); if (value.maybeTimeout()) { ++timedOutOperations; iterator.remove(); } } } if (timedOutOperations > 0) { LOG.info(\"Timed-out {} operations to channel {} for {}\", timedOutOperations, channel, addr); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Need put this - change API'\nThe code is: 'public static Object percent3( ValueMetaInterface metaA, Object dataA, ValueMetaInterface metaB, Object dataB ) throws KettleValueException { if ( dataA == null || dataB == null ) { return null; } switch ( metaA.getType() ) { case ValueMetaInterface.TYPE_NUMBER: return new Double( metaA.getNumber( dataA ).doubleValue() + divideDoubles( multiplyDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) ), 100.0D ) ); case ValueMetaInterface.TYPE_INTEGER: return new Long( metaA.getInteger( dataA ).longValue() + divideLongs( multiplyLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) ), 100L ) ); case ValueMetaInterface.TYPE_BIGNUMBER: return metaA.getBigNumber( dataA ).add( divideBigDecimals( multiplyBigDecimals( <START> metaB.getBigNumber( dataB ), metaA.getBigNumber( dataA ), null ), new BigDecimal( 100 ) ) ); <END> \/\/ Need put this - change API default: throw new KettleValueException( \"The 'A+B%' function only works on numeric data\" ); } }'","output":"public static Object percent3( ValueMetaInterface metaA, Object dataA, ValueMetaInterface metaB, Object dataB ) throws KettleValueException { if ( dataA == null || dataB == null ) { return null; } switch ( metaA.getType() ) { case ValueMetaInterface.TYPE_NUMBER: return new Double( metaA.getNumber( dataA ).doubleValue() + divideDoubles( multiplyDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) ), 100.0D ) ); case ValueMetaInterface.TYPE_INTEGER: return new Long( metaA.getInteger( dataA ).longValue() + divideLongs( multiplyLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) ), 100L ) ); case ValueMetaInterface.TYPE_BIGNUMBER: return metaA.getBigNumber( dataA ).add( divideBigDecimals( multiplyBigDecimals( metaB.getBigNumber( dataB ), metaA.getBigNumber( dataA ), null ), new BigDecimal( 100 ), (MathContext) null ) ); default: throw new KettleValueException( \"The 'A+B%' function only works on numeric data\" ); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this separately lined for legibility'\nThe code is: 'public Optional<DyeableData> from(DataHolder dataHolder) { if (supports(dataHolder)) { if (dataHolder instanceof EntitySheep) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) ((EntitySheep) dataHolder).getFleeceColor())); } else if (dataHolder instanceof EntityWolf) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) ((EntityWolf) dataHolder).getCollarColor())); } else if (dataHolder instanceof ItemStack) { if(((ItemStack) dataHolder).getItem().equals(Items.DYE)) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) EnumDyeColor.byDyeDamage(((ItemStack) dataHolder).getItemDamage()))); } else { return Optional.of(new SpongeDyeableData((DyeColor) (Object) EnumDyeColor.byMetadata(((ItemStack) dataHolder).getItemDamage()))); } } else if (dataHolder instanceof TileEntityShulkerBox) { <START> return Optional.ofNullable(((IMixinTileEntityShulkerBox) dataHolder).getColor()).map(enumType -> (DyeColor) (Object) enumType).map <END> \/\/ this separately lined for legibility (SpongeDyeableData::new); } } return Optional.empty(); }'","output":"public Optional<DyeableData> from(DataHolder dataHolder) { if (supports(dataHolder)) { if (dataHolder instanceof EntitySheep) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) ((EntitySheep) dataHolder).getFleeceColor())); } else if (dataHolder instanceof EntityWolf) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) ((EntityWolf) dataHolder).getCollarColor())); } else if (dataHolder instanceof ItemStack) { if(((ItemStack) dataHolder).getItem().equals(Items.DYE)) { return Optional.of(new SpongeDyeableData((DyeColor) (Object) EnumDyeColor.byDyeDamage(((ItemStack) dataHolder).getItemDamage()))); } else { return Optional.of(new SpongeDyeableData((DyeColor) (Object) EnumDyeColor.byMetadata(((ItemStack) dataHolder).getItemDamage()))); } } } return Optional.empty(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'hardcode string, classname'\nThe code is: 'public void testDeleteClientDeleteMutationPlan() throws Exception { String tableName = generateUniqueName(); String indexName = generateUniqueName(); String tagValue = \"customer-delete\"; String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\"; Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES); props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue); createAndUpsertTable(tableName, indexName, props); <START> verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props); <END> \/\/ hardcode string, classname executeDelete(delete, props, 1); String startRowKeyForBaseTable = \"1\"; String startRowKeyForIndexTable = \"foo\"; checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue); checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null); }'","output":"public void testDeleteClientDeleteMutationPlan() throws Exception { String tableName = generateUniqueName(); String indexName = generateUniqueName(); String tagValue = \"customer-delete\"; String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\"; Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES); props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue); createAndUpsertTable(tableName, indexName, props); verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props); executeDelete(delete, props, 1); String startRowKeyForBaseTable = \"1\"; String startRowKeyForIndexTable = \"foo\"; checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue); checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"Table {0} a primary key. A vast amount of memory required.\"'\nThe code is: 'public void execute(ProgressMonitor pm) throws SQLException { if(!pk_name.isEmpty()) { resultSetHolder.setCommand(getCommand()+\" LIMIT 0\"); cachePrimaryKey(pm); } else { <START> LOGGER.warn(I18N.tr(\"The table {0} does not contain a primary key, a vast amount of memory may be required\", location)); <END> \/\/ \"Table {0} a primary key. A vast amount of memory required.\" resultSetHolder.setCommand(getCommand()); PropertyChangeListener listener = EventHandler.create(PropertyChangeListener.class, resultSetHolder, \"cancel\"); pm.addPropertyChangeListener(ProgressMonitor.PROP_CANCEL, listener); try { resultSetHolder.getResource(); } finally { pm.removePropertyChangeListener(listener); } } }'","output":"public void execute(ProgressMonitor pm) throws SQLException { if(!pk_name.isEmpty()) { resultSetHolder.setCommand(getCommand()+\" LIMIT 0\"); cachePrimaryKey(pm); } else { LOGGER.warn(I18N.tr(\"Table {0} does not contain a primary key. A vast amount of memory may be required.\", location)); resultSetHolder.setCommand(getCommand()); PropertyChangeListener listener = EventHandler.create(PropertyChangeListener.class, resultSetHolder, \"cancel\"); pm.addPropertyChangeListener(ProgressMonitor.PROP_CANCEL, listener); try { resultSetHolder.getResource(); } finally { pm.removePropertyChangeListener(listener); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'override this in test methods this variable need this scope. test'\nThe code is: 'public void setUp() { PaChannelsIngester paChannelsIngester = mock(PaChannelsIngester.class); PaChannelGroupsIngester paChannelGroupsIngester = mock(PaChannelGroupsIngester.class); ChannelResolver channelResolver = mock(ChannelResolver.class); ChannelWriter channelWriter = mock(ChannelWriter.class); ChannelGroupResolver channelGroupResolver = mock(ChannelGroupResolver.class); ChannelGroupWriter channelGroupWriter = mock(ChannelGroupWriter.class); channelDataHandler = new PaChannelDataHandler( paChannelsIngester, paChannelGroupsIngester, channelResolver, channelWriter, channelGroupResolver, channelGroupWriter ); Image existingImage = Image.builder(\"existing uri\").withTheme(ImageTheme.DARK_MONOCHROME).build(); existingChannel = Channel.builder().withImage(existingImage).build(); Image newImage = Image.builder(\"new uri\").withTheme(ImageTheme.DARK_MONOCHROME).build(); <START> newChannel = Channel.builder().withImage(newImage).build(); <END> \/\/ override this in test methods this variable need this scope. test }'","output":"public void setUp() { PaChannelsIngester paChannelsIngester = mock(PaChannelsIngester.class); PaChannelGroupsIngester paChannelGroupsIngester = mock(PaChannelGroupsIngester.class); ChannelResolver channelResolver = mock(ChannelResolver.class); ChannelWriter channelWriter = mock(ChannelWriter.class); ChannelGroupResolver channelGroupResolver = mock(ChannelGroupResolver.class); ChannelGroupWriter channelGroupWriter = mock(ChannelGroupWriter.class); channelDataHandler = new PaChannelDataHandler( paChannelsIngester, paChannelGroupsIngester, channelResolver, channelWriter, channelGroupResolver, channelGroupWriter ); Image existingImage = Image.builder(\"existing uri\").withTheme(ImageTheme.DARK_MONOCHROME).build(); existingChannel = Channel.builder().withImage(existingImage).build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'check for postArtifact postArtifacts'\nThe code is: 'private void getHistory(IngestJobContext context, AbstractFile historyFile) throws TskCoreException, IOException { if (historyFile.getSize() == 0) { return; } File tempHistoryFile = createTemporaryFile(context, historyFile); try { ContentUtils.writeToFile(historyFile, tempHistoryFile, context::dataSourceIngestIsCancelled); } catch (IOException ex) { throw new IOException(\"Error writingToFile: \" + historyFile, ex); } try { <START> postArtifact(getHistoryArtifacts(historyFile, tempHistoryFile.toPath(), context)); <END> \/\/ check for postArtifact postArtifacts } finally { tempHistoryFile.delete(); } }'","output":"private void getHistory(IngestJobContext context, AbstractFile historyFile) throws TskCoreException, IOException { if (historyFile.getSize() == 0) { return; } File tempHistoryFile = createTemporaryFile(context, historyFile); try { ContentUtils.writeToFile(historyFile, tempHistoryFile, context::dataSourceIngestIsCancelled); } catch (IOException ex) { throw new IOException(\"Error writingToFile: \" + historyFile, ex); } try { postArtifacts(getHistoryArtifacts(historyFile, tempHistoryFile.toPath(), context)); } finally { tempHistoryFile.delete(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'delete this line'\nThe code is: 'public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); <START> assertNotNull(keySet); <END> \/\/ delete this line assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }'","output":"public void testWithArrays() { final byte[] authenthicationKey = { 1 }; final byte[] encryptionKey = { 1 }; final KeySet keySet = new KeySet(authenthicationKey, encryptionKey); final KeySetDto keySetDto = this.configurationMapper.map(keySet, KeySetDto.class); assertNotNull(keySetDto); assertNotNull(keySetDto.getAuthenticationKey()); assertNotNull(keySetDto.getEncryptionKey()); assertEquals(keySet.getAuthenticationKey().length, keySetDto.getAuthenticationKey().length); assertEquals(keySet.getEncryptionKey().length, keySetDto.getEncryptionKey().length); assertEquals(keySet.getAuthenticationKey()[0], keySetDto.getAuthenticationKey()[0]); assertEquals(keySet.getEncryptionKey()[0], keySetDto.getEncryptionKey()[0]); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wrapping this now? declaring throw E, throwing a RuntimeException'\nThe code is: 'public static <T, E extends Exception> T maybeLog(CallableCheckedException<T, E> action, BiConsumer<LoggingFunction, Stopwatch> primaryLogger, BiConsumer<LoggingFunction, T> additonalLoggerWithAccessToResult) throws E { if (log.isTraceEnabled() || slowlogger.isWarnEnabled()) { Monitor<T> monitor = Monitor.createMonitor( primaryLogger, additonalLoggerWithAccessToResult, slowLogPredicate); try { T res = action.call(); monitor.registerResult(res); return res; } catch (Exception ex) { monitor.registerException(ex); <START> throw Throwables.throwUncheckedException(ex); <END> \/\/ wrapping this now? declaring throw E, throwing a RuntimeException } finally { monitor.log(); } } else { return action.call(); } }'","output":"public static <T, E extends Exception> T maybeLog(CallableCheckedException<T, E> action, BiConsumer<LoggingFunction, Stopwatch> primaryLogger, BiConsumer<LoggingFunction, T> additonalLoggerWithAccessToResult) throws E { if (log.isTraceEnabled() || slowlogger.isWarnEnabled()) { Monitor<T> monitor = Monitor.createMonitor( primaryLogger, additonalLoggerWithAccessToResult, slowLogPredicate); try { T res = action.call(); monitor.registerResult(res); return res; } catch (Exception ex) { monitor.registerException(ex); throw ex; } finally { monitor.log(); } } else { return action.call(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@lbergelson @nh13 in case, put 0L here'\nThe code is: 'public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { <START> counts.put(contingencyState, (long)0); <END> \/\/ @lbergelson @nh13 in case, put 0L here } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }'","output":"public Map<ContingencyState, Long> getContingencyStateCounts(final GenotypeConcordanceScheme scheme) { scheme.validateScheme(); final Map<ContingencyState, Long> counts = new HashMap<ContingencyState, Long>(); for (final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState, 0L); } for (final TruthState truthState : TruthState.values()) { for (final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState); final ContingencyState[] contingencyStateArray = scheme.getConcordanceStateArray(truthAndCallStates); for (final ContingencyState contingencyState : contingencyStateArray) { final long newCount = counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState, newCount); } } } return counts; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Need remove redundant cast'\nThe code is: 'protected void restore(Bundle savedInstanceState) { blocksApiVersion = config.getApiUrlVersionConfig().getBlocksApiVersion(); courseData = (EnrolledCoursesResponse) savedInstanceState.getSerializable(Router.EXTRA_COURSE_DATA); <START> courseUpgradeData = (CourseUpgradeResponse) savedInstanceState.getParcelable(Router.EXTRA_COURSE_UPGRADE_DATA); <END> \/\/ Need remove redundant cast courseComponentId = savedInstanceState.getString(Router.EXTRA_COURSE_COMPONENT_ID); if (courseComponentId == null) { final String courseId = courseData.getCourse().getId(); getHierarchyCall = courseApi.getCourseStructure(blocksApiVersion, courseId); getHierarchyCall.enqueue(new CourseAPI.GetCourseStructureCallback(this, courseId, new ProgressViewController(progressWheel), errorNotification, snackbarErrorNotification, this) { @Override protected void onResponse(@NonNull final CourseComponent courseComponent) { courseComponentId = courseComponent.getId(); invalidateOptionsMenu(); onLoadData(); } @Override protected void onFinish() { isInitialServerCallDone = true; } }); } }'","output":"protected void restore(Bundle savedInstanceState) { blocksApiVersion = config.getApiUrlVersionConfig().getBlocksApiVersion(); courseData = (EnrolledCoursesResponse) savedInstanceState.getSerializable(Router.EXTRA_COURSE_DATA); courseUpgradeData = savedInstanceState.getParcelable(Router.EXTRA_COURSE_UPGRADE_DATA); courseComponentId = savedInstanceState.getString(Router.EXTRA_COURSE_COMPONENT_ID); if (courseComponentId == null) { final String courseId = courseData.getCourse().getId(); getHierarchyCall = courseApi.getCourseStructure(blocksApiVersion, courseId); getHierarchyCall.enqueue(new CourseAPI.GetCourseStructureCallback(this, courseId, new ProgressViewController(progressWheel), errorNotification, snackbarErrorNotification, this) { @Override protected void onResponse(@NonNull final CourseComponent courseComponent) { courseComponentId = courseComponent.getId(); invalidateOptionsMenu(); onLoadData(); } @Override protected void onFinish() { isInitialServerCallDone = true; } }); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this code executed UI thread? syncExec() needed'\nThe code is: 'protected static void openEditor(final IWorkbenchPage page, final EditorHandle handle, final IBuild build, final boolean partial) { <START> Display.getDefault().syncExec(new Runnable() { <END> \/\/ this code executed UI thread? syncExec() needed public void run() { if (!page.getWorkbenchWindow().getShell().isDisposed()) { BuildEditorInput input = new BuildEditorInput(build, partial); try { IEditorPart part = page.openEditor(input, BuildsUiConstants.ID_EDITOR_BUILDS); handle.setPart(part); handle.setStatus(Status.OK_STATUS); } catch (PartInitException e) { IStatus status = new Status(IStatus.ERROR, BuildsUiPlugin.ID_PLUGIN, \"Unexpected error while opening build\", e); StatusHandler.log(status); handle.setStatus(status); } } } }); }'","output":"protected static void openEditor(final IWorkbenchPage page, final EditorHandle handle, final IBuild build, final boolean partial) { BuildEditorInput input = new BuildEditorInput(build, partial); try { IEditorPart part = page.openEditor(input, BuildsUiConstants.ID_EDITOR_BUILDS); handle.setPart(part); handle.setStatus(Status.OK_STATUS); } catch (PartInitException e) { IStatus status = new Status(IStatus.ERROR, BuildsUiPlugin.ID_PLUGIN, \"Unexpected error while opening build\", e); StatusHandler.log(status); handle.setStatus(status); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add navigator's dependencies this is supported'\nThe code is: 'public static Set<DistributionModuleGroup> getModuleGroups() { Set<DistributionModuleGroup> hs = new HashSet<>(); hs.add(new DistributionModuleGroup(CDH5120Constant.HDFS_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_PARQUET_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_PARQUET_MRREQUIRED_MODULE_GROUP.getModuleName(), true, null)); <START> ComponentCondition conditionUseNavigator = new SimpleComponentCondition(new BasicExpression( <END> \/\/ add navigator's dependencies this is supported MRConstant.USE_CLOUDERA_NAVIGATOR)); hs.add(new DistributionModuleGroup(CDH5120Constant.TALEND_CLOUDERA_CDH_5_12_NAVIGATOR.getModuleName(), true, conditionUseNavigator)); return hs; }'","output":"public static Set<DistributionModuleGroup> getModuleGroups() { Set<DistributionModuleGroup> hs = new HashSet<>(); hs.add(new DistributionModuleGroup(CDH5120Constant.HDFS_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_PARQUET_MODULE_GROUP.getModuleName())); hs.add(new DistributionModuleGroup(CDH5120Constant.MAPREDUCE_PARQUET_MRREQUIRED_MODULE_GROUP.getModuleName(), true, null)); END_CLOUDERA_CDH_5_12_NAVIGATOR.getModuleName(), return hs; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'used'\nThe code is: 'private void registerHll() { <START> String p = \"asd\"; <END> \/\/ used SketchDescriptor sd = new SketchDescriptor(\"hll\"); sd.register(DATA_TO_SKETCH, org.apache.datasketches.hive.hll.DataToSketchUDAF.class); sd.register(SKETCH_TO_ESTIMATE_WITH_ERROR_BOUNDS, org.apache.datasketches.hive.hll.SketchToEstimateAndErrorBoundsUDF.class); sd.register(SKETCH_TO_ESTIMATE, org.apache.datasketches.hive.hll.SketchToEstimateUDF.class); sd.register(SKETCH_TO_STRING, org.apache.datasketches.hive.hll.SketchToStringUDF.class); sd.register(UNION_SKETCH1, org.apache.datasketches.hive.hll.UnionSketchUDF.class); sd.register(UNION_SKETCH, org.apache.datasketches.hive.hll.UnionSketchUDAF.class); sketchClasses.add(sd); }'","output":"private void registerHll() { SketchDescriptor sd = new SketchDescriptor(\"hll\"); sd.register(DATA_TO_SKETCH, org.apache.datasketches.hive.hll.DataToSketchUDAF.class); sd.register(SKETCH_TO_ESTIMATE_WITH_ERROR_BOUNDS, org.apache.datasketches.hive.hll.SketchToEstimateAndErrorBoundsUDF.class); sd.register(SKETCH_TO_ESTIMATE, org.apache.datasketches.hive.hll.SketchToEstimateUDF.class); sd.register(SKETCH_TO_STRING, org.apache.datasketches.hive.hll.SketchToStringUDF.class); sd.register(UNION_SKETCH1, org.apache.datasketches.hive.hll.UnionSketchUDF.class); sd.register(UNION_SKETCH, org.apache.datasketches.hive.hll.UnionSketchUDAF.class); sketchClasses.add(sd); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove toString() call'\nThe code is: 'protected void doExecute(ApplicationService applicationService) throws ApplicationServiceException { Application application = applicationService.getApplication(appName); if (application == null) { console.println(\"No application found with name \" + appName); return; } ApplicationStatus appStatus = applicationService.getApplicationStatus(application); console.println(application.getName()); <START> console.println(\"\\nCurrent State is: \" + appStatus.getState().toString()); <END> \/\/ remove toString() call console.println(\"\\nFeatures Located within this Application:\"); for (Feature curFeature : application.getFeatures()) { console.println(\"\\t\" + curFeature.getName()); } console.println(\"\\nRequired Features Not Started\"); if (appStatus.getErrorFeatures().isEmpty()) { console.print(Ansi.ansi().fg(Ansi.Color.GREEN).toString()); console.println(\"\\tNONE\"); console.print(Ansi.ansi().reset().toString()); } else { for (Feature curFeature : appStatus.getErrorFeatures()) { console.print(Ansi.ansi().fg(Ansi.Color.RED).toString()); console.println(\"\\t\" + curFeature.getName()); console.print(Ansi.ansi().reset().toString()); } } console.println(\"\\nRequired Bundles Not Started\"); if (appStatus.getErrorBundles().isEmpty()) { console.print(Ansi.ansi().fg(Ansi.Color.GREEN).toString()); console.println(\"\\tNONE\"); console.print(Ansi.ansi().reset().toString()); } else { for (Bundle curBundle : appStatus.getErrorBundles()) { console.print(Ansi.ansi().fg(Ansi.Color.RED).toString()); console.println(\"\\t[\" + curBundle.getBundleId() + \"]\\t\" + curBundle.getSymbolicName()); console.print(Ansi.ansi().reset().toString()); } } }'","output":"protected void doExecute(ApplicationService applicationService) throws ApplicationServiceException { Application application = applicationService.getApplication(appName); if (application == null) { console.println(\"No application found with name \" + appName); return; } ApplicationStatus appStatus = applicationService.getApplicationStatus(application); console.println(application.getName()); console.println(\"\\nCurrent State is: \" + appStatus.getState()); console.println(\"\\nFeatures Located within this Application:\"); for (Feature curFeature : application.getFeatures()) { console.println(\"\\t\" + curFeature.getName()); } console.println(\"\\nRequired Features Not Started\"); if (appStatus.getErrorFeatures().isEmpty()) { console.print(Ansi.ansi().fg(Ansi.Color.GREEN).toString()); console.println(\"\\tNONE\"); console.print(Ansi.ansi().reset().toString()); } else { for (Feature curFeature : appStatus.getErrorFeatures()) { console.print(Ansi.ansi().fg(Ansi.Color.RED).toString()); console.println(\"\\t\" + curFeature.getName()); console.print(Ansi.ansi().reset().toString()); } } console.println(\"\\nRequired Bundles Not Started\"); if (appStatus.getErrorBundles().isEmpty()) { console.print(Ansi.ansi().fg(Ansi.Color.GREEN).toString()); console.println(\"\\tNONE\"); console.print(Ansi.ansi().reset().toString()); } else { for (Bundle curBundle : appStatus.getErrorBundles()) { console.print(Ansi.ansi().fg(Ansi.Color.RED).toString()); console.println(\"\\t[\" + curBundle.getBundleId() + \"]\\t\" + curBundle.getSymbolicName()); console.print(Ansi.ansi().reset().toString()); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again: Capture, test. getGenericParams is expensive'\nThe code is: 'public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { if (nonNull(model.getGenericParams())) { <START> List<HaxeGenericParamModel> genericParams = model.getGenericParams(); <END> \/\/ Again: Capture, test. getGenericParams is expensive if (genericParams != null) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } } return specifics; }'","output":"public static ResultHolder[] applyConstraintsToSpecifics(HaxeMethodModel model, ResultHolder[] specifics) { List<HaxeGenericParamModel> genericParams = model.getGenericParams(); if (nonNull(genericParams)) { Map<String, ResultHolder> nameAndConstraints = getGenericTypeParametersByName(genericParams); for (int i = 0; i < specifics.length; i++) { String name = specifics[i].getClassType().getClassName(); boolean nameFound = genericParams.stream().anyMatch(m -> m.getName().equals(name)); if (nameFound) { if (nameAndConstraints.containsKey(name)) { specifics[i] = nameAndConstraints.get(name); if (specifics[i].getClassType().isEnumValueClass()) { ResultHolder dynamicType = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); specifics[i] = wrapType(dynamicType, specifics[i].getElementContext(), true).createHolder(); } continue; } specifics[i] = SpecificTypeReference.getDynamic(model.getMethodPsi()).createHolder(); } } } return specifics; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'val ->'\nThe code is: 'public PropertiesExpander(Properties properties) { if (properties == null) { throw new IllegalArgumentException(\"cannot pass null\"); } values = new HashMap<>(properties.size()); for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) { final String name = (String) e.nextElement(); <START> String val = properties.getProperty(name); <END> \/\/ val -> val = resolveValue(properties, name, val, new HashSet<>()); values.put(name, val); } }'","output":"public PropertiesExpander(Properties properties) { if (properties == null) { throw new IllegalArgumentException(\"cannot pass null\"); } values = new HashMap<>(properties.size()); for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) { final String name = (String) e.nextElement(); String value = properties.getProperty(name); value = resolveValue(properties, name, value, new HashSet<>()); values.put(name, value); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please remove this new exception here? I unused left previous fix attempt. Thank you'\nThe code is: 'private T doPut(T row, boolean needOld) throws IgniteCheckedException { checkDestroyed(); Put p = new Put(row, needOld); try { for (;;) { p.init(); Result res = putDown(p, p.rootId, 0L, p.rootLvl); switch (res) { case RETRY: case RETRY_ROOT: checkInterrupted(); continue; case FOUND: if (!p.isFinished()) { assert p.btmLvl <= getRootLevel(); checkInterrupted(); continue; } return p.oldRow; default: throw new IllegalStateException(\"Result: \" + res); } } } <START> catch (IgniteCheckedException | IgniteSQLException e) { <END> \/\/ please remove this new exception here? I unused left previous fix attempt. Thank you throw new IgniteCheckedException(\"Runtime failure on row: \" + row, e); } catch (RuntimeException | AssertionError e) { throw corruptedTreeException(\"Runtime failure on row: \" + row, e, grpId, p.pageId); } finally { checkDestroyed(); } }'","output":"private T doPut(T row, boolean needOld) throws IgniteCheckedException { checkDestroyed(); Put p = new Put(row, needOld); try { for (;;) { p.init(); Result res = putDown(p, p.rootId, 0L, p.rootLvl); switch (res) { case RETRY: case RETRY_ROOT: checkInterrupted(); continue; case FOUND: if (!p.isFinished()) { assert p.btmLvl <= getRootLevel(); checkInterrupted(); continue; } return p.oldRow; default: throw new IllegalStateException(\"Result: \" + res); } } } catch (IgniteCheckedException e) { throw new IgniteCheckedException(\"Runtime failure on row: \" + row, e); } catch (RuntimeException | AssertionError e) { throw corruptedTreeException(\"Runtime failure on row: \" + row, e, grpId, p.pageId); } finally { checkDestroyed(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove \/ update log line'\nThe code is: 'public <T> void notifyReadyAsync( Callable<T> callable, BiConsumer<T, Throwable> handler, long initialDelayMs, long periodMs) { workerExecutor.scheduleAtFixedRate(() -> { try { T result = callable.call(); executorToNotify.execute(() -> handler.accept(result, null)); } catch (Throwable t) { <START> LOG.error(\"Unexpected exception\", t); <END> \/\/ Remove \/ update log line executorToNotify.execute(() -> handler.accept(null, t)); } }, initialDelayMs, periodMs, TimeUnit.MILLISECONDS); }'","output":"public <T> void notifyReadyAsync( Callable<T> callable, BiConsumer<T, Throwable> handler, long initialDelayMs, long periodMs) { workerExecutor.scheduleAtFixedRate(() -> { try { T result = callable.call(); executorToNotify.execute(() -> handler.accept(result, null)); } catch (Throwable t) { executorToNotify.execute(() -> handler.accept(null, t)); } }, initialDelayMs, periodMs, TimeUnit.MILLISECONDS); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this static'\nThe code is: '<START> private MessageType createSchema() { <END> \/\/ this static return new MessageType(\"schema\", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT32, INT32_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT64, INT64_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FLOAT, FLOAT_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.DOUBLE, DOUBLE_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.BINARY, BINARY_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, 12, FIXED_LEN_BYTE_ARRAY_FIELD) ); }'","output":"private static MessageType createSchema() { return new MessageType(\"schema\", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT32, INT32_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT64, INT64_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FLOAT, FLOAT_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.DOUBLE, DOUBLE_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.BINARY, BINARY_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, 12, FIXED_LEN_BYTE_ARRAY_FIELD) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This simplified return \"<html><title>Google<\/title><\/html>\";'\nThe code is: 'public void shouldRaiseAlertIfResponseHasRemoteFileContentAndPayloadIsNullByteBased() throws HttpMalformedHeaderException { NullByteVulnerableServerHandler vulnServerHandler = new NullByteVulnerableServerHandler(\"\/\", \"p\", Tech.Linux) { protected String getContent(IHTTPSession session) { String value = getFirstParamValue(session, \"p\"); if (value.contains(NULL_BYTE_CHARACTER)) { <START> return \"<!doctype html><html itemscope=\\\"\\\" itemtype=\\\"<LINK_0>\\\" \" <END> \/\/ This simplified return \"<html><title>Google<\/title><\/html>\"; + \"lang=\\\"en-IN\\\"><head><meta charset=\\\"UTF-8\\\"><meta content=\\\"origin\\\" \" + \"name=\\\"referrer\\\"><meta content=\\\"\/logos\/doodles\/2020\/sir-john-tenniels-200th-birthday-6753651837108300.5-l.png\\\" \" + \"itemprop=\\\"image\\\"><meta content=\\\"origin\\\" name=\\\"referrer\\\"><title>Google<\/title> \" + \"<\/html>\"; } else { return \"<html><\/html>\"; } } }; nano.addHandler(vulnServerHandler); rule.init(getHttpMessage(\"\/?p=a\"), parent); rule.setAttackStrength(AttackStrength.INSANE); rule.scan(); assertThat(alertsRaised, hasSize(1)); }'","output":"public void shouldRaiseAlertIfResponseHasRemoteFileContentAndPayloadIsNullByteBased() throws HttpMalformedHeaderException { NullByteVulnerableServerHandler vulnServerHandler = new NullByteVulnerableServerHandler(\"\/\", \"p\", Tech.Linux) { protected String getContent(IHTTPSession session) { String value = getFirstParamValue(session, \"p\"); if (value.contains(NULL_BYTE_CHARACTER)) { return \"<html><title>Google<\/title><\/html>\"; } else { return \"<html><\/html>\"; } } }; nano.addHandler(vulnServerHandler); rule.init(getHttpMessage(\"\/?p=a\"), parent); rule.setAttackStrength(AttackStrength.INSANE); rule.scan(); assertThat(alertsRaised, hasSize(1)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this done a new volume is detected - i.e in createVolume() flow'\nThe code is: 'private void refreshClusterHeavyWeightData(VDSGroup cluster) { VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId()); if (upServer == null) { log.debug(\"No server UP in cluster '{}'. Can't refresh it's data at this point.\", cluster.getName()); return; } for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) { log.debug(\"Refreshing brick statuses for volume '{}' of cluster '{}'\", volume.getName(), cluster.getName()); if (volume.isOnline()) { acquireLock(cluster.getId()); try { refreshVolumeDetails(upServer, volume); } catch (Exception e) { log.error(\"Error while refreshing brick statuses for volume '{}' of cluster '{}': {}\", volume.getName(), cluster.getName(), e.getMessage()); log.debug(\"Exception\", e); } finally { releaseLock(cluster.getId()); } } } <START> for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) { <END> \/\/ this done a new volume is detected - i.e in createVolume() flow if (volume.getName().equals(Config.<String> getValue(ConfigValues.GlusterMetaVolumeName))) { log.debug(\"Mounting gluster meta volume on nodes of cluster '{}'\", cluster.getName()); acquireLock(cluster.getId()); try { mountMetaVolumeOnNodes(volume.getClusterId()); } catch (Exception e) { log.error(\"Error while mounting the gluster meta volume on nodes of cluster '{}': {}\", cluster.getName(), e.getMessage()); log.debug(\"Exception\", e); } finally { releaseLock(cluster.getId()); } } } }'","output":"private void refreshClusterHeavyWeightData(VDSGroup cluster) { VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId()); if (upServer == null) { log.debug(\"No server UP in cluster '{}'. Can't refresh it's data at this point.\", cluster.getName()); return; } for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) { log.debug(\"Refreshing brick statuses for volume '{}' of cluster '{}'\", volume.getName(), cluster.getName()); if (volume.isOnline()) { acquireLock(cluster.getId()); try { refreshVolumeDetails(upServer, volume); } catch (Exception e) { log.error(\"Error while refreshing brick statuses for volume '{}' of cluster '{}': {}\", volume.getName(), cluster.getName(), e.getMessage()); log.debug(\"Exception\", e); } finally { releaseLock(cluster.getId()); } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I of stay non-final provide more efficient implementations in subclasses'\nThe code is: 'public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; <START> public final List<T> peek(int max) throws IOException { <END> \/\/ I of stay non-final provide more efficient implementations in subclasses int end = Math.min(max, size()); List<T> subList = new ArrayList<T>(end); Iterator<T> iterator = iterator(); for (int i = 0; i < end; i++) { subList.add(iterator.next()); } return Collections.unmodifiableList(subList); }'","output":"public abstract void add(T entry) throws IOException; public abstract T peek() throws IOException; public List<T> peek(int max) throws IOException { int end = Math.min(max, size()); List<T> subList = new ArrayList<T>(end); Iterator<T> iterator = iterator(); for (int i = 0; i < end; i++) { subList.add(iterator.next()); } return Collections.unmodifiableList(subList); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is for this vmGroupMapping null? code this impossible case'\nThe code is: 'protected void processAffinityGroup(AffinityGroupVMMapVO vmGroupMapping, DeploymentPlan plan, VirtualMachine vm) { <START> if (vmGroupMapping != null) { <END> \/\/ Is for this vmGroupMapping null? code this impossible case AffinityGroupVO group = _affinityGroupDao.findById(vmGroupMapping.getAffinityGroupId()); s_logger.debug(\"Processing affinity group \" + group.getName() + \" for VM Id: \" + vm.getId()); List<Long> groupVMIds = _affinityGroupVMMapDao.listVmIdsByAffinityGroup(group.getId()); groupVMIds.remove(vm.getId()); List<Long> preferredHosts = getPreferredHostsFromGroupVMIds(groupVMIds); plan.setPreferredHosts(preferredHosts); } }'","output":"protected void processAffinityGroup(AffinityGroupVMMapVO vmGroupMapping, DeploymentPlan plan, VirtualMachine vm) { AffinityGroupVO group = _affinityGroupDao.findById(vmGroupMapping.getAffinityGroupId()); s_logger.debug(\"Processing affinity group \" + group.getName() + \" for VM Id: \" + vm.getId()); List<Long> groupVMIds = _affinityGroupVMMapDao.listVmIdsByAffinityGroup(group.getId()); groupVMIds.remove(vm.getId()); List<Long> preferredHosts = getPreferredHostsFromGroupVMIds(groupVMIds); plan.setPreferredHosts(preferredHosts); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I change variable name. monthBefore is missleading. nextMonth'\nThe code is: 'private void auditIncomingExpirations(List<Status> allowedStatuses, Map<Integer, Vo> vosMap) throws InternalErrorException { <START> LocalDate monthBefore = LocalDate.now().plusMonths(1); <END> \/\/ I change variable name. monthBefore is missleading. nextMonth auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, monthBefore, ExpirationPeriod.MONTH); LocalDate expireInA14Days = LocalDate.now().plusDays(14); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInA14Days, ExpirationPeriod.DAYS_14); LocalDate expireInA7Days = LocalDate.now().plusDays(7); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInA7Days, ExpirationPeriod.DAYS_7); LocalDate expireInADay = LocalDate.now().plusDays(1); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInADay, ExpirationPeriod.DAYS_1); }'","output":"private void auditIncomingExpirations(List<Status> allowedStatuses, Map<Integer, Vo> vosMap) throws InternalErrorException { LocalDate nextMonth = LocalDate.now().plusMonths(1); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, nextMonth, ExpirationPeriod.MONTH); LocalDate expireInA14Days = LocalDate.now().plusDays(14); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInA14Days, ExpirationPeriod.DAYS_14); LocalDate expireInA7Days = LocalDate.now().plusDays(7); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInA7Days, ExpirationPeriod.DAYS_7); LocalDate expireInADay = LocalDate.now().plusDays(1); auditInfoAboutIncomingMembersExpirationInGivenTime(allowedStatuses, vosMap, expireInADay, ExpirationPeriod.DAYS_1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this info log? feels a debug log me'\nThe code is: 'private void logon(MessageContext messageContext, JCoDestination destination, String escapeErrorHandling) throws AxisFault { JCoFunction logonFunction = getRFCfunction(destination, SAPConstants.BABI_XMI_LOGON); logonFunction.getImportParameterList().setValue(SAPConstants.EXTCOMPANY, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_EXTCOMPANY)); logonFunction.getImportParameterList().setValue(SAPConstants.EXTPRODUCT, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_EXTPRODUCT)); logonFunction.getImportParameterList().setValue(SAPConstants.INTERFACE, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_INTERFACE)); logonFunction.getImportParameterList().setValue(SAPConstants.VERSION, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_VERSION)); String logonResponse = evaluateRFCfunction(logonFunction, destination, escapeErrorHandling); if (log.isDebugEnabled()) { log.debug(\"BAPI XMI Logon response: \" + logonResponse); } <START> log.info(\"logged in\"); <END> \/\/ this info log? feels a debug log me }'","output":"private void logon(MessageContext messageContext, JCoDestination destination, String escapeErrorHandling) throws AxisFault { JCoFunction logonFunction = getRFCfunction(destination, SAPConstants.BABI_XMI_LOGON); logonFunction.getImportParameterList().setValue(SAPConstants.EXTCOMPANY, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_EXTCOMPANY)); logonFunction.getImportParameterList().setValue(SAPConstants.EXTPRODUCT, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_EXTPRODUCT)); logonFunction.getImportParameterList().setValue(SAPConstants.INTERFACE, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_INTERFACE)); logonFunction.getImportParameterList().setValue(SAPConstants.VERSION, (String) messageContext.getProperty(SAPConstants.TRANSPORT_SAP_VERSION)); String logonResponse = evaluateRFCfunction(logonFunction, destination, escapeErrorHandling); if (log.isDebugEnabled()) { log.debug(\"BAPI XMI Logon response: \" + logonResponse); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please remove this line'\nThe code is: 'public static List<RedDeerLauncherProperties> loadAll(ILaunchConfiguration configuration) throws CoreException{ List<RedDeerLauncherProperties> properties = new ArrayList<RedDeerLauncherProperties>(); for (String key : configuration.getAttributes().keySet()){ if (key.startsWith(RedDeerLauncherProperties.ATTRIBUTE_PREFIX)){ String argName = key.replace(RedDeerLauncherProperties.ATTRIBUTE_PREFIX, \"\"); try{ RedDeerProperties rdProperty = getByName(argName); RedDeerLauncherProperties property = new RedDeerLauncherProperties(rdProperty); String argValue = configuration.getAttribute(key, property.getProperty().getValue()); property.setCurrentValue(argValue); property.setDoubleDefined(configuration); <START> System.out.println(\"Found property: \" + property.getProperty().getName() + \" with value \" + property.currentValue); <END> \/\/ Please remove this line properties.add(property); } catch (RedDeerException re){ } } } return properties; }'","output":"public static List<RedDeerLauncherProperties> loadAll(ILaunchConfiguration configuration) throws CoreException{ List<RedDeerLauncherProperties> properties = new ArrayList<RedDeerLauncherProperties>(); for (String key : configuration.getAttributes().keySet()){ if (key.startsWith(RedDeerLauncherProperties.ATTRIBUTE_PREFIX)){ String argName = key.replace(RedDeerLauncherProperties.ATTRIBUTE_PREFIX, \"\"); try{ RedDeerProperties rdProperty = getByName(argName); RedDeerLauncherProperties property = new RedDeerLauncherProperties(rdProperty); String argValue = configuration.getAttribute(key, property.getProperty().getValue()); property.setCurrentValue(argValue); property.setDoubleDefined(configuration); properties.add(property); } catch (RedDeerException re){ } } } return properties; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'wrap super.close() a try\/finally channel is diconnected'\nThe code is: 'public FSDataInputStream open(Path f, int bufferSize) throws IOException { ChannelSftp channel = connect(); Path workDir; try { workDir = new Path(channel.pwd()); } catch (SftpException e) { throw new IOException(e); } Path absolute = makeAbsolute(workDir, f); FileStatus fileStat = getFileStatus(channel, absolute); if (fileStat.isDirectory()) { disconnect(channel); throw new IOException(String.format(E_PATH_DIR, f)); } try { absolute = new Path(\"\/\", channel.realpath(absolute.toUri().getPath())); } catch (SftpException e) { throw new IOException(e); } return new FSDataInputStream( new SFTPInputStream(channel, absolute, statistics)){ @Override public void close() throws IOException { <START> super.close(); <END> \/\/ wrap super.close() a try\/finally channel is diconnected disconnect(channel); } }; }'","output":"public FSDataInputStream open(Path f, int bufferSize) throws IOException { ChannelSftp channel = connect(); Path workDir; try { workDir = new Path(channel.pwd()); } catch (SftpException e) { throw new IOException(e); } Path absolute = makeAbsolute(workDir, f); FileStatus fileStat = getFileStatus(channel, absolute); if (fileStat.isDirectory()) { disconnect(channel); throw new IOException(String.format(E_PATH_DIR, f)); } try { absolute = new Path(\"\/\", channel.realpath(absolute.toUri().getPath())); } catch (SftpException e) { throw new IOException(e); } return new FSDataInputStream( new SFTPInputStream(channel, absolute, statistics)){ @Override public void close() throws IOException { try { super.close(); } finally { disconnect(channel); } } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Ds3DocSpecEmptyImpl'\nThe code is: 'public void testGenerateAmazonS3GetBucketRequestPrototype() throws IOException, TemplateModelException { final TestFileUtilsImpl fileUtils = new TestFileUtilsImpl(); final Map<String,Object> testMap = new HashMap<>(); final Request requestEntry = RequestConverter.toRequest(Ds3ModelFixtures.getBucketRequest(), <START> new Ds3DocSpecImpl( <END> \/\/ Ds3DocSpecEmptyImpl ImmutableMap.of(), ImmutableMap.of())); testMap.put(\"requestEntry\", requestEntry); final CCodeGenerator codeGenerator = new CCodeGenerator(); codeGenerator.processTemplate(testMap, \"header-templates\/RequestPrototype.ftl\", fileUtils.getOutputStream()); final ByteArrayOutputStream bstream = (ByteArrayOutputStream) fileUtils.getOutputStream(); final String output = new String(bstream.toByteArray()); final String expectedOutput = \"LIBRARY_API ds3_error* ds3_get_bucket(const ds3_client* client, const ds3_request* request, ds3_list_bucket_result_response** response);\"; assertEquals(expectedOutput, output); }'","output":"public void testGenerateAmazonS3GetBucketRequestPrototype() throws IOException, TemplateModelException { final TestFileUtilsImpl fileUtils = new TestFileUtilsImpl(); final Map<String,Object> testMap = new HashMap<>(); final Request requestEntry = RequestConverter.toRequest(Ds3ModelFixtures.getBucketRequest(), new Ds3DocSpecEmptyImpl()); testMap.put(\"requestEntry\", requestEntry); final CCodeGenerator codeGenerator = new CCodeGenerator(); codeGenerator.processTemplate(testMap, \"header-templates\/RequestPrototype.ftl\", fileUtils.getOutputStream()); final ByteArrayOutputStream bstream = (ByteArrayOutputStream) fileUtils.getOutputStream(); final String output = new String(bstream.toByteArray()); final String expectedOutput = \"LIBRARY_API ds3_error* ds3_get_bucket(const ds3_client* client, const ds3_request* request, ds3_list_bucket_result_response** response);\"; assertEquals(expectedOutput, output); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'intend resolve property name, aligned this property name defined in enum itself, resolution of enum is done \"ConfigValues.valueof(enumName). If name match, exception thrown. setting ConfigValues.AsyncTaskPollingRate.toString() toString() - some risk this method overridden, however, final method ConfigValues.AsyncTaskPollingRate.name() code is safer. Please replace toString() name() this patch'\nThe code is: 'private AsyncTaskManager() { _tasks = new HashMap<Guid, SPMAsyncTask>(); SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance(); scheduler.scheduleAConfigurableDelayJob(this, \"_timer_Elapsed\", new Class[] {}, new Object[] {}, Config.<Integer> GetValue(ConfigValues.AsyncTaskPollingRate), <START> ConfigValues.AsyncTaskPollingRate.toString(), TimeUnit.SECONDS); <END> \/\/ intend resolve property name, aligned this property name defined in enum itself, resolution of enum is done \"ConfigValues.valueof(enumName). If name match, exception thrown. setting ConfigValues.AsyncTaskPollingRate.toString() toString() - some risk this method overridden, however, final method ConfigValues.AsyncTaskPollingRate.name() code is safer. Please replace toString() name() this patch scheduler.scheduleAFixedDelayJob(this, \"_cacheTimer_Elapsed\", new Class[] {}, new Object[] {}, Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), TimeUnit.SECONDS); _cacheTimeInMinutes = Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCachingTimeInMinutes); }'","output":"private AsyncTaskManager() { _tasks = new HashMap<Guid, SPMAsyncTask>(); SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance(); scheduler.scheduleAConfigurableDelayJob(this, \"_timer_Elapsed\", new Class[] {}, new Object[] {}, Config.<Integer> GetValue(ConfigValues.AsyncTaskPollingRate), ConfigValues.AsyncTaskPollingRate.name(), TimeUnit.SECONDS); scheduler.scheduleAFixedDelayJob(this, \"_cacheTimer_Elapsed\", new Class[] {}, new Object[] {}, Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), TimeUnit.SECONDS); _cacheTimeInMinutes = Config.<Integer> GetValue(ConfigValues.AsyncTaskStatusCachingTimeInMinutes); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is nitpicky, c is a readable name'\nThe code is: 'public WorkflowVersion addAliasesAndCheck(User user, Long id, String aliases, boolean blockFormat) { WorkflowVersion c = getAndCheckResource(user, id); Set<String> oldAliases = c.getAliases().keySet(); Set<String> newAliases = Sets.newHashSet(Arrays.stream(aliases.split(\",\")).map(String::trim).toArray(String[]::new)); AliasableResourceInterface.checkAliases(newAliases, user, blockFormat); Set<String> duplicateAliasesToAdd = Sets.intersection(newAliases, oldAliases); if (!duplicateAliasesToAdd.isEmpty()) { String dupAliasesString = String.join(\", \", duplicateAliasesToAdd); throw new CustomWebApplicationException(\"Aliases \" + dupAliasesString + \" already exist; please use unique aliases\", HttpStatus.SC_BAD_REQUEST); } newAliases.forEach(alias -> c.getAliases().put(alias, new Alias())); <START> return c; <END> \/\/ This is nitpicky, c is a readable name }'","output":"public WorkflowVersion addAliasesAndCheck(User user, Long id, String aliases, boolean blockFormat) { WorkflowVersion workflowVersion = getAndCheckResource(user, id); Set<String> oldAliases = workflowVersion.getAliases().keySet(); Set<String> newAliases = Sets.newHashSet(Arrays.stream(aliases.split(\",\")).map(String::trim).toArray(String[]::new)); AliasableResourceInterface.checkAliases(newAliases, user, blockFormat); Set<String> duplicateAliasesToAdd = Sets.intersection(newAliases, oldAliases); if (!duplicateAliasesToAdd.isEmpty()) { String dupAliasesString = String.join(\", \", duplicateAliasesToAdd); throw new CustomWebApplicationException(\"Aliases \" + dupAliasesString + \" already exist; please use unique aliases\", HttpStatus.SC_BAD_REQUEST); } newAliases.forEach(alias -> workflowVersion.getAliases().put(alias, new Alias())); return workflowVersion; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'setErrorMessage'\nThe code is: 'public String solveProblemForAll() { for (Task task : this.steps) { this.currentStep = task; this.solution.setId(getIdForCorrection(this.solutionTask)); serviceManager.getWorkflowService().setSolution(getSolution()); try { setCurrentStep(serviceManager.getWorkflowService().solveProblem(this.currentStep)); saveStep(); } catch (DAOException | DataException e) { Helper.setFehlerMeldung(\"correctionSolveProblem\"); <START> logger.error(e.getMessage(), e); <END> \/\/ setErrorMessage } } setSolution(serviceManager.getWorkflowService().getSolution()); this.solutionTask = \"\"; AktuelleSchritteForm asf = (AktuelleSchritteForm) Helper.getManagedBeanValue(\"#{AktuelleSchritteForm}\"); return asf.filterAll(); }'","output":"public String solveProblemForAll() { for (Task task : this.steps) { this.currentStep = task; this.solution.setId(getIdForCorrection(this.solutionTask)); serviceManager.getWorkflowControllerService().setSolution(getSolution()); try { setCurrentStep(serviceManager.getWorkflowControllerService().solveProblem(this.currentStep)); saveStep(); } catch (DAOException | DataException e) { Helper.setErrorMessage(\"correctionSolveProblem\", logger, e); } } setSolution(serviceManager.getWorkflowControllerService().getSolution()); this.solutionTask = \"\"; AktuelleSchritteForm asf = (AktuelleSchritteForm) Helper.getManagedBeanValue(\"#{AktuelleSchritteForm}\"); return asf.filterAll(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Arrays.asList'\nThe code is: 'public void shouldDeleteUsers() { User john = new User(\"john\"); john.disable(); User joan = new User(\"joan\"); joan.disable(); <START> List<String> userNames = new ArrayList<String>() {{ <END> \/\/ Arrays.asList add(\"john\"); add(\"joan\"); }}; userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }'","output":"public void shouldDeleteUsers() { User john = new User(\"john\"); john.disable(); User joan = new User(\"joan\"); joan.disable(); List<String> userNames = Arrays.asList(\"john\", \"joan\"); userDao.saveOrUpdate(john); userDao.saveOrUpdate(joan); boolean result = userDao.deleteUsers(userNames); assertThat(result, is(true)); Users users = userDao.allUsers(); assertThat(users, is(empty())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do need this? Is this case cluster is get connection? this auto connect is enabled'\nThe code is: 'private void connectToOneServerWithRetry(String hostname, int port) { long sleep = m_initialRetryIntervalMS; while (m_shouldContinue.get()) { try { m_client.createConnection(hostname, port); LOG.info(String.format(\"Connected to VoltDB node at %s:%d.\", hostname, port)); <START> synchronized (m_client) { <END> \/\/ do need this? Is this case cluster is get connection? this auto connect is enabled m_client.notifyAll(); } break; } catch (Exception e) { LOG.warn(String.format(\"Connection to VoltDB node at %s:%d failed - retrying in %d second(s).\", hostname, port, TimeUnit.MILLISECONDS.toSeconds(sleep))); try { Thread.sleep(sleep); } catch (Exception ignored) { } if (sleep < m_maxRetryIntervalMS) { sleep = Math.min(sleep + sleep, m_maxRetryIntervalMS); } } } }'","output":"private void connectToOneServerWithRetry(String hostname, int port) { long sleep = m_initialRetryIntervalMS; while (m_shouldContinue.get()) { try { m_client.createConnection(hostname, port); LOG.info(String.format(\"Connected to VoltDB node at %s:%d.\", hostname, port)); break; } catch (Exception e) { LOG.warn(String.format(\"Connection to VoltDB node at %s:%d failed - retrying in %d second(s).\", hostname, port, TimeUnit.MILLISECONDS.toSeconds(sleep))); try { Thread.sleep(sleep); } catch (Exception ignored) { } if (sleep < m_maxRetryIntervalMS) { sleep = Math.min(sleep + sleep, m_maxRetryIntervalMS); } } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need .toString() here..'\nThe code is: 'public FileReplacer(final File file) throws IOException { this.file = checkNotNull(file); <START> this.filePrefix = file.getName() + \"-\" + UUID.randomUUID().toString() + \"-\" + counter.getAndIncrement(); <END> \/\/ need .toString() here.. this.tempFile = new File(file.getParentFile(), filePrefix + \".tmp\"); this.backupFile = new File(file.getParentFile(), filePrefix + \".bak\"); file.getParentFile().mkdirs(); if (tempFile.exists()) { log.warn(\"Temporary file already exists; removing: {}\", tempFile); delete(tempFile); } tempFile.createNewFile(); }'","output":"public FileReplacer(final File file) throws IOException { this.file = checkNotNull(file); this.filePrefix = file.getName() + \"-\" + UUID.randomUUID() + \"-\" + counter.getAndIncrement(); this.tempFile = new File(file.getParentFile(), filePrefix + \".tmp\"); this.backupFile = new File(file.getParentFile(), filePrefix + \".bak\"); file.getParentFile().mkdirs(); if (tempFile.exists()) { log.warn(\"Temporary file already exists; removing: {}\", tempFile); delete(tempFile); } tempFile.createNewFile(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'omit Assert.'\nThe code is: 'public void testProcessSpecialSoftwareCapabilities() { VDS vds = new VDS(); vds.setSupportedEmulatedMachines(\"pc-1.0\"); vds.setStatus(VDSStatus.Up); virtStrategy.processSoftwareCapabilities(vds); <START> Assert.assertEquals(VDSStatus.Up, vds.getStatus()); <END> \/\/ omit Assert. vds.setKvmEnabled(Boolean.TRUE); virtStrategy.processSoftwareCapabilities(vds); Assert.assertEquals(VDSStatus.Up, vds.getStatus()); vds.setKvmEnabled(Boolean.FALSE); virtStrategy.processSoftwareCapabilities(vds); assertEquals(VDSStatus.NonOperational, vds.getStatus()); }'","output":"public void testProcessSpecialSoftwareCapabilities() { VDS vds = new VDS(); vds.setSupportedEmulatedMachines(\"pc-1.0\"); vds.setStatus(VDSStatus.Up); virtStrategy.processSoftwareCapabilities(vds); assertEquals(VDSStatus.Up, vds.getStatus()); vds.setKvmEnabled(Boolean.TRUE); virtStrategy.processSoftwareCapabilities(vds); assertEquals(VDSStatus.Up, vds.getStatus()); vds.setKvmEnabled(Boolean.FALSE); virtStrategy.processSoftwareCapabilities(vds); assertEquals(VDSStatus.NonOperational, vds.getStatus()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'private String getIdForEvent(MuleEvent event) throws Exception { if (useSecureHash) { MuleMessage message = event.getMessage(); Object payload = message.getPayload(); byte[] payloadBytes = (byte[]) objectToByteArray.transform(payload); <START> byte[] bytes = Bytes.concat(payloadBytes, message.getUniqueId().getBytes()); <END> \/\/ static import if (payload instanceof InputStream) { event.getMessage().setPayload(bytes); } MessageDigest md = MessageDigest.getInstance(messageDigestAlgorithm); byte[] digestedBytes = md.digest(bytes); return (String)byteArrayToHexString.transform(digestedBytes); } else { return event.getMuleContext().getExpressionManager().parse(idExpression, event, true); } }'","output":"private String getIdForEvent(MuleEvent event) throws Exception { if (useSecureHash) { MuleMessage message = event.getMessage(); Object payload = message.getPayload(); byte[] payloadBytes = (byte[]) objectToByteArray.transform(payload); byte[] bytes = concat(payloadBytes, message.getUniqueId().getBytes()); if (payload instanceof InputStream) { event.getMessage().setPayload(bytes); } MessageDigest md = MessageDigest.getInstance(messageDigestAlgorithm); byte[] digestedBytes = md.digest(bytes); return (String)byteArrayToHexString.transform(digestedBytes); } else { return event.getMuleContext().getExpressionManager().parse(idExpression, event, true); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a constant'\nThe code is: 'public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(\"tableDisplayName\", ti.getTableName()); heapProperties.setProperty(\"catalogVersion\", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); <START> long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, 100); <END> \/\/ a constant ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(\"Dictionary Table Failure - exiting \"); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }'","output":"public void run(){ try{ ContextManager cm=ContextService.getFactory().newContextManager(); cm.pushContext(ec); ContextService.getFactory().setCurrentContextManager(cm); TabInfoImpl ti=coreInfo[coreCtr]; String version = catalogVersions.get(coreCtr); Properties heapProperties=new Properties(); heapProperties.setProperty(\"tableDisplayName\", ti.getTableName()); heapProperties.setProperty(\"catalogVersion\", version); ExecRow rowTemplate=ti.getCatalogRowFactory().makeEmptyRowForLatestVersion(); long conglomerate=createConglomerate(tc,rowTemplate,heapProperties, Conglomerate.Priority.HIGH); ti.setHeapConglomerate(conglomerate); }catch(Exception e){ e.printStackTrace(); StringBuilder strbuf = new StringBuilder(\"Dictionary Table Failure - exiting \"); strbuf.append(coreCtr); SanityManager.THROWASSERT(strbuf.toString()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change 1? work multiple partitions'\nThe code is: 'public static void main(String... args) throws InterruptedException { System.out.println(\">>> Decision tree classification trainer example started.\"); try (Ignite ignite = Ignition.start(\"examples\/config\/example-ignite.xml\")) { System.out.println(\">>> Ignite grid started.\"); IgniteThread igniteThread = new IgniteThread(ignite.configuration().getIgniteInstanceName(), DecisionTreeClassificationTrainerExample.class.getSimpleName(), () -> { CacheConfiguration<Integer, LabeledPoint> trainingSetCfg = new CacheConfiguration<>(); trainingSetCfg.setName(\"TRAINING_SET\"); <START> trainingSetCfg.setAffinity(new RendezvousAffinityFunction(false, 1)); <END> \/\/ change 1? work multiple partitions IgniteCache<Integer, LabeledPoint> trainingSet = ignite.createCache(trainingSetCfg); Random rnd = new Random(0); for (int i = 0; i < 1000; i++) trainingSet.put(i, generatePoint(rnd)); DecisionTreeClassificationTrainer trainer = new DecisionTreeClassificationTrainer(4, 0, false); DecisionTreeNode mdl = trainer.fit( ignite, trainingSet, (k, v) -> VectorUtils.of(v.x, v.y), (k, v) -> v.lb ); int correctPredictions = 0; for (int i = 0; i < 1000; i++) { LabeledPoint pnt = generatePoint(rnd); double prediction = mdl.apply(VectorUtils.of(pnt.x, pnt.y)); if (prediction == pnt.lb) correctPredictions++; } System.out.println(\">>> Accuracy: \" + correctPredictions \/ 10.0 + \"%\"); System.out.println(\">>> Decision tree classification trainer example completed.\"); }); igniteThread.start(); igniteThread.join(); } }'","output":"public static void main(String... args) throws InterruptedException { System.out.println(\">>> Decision tree classification trainer example started.\"); try (Ignite ignite = Ignition.start(\"examples\/config\/example-ignite.xml\")) { System.out.println(\">>> Ignite grid started.\"); IgniteThread igniteThread = new IgniteThread(ignite.configuration().getIgniteInstanceName(), DecisionTreeClassificationTrainerExample.class.getSimpleName(), () -> { CacheConfiguration<Integer, LabeledPoint> trainingSetCfg = new CacheConfiguration<>(); trainingSetCfg.setName(\"TRAINING_SET\"); trainingSetCfg.setAffinity(new RendezvousAffinityFunction(false, 10)); IgniteCache<Integer, LabeledPoint> trainingSet = ignite.createCache(trainingSetCfg); Random rnd = new Random(0); for (int i = 0; i < 1000; i++) trainingSet.put(i, generatePoint(rnd)); DecisionTreeClassificationTrainer trainer = new DecisionTreeClassificationTrainer(4, 0); DecisionTreeNode mdl = trainer.fit( ignite, trainingSet, (k, v) -> VectorUtils.of(v.x, v.y), (k, v) -> v.lb ); int correctPredictions = 0; for (int i = 0; i < 1000; i++) { LabeledPoint pnt = generatePoint(rnd); double prediction = mdl.apply(VectorUtils.of(pnt.x, pnt.y)); if (prediction == pnt.lb) correctPredictions++; } System.out.println(\">>> Accuracy: \" + correctPredictions \/ 10.0 + \"%\"); System.out.println(\">>> Decision tree classification trainer example completed.\"); }); igniteThread.start(); igniteThread.join(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Consider renaming splitedURL splitURL'\nThe code is: 'public static String getSessionToken(String url) { String token = \"undefined\"; try { String decodedURL = URLDecoder.decode(url, \"UTF-8\"); <START> String[] splitedURL = decodedURL.split(\"\\\\?\"); <END> \/\/ Consider renaming splitedURL splitURL if (splitedURL.length == 2) { String params = splitedURL[1]; for (String param : params.split(\"\\\\&\")) { if (param.startsWith(\"sessionToken=\")) { token = param.split(\"\\\\=\")[1]; } } } } catch (UnsupportedEncodingException e) { log.error(e.toString()); } return token; }'","output":"public static String getSessionToken(String url) { String token = \"undefined\"; try { String decodedURL = URLDecoder.decode(url, \"UTF-8\"); String[] splitURL = decodedURL.split(\"\\\\?\"); if (splitURL.length == 2) { String params = splitURL[1]; for (String param : params.split(\"\\\\&\")) { if (param.startsWith(\"sessionToken=\")) { token = param.split(\"\\\\=\")[1]; } } } } catch (UnsupportedEncodingException e) { log.error(e.toString()); } return token; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Setting submit enablement in method buttonsEnablement'\nThe code is: 'public void setChangeInfo(GerritRepository gerritRepository, ChangeInfo element) { filesTab.setGerritRepository(gerritRepository); fChangeInfo.reset(); fChangeInfo.setNumber(element.get_number()); fChangeInfo.setId(element.getId()); fChangeInfo.setChange_id(element.getChange_id()); fChangeInfo.setStatus(element.getStatus()); fChangeInfo.setProject(element.getProject()); fChangeInfo.setBranch(element.getBranch()); fChangeInfo.setUpdated(element.getUpdated()); fChangeInfo.setTopic(element.getTopic()); fChangeInfo.setCodeReviewedTally(element.getCodeReviewedTally()); fChangeInfo.setVerifiedTally(element.getVerifiedTally()); fChangeInfo.setLabels(element.getLabels()); setCurrentRevisionAndMessageTab(gerritRepository, element.getChange_id()); summaryTab.setTabs(gerritRepository, element); <START> fSubmit.setEnabled(true); <END> \/\/ Setting submit enablement in method buttonsEnablement buttonsEnablement(); }'","output":"public void setChangeInfo(GerritRepository gerritRepository, ChangeInfo element) { filesTab.setGerritRepository(gerritRepository); fChangeInfo.reset(); fChangeInfo.setNumber(element.get_number()); fChangeInfo.setId(element.getId()); fChangeInfo.setChange_id(element.getChange_id()); fChangeInfo.setStatus(element.getStatus()); fChangeInfo.setProject(element.getProject()); fChangeInfo.setBranch(element.getBranch()); fChangeInfo.setUpdated(element.getUpdated()); fChangeInfo.setTopic(element.getTopic()); fChangeInfo.setCodeReviewedTally(element.getCodeReviewedTally()); fChangeInfo.setVerifiedTally(element.getVerifiedTally()); fChangeInfo.setLabels(element.getLabels()); setCurrentRevisionAndMessageTab(gerritRepository, element.getChange_id()); summaryTab.setTabs(gerritRepository, element); buttonsEnablement(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this false -> true change do'\nThe code is: 'private byte[] mirrorImage(byte[] data) { ByteArrayInputStream inputStream = new ByteArrayInputStream(data); Bitmap photo = BitmapFactory.decodeStream(inputStream); Matrix m = new Matrix(); m.preScale(-1, 1); <START> Bitmap mirroredImage = Bitmap.createBitmap(photo, 0, 0, photo.getWidth(), photo.getHeight(), m, true); <END> \/\/ this false -> true change do byte[] result = null; try { result = compress(mirroredImage, 85); } catch (OutOfMemoryError e) { try { result = compress(mirroredImage, 70); } catch (OutOfMemoryError e2) { e.printStackTrace(); } } try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } return result; }'","output":"private byte[] mirrorImage(byte[] data) { ByteArrayInputStream inputStream = new ByteArrayInputStream(data); Bitmap photo = BitmapFactory.decodeStream(inputStream); Matrix m = new Matrix(); m.preScale(-1, 1); Bitmap mirroredImage = Bitmap.createBitmap(photo, 0, 0, photo.getWidth(), photo.getHeight(), m, false); byte[] result = null; try { result = compress(mirroredImage, 85); } catch (OutOfMemoryError e) { try { result = compress(mirroredImage, 70); } catch (OutOfMemoryError e2) { e.printStackTrace(); } } try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I good log exceptions. Please remove this check'\nThe code is: 'public HashSet<PersistentID> doBackup() throws IOException { BackupTask task = currentTask.get(); if (task == null) { throw new IOException(\"No backup currently in progress\"); } task.notifyOtherMembersReady(); HashSet<PersistentID> result; try { result = taskFuture.get(); } catch (InterruptedException | ExecutionException e) { <START> if (e instanceof ExecutionException) { <END> \/\/ I good log exceptions. Please remove this check logger.warn(\"Backup failed with exception: \", e); } result = new HashSet<>(); } finally { cleanup(); } return result; }'","output":"public HashSet<PersistentID> doBackup() throws IOException { BackupTask task = currentTask.get(); if (task == null) { throw new IOException(\"No backup currently in progress\"); } task.notifyOtherMembersReady(); HashSet<PersistentID> result; try { result = taskFuture.get(); } catch (InterruptedException | ExecutionException e) { logger.warn(\"Backup failed with exception: \", e); result = new HashSet<>(); } finally { cleanup(); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Check args'\nThe code is: 'public Surface<Double, Double, Pair<Double, DoubleMatrix1D>> getVolAndParameterSensitivitySurface(final DoubleMatrix1D modelParameters) { <START> final BasisFunctionAggregation<double[]> bSpline = new BasisFunctionAggregation<>(_bSplines, modelParameters.getData()); <END> \/\/ Check args final Function2D<Double, Pair<Double, DoubleMatrix1D>> func = new Function2D<Double, Pair<Double, DoubleMatrix1D>>() { @Override public Pair<Double, DoubleMatrix1D> evaluate(final Double t, final Double k) { return bSpline.valueAndWeightSensitivity(new double[] {t, k }); } }; return new FunctionalSurface<>(func); }'","output":"public Surface<Double, Double, Pair<Double, DoubleMatrix1D>> getVolAndParameterSensitivitySurface(final DoubleMatrix1D modelParameters) { ArgumentChecker.notNull(modelParameters, \"modelParameters\"); final BasisFunctionAggregation<double[]> bSpline = new BasisFunctionAggregation<>(_bSplines, modelParameters.getData()); final Function2D<Double, Pair<Double, DoubleMatrix1D>> func = new Function2D<Double, Pair<Double, DoubleMatrix1D>>() { @Override public Pair<Double, DoubleMatrix1D> evaluate(final Double t, final Double k) { return bSpline.valueAndWeightSensitivity(new double[] {t, k }); } }; return new FunctionalSurface<>(func); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'change in this class removed test moved a dedicated class'\nThe code is: 'public void setUp() throws Exception { super.setUp(); siteService = ContentServiceFactory.getInstance().getSiteService(); alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME); alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME); alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME); trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME); trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME); trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME); trueForUsersInGroupTest = authorizationFeatureService.find(TrueForUsersInGroupTestFeature.NAME); <START> loginOnBehalfOf = authorizationFeatureService.find(LoginOnBehalfOfFeature.NAME); <END> \/\/ change in this class removed test moved a dedicated class }'","output":"public void setUp() throws Exception { super.setUp(); siteService = ContentServiceFactory.getInstance().getSiteService(); alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME); alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME); alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME); trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME); trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME); trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME); trueForUsersInGroupTest = authorizationFeatureService.find(TrueForUsersInGroupTestFeature.NAME); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'IllegalStateException'\nThe code is: 'private CloseableHttpResponse proxyRequest(String appUrl, ContainerRequestContext request) throws IOException { String method = request.getMethod(); String requestURI = request.getUriInfo().getRequestUri().getPath(); CloseableHttpResponse proxiedResponse; switch (method) { case \"GET\": HttpGet httpGet = new HttpGet(appUrl + requestURI); proxiedResponse = httpclient.execute(httpGet); break; case \"PUT\": HttpPut httpPut = new HttpPut(appUrl + requestURI); httpPut.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); httpPut.setEntity(new InputStreamEntity(request.getEntityStream())); proxiedResponse = httpclient.execute(httpPut); break; case \"POST\": HttpPost httpPost = new HttpPost(appUrl + requestURI); httpPost.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); httpPost.setEntity(new InputStreamEntity(request.getEntityStream())); proxiedResponse = httpclient.execute(httpPost); break; case \"DELETE\": HttpDelete httpDelete = new HttpDelete(appUrl + requestURI); httpDelete.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); proxiedResponse = httpclient.execute(httpDelete); break; default: <START> throw new RuntimeException(\"Method not supported: \" + method); <END> \/\/ IllegalStateException } return proxiedResponse; }'","output":"private CloseableHttpResponse proxyRequest(String appUrl, ContainerRequestContext request) throws IOException { String method = request.getMethod(); String requestURI = request.getUriInfo().getRequestUri().getPath(); CloseableHttpResponse proxiedResponse; switch (method) { case \"GET\": HttpGet httpGet = new HttpGet(appUrl + requestURI); proxiedResponse = httpclient.execute(httpGet); break; case \"PUT\": HttpPut httpPut = new HttpPut(appUrl + requestURI); httpPut.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); httpPut.setEntity(new InputStreamEntity(request.getEntityStream())); proxiedResponse = httpclient.execute(httpPut); break; case \"POST\": HttpPost httpPost = new HttpPost(appUrl + requestURI); httpPost.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); httpPost.setEntity(new InputStreamEntity(request.getEntityStream())); proxiedResponse = httpclient.execute(httpPost); break; case \"DELETE\": HttpDelete httpDelete = new HttpDelete(appUrl + requestURI); httpDelete.setHeader(HTTP.CONTENT_TYPE, request.getHeaderString(\"Content-Type\")); proxiedResponse = httpclient.execute(httpDelete); break; default: throw new IllegalStateException(\"Method not supported: \" + method); } return proxiedResponse; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'assertThat(someContainer).hasSize(4) is shorter error message. 15x in this PR: CTRL + f \".size()).isEqualTo(\"'\nThe code is: 'public void compileTest() { CompilationRequest req = new DefaultCompilationRequest(mavenRepo.toAbsolutePath().toString(), info, new String[]{ MavenCLIArgs.INSTALL, MavenCLIArgs.ALTERNATE_USER_SETTINGS + alternateSettingsAbsPath }, Boolean.FALSE); ClasspathDepsAfterDecorator decorator = new ClasspathDepsAfterDecorator(new BaseMavenCompiler()); CompilationResponse res = decorator.compile(req); SoftAssertions.assertSoftly(softly -> { softly.assertThat(res.isSuccessful()).isTrue(); <START> softly.assertThat(res.getDependencies().size()).isEqualTo(4); <END> \/\/ assertThat(someContainer).hasSize(4) is shorter error message. 15x in this PR: CTRL + f \".size()).isEqualTo(\" }); }'","output":"public void compileTest() { CompilationRequest req = new DefaultCompilationRequest(mavenRepo.toAbsolutePath().toString(), info, new String[]{ MavenCLIArgs.INSTALL, MavenCLIArgs.ALTERNATE_USER_SETTINGS + alternateSettingsAbsPath }, Boolean.FALSE); ClasspathDepsAfterDecorator decorator = new ClasspathDepsAfterDecorator(new BaseMavenCompiler()); CompilationResponse res = decorator.compile(req); SoftAssertions.assertSoftly(softly -> { softly.assertThat(res.isSuccessful()).isTrue(); softly.assertThat(res.getDependencies()).hasSize(4); }); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'TestNG assertEquals(boolean actual, boolean expected), assertEquals(groups.size(), 1);'\nThe code is: 'public void testListSecurityGroups() { HttpRequest list = HttpRequest.builder().method(\"GET\").endpoint( URI.create(\"<LINK_0>\")).headers( ImmutableMultimap.<String, String> builder().put(\"Accept\", \"application\/json\").put(\"X-Auth-Token\", authToken).build()).build(); HttpResponse listResponse = HttpResponse.builder().statusCode(200).payload( payloadFromResource(\"\/securitygroup_list.json\")).build(); Builder<HttpRequest, HttpResponse> requestResponseMap = ImmutableMap.<HttpRequest, HttpResponse> builder(); requestResponseMap.put(keystoneAuthWithUsernameAndPasswordAndTenantName, responseWithKeystoneAccess); requestResponseMap.put(extensionsOfNovaRequest, extensionsOfNovaResponse); requestResponseMap.put(list, listResponse).build(); SecurityGroupExtension extension = requestsSendResponses(requestResponseMap.build()).getSecurityGroupExtension().get(); Set<SecurityGroup> groups = extension.listSecurityGroups(); <START> assertEquals(1, groups.size()); <END> \/\/ TestNG assertEquals(boolean actual, boolean expected), assertEquals(groups.size(), 1); }'","output":"public void testListSecurityGroups() { HttpRequest list = HttpRequest.builder().method(\"GET\").endpoint( URI.create(\"<LINK_0>\")).headers( ImmutableMultimap.<String, String> builder().put(\"Accept\", \"application\/json\").put(\"X-Auth-Token\", authToken).build()).build(); HttpResponse listResponse = HttpResponse.builder().statusCode(200).payload( payloadFromResource(\"\/securitygroup_list.json\")).build(); Builder<HttpRequest, HttpResponse> requestResponseMap = ImmutableMap.<HttpRequest, HttpResponse> builder(); requestResponseMap.put(keystoneAuthWithUsernameAndPasswordAndTenantName, responseWithKeystoneAccess); requestResponseMap.put(extensionsOfNovaRequest, extensionsOfNovaResponse); requestResponseMap.put(list, listResponse).build(); SecurityGroupExtension extension = requestsSendResponses(requestResponseMap.build()).getSecurityGroupExtension().get(); Set<SecurityGroup> groups = extension.listSecurityGroups(); assertEquals(groups.size(), 1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Return empty list instead of null (same for L77)'\nThe code is: 'public static <T> List<T> safeGetList(Map map, String key, Class<T> type) { List<?> unchecked = safeGet(map, key, List.class); if (unchecked == null) { <START> return null; <END> \/\/ Return empty list instead of null (same for L77) } try { return (List<T>) unchecked.stream().map(type::cast).collect(Collectors.toList()); } catch (ClassCastException e) { LOGGER.debug(EXCEPTION_OCCURRED_PARSING, e); LOGGER.warn( \"Form configuration field {} was malformed, expected a List containing type {}\", key, type.getName()); } return null; }'","output":"public static <T> List<T> safeGetList(Map map, String key, Class<T> type) { List<?> unchecked = safeGet(map, key, List.class); if (unchecked == null) { return Collections.emptyList(); } try { return (List<T>) unchecked.stream().map(type::cast).collect(Collectors.toList()); } catch (ClassCastException e) { LOGGER.debug(EXCEPTION_OCCURRED_PARSING, e); LOGGER.warn( \"Form configuration field {} was malformed, expected a List containing type {}\", key, type.getName()); } return Collections.emptyList(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need check debug is enabled'\nThe code is: 'public void start(final BundleContext bundleContext) { WebAppConfigurationService webAppConfigurationService = new WebAppConfigurationDataHolder(); bundleContext.registerService(WebAppConfigurationService.class.getName(), webAppConfigurationService, null); <START> log.debug(\"WebappConfigService was registered!\"); <END> \/\/ need check debug is enabled if (!CarbonUtils.isRunningInStandaloneMode()) { Thread th = new Thread() { public void run() { try { bundleContext.getBundle().uninstall(); } catch (Throwable e) { log.warn(\"Error occurred while uninstalling webapp-mgt UI bundle\", e); } } }; try { th.join(); } catch (InterruptedException ignored) { } th.start(); } }'","output":"public void start(final BundleContext bundleContext) { WebAppConfigurationService webAppConfigurationService = new WebAppConfigurationDataHolder(); bundleContext.registerService(WebAppConfigurationService.class.getName(), webAppConfigurationService, null); if (log.isDebugEnabled()) { log.debug(\"WebappConfigService was registered!\"); } if (!CarbonUtils.isRunningInStandaloneMode()) { Thread th = new Thread() { public void run() { try { bundleContext.getBundle().uninstall(); } catch (Throwable e) { log.warn(\"Error occurred while uninstalling webapp-mgt UI bundle\", e); } } }; try { th.join(); } catch (InterruptedException ignored) { } th.start(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'rename listIterator'\nThe code is: 'private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(\"Cannot create two iterators on a singly-iterable sequence\"); isIteratorCreated = true; return new Iterator<String>() { <START> private final Iterator<String> l_it = values.iterator(); <END> \/\/ rename listIterator @Override public boolean hasNext() { return l_it.hasNext(); } @Override public String next() { return l_it.next(); } }; } }; }'","output":"private Iterable<String> createSinglyIterable(final List<String> values) { return new Iterable<String>() { private boolean isIteratorCreated = false; @Override public Iterator<String> iterator() { if (isIteratorCreated) throw new IllegalArgumentException(\"Cannot create two iterators on a singly-iterable sequence\"); isIteratorCreated = true; return new Iterator<String>() { private final Iterator<String> listIterator = values.iterator(); @Override public boolean hasNext() { return listIterator.hasNext(); } @Override public String next() { return listIterator.next(); } }; } }; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Pass settingsRepository argument DownloadLanguageTranslationUseCase is necessary'\nThe code is: 'public void downloadLanguagesFromServer() throws Exception { try { if (BuildConfig.downloadLanguagesFromServer) { Log.i(TAG, \"Starting to download Languages From Server\"); CredentialsReader credentialsReader = CredentialsReader.getInstance(); IConnectivityManager connectivity = NetworkManagerFactory.getConnectivityManager( activity); ISettingsRepository settingsRepository = new SettingsDataSource(activity); <START> DownloadLanguageTranslationUseCase downloader = <END> \/\/ Pass settingsRepository argument DownloadLanguageTranslationUseCase is necessary new DownloadLanguageTranslationUseCase(credentialsReader, connectivity, settingsRepository); downloader.download(); } } catch (Exception e) { Log.e(TAG, \"Unable to download Languages From Server\" + e.getMessage()); e.printStackTrace(); showToast(R.string.error_downloading_languages, e); } }'","output":"public void downloadLanguagesFromServer() throws Exception { try { if (BuildConfig.downloadLanguagesFromServer) { Log.i(TAG, \"Starting to download Languages From Server\"); CredentialsReader credentialsReader = CredentialsReader.getInstance(); IConnectivityManager connectivity = NetworkManagerFactory.getConnectivityManager( activity); DownloadLanguageTranslationUseCase downloader = new DownloadLanguageTranslationUseCase(credentialsReader, connectivity); downloader.download(); } } catch (Exception e) { Log.e(TAG, \"Unable to download Languages From Server\" + e.getMessage()); e.printStackTrace(); showToast(R.string.error_downloading_languages, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do java Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; slightly easier read for loop'\nThe code is: 'private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { <START> Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.size()); <END> \/\/ do java Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; slightly easier read for loop for (Iterator<FileRef> iterator = filesToCompact.keySet().iterator(); iterator.hasNext();) { smallestFiles.add(iterator.next()); iterator.remove(); } return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public int compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }'","output":"private Set<FileRef> removeSmallest(Map<FileRef,DataFileValue> filesToCompact, int maxFilesToCompact) { if (filesToCompact.size() <= maxFilesToCompact) { Set<FileRef> smallestFiles = new HashSet<FileRef>(filesToCompact.keySet()); filesToCompact.clear(); return smallestFiles; } PriorityQueue<Pair<FileRef,Long>> fileHeap = new PriorityQueue<Pair<FileRef,Long>>(filesToCompact.size(), new Comparator<Pair<FileRef,Long>>() { @Override public int compare(Pair<FileRef,Long> o1, Pair<FileRef,Long> o2) { if (o1.getSecond() == o2.getSecond()) return o1.getFirst().compareTo(o2.getFirst()); if (o1.getSecond() < o2.getSecond()) return -1; return 1; } }); for (Iterator<Entry<FileRef,DataFileValue>> iterator = filesToCompact.entrySet().iterator(); iterator.hasNext();) { Entry<FileRef,DataFileValue> entry = iterator.next(); fileHeap.add(new Pair<FileRef,Long>(entry.getKey(), entry.getValue().getSize())); } Set<FileRef> smallestFiles = new HashSet<FileRef>(); while (smallestFiles.size() < maxFilesToCompact && fileHeap.size() > 0) { Pair<FileRef,Long> pair = fileHeap.remove(); filesToCompact.remove(pair.getFirst()); smallestFiles.add(pair.getFirst()); } return smallestFiles; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'blocks code hard readable, I able more readable code. is expcetion. do need line final Node node = (Node) element;. minimize dangerous of NPE Objects.equals(e, definition.getDefinition()) code like: java final Element<?> element = event.getElement(); if ((element instanceof Node)) { if (element.getContent() instanceof Definition) { final Definition definition = (Definition) element.getContent(); hasExpression.ifPresent(e -> { if (Objects.equals(e, definition.getDefinition())) { view.setReturnToDRGText(Optional.ofNullable((HasName) definition.getDefinition())); } }); } }'\nThe code is: 'void onCanvasElementUpdated(final @Observes CanvasElementUpdatedEvent event) { final Element<?> element = event.getElement(); if ((element instanceof Node)) { final Node node = (Node) element; if (node.getContent() instanceof Definition) { final Definition definition = (Definition) node.getContent(); hasExpression.ifPresent(e -> { if (e.equals(definition.getDefinition())) { view.setReturnToDRGText(Optional.ofNullable((HasName) definition.getDefinition())); } }); } <START> } <END> \/\/ blocks code hard readable, I able more readable code. is expcetion. do need line final Node node = (Node) element;. minimize dangerous of NPE Objects.equals(e, definition.getDefinition()) code like: java final Element<?> element = event.getElement(); if ((element instanceof Node)) { if (element.getContent() instanceof Definition) { final Definition definition = (Definition) element.getContent(); hasExpression.ifPresent(e -> { if (Objects.equals(e, definition.getDefinition())) { view.setReturnToDRGText(Optional.ofNullable((HasName) definition.getDefinition())); } }); } } }'","output":"void onCanvasElementUpdated(final @Observes CanvasElementUpdatedEvent event) { final Element<?> element = event.getElement(); if ((element instanceof Node)) { if (element.getContent() instanceof Definition) { final Definition definition = (Definition) element.getContent(); hasExpression.ifPresent(e -> { if (Objects.equals(e, definition.getDefinition())) { view.setReturnToDRGText(Optional.ofNullable((HasName) definition.getDefinition())); } }); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'forgot remove character encoding setting'\nThe code is: 'public void differentialRnaSeqExperimentEvidence(@RequestParam(defaultValue = \"0\") double logFoldChangeCutoff, @RequestParam(defaultValue = \"1\") double pValueCutoff, @RequestParam(defaultValue = \"-1\") int maxGenesPerContrast, @PathVariable String experimentAccession, @RequestParam(defaultValue = \"\") String accessKey, HttpServletResponse response) throws IOException { DifferentialExperiment experiment = (DifferentialExperiment) experimentTrader.getExperiment(experimentAccession, accessKey); response.setHeader(\"content-type\", \"application\/json-seq; charset=UTF-8\"); <START> response.setCharacterEncoding(\"UTF-8\"); <END> \/\/ forgot remove character encoding setting PrintWriter w = response.getWriter(); diffRnaSeqEvidenceService.evidenceForExperiment( experiment, contrast -> { DifferentialRequestPreferences requestPreferences = new DifferentialRequestPreferences(); requestPreferences.setFoldChangeCutoff(logFoldChangeCutoff); requestPreferences.setCutoff(pValueCutoff); requestPreferences.setHeatmapMatrixSize(maxGenesPerContrast); requestPreferences.setSelectedColumnIds(ImmutableSet.of(contrast.getId())); return new RnaSeqRequestContext(requestPreferences, experiment); }, o -> w.println(GSON.toJson(o))); }'","output":"public void differentialRnaSeqExperimentEvidence(@RequestParam(defaultValue = \"0\") double logFoldChangeCutoff, @RequestParam(defaultValue = \"1\") double pValueCutoff, @RequestParam(defaultValue = \"-1\") int maxGenesPerContrast, @PathVariable String experimentAccession, @RequestParam(defaultValue = \"\") String accessKey, HttpServletResponse response) throws IOException { DifferentialExperiment experiment = (DifferentialExperiment) experimentTrader.getExperiment(experimentAccession, accessKey); response.setHeader(\"content-type\", \"application\/json-seq; charset=UTF-8\"); PrintWriter w = response.getWriter(); diffRnaSeqEvidenceService.evidenceForExperiment( experiment, contrast -> { DifferentialRequestPreferences requestPreferences = new DifferentialRequestPreferences(); requestPreferences.setFoldChangeCutoff(logFoldChangeCutoff); requestPreferences.setCutoff(pValueCutoff); requestPreferences.setHeatmapMatrixSize(maxGenesPerContrast); requestPreferences.setSelectedColumnIds(ImmutableSet.of(contrast.getId())); return new RnaSeqRequestContext(requestPreferences, experiment); }, o -> w.println(GSON.toJson(o))); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'LOL this is of PMD catch in recipientTeam.isEmpty() (oh means this conflict #5268)'\nThe code is: 'getQuestionResponseMapByRecipientTeam() { LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>(); Collections.sort(responses, compareByTeamQuestionRecipientTeamGiver); for (FeedbackResponseAttributes response : responses) { String recipientTeam = getTeamNameForEmail(response.recipientEmail); <START> if (recipientTeam == \"\") { <END> \/\/ LOL this is of PMD catch in recipientTeam.isEmpty() (oh means this conflict #5268) recipientTeam = getNameForEmail(response.recipientEmail); } if (!sortedMap.containsKey(recipientTeam)) { sortedMap.put(recipientTeam, new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>()); } Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.get(recipientTeam); FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId); if (!responsesForOneRecipient.containsKey(question)) { responsesForOneRecipient.put(question, new ArrayList<FeedbackResponseAttributes>()); } List<FeedbackResponseAttributes> responsesForOneRecipientOneQuestion = responsesForOneRecipient.get(question); responsesForOneRecipientOneQuestion.add(response); } return sortedMap; }'","output":"getQuestionResponseMapByRecipientTeam() { LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>(); Collections.sort(responses, compareByTeamQuestionRecipientTeamGiver); for (FeedbackResponseAttributes response : responses) { String recipientTeam = getTeamNameForEmail(response.recipientEmail); if (recipientTeam.isEmpty()) { recipientTeam = getNameForEmail(response.recipientEmail); } if (!sortedMap.containsKey(recipientTeam)) { sortedMap.put(recipientTeam, new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>()); } Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.get(recipientTeam); FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId); if (!responsesForOneRecipient.containsKey(question)) { responsesForOneRecipient.put(question, new ArrayList<FeedbackResponseAttributes>()); } List<FeedbackResponseAttributes> responsesForOneRecipientOneQuestion = responsesForOneRecipient.get(question); responsesForOneRecipientOneQuestion.add(response); } return sortedMap; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This assertion is necessary is tested in assertAllInformationMatch'\nThe code is: 'protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(\"instructor2OfCourse1\"); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(\"session1InCourse1\"); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, \"true\", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); <START> assertNotNull(fs.getDeletedAtTimestamp()); <END> \/\/ This assertion is necessary is tested in assertAllInformationMatch assertAllInformationMatch(fs, session1InCourse1); }'","output":"protected void testExecute_asInstructorWithRecycleBinFlagTrue_shouldReturnAllSoftDeletedSessionsForInstructor() { InstructorAttributes instructor2OfCourse1 = typicalBundle.instructors.get(\"instructor2OfCourse1\"); FeedbackSessionAttributes session1InCourse1 = typicalBundle.feedbackSessions.get(\"session1InCourse1\"); loginAsInstructor(instructor2OfCourse1.googleId); String[] submissionParam = { Const.ParamsNames.IS_IN_RECYCLE_BIN, \"true\", Const.ParamsNames.ENTITY_TYPE, Const.EntityType.INSTRUCTOR, }; GetFeedbackSessionsAction action = getAction(submissionParam); FeedbackSessionsData fsData = (FeedbackSessionsData) getJsonResult(action).getOutput(); assertEquals(1, fsData.getFeedbackSessions().size()); FeedbackSessionData fs = fsData.getFeedbackSessions().get(0); assertAllInformationMatch(fs, session1InCourse1); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Gilad Bracha's quote: \"live is death\", I \"positive is negative\" :) replacing with: if (unmanagedControllers.isEmpty())'\nThe code is: 'private void acquireUnmanagedUsbController( VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) { if (unmanagedControllers.size() > 1) { throw new IllegalStateException(format(\"At most one unmanaged USB controller expected for VM=%s(%s), found=%s\", vmBase.getName(), vmBase.getId(), unmanagedControllers)); } final UsbControllerModel controllerModel = getUsbControllerModel(vmBase); <START> if (unmanagedControllers.size() != 1) { <END> \/\/ Gilad Bracha's quote: \"live is death\", I \"positive is negative\" :) replacing with: if (unmanagedControllers.isEmpty()) return; } removeVmDevices(managedUsbControllers); VmDevice device = unmanagedControllers.iterator().next(); device.setManaged(true); device.setPlugged(true); device.setReadOnly(false); device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0)); vmDeviceDao.update(device); }'","output":"private void acquireUnmanagedUsbController( VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) { if (unmanagedControllers.size() > 1) { throw new IllegalStateException(format(\"At most one unmanaged USB controller expected for VM=%s(%s), found=%s\", vmBase.getName(), vmBase.getId(), unmanagedControllers)); } final UsbControllerModel controllerModel = getUsbControllerModel(vmBase); if (unmanagedControllers.isEmpty()) { return; } removeVmDevices(managedUsbControllers); VmDevice device = unmanagedControllers.iterator().next(); device.setManaged(true); device.setPlugged(true); device.setReadOnly(false); device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0)); vmDeviceDao.update(device); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'e wrapped in a CucumberException in this case. construct throw new CucumberException(e); pretty common in code base'\nThe code is: 'private <T> List<T> toListOfComplexType(DataTable dataTable, Class<T> itemType) { HierarchicalStreamReader reader = new ListOfComplexTypeReader(itemType, convertTopCellsToFieldNames(dataTable), dataTable.cells(1)); try { return Collections.unmodifiableList((List<T>) xStream.unmarshal(reader)); } catch (AbstractReflectionConverter.UnknownFieldException e) { throw new CucumberException(e.getShortMessage()); } catch (AbstractReflectionConverter.DuplicateFieldException e) { throw new CucumberException(e.getShortMessage()); } catch (ConversionException e) { if (e.getCause() instanceof NullPointerException) { throw new CucumberException(String.format(\"Can't assign null value to one of the primitive fields in %s. Please use boxed types.\", e.get(\"class\"))); } else { <START> throw e; <END> \/\/ e wrapped in a CucumberException in this case. construct throw new CucumberException(e); pretty common in code base } } }'","output":"private <T> List<T> toListOfComplexType(DataTable dataTable, Class<T> itemType) { HierarchicalStreamReader reader = new ListOfComplexTypeReader(itemType, convertTopCellsToFieldNames(dataTable), dataTable.cells(1)); try { return Collections.unmodifiableList((List<T>) xStream.unmarshal(reader)); } catch (AbstractReflectionConverter.UnknownFieldException e) { throw new CucumberException(e.getShortMessage()); } catch (AbstractReflectionConverter.DuplicateFieldException e) { throw new CucumberException(e.getShortMessage()); } catch (ConversionException e) { if (e.getCause() instanceof NullPointerException) { throw new CucumberException(String.format(\"Can't assign null value to one of the primitive fields in %s. Please use boxed types.\", e.get(\"class\"))); } else { throw new CucumberException(e); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consider String.valueOf() circumvent NPE'\nThe code is: 'public AbstractFindStoragePopupView(EventBus eventBus, boolean multiSelection) { super(eventBus); table = new EntityModelCellTable<>(multiSelection); initWidget(ViewUiBinder.uiBinder.createAndBindUi(this)); table.addColumn(new AbstractEntityModelTextColumn<StorageDomain>() { @Override public String getText(StorageDomain storage) { return storage.getStorageName(); } }, constants.nameStorage()); table.addColumn(new AbstractEntityModelEnumColumn<StorageDomain, StorageDomainType>() { @Override protected StorageDomainType getEnum(StorageDomain storage) { return storage.getStorageDomainType(); } }, constants.typeStorage()); table.addColumn(new AbstractEntityModelTextColumn<StorageDomain>() { @Override public String getText(StorageDomain storage) { if (storage.getAvailableDiskSize() == null || storage.getAvailableDiskSize() < 1) { return messages.gigabytes(\"< 1\"); } return <START> messages.gigabytes(storage.getAvailableDiskSize().toString()); <END> \/\/ consider String.valueOf() circumvent NPE } }, constants.freeSpaceStorage()); }'","output":"public AbstractFindStoragePopupView(EventBus eventBus, boolean multiSelection) { super(eventBus); table = new EntityModelCellTable<>(multiSelection); initWidget(ViewUiBinder.uiBinder.createAndBindUi(this)); table.addColumn(new AbstractEntityModelTextColumn<StorageDomain>() { @Override public String getText(StorageDomain storage) { return storage.getStorageName(); } }, constants.nameStorage()); table.addColumn(new AbstractEntityModelEnumColumn<StorageDomain, StorageDomainType>() { @Override protected StorageDomainType getEnum(StorageDomain storage) { return storage.getStorageDomainType(); } }, constants.typeStorage()); table.addColumn(new AbstractEntityModelTextColumn<StorageDomain>() { @Override public String getText(StorageDomain storage) { if (storage.getAvailableDiskSize() == null || storage.getAvailableDiskSize() < 1) { return messages.gigabytes(\"< 1\"); } return messages.gigabytes(String.valueOf(storage.getAvailableDiskSize())); } }, constants.freeSpaceStorage()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@Override'\nThe code is: 'public String toString() <START> { <END> \/\/ @Override StringBuilder sb = new StringBuilder(\"ColumnarArray{\"); sb.append(\"positionCount=\").append(getPositionCount()).append(\",\"); sb.append(\"offsetsOffset=\").append(offsetsOffset).append(\",\"); sb.append(\"nullCheckBlock=\").append(nullCheckBlock.toString()).append(\",\"); sb.append(\"elementsBlock=\").append(elementsBlock.toString()).append(\",\"); sb.append('}'); return sb.toString(); }'","output":"public String toString() { StringBuilder sb = new StringBuilder(getClass().getSimpleName()).append(\"{\"); sb.append(\"positionCount=\").append(getPositionCount()).append(\",\"); sb.append(\"offsetsOffset=\").append(offsetsOffset).append(\",\"); sb.append(\"nullCheckBlock=\").append(nullCheckBlock.toString()).append(\",\"); sb.append(\"elementsBlock=\").append(elementsBlock.toString()).append(\",\"); sb.append('}'); return sb.toString(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catch checkArg()'\nThe code is: 'public ConstructQueryMetadata readConstructQueryMetadata(SnapshotBase tx, String nodeId) { Optional<NodeType> type = NodeType.fromNodeId(nodeId); try { <START> checkArgument(type.isPresent() && type.get() == NodeType.CONSTRUCT); <END> \/\/ catch checkArg() LOG.debug(\"Retrieving Metadata from Cache: {}\", nodeId); return (ConstructQueryMetadata) commonNodeMetadataCache.get(nodeId, new Callable<CommonNodeMetadata>() { @Override public CommonNodeMetadata call() throws Exception { LOG.debug(\"Seeking Metadata from Fluo Table: {}.\", nodeId); return dao.readConstructQueryMetadata(tx, nodeId); } }); } catch (Exception e) { throw new RuntimeException(\"Unable to access ConstructQueryMetadata for nodeId: \" + nodeId, e); } }'","output":"public ConstructQueryMetadata readConstructQueryMetadata(SnapshotBase tx, String nodeId) { checkNotNull(nodeId); checkNotNull(tx); Optional<NodeType> type = NodeType.fromNodeId(nodeId); checkArgument(type.isPresent() && type.get() == NodeType.CONSTRUCT); try { LOG.debug(\"Retrieving Metadata from Cache: {}\", nodeId); return (ConstructQueryMetadata) commonNodeMetadataCache.get(nodeId, () -> { LOG.debug(\"Seeking Metadata from Fluo Table: {}.\", nodeId); return dao.readConstructQueryMetadata(tx, nodeId); }); } catch (Exception e) { throw new RuntimeException(\"Unable to access ConstructQueryMetadata for nodeId: \" + nodeId, e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Remove this'\nThe code is: 'private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { <START> System.out.println(\"brokerRequest = \" + brokerRequest.toString()); <END> \/\/ Remove this BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }'","output":"private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs, RequestStatistics requestStatistics) throws IllegalStateException { BrokerResponseNative brokerResponse = new BrokerResponseNative(); List<String> columnNames = new ArrayList<>(); List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>(); List<Object> row = new ArrayList<>(); for (Expression e : brokerRequest.getPinotQuery().getSelectList()) { computeResultsForExpression(e, columnNames, columnTypes, row); } DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0])); List<Object[]> rows = new ArrayList<>(); rows.add(row.toArray()); ResultTable resultTable = new ResultTable(dataSchema, rows); brokerResponse.setResultTable(resultTable); long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs); brokerResponse.setTimeUsedMs(totalTimeMs); requestStatistics.setQueryProcessingTime(totalTimeMs); requestStatistics.setStatistics(brokerResponse); return brokerResponse; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this test pass year 2100'\nThe code is: 'public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date endDateEarlier = dateFormat.parse(\"2007-02-01 00:00:00\"); Date endDateLater = dateFormat.parse(\"2100-02-01 00:00:00\"); <START> <END> \/\/ this test pass year 2100 Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }'","output":"public void hasNoActiveMemberships_shouldReturnTrueIfNoneExists() throws Exception{ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, 1); Date endDateLater = calendar.getTime(); calendar.add(Calendar.DAY_OF_YEAR, -2); Date endDateEarlier = calendar.getTime(); Cohort cohort = new Cohort(3); CohortMembership temp = new CohortMembership(7); temp.setVoided(true); temp.setEndDate(endDateLater); cohort.addMembership(temp); temp = new CohortMembership(8); temp.setVoided(true); cohort.addMembership(temp); temp = new CohortMembership(9); temp.setEndDate(endDateEarlier); cohort.addMembership(temp); temp = new CohortMembership(10); temp.setVoided(true); cohort.addMembership(temp); assertTrue(cohort.hasNoActiveMemberships()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is array of SortFields null in it'\nThe code is: 'public SortableItem(JsonNode node,SortFieldInfo[] sortFields) { this.node=node; this.sortFields=sortFields; keyValues=new Object[sortFields.length]; for(int i=0;i<sortFields.length;i++) { <START> if (sortFields[i] != null) { <END> \/\/ is array of SortFields null in it JsonNode valueNode=JsonDoc.get(node,sortFields[i].getName()); keyValues[i]=sortFields[i].getField().getType().fromJson(valueNode); } } }'","output":"public SortableItem(JsonNode node,SortFieldInfo[] sortFields) { this.node=node; this.sortFields=sortFields; keyValues=new Object[sortFields.length]; for(int i=0;i<sortFields.length;i++) { JsonNode valueNode=JsonDoc.get(node,sortFields[i].getName()); keyValues[i]=sortFields[i].getField().getType().fromJson(valueNode); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Merge if statements'\nThe code is: 'public void placeNewMarketOrder(Market m, String symbol, int volume, double price, OrderType orderType) throws StockMarketExpection { Order order; if (orderType == OrderType.BUY) { if (price * volume > this.cashInHand) throw new StockMarketExpection(\"You don't have enough cash.\"); for(Order o: this.ordersPlaced) { if (o.getStockSymbol() == symbol) { throw new StockMarketExpection(\"You've already ordered this stock.\"); } } order = new BuyOrder(symbol, volume, true, this); ordersPlaced.add(order); } else { for(Order o: this.stocksOwned) { <START> if (o.getStockSymbol() == symbol) { if (o.getSize() < volume) <END> \/\/ Merge if statements throw new StockMarketExpection(\"You don't have enough stocks.\"); } } order = new SellOrder(symbol, volume, true, this); } m.addOrder(order); }'","output":"public void placeNewMarketOrder(Market m, String symbol, int volume, double price, OrderType orderType) throws StockMarketExpection { Order order; if (orderType == OrderType.BUY) { if (price * volume > this.cashInHand) throw new StockMarketExpection(\"You don't have enough cash.\"); for(Order o: this.ordersPlaced) { if (o.getStockSymbol() == symbol) { throw new StockMarketExpection(\"You've already ordered this stock.\"); } } order = new BuyOrder(symbol, volume, true, this); ordersPlaced.add(order); } else { for(Order o: this.stocksOwned) { if (o.getStockSymbol() == symbol && o.getSize() < volume) { throw new StockMarketExpection(\"You don't have enough stocks.\"); } } order = new SellOrder(symbol, volume, true, this); } m.addOrder(order); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'simpler get TmfTimestampFormat.getDefaulTimeFormat() set time zone UTC, in setUp method'\nThe code is: '<START> public void testToStringDefault() { <END> \/\/ simpler get TmfTimestampFormat.getDefaulTimeFormat() set time zone UTC, in setUp method DateFormat df = new SimpleDateFormat(\"HH:mm:ss.SSS\"); df.setTimeZone(TimeZone.getTimeZone(\"UTC\")); int timeOffset = TimeZone.getDefault().getOffset(0); Date d0 = new Date(0 + timeOffset); Date d1 = new Date(12345000L + timeOffset); Date d2 = new Date(1234500L + timeOffset); Date d3 = new Date(1234500000L + timeOffset); assertEquals(\"toString\", df.format(d0) + \" 000 000\", ts0.toString()); assertEquals(\"toString\", df.format(d1) + \" 000 000\", ts1.toString()); assertEquals(\"toString\", df.format(d2) + \" 000 000\", ts2.toString()); assertEquals(\"toString\", df.format(d3) + \" 000 000\", ts3.toString()); }'","output":"public void testToStringDefault() { DateFormat df = new SimpleDateFormat(\"HH:mm:ss.SSS\"); Date d0 = new Date(0); Date d1 = new Date(12345000L); Date d2 = new Date(1234500L); Date d3 = new Date(1234500000L); assertEquals(\"toString\", df.format(d0) + \" 000 000\", ts0.toString()); assertEquals(\"toString\", df.format(d1) + \" 000 000\", ts1.toString()); assertEquals(\"toString\", df.format(d2) + \" 000 000\", ts2.toString()); assertEquals(\"toString\", df.format(d3) + \" 000 000\", ts3.toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This business rule part of backend, of RESTAPI'\nThe code is: 'public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) { VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity); Version compatibilityVersion = Version.getLast(); if (!updated.isBlank()) { compatibilityVersion = lookupCluster(updated.getVdsGroupId()).getCompatibilityVersion(); <START> } <END> \/\/ This business rule part of backend, of RESTAPI updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), compatibilityVersion)); UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated); if (incoming.isSetRngDevice()) { params.setUpdateRngDevice(true); params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null)); } if(incoming.isSetSoundcardEnabled()) { params.setSoundDeviceEnabled(incoming.isSoundcardEnabled()); } IconHelper.setIconToParams(incoming, params); DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params); return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params); }'","output":"public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) { VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity); updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy())); UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated); if (incoming.isSetRngDevice()) { params.setUpdateRngDevice(true); params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null)); } if(incoming.isSetSoundcardEnabled()) { params.setSoundDeviceEnabled(incoming.isSoundcardEnabled()); } IconHelper.setIconToParams(incoming, params); DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params); return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this right. call kem.print() in FrontEnd.java execution ends. this done'\nThe code is: 'private void checkDefinition(Definition parsedDef) { CheckRHSVariables checkRHSVariables = new CheckRHSVariables(errors); stream(parsedDef.modules()).forEach(m -> stream(m.localSentences()).forEach(checkRHSVariables::check)); if (!errors.isEmpty()) { kem.addAllKException(errors.stream().map(e -> e.exception).collect(Collectors.toList())); <START> kem.print(); <END> \/\/ this right. call kem.print() in FrontEnd.java execution ends. this done throw KEMException.compilerError(\"Had \" + errors.size() + \" structural errors.\"); } }'","output":"private void checkDefinition(Definition parsedDef) { CheckRHSVariables checkRHSVariables = new CheckRHSVariables(errors); stream(parsedDef.modules()).forEach(m -> stream(m.localSentences()).forEach(checkRHSVariables::check)); if (!errors.isEmpty()) { kem.addAllKException(errors.stream().map(e -> e.exception).collect(Collectors.toList())); throw KEMException.compilerError(\"Had \" + errors.size() + \" structural errors.\"); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'if\/else block exact onError(), call here'\nThe code is: 'void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), \"The bufferSupplier returned a null Collection\"); p = ObjectHelper.requireNonNull(bufferClose.apply(token), \"The bufferClose returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); <START> if (errors.addThrowable(ex)) { <END> \/\/ if\/else block exact onError(), call here subscribers.dispose(); synchronized (this) { buffers = null; } done = true; drain(); } else { RxJavaPlugins.onError(ex); } return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }'","output":"void open(Open token) { Publisher<? extends Close> p; C buf; try { buf = ObjectHelper.requireNonNull(bufferSupplier.call(), \"The bufferSupplier returned a null Collection\"); p = ObjectHelper.requireNonNull(bufferClose.apply(token), \"The bufferClose returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); SubscriptionHelper.cancel(upstream); onError(ex); return; } long idx = index; index = idx + 1; synchronized (this) { Map<Long, C> bufs = buffers; if (bufs == null) { return; } bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'channel.close().sync()? Channel#close() is async returns a future'\nThe code is: 'public void shouldDecreaseIdleWhenClosedOutsidePool() throws Throwable { Channel channel = newChannel(); tracker.channelCreated( channel, null ); assertEquals( 1, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); <START> channel.close(); <END> \/\/ channel.close().sync()? Channel#close() is async returns a future assertEquals( 1, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); tracker.channelReleased( channel ); assertEquals( 0, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); }'","output":"public void shouldDecreaseIdleWhenClosedOutsidePool() throws Throwable { Channel channel = newChannel(); tracker.channelCreated( channel, null ); assertEquals( 1, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); channel.close().sync(); assertEquals( 1, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); tracker.channelReleased( channel ); assertEquals( 0, tracker.inUseChannelCount( address ) ); assertEquals( 0, tracker.idleChannelCount( address ) ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please {} placeholders'\nThe code is: 'public void batchDelete(List<Entitlement> entitlements) { for (Entitlement ent : entitlements) { <START> log.debug(\"Deleting entitlement: \" + ent); <END> \/\/ Please {} placeholders log.debug(\"certs.size = \" + ent.getCertificates().size()); for (EntitlementCertificate cert : ent.getCertificates()) { getEntityManager().remove(cert); } ent.getCertificates().clear(); getEntityManager().remove(ent); } for (Entitlement ent : entitlements) { ent.getCertificates().clear(); ent.getConsumer().getEntitlements().remove(ent); } }'","output":"public void batchDelete(List<Entitlement> entitlements) { for (Entitlement ent : entitlements) { log.debug(\"Deleting entitlement: {}\", ent); log.debug(\"certs.size = {}\", ent.getCertificates().size()); for (EntitlementCertificate cert : ent.getCertificates()) { getEntityManager().remove(cert); } ent.getCertificates().clear(); getEntityManager().remove(ent); } for (Entitlement ent : entitlements) { ent.getCertificates().clear(); ent.getConsumer().getEntitlements().remove(ent); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'chance more specific'\nThe code is: 'public static void createQueue(String projectId, String locationId, String queueId) <START> throws Exception { <END> \/\/ chance more specific try (CloudTasksClient client = CloudTasksClient.create()) { String parent = LocationName.of(projectId, locationId).toString(); String queuePath = QueueName.of(projectId, locationId, queueId).toString(); Queue queue = client.createQueue(parent, Queue.newBuilder().setName(queuePath).build()); System.out.println(\"Queue created: \" + queue.getName()); } }'","output":"public static void createQueue(String projectId, String locationId, String queueId) throws IOException { try (CloudTasksClient client = CloudTasksClient.create()) { String parent = LocationName.of(projectId, locationId).toString(); String queuePath = QueueName.of(projectId, locationId, queueId).toString(); Queue queue = client.createQueue(parent, Queue.newBuilder().setName(queuePath).build()); System.out.println(\"Queue created: \" + queue.getName()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '![CRITICAL](<LINK_1> 'Severity: CRITICAL') Refactor this method reduce Cognitive Complexity 16 15 allowed. [![rule](<LINK_2>](<LINK_0>'\nThe code is: '<START> protected File getFile(Class<?> type, String qualifier, String fileName, boolean createIfNotExist) throws IOException { <END> \/\/ ![CRITICAL](<LINK_1> 'Severity: CRITICAL') Refactor this method reduce Cognitive Complexity 16 15 allowed. [![rule](<LINK_2>](<LINK_0> final File path = new File(fileStorageDirectory + \"\/\" + type.getSimpleName().toLowerCase() + \"\/\" + qualifier + \"\/\"); final File file = new File(path, fileName); log.info(\"Looking up \" + file); if (path.exists()) { if (file.exists()) { if (file.canRead()) { log.info(\"OK\"); return file; } else { throw new IOException(\"Access denied. Please check file permissions.\"); } } else { if (createIfNotExist && file.createNewFile()) { log.info(\"OK\"); return file; } throw new IOException(\"No such file.\"); } } else { log.warn(\"MISO files directory doesn't seem to exist. Trying to create it...\"); if (path.mkdirs()) { log.warn(\"MISO files directory created.. retrying file listing...\"); return getFile(type, qualifier, fileName, createIfNotExist); } else { throw new IOException(\"Could not create MISO file directory (\" + path + \"). Please create this directory or allow the parent to be writable to MISO.\"); } } }'","output":"protected File getFile(Class<?> type, String qualifier, String fileName, boolean createIfNotExist) throws IOException { final File path = new File(fileStorageDirectory + \"\/\" + type.getSimpleName().toLowerCase() + \"\/\" + qualifier + \"\/\"); final File file = new File(path, fileName); log.info(\"Looking up {}\", file); if (path.exists()) { if (file.exists()) { if (file.canRead()) { log.info(\"OK\"); return file; } else { throw new IOException(\"Access denied. Please check file permissions.\"); } } else { if (createIfNotExist && file.createNewFile()) { log.info(\"OK\"); return file; } throw new IOException(\"No such file.\"); } } else { log.warn(\"MISO files directory doesn't seem to exist. Trying to create it...\"); if (path.mkdirs()) { log.warn(\"MISO files directory created.. retrying file listing...\"); return getFile(type, qualifier, fileName, createIfNotExist); } else { throw new IOException(\"Could not create MISO file directory (\" + path + \"). Please create this directory or allow the parent to be writable to MISO.\"); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'want remove legacy this name also'\nThe code is: 'private void configureMemoryPools(NodeMemoryConfig config, long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), \"Max query memory per node (%s) cannot be greater than the max query total memory per node (%s).\", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); long generalPoolSize = maxMemory.toBytes(); <START> if (config.isLegacyReservedPoolEnabled()) { <END> \/\/ want remove legacy this name also builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, \"general memory pool size is 0\"); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }'","output":"private void configureMemoryPools(NodeMemoryConfig config, long availableMemory) { validateHeapHeadroom(config, availableMemory); maxMemory = new DataSize(availableMemory - config.getHeapHeadroom().toBytes(), BYTE); checkArgument( config.getMaxQueryMemoryPerNode().toBytes() <= config.getMaxQueryTotalMemoryPerNode().toBytes(), \"Max query memory per node (%s) cannot be greater than the max query total memory per node (%s).\", QUERY_MAX_MEMORY_PER_NODE_CONFIG, QUERY_MAX_TOTAL_MEMORY_PER_NODE_CONFIG); ImmutableMap.Builder<MemoryPoolId, MemoryPool> builder = ImmutableMap.builder(); long generalPoolSize = maxMemory.toBytes(); if (config.isReservedPoolEnabled()) { builder.put(RESERVED_POOL, new MemoryPool(RESERVED_POOL, config.getMaxQueryTotalMemoryPerNode())); generalPoolSize -= config.getMaxQueryTotalMemoryPerNode().toBytes(); } verify(generalPoolSize > 0, \"general memory pool size is 0\"); builder.put(GENERAL_POOL, new MemoryPool(GENERAL_POOL, new DataSize(generalPoolSize, BYTE))); this.pools = builder.build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static'\nThe code is: 'private void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { int[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (int i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } <START> int[] filterResults = new int[qualifyingSet.getPositionCount()]; <END> \/\/ static PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); int numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }'","output":"private static void evaluateConstantFilterFunction(FilterFunction filter, Block[] constantBlocks, QualifyingSet qualifyingSet) { int[] channels = filter.getInputChannels(); Block[] inputs = new Block[channels.length]; for (int i = 0; i < channels.length; i++) { inputs[i] = constantBlocks[channels[i]]; } int[] filterResults = new int[qualifyingSet.getPositionCount()]; PageSourceOptions.ErrorSet errors = qualifyingSet.getOrCreateErrorSet(); int numHits = filter.filter(new Page(qualifyingSet.getPositionCount(), inputs), filterResults, errors); qualifyingSet.compactPositionsAndErrors(filterResults, numHits); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this System.out.println leftover debugging'\nThe code is: 'public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(\"tdb.lock\")))) { writer.write(Integer.toString(-1234)); writer.write('\\n'); } try { lock.canObtain(); Assert.fail(\"Expected the lock file to be considered invalid\"); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); <START> System.out.println(errMsg); <END> \/\/ Is this System.out.println leftover debugging Assert.assertTrue(errMsg.contains(\"appear to be for a TDB2 database\")); } }'","output":"public void location_lock_dir_error_03() throws IOException { Assume.assumeTrue(negativePidsTreatedAsAlive); Location dir = Location.create(tempDir.getRoot().getAbsolutePath()); LocationLock lock = dir.getLock(); Assert.assertTrue(lock.canLock()); Assert.assertFalse(lock.isLocked()); Assert.assertFalse(lock.isOwned()); Assert.assertTrue(lock.canObtain()); try (BufferedWriter writer = new BufferedWriter(new FileWriter(dir.getPath(\"tdb.lock\")))) { writer.write(Integer.toString(-1234)); writer.write('\\n'); } try { lock.canObtain(); Assert.fail(\"Expected the lock file to be considered invalid\"); } catch (FileException e) { String errMsg = e.getMessage(); Assert.assertNotNull(errMsg); Assert.assertTrue(errMsg.contains(\"appear to be for a TDB2 database\")); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I thinking more this, getTokens(HttpMessage) (with requestMessage) instead of making public. This allow method for JSON messages (and others, Content-Type) support is added'\nThe code is: '<START> public List<AntiCsrfToken> getTokens(String reqBody, String targetUrl) { <END> \/\/ I thinking more this, getTokens(HttpMessage) (with requestMessage) instead of making public. This allow method for JSON messages (and others, Content-Type) support is added List<AntiCsrfToken> tokens = new ArrayList<>(); Set<String> values; synchronized (valueToToken) { values = Collections.unmodifiableSet(new HashSet<String>(valueToToken.keySet())); } for (String value : values) { if (reqBody.indexOf(value) >= 0) { AntiCsrfToken token = valueToToken.get(value).clone(); token.setTargetURL(targetUrl); tokens.add(token); } } return tokens; }'","output":"private List<AntiCsrfToken> getTokens(String reqBody, String targetUrl) { List<AntiCsrfToken> tokens = new ArrayList<>(); Set<String> values; synchronized (valueToToken) { values = Collections.unmodifiableSet(new HashSet<String>(valueToToken.keySet())); } for (String value : values) { if (reqBody.indexOf(value) >= 0) { AntiCsrfToken token = valueToToken.get(value).clone(); token.setTargetURL(targetUrl); tokens.add(token); } } return tokens; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Add a check verify serialDataReceived method called'\nThe code is: 'public void testBroadcastSerialDataReceiveSubscribedRx64() throws Exception { Mockito.when(rx64Packet.getReceiveOptions()).thenReturn(RECEIVE_OPTIONS_BROADCAST); dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx64Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).broadcastSerialDataReceived(XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); <START> <END> \/\/ Add a check verify serialDataReceived method called assertEquals(XBEE_64BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }'","output":"public void testBroadcastSerialDataReceiveSubscribedRx64() throws Exception { Mockito.when(rx64Packet.getReceiveOptions()).thenReturn(RECEIVE_OPTIONS_BROADCAST); dataReader.addSerialDatatReceiveListener(receiveSerialDataListener); Whitebox.invokeMethod(dataReader, PACKET_RECEIVED_METHOD, rx64Packet); PowerMockito.verifyPrivate(dataReader, Mockito.times(1)).invoke(NOTIFY_SERIAL_DATA_RECEIVED_METHOD, XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES, IS_BROADCAST_DATA); Mockito.verify(receiveSerialDataListener, Mockito.times(1)).broadcastSerialDataReceived(XBEE_64BIT_ADDRESS.toString(), RECEIVED_DATA_BYTES); Mockito.verify(receiveSerialDataListener, Mockito.never()).serialDataReceived(Mockito.anyString(), (byte[])Mockito.any()); assertEquals(XBEE_64BIT_ADDRESS.toString(), receiveSerialDataListener.getAddress()); assertArrayEquals(RECEIVED_DATA_BYTES, receiveSerialDataListener.getSerialData()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Map type for declaration. diamond <> construction work. I suggest Map<String, String> requirementsValues = new LinkedHashMap<>();'\nThe code is: 'private SelectItem createTagsSelect() { SelectItem tagsCb = new SelectItem(); tagsCb.setTitle(\"<b>Dirac tag<\/b>\"); tagsCb.setType(\"comboBox\"); final AsyncCallback<List<String>> callback = new AsyncCallback<List<String>>() { @Override public void onFailure(Throwable caught) { Layout.getInstance().setWarningMessage(\"Unable to retrieve configurated list of requirements, setting it to None:<br \/>\" + caught.getMessage()); tagsCb.setValueMap(\"None\"); } @Override public void onSuccess(List<String> result) { if(!result.contains(\"None\")){ result.add(\"None\"); } <START> LinkedHashMap<String, String> requirementsValues = new LinkedHashMap<String, String>(); <END> \/\/ Map type for declaration. diamond <> construction work. I suggest Map<String, String> requirementsValues = new LinkedHashMap<>(); for (String requirement : result) { requirementsValues.put(requirement, requirement); } tagsCb.setValueMap(requirementsValues); } }; ApplicationImporterService.Util.getInstance().getApplicationImporterRequirements(callback); tagsCb.setValue(\"None\"); return tagsCb; }'","output":"private SelectItem createTagsSelect() { SelectItem tagsCb = new SelectItem(); tagsCb.setTitle(\"<b>Dirac tag<\/b>\"); tagsCb.setType(\"comboBox\"); final AsyncCallback<List<String>> callback = new AsyncCallback<List<String>>() { @Override public void onFailure(Throwable caught) { Layout.getInstance().setWarningMessage(\"Unable to retrieve configurated list of requirements, setting it to None:<br \/>\" + caught.getMessage()); tagsCb.setValueMap(\"None\"); } @Override public void onSuccess(List<String> result) { if(!result.contains(\"None\")){ result.add(\"None\"); } Map<String, String> requirementsValues = new LinkedHashMap<>(); for (String requirement : result) { requirementsValues.put(requirement, requirement); } tagsCb.setValueMap(requirementsValues); } }; ApplicationImporterService.Util.getInstance().getApplicationImporterRequirements(callback); tagsCb.setValue(\"None\"); return tagsCb; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'required, fine :P'\nThe code is: 'public void run() { Looper.prepare(); try { initRealm(); setLooper(Looper.myLooper()); base.evaluate(); Looper.loop(); } catch (Throwable t) { setAssertionError(t); setUnitTestFailed(); } finally { try { looperTearDown(); closeResources(); <START> if (!runAfterTestIsComplete.isEmpty()) { <END> \/\/ required, fine :P for (Runnable task : runAfterTestIsComplete) { task.run(); } } } catch (Throwable t) { setAssertionError(t); setUnitTestFailed(); } testComplete(); closeRealms(); signalClosedRealm.countDown(); } }'","output":"public void run() { Looper.prepare(); try { initRealm(); setLooper(Looper.myLooper()); base.evaluate(); Looper.loop(); } catch (Throwable t) { setAssertionError(t); setUnitTestFailed(); } finally { try { looperTearDown(); closeResources(); for (Runnable task : runAfterTestIsComplete) { task.run(); } } catch (Throwable t) { setAssertionError(t); setUnitTestFailed(); } testComplete(); closeRealms(); signalClosedRealm.countDown(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@tmjee is a big sense declaring one-time variable (especially names). inline put checkstyle suppression'\nThe code is: 'public void validatesXmlForSchemaValidity() throws Exception { <START> final int zero = 0; <END> \/\/ @tmjee is a big sense declaring one-time variable (especially names). inline put checkstyle suppression final int ten = 10; final int hundred = 100; final int fifty = 50; final Random rand = new SecureRandom(); final XSD xsd = new XSDDocument( StringUtils.join( \"<xs:schema xmlns:xs ='<LINK_0>' >\", \"<xs:element name='r'><xs:complexType>\", \"<xs:sequence>\", \"<xs:element name='x' type='xs:integer'\", \" minOccurs='0' maxOccurs='unbounded'\/>\", \"<\/xs:sequence><\/xs:complexType><\/xs:element>\", \"<\/xs:schema>\" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final int cnt = rand.nextInt(hundred); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( \"<r>\", StringUtils.repeat(\"<x>hey<\/x>\", cnt), \"<\/r>\" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (int count = zero; count < fifty; count = count + 1) { executorService.submit(callable); } executorService.awaitTermination(ten, TimeUnit.SECONDS); executorService.shutdown(); }'","output":"public void validatesXmlForSchemaValidity() throws Exception { final int timeout = 10; final int random = 100; final int loop = 50; final Random rand = new SecureRandom(); final XSD xsd = new XSDDocument( StringUtils.join( \"<xs:schema xmlns:xs ='<LINK_0>' >\", \"<xs:element name='r'><xs:complexType>\", \"<xs:sequence>\", \"<xs:element name='x' type='xs:integer'\", \" minOccurs='0' maxOccurs='unbounded'\/>\", \"<\/xs:sequence><\/xs:complexType><\/xs:element>\", \"<\/xs:schema>\" ) ); final Callable<Void> callable = new Callable<Void>() { @Override public Void call() throws Exception { final int cnt = rand.nextInt(random); MatcherAssert.assertThat( xsd.validate( new DOMSource( new XMLDocument( StringUtils.join( \"<r>\", StringUtils.repeat(\"<x>hey<\/x>\", cnt), \"<\/r>\" ) ).node() ) ), Matchers.hasSize(cnt << 1) ); return null; } }; final ExecutorService executorService = Executors.newFixedThreadPool(5); for (int count = 0; count < loop; count = count + 1) { executorService.submit(callable); } executorService.shutdown(); MatcherAssert.assertThat( executorService.awaitTermination(timeout, TimeUnit.SECONDS), Matchers.is(true) ); executorService.shutdownNow(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Please assertNull instead'\nThe code is: 'public void testGetUserSelectResolverNotSet() { MockEnabledModelResolver resolver1 = new MockEnabledModelResolver(); manager.add(resolver1, resolver1.getClass().getName() + \"1\", \"\", \"\"); MockEnabledModelResolver resolver2 = new MockEnabledModelResolver(); manager.add(resolver2, resolver2.getClass().getName() + \"2\", \"\", \"\"); MockEnabledModelResolver resolver3 = new MockEnabledModelResolver(); String resolver3Id = resolver3.getClass().getName() + \"3\"; manager.add(resolver3, resolver3Id, \"\", \"\"); <START> assertEquals(manager.getUserSelectedResolver(), null); <END> \/\/ Please assertNull instead }'","output":"public void testGetUserSelectResolverNotSet() { MockEnabledModelResolver resolver1 = new MockEnabledModelResolver(); manager.add(resolver1, resolver1.getClass().getName() + \"1\", \"\", \"\"); MockEnabledModelResolver resolver2 = new MockEnabledModelResolver(); manager.add(resolver2, resolver2.getClass().getName() + \"2\", \"\", \"\"); MockEnabledModelResolver resolver3 = new MockEnabledModelResolver(); String resolver3Id = resolver3.getClass().getName() + \"3\"; manager.add(resolver3, resolver3Id, \"\", \"\"); assertNull(manager.getUserSelectedResolver()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'true. remove it'\nThe code is: 'private ITmfTrace put(String path, String name, String typeID) throws TmfTraceException, TmfTraceImportException, InstantiationException, IllegalAccessException, CoreException { List<TraceTypeHelper> traceTypes = TmfTraceType.selectTraceType(path, typeID); if (traceTypes.isEmpty()) { return null; } IResource resource = getResource(path); if <START> (resource == null) { return null; } <END> \/\/ true. remove it TraceTypeHelper helper = traceTypes.get(0); ITmfTrace trace = helper.getTraceClass().newInstance(); trace.initTrace(resource, path, ITmfEvent.class, name, typeID); trace.indexTrace(false); TmfSignalManager.dispatchSignal(new TmfTraceOpenedSignal(this, trace, null)); return trace; }'","output":"private ITmfTrace put(String path, String name, String typeID) throws TmfTraceException, TmfTraceImportException, InstantiationException, IllegalAccessException, CoreException { List<TraceTypeHelper> traceTypes = TmfTraceType.selectTraceType(path, typeID); if (traceTypes.isEmpty()) { return null; } IResource resource = getResource(path); TraceTypeHelper helper = traceTypes.get(0); ITmfTrace trace = helper.getTraceClass().newInstance(); trace.initTrace(resource, path, ITmfEvent.class, name, typeID); trace.indexTrace(false); TmfSignalManager.dispatchSignal(new TmfTraceOpenedSignal(this, trace, null)); return trace; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'final . CacheStorageImpl cache -> CacheStorage'\nThe code is: 'public void deleteCacheStorageTest() { <START> CacheStorageImpl cache = new CacheStorageImpl(); <END> \/\/ final . CacheStorageImpl cache -> CacheStorage final Map<Identifier, OperatorState> queryState1= new HashMap<>(); queryState1.put(oid1, value1); cache.create(qid1, queryState1); Assert.assertEquals(value1, cache.read(qid1, oid1)); Assert.assertEquals(true, cache.delete(qid1)); Assert.assertSame(null, cache.read(qid1, oid1)); Assert.assertEquals(false, cache.delete(qid1)); Assert.assertEquals(false, cache.delete(qid2)); }'","output":"public void deleteCacheStorageTest() { final CacheStorage cache = new CacheStorageImpl(); final Map<Identifier, OperatorState> queryState1 = new HashMap<>(); queryState1.put(oid1, value1); cache.create(qid1, queryState1); Assert.assertEquals(value1, cache.read(qid1, oid1)); Assert.assertTrue(cache.delete(qid1)); Assert.assertSame(null, cache.read(qid1, oid1)); Assert.assertFalse(cache.delete(qid1)); Assert.assertFalse(cache.delete(qid2)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'remove explicit setting of purgeLessThanEqualTo'\nThe code is: 'public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(\"purgeLessThanEqualTo\", -2L, purgeLessThanEqualTo.longValue()); long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", -1, purgeLessThanEqualTo.longValue()); long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 8, purgeLessThanEqualTo.longValue()); <START> purgeLessThanEqualTo.setValue(-2); <END> \/\/ remove explicit setting of purgeLessThanEqualTo long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 9, purgeLessThanEqualTo.longValue()); Assert.assertEquals(\"time bucket\", -1, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 9, purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }'","output":"public void testTimeBucketKeyExpiry() { final MutableLong purgeLessThanEqualTo = new MutableLong(-2); testMeta.timeBucketAssigner.setExpireBefore(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setBucketSpan(Duration.standardSeconds(1)); testMeta.timeBucketAssigner.setPurgeListener(new TimeBucketAssigner.PurgeListener() { @Override public void purgeTimeBucketsLessThanEqualTo(long timeBucket) { purgeLessThanEqualTo.setValue(timeBucket); } }); long referenceTime = testMeta.timeBucketAssigner.getReferenceInstant().getMillis(); testMeta.timeBucketAssigner.setup(testMeta.mockManagedStateContext); Assert.assertEquals(\"purgeLessThanEqualTo\", -2L, purgeLessThanEqualTo.longValue()); long time0 = Duration.standardSeconds(0).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 1, testMeta.timeBucketAssigner.getTimeBucket(time0) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", -1, purgeLessThanEqualTo.longValue()); long time1 = Duration.standardSeconds(9).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 10, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 8, purgeLessThanEqualTo.longValue()); long time2 = Duration.standardSeconds(10).getMillis() + referenceTime; Assert.assertEquals(\"time bucket\", 11, testMeta.timeBucketAssigner.getTimeBucket(time2) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 9, purgeLessThanEqualTo.longValue()); Assert.assertEquals(\"time bucket\", -1, testMeta.timeBucketAssigner.getTimeBucket(time1) ); testMeta.timeBucketAssigner.endWindow(); Assert.assertEquals(\"purgeLessThanEqualTo\", 9, purgeLessThanEqualTo.longValue()); testMeta.timeBucketAssigner.teardown(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '<LINK_0>'\nThe code is: 'public Response createPolicy(@Context UriInfo info, @PathParam(\"tenant\") String tenant, @PathParam(\"subject\") String subject, String policy) { String id; try { <START> LOGGER.debug(\"Creating policy for tenant [\" + tenant + \"] and subject [\" + subject + \"]\"); <END> \/\/ <LINK_0> id = factory.create(Xml.toXml(policy)).getId().toString(); } catch (Exception e) { LOGGER.error(\"Cannot parse policy: \" + e.getMessage()); return Response.status(400).build(); } dao.createPolicy(new Policy(id, tenant, subject, policy)); return Response.created(info.getAbsolutePathBuilder().path(\"\/policy\/\" + id).build()).build(); }'","output":"public Response createPolicy(@Context UriInfo info, @PathParam(\"tenant\") String tenant, @PathParam(\"subject\") String subject, String policy) { String id; try { LOGGER.debug(\"Creating policy for tenant [{}] and subject [{}]\", tenant, subject); id = factory.create(Xml.toXml(policy)).getId().toString(); } catch (Exception e) { LOGGER.error(\"Cannot parse policy: \" + e.getMessage()); return Response.status(400).build(); } dao.createPolicy(new Policy(id, tenant, subject, policy)); return Response.created(info.getAbsolutePathBuilder().path(\"\/policy\/\" + id).build()).build(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Delete ____TS method name tells story'\nThe code is: 'public void testDeleteActionForTeamAsFeedbackParticipant() { prepareTestData(); <START> ______TS(\"Typical successful case when feedback participant is a team\"); <END> \/\/ Delete ____TS method name tells story FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(\"First Session\", \"idOfCourse1\", questionNumber); String giverEmail = \"Team 1.1<\/td><\/div>'\\\"\"; String receiverEmail = \"Team 2.1<\/td><\/div>'\\\"\"; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(\"comment1FromTeam1\"); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(\"response comment not found\", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(\"student1InCourse1\"); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, feedbackResponseComment.commentText + \" (Edited)\", }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals(\"\", result.getStatusMessage()); }'","output":"public void testDeleteActionForTeamAsFeedbackParticipant() { FeedbackQuestionsDb feedbackQuestionsDb = new FeedbackQuestionsDb(); int questionNumber = 4; FeedbackQuestionAttributes feedbackQuestion = feedbackQuestionsDb.getFeedbackQuestion(\"First Session\", \"idOfCourse1\", questionNumber); String giverEmail = \"Team 1.1<\/td><\/div>'\\\"\"; String receiverEmail = \"Team 2.1<\/td><\/div>'\\\"\"; FeedbackResponsesDb feedbackResponsesDb = new FeedbackResponsesDb(); FeedbackResponseAttributes feedbackResponse = feedbackResponsesDb.getFeedbackResponse(feedbackQuestion.getId(), giverEmail, receiverEmail); FeedbackResponseCommentAttributes feedbackResponseComment = dataBundle.feedbackResponseComments.get(\"comment1FromTeam1\"); FeedbackResponseCommentsDb feedbackResponseCommentsDb = new FeedbackResponseCommentsDb(); feedbackResponseComment = feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponse.getId(), feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt); assertNotNull(\"response comment not found\", feedbackResponseComment); StudentAttributes student = dataBundle.students.get(\"student1InCourse1\"); gaeSimulation.loginAsStudent(student.googleId); String[] submissionParams = new String[] { Const.ParamsNames.COURSE_ID, feedbackResponseComment.courseId, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackResponseComment.feedbackSessionName, Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseComment.feedbackResponseId, Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseComment.getId().toString(), }; AjaxResult result = getAjaxResult(getAction(submissionParams)); FeedbackResponseCommentAjaxPageData data = (FeedbackResponseCommentAjaxPageData) result.data; assertFalse(data.isError); assertNull(feedbackResponseCommentsDb.getFeedbackResponseComment(feedbackResponseComment.feedbackResponseId, feedbackResponseComment.commentGiver, feedbackResponseComment.createdAt)); assertEquals(\"\", result.getStatusMessage()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Component type for inactive device exception DOMAIN_TARIFF_SWITCHING here'\nThe code is: 'protected Device findActiveDevice(final String deviceIdentification) throws FunctionalException { Device device; try { device = this.deviceDomainService.searchActiveDevice(deviceIdentification); } catch (final UnregisteredDeviceException e) { throw new FunctionalException(FunctionalExceptionType.UNREGISTERED_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } catch (final InactiveDeviceException e) { <START> throw new FunctionalException(FunctionalExceptionType.INACTIVE_DEVICE, ComponentType.DOMAIN_CORE, e); <END> \/\/ Component type for inactive device exception DOMAIN_TARIFF_SWITCHING here } catch (final UnknownEntityException e) { throw new FunctionalException(FunctionalExceptionType.UNKNOWN_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } return device; }'","output":"protected Device findActiveDevice(final String deviceIdentification) throws FunctionalException { Device device; try { device = this.deviceDomainService.searchActiveDevice(deviceIdentification); } catch (final UnregisteredDeviceException e) { throw new FunctionalException(FunctionalExceptionType.UNREGISTERED_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } catch (final InactiveDeviceException e) { throw new FunctionalException(FunctionalExceptionType.INACTIVE_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } catch (final UnknownEntityException e) { throw new FunctionalException(FunctionalExceptionType.UNKNOWN_DEVICE, ComponentType.DOMAIN_TARIFF_SWITCHING, e); } return device; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'need this default in a test workspace services'\nThe code is: 'private void prepareDataDirectory(SystemTestData testData) throws Exception { Catalog catalog = getCatalog(); <START> catalog.setDefaultWorkspace(getCatalog().getWorkspaceByName(BASIC_POLYGONS.getPrefix())); <END> \/\/ need this default in a test workspace services testData.addWorkspace(TEST_WORKSPACE_NAME, TEST_WORKSPACE_URI, catalog); WorkspaceInfo wi = catalog.getWorkspaceByName(TEST_WORKSPACE_NAME); testData.addStyle( wi, WORKSPACED_STYLE_NAME, WORKSPACED_STYLE_FILE, this.getClass(), catalog); assertThat( catalog.getStyleByName(wi, WORKSPACED_STYLE_NAME), Matchers.describedAs( \"Style %0 should be in workspace %1.\", (not(nullValue())), WORKSPACED_STYLE_NAME, TEST_WORKSPACE_NAME)); Map<LayerProperty, Object> props = new HashMap<>(); props.put(LayerProperty.STYLE, WORKSPACED_STYLE_NAME); testData.addVectorLayer(WORKSPACED_LAYER_QNAME, props, this.getClass(), catalog); LayerInfo li = catalog.getLayerByName(getLayerId(WORKSPACED_LAYER_QNAME)); li.setDefaultStyle(catalog.getStyleByName(wi, WORKSPACED_STYLE_NAME)); catalog.save(li); createLayerGroup(SIMPLE_LAYER_GROUP, MockData.BUILDINGS, MockData.BRIDGES); GWC.get().getConfig().setDirectWMSIntegrationEnabled(false); props = new HashMap<>(); props.put(LayerProperty.SRS, \"4326\"); props.put(LayerProperty.PROJECTION_POLICY, ProjectionPolicy.FORCE_DECLARED); testData.addVectorLayer( BASIC_POLYGONS_NO_CRS, null, \"BasicPolygonsNoCrs.properties\", this.getClass(), catalog); testData.addStyle(\"stylegroup\", \"stylegroup.sld\", GWCIntegrationTest.class, catalog); final LayerGroupInfo group = catalog.getFactory().createLayerGroup(); group.getLayers().add(null); group.getStyles().add(catalog.getStyleByName(\"stylegroup\")); group.setName(\"stylegroup\"); new LayerGroupHelper(group).calculateBounds(); catalog.add(group); HttpRequestRecorderCallback.reset(); }'","output":"private void prepareDataDirectory(SystemTestData testData) throws Exception { Catalog catalog = getCatalog(); testData.addWorkspace(TEST_WORKSPACE_NAME, TEST_WORKSPACE_URI, catalog); WorkspaceInfo wi = catalog.getWorkspaceByName(TEST_WORKSPACE_NAME); testData.addStyle( wi, WORKSPACED_STYLE_NAME, WORKSPACED_STYLE_FILE, this.getClass(), catalog); assertThat( catalog.getStyleByName(wi, WORKSPACED_STYLE_NAME), Matchers.describedAs( \"Style %0 should be in workspace %1.\", (not(nullValue())), WORKSPACED_STYLE_NAME, TEST_WORKSPACE_NAME)); Map<LayerProperty, Object> props = new HashMap<>(); props.put(LayerProperty.STYLE, WORKSPACED_STYLE_NAME); testData.addVectorLayer(WORKSPACED_LAYER_QNAME, props, this.getClass(), catalog); LayerInfo li = catalog.getLayerByName(getLayerId(WORKSPACED_LAYER_QNAME)); li.setDefaultStyle(catalog.getStyleByName(wi, WORKSPACED_STYLE_NAME)); catalog.save(li); createLayerGroup(SIMPLE_LAYER_GROUP, MockData.BUILDINGS, MockData.BRIDGES); GWC.get().getConfig().setDirectWMSIntegrationEnabled(false); props = new HashMap<>(); props.put(LayerProperty.SRS, \"4326\"); props.put(LayerProperty.PROJECTION_POLICY, ProjectionPolicy.FORCE_DECLARED); testData.addVectorLayer( BASIC_POLYGONS_NO_CRS, null, \"BasicPolygonsNoCrs.properties\", this.getClass(), catalog); testData.addStyle(\"stylegroup\", \"stylegroup.sld\", GWCIntegrationTest.class, catalog); final LayerGroupInfo group = catalog.getFactory().createLayerGroup(); group.getLayers().add(null); group.getStyles().add(catalog.getStyleByName(\"stylegroup\")); group.setName(\"stylegroup\"); new LayerGroupHelper(group).calculateBounds(); catalog.add(group); HttpRequestRecorderCallback.reset(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'method declare \"throws URISyntaxException, IOException\" extra try\/catch\/log removed'\nThe code is: 'private void configureGerrit(Repository repository) { StoredConfig config = repository.getConfig(); RemoteConfig remoteConfig; try { remoteConfig = GerritUtil.findRemoteConfig(config, remoteName); if (remoteConfig == null) { return; } GerritUtil.configurePushURI(remoteConfig, new URIish(uri)); GerritUtil.configurePushRefSpec(remoteConfig, Constants.MASTER); GerritUtil.configureFetchNotes(remoteConfig); GerritUtil.setCreateChangeId(config); remoteConfig.update(config); config.save(); <START> } catch (Exception e) { <END> \/\/ method declare \"throws URISyntaxException, IOException\" extra try\/catch\/log removed Activator.logError(e.getMessage(), e); } }'","output":"private void configureGerrit(Repository repository) throws URISyntaxException, IOException { StoredConfig config = repository.getConfig(); RemoteConfig remoteConfig; remoteConfig = GerritUtil.findRemoteConfig(config, remoteName); if (remoteConfig == null) { return; } GerritUtil.configurePushURI(remoteConfig, new URIish(uri)); GerritUtil.configurePushRefSpec(remoteConfig, Constants.MASTER); GerritUtil.configureFetchNotes(remoteConfig); GerritUtil.setCreateChangeId(config); remoteConfig.update(config); config.save(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This line removed. pass I guess this is covered test, write a quick John'\nThe code is: 'public boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); <START> left = leftRS.next(); <END> \/\/ This line removed. pass I guess this is covered test, write a quick John currentRightIterator = rightsForLeft(left); boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }'","output":"public boolean internalHasNext() { try { while (leftRS.hasNext()) { if (left == null) left = leftRS.next().getClone(); else left.transfer(leftRS.next()); currentRightIterator = rightsForLeft(left); boolean returnedRows = false; while (currentRightIterator.hasNext()) { currentExecRow = mergeRows(left, currentRightIterator.next()); if (mergeJoinOperation.getRestriction().apply(currentExecRow)) { returnedRows = true; break; } operationContext.recordFilter(); } if (!returnedRows) { currentExecRow = mergeRows(left, null); return true; } } return false; } catch (Exception e) { throw new RuntimeException(e); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'do copy, view change calls method'\nThe code is: 'private Map<Client, PaxosLong> unsafeGetLatest(Set<Client> clients) { if (cacheKey == null) { processDigest(delegate.latestSequencesPreparedOrAccepted(Optional.empty(), clients)); <START> return Collections.unmodifiableMap(cachedEntries); END> } Set<Client> newClients = Sets.difference(clients, cachedEntries.keySet()); if (newClients.isEmpty()) { delegate.latestSequencesPreparedOrAcceptedCached(cacheKey).ifPresent(this::processDigest); return Collections.unmodifiableMap(cachedEntries); } else { processDigest(delegate.latestSequencesPreparedOrAccepted(Optional.of(cacheKey), newClients)); return Collections.unmodifiableMap(cachedEntries); } }'","output":"private Map<Client, PaxosLong> unsafeGetLatest(Set<Client> clients) { if (cacheKey == null) { processDigest(delegate.latestSequencesPreparedOrAccepted(Optional.empty(), clients)); return ImmutableMap.copyOf(cachedEntries); } Set<Client> newClients = Sets.difference(clients, cachedEntries.keySet()); if (newClients.isEmpty()) { delegate.latestSequencesPreparedOrAcceptedCached(cacheKey).ifPresent(this::processDigest); return ImmutableMap.copyOf(cachedEntries); } else { processDigest(delegate.latestSequencesPreparedOrAccepted(Optional.of(cacheKey), newClients)); return ImmutableMap.copyOf(cachedEntries); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: Fix indentation. Also, is this change for'\nThe code is: 'public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public int getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public int getPriority() { return 0; } @Override public int getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } <START> @Override <END> \/\/ nit: Fix indentation. Also, is this change for public MetricRegistry getMetricRegistryForRegionServer() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }'","output":"public void setUp() throws Exception { MockitoAnnotations.initMocks(this); configuration = new Configuration(); RegionCoprocessorEnvironment environment = new CompatRegionCoprocessorEnvironment() { @Override public int getVersion() { return 0; } @Override public String getHBaseVersion() { return null; } @Override public Coprocessor getInstance() { return null; } @Override public int getPriority() { return 0; } @Override public int getLoadSequence() { return 0; } @Override public Configuration getConfiguration() { return configuration; } @Override public HTableInterface getTable( TableName tableName) throws IOException { return null; } @Override public HTableInterface getTable(TableName tableName, ExecutorService service) throws IOException { return null; } @Override public ClassLoader getClassLoader() { return null; } @Override public Region getRegion() { return region; } @Override public HRegionInfo getRegionInfo() { return regionInfo; } @Override public RegionServerServices getRegionServerServices() { return null; } @Override public ConcurrentMap<String, Object> getSharedData() { return null; } }; taskMetaDataEndpoint = new TaskMetaDataEndpoint(); taskMetaDataEndpoint.start(environment); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Predicates.equal'\nThe code is: 'public Predicate visit(BetweenPredicate predicate, Indexes indexes) { TypeConverter converter = indexes.getConverter(predicate.attributeName); if (converter == null) { return predicate; } Comparable from = converter.convert(predicate.from); Comparable to = converter.convert(predicate.to); Order order = compare(from, to); switch (order) { case LESS: return predicate; case EQUAL: <START> return new EqualPredicate(predicate.attributeName, from); <END> \/\/ Predicates.equal case GREATER: return Predicates.alwaysFalse(); default: throw new IllegalStateException(\"Unexpected order: \" + order); } }'","output":"public Predicate visit(BetweenPredicate predicate, Indexes indexes) { TypeConverter converter = indexes.getConverter(predicate.attributeName); if (converter == null) { return predicate; } Comparable from = converter.convert(predicate.from); Comparable to = converter.convert(predicate.to); Order order = compare(from, to); switch (order) { case LESS: return predicate; case EQUAL: return Predicates.equal(predicate.attributeName, from); case GREATER: return Predicates.alwaysFalse(); default: throw new IllegalStateException(\"Unexpected order: \" + order); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Collection.emptyList() instead is type safe. unit tests cover handle empty list properly'\nThe code is: 'private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) { Map<Guid, List<Guid>> hostCount = new HashMap<>(); for (Guid vm : affinityGroup.getEntityIds()) { Guid host = vmToHost.get(vm); if (host == null) { continue; } if (hostCount.containsKey(host)) { hostCount.get(host).add(vm); } else { hostCount.put(host, new ArrayList<>()); hostCount.get(host).add(vm); } } Guid host = chooseCandidateHostForMigration(hostCount); if (host == null) { <START> return Collections.EMPTY_LIST; <END> \/\/ Collection.emptyList() instead is type safe. unit tests cover handle empty list properly } return hostCount.get(host); }'","output":"private List<Guid> findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) { Map<Guid, List<Guid>> hostCount = new HashMap<>(); for (Guid vm : affinityGroup.getEntityIds()) { Guid host = vmToHost.get(vm); if (host == null) { continue; } if (hostCount.containsKey(host)) { hostCount.get(host).add(vm); } else { hostCount.put(host, new ArrayList<>()); hostCount.get(host).add(vm); } } Guid host = chooseCandidateHostForMigration(hostCount); if (host == null) { return Collections.emptyList(); } return hostCount.get(host); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'prefer isEmpty test emptyness :)'\nThe code is: 'public List<Client> find(final Clients clients, final WebContext context, final String clientNames) { final List<Client> result = new ArrayList<>(); for (final Client client : clients.findAllClients()) { if (client instanceof IndirectClient) { final IndirectClient indirectClient = (IndirectClient) client; indirectClient.init(); if (indirectClient.getCallbackUrlResolver().matches(indirectClient.getName(), context)) { result.add(indirectClient); } } } <START> if (result.size() == 0 && CommonHelper.isNotBlank(clientNames)) { <END> \/\/ prefer isEmpty test emptyness :) result.add(clients.findClient(clientNames)); } return result; }'","output":"public List<Client> find(final Clients clients, final WebContext context, final String clientNames) { final List<Client> result = new ArrayList<>(); for (final Client client : clients.findAllClients()) { if (client instanceof IndirectClient) { final IndirectClient indirectClient = (IndirectClient) client; indirectClient.init(); if (indirectClient.getCallbackUrlResolver().matches(indirectClient.getName(), context)) { result.add(indirectClient); } } } if (result.isEmpty() && CommonHelper.isNotBlank(clientNames)) { result.add(clients.findClient(clientNames)); } return result; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'class is named EchoApi ECHOApi. This code compile'\nThe code is: 'public static void main(String[] args) { final String key = \"your key\"; final String secret = \"your secret\"; Token token = new Token(\"\", \"\"); <START> OAuthService service = new ServiceBuilder().apiKey(key).apiSecret(secret).provider(ECHOApi.class).build(); <END> \/\/ class is named EchoApi ECHOApi. This code compile System.out.println(\"Now we're going to access a protected resource...\"); OAuthRequest request = new OAuthRequest(Verb.POST, PROTECTED_RESOURCE_URL); request.addBodyParameter(\"content\", \"your valid activity streams xml\"); service.signRequest(token, request); Response response = request.send(); System.out.println(); System.out.println(response.getCode()); System.out.println(response.getBody()); System.out.println(); System.out.println(\"Thats it man! Go and build something awesome with Scribe! :)\"); }'","output":"public static void main(String[] args) { final String key = \"your key\"; final String secret = \"your secret\"; Token token = new Token(\"\", \"\"); OAuthService service = new ServiceBuilder().apiKey(key).apiSecret(secret).provider(EchoApi.class).build(); System.out.println(\"Now we're going to access a protected resource...\"); OAuthRequest request = new OAuthRequest(Verb.POST, PROTECTED_RESOURCE_URL); request.addBodyParameter(\"content\", \"your valid activity streams xml\"); service.signRequest(token, request); Response response = request.send(); System.out.println(); System.out.println(response.getCode()); System.out.println(response.getBody()); System.out.println(); System.out.println(\"Thats it man! Go and build something awesome with Scribe! :)\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@unyoungwax, able this private too'\nThe code is: '<START> public void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes, boolean hasResponseRateUpdate) <END> \/\/ @unyoungwax, able this private too throws InvalidParametersException, EntityDoesNotExistException { FeedbackQuestionAttributes oldQuestion = null; if (newAttributes.getId() == null) { oldQuestion = fqDb.getFeedbackQuestion(newAttributes.feedbackSessionName, newAttributes.courseId, newAttributes.questionNumber); } else { oldQuestion = fqDb.getFeedbackQuestion(newAttributes.getId()); } if (oldQuestion == null) { throw new EntityDoesNotExistException( \"Trying to update a feedback question that does not exist.\"); } if(oldQuestion.isChangesRequiresResponseDeletion(newAttributes)) { frLogic.deleteFeedbackResponsesForQuestionAndCascade(oldQuestion.getId(), hasResponseRateUpdate); } oldQuestion.updateValues(newAttributes); newAttributes.removeIrrelevantVisibilityOptions(); fqDb.updateFeedbackQuestion(newAttributes); }'","output":"private void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes, boolean hasResponseRateUpdate) throws InvalidParametersException, EntityDoesNotExistException { FeedbackQuestionAttributes oldQuestion = null; if (newAttributes.getId() == null) { oldQuestion = fqDb.getFeedbackQuestion(newAttributes.feedbackSessionName, newAttributes.courseId, newAttributes.questionNumber); } else { oldQuestion = fqDb.getFeedbackQuestion(newAttributes.getId()); } if (oldQuestion == null) { throw new EntityDoesNotExistException( \"Trying to update a feedback question that does not exist.\"); } if(oldQuestion.isChangesRequiresResponseDeletion(newAttributes)) { frLogic.deleteFeedbackResponsesForQuestionAndCascade(oldQuestion.getId(), hasResponseRateUpdate); } oldQuestion.updateValues(newAttributes); newAttributes.removeIrrelevantVisibilityOptions(); fqDb.updateFeedbackQuestion(newAttributes); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Is this for testing? want some logging library'\nThe code is: 'public static WSResponse startJob(String conf_id, String url) { Configuration runConfig = getConfigurationFromDb(conf_id); Evaluator newEval = getEvaluator(runConfig); List<TextAnnotation> instances = getInstancesFromDb(runConfig); LearnerInterface learner = new LearnerInterface(url); String jsonInfo = learner.getInfo(); <START> System.out.println(jsonInfo); <END> \/\/ Is this for testing? want some logging library if(jsonInfo.equals(\"err\")) return null; instances = cleanseInstances(instances, jsonInfo); Job newJob = new Job(learner, instances); WSResponse solverResponse = newJob.sendAndReceiveRequestsFromSolver(); Evaluation eval = newJob.evaluateSolver(); return solverResponse; }'","output":"public static WSResponse startJob(String conf_id, String url) { Configuration runConfig = getConfigurationFromDb(conf_id); Evaluator newEval = getEvaluator(runConfig); List<TextAnnotation> instances = getInstancesFromDb(runConfig); LearnerInterface learner = new LearnerInterface(url); String jsonInfo = learner.getInfo(); if(jsonInfo.equals(\"err\")) return null; instances = cleanseInstances(instances, jsonInfo); Job newJob = new Job(learner, instances); WSResponse solverResponse = newJob.sendAndReceiveRequestsFromSolver(); Evaluation eval = newJob.evaluateSolver(); return solverResponse; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'important all, return jobDate.after(searchedTimestamp) directly'\nThe code is: 'public boolean isEligibleJob(final String timestamp, final String name) { final Date searchedTimestamp; if (timestamp == null || Long.valueOf(timestamp) < 0) { return true; } else { searchedTimestamp = new Date(Long.valueOf(timestamp)); } final String timestampString = name.substring(name.lastIndexOf(\"-\") + 1, name.indexOf(\".\")); final Date jobDate = new Date(Long.valueOf(timestampString)); <START> if (jobDate.after(searchedTimestamp)) { <END> \/\/ important all, return jobDate.after(searchedTimestamp) directly return true; } return false; }'","output":"public boolean isEligibleJob(final String timestamp, final String name) { final Date searchedTimestamp; if (timestamp == null || Long.valueOf(timestamp) < 0) { return true; } else { searchedTimestamp = new Date(Long.valueOf(timestamp)); } final String timestampString = name.substring(name.lastIndexOf(\"-\") + 1, name.indexOf(\".\")); final Date jobDate = new Date(Long.valueOf(timestampString)); return jobDate.after(searchedTimestamp); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'ProtocolAdapterException is thrown in method. removed'\nThe code is: '<START> public SmsDetails getSmsDetails(final DlmsDeviceMessageMetadata messageMetadata, final SmsDetails smsDetailsRequest) <END> \/\/ ProtocolAdapterException is thrown in method. removed throws OsgpException, ProtocolAdapterException { final DlmsDevice device = this.domainHelperService.findDlmsDevice(messageMetadata); final GetSMSDetailsResponse response = this.smsClient.getSMSDetails(smsDetailsRequest.getSmsMsgId(), device.getIccId()); SmsDetails smsDetailsResponse = null; final List<SmsMessageType> smsMessagesTypes = response.getSmsMessages().getSmsMessage(); for (final SmsMessageType smsMessageType : smsMessagesTypes) { if (smsMessageType.getSmsMsgId() == smsDetailsRequest.getSmsMsgId().longValue()) { smsDetailsResponse = new SmsDetails(device.getDeviceIdentification(), smsMessageType.getSmsMsgId(), smsMessageType.getStatus(), smsMessageType.getSmsMsgAttemptStatus(), smsMessageType.getMsgType()); } } return smsDetailsResponse; }'","output":"public SmsDetails getSmsDetails(final DlmsDeviceMessageMetadata messageMetadata, final SmsDetails smsDetailsRequest) throws OsgpException { final DlmsDevice device = this.domainHelperService.findDlmsDevice(messageMetadata); final GetSMSDetailsResponse response = this.smsClient.getSMSDetails(smsDetailsRequest.getSmsMsgId(), device.getIccId()); SmsDetails smsDetailsResponse = null; final List<SmsMessageType> smsMessagesTypes = response.getSmsMessages().getSmsMessage(); for (final SmsMessageType smsMessageType : smsMessagesTypes) { if (smsMessageType.getSmsMsgId() == smsDetailsRequest.getSmsMsgId().longValue()) { smsDetailsResponse = new SmsDetails(device.getDeviceIdentification(), smsMessageType.getSmsMsgId(), smsMessageType.getStatus(), smsMessageType.getSmsMsgAttemptStatus(), smsMessageType.getMsgType()); } } return smsDetailsResponse; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'catch Throwable. change this Exception'\nThe code is: 'public List<Future<Boolean>> primeConnectionsAsync(final List<Server> servers, final PrimeConnectionListener listener) { if (servers == null) { return Collections.emptyList(); } List<Server> allServers = new ArrayList<Server>(); allServers.addAll(servers); if (allServers.size() == 0){ logger.debug(\"RestClient:\" + name + \". No nodes\/servers to prime connections\"); return Collections.emptyList(); } logger.info(\"Priming Connections for RestClient:\" + name + \", numServers:\" + allServers.size()); List<Future<Boolean>> ftList = new ArrayList<Future<Boolean>>(); for (Server s : allServers) { s.setReadyToServe(false); if (aSync) { Future<Boolean> ftC = null; try { ftC = makeConnectionASync(s, listener); ftList.add(ftC); } catch (RejectedExecutionException ree) { logger.error(\"executor submit failed\", ree); } <START> catch (Throwable e) { <END> \/\/ catch Throwable. change this Exception logger.error(\"general error\", e); } } else { connectToServer(s, listener); } } return ftList; }'","output":"public List<Future<Boolean>> primeConnectionsAsync(final List<Server> servers, final PrimeConnectionListener listener) { if (servers == null) { return Collections.emptyList(); } List<Server> allServers = new ArrayList<Server>(); allServers.addAll(servers); if (allServers.size() == 0){ logger.debug(\"RestClient:\" + name + \". No nodes\/servers to prime connections\"); return Collections.emptyList(); } logger.info(\"Priming Connections for RestClient:\" + name + \", numServers:\" + allServers.size()); List<Future<Boolean>> ftList = new ArrayList<Future<Boolean>>(); for (Server s : allServers) { s.setReadyToServe(false); if (aSync) { Future<Boolean> ftC = null; try { ftC = makeConnectionASync(s, listener); ftList.add(ftC); } catch (RejectedExecutionException ree) { logger.error(\"executor submit failed\", ree); } catch (Exception e) { logger.error(\"general error\", e); } } else { connectToServer(s, listener); } } return ftList; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is null check required turn equals call'\nThe code is: 'public void onLightStateChanged(@Nullable HueBridge bridge, FullLight fullLight) { logger.trace(\"onLightStateChanged() was called\"); if (!fullLight.getId().equals(lightId)) { logger.trace(\"Received state change for another handler's light ({}). Will be ignored.\", fullLight.getId()); return; } initializeProperties(); lastSentColorTemp = null; lastSentBrightness = null; if (fullLight.getState().isReachable()) { updateStatus(ThingStatus.ONLINE); } else { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"@text\/offline.light-not-reachable\"); } HSBType hsbType = LightStateConverter.toHSBType(fullLight.getState()); if (!fullLight.getState().isOn()) { hsbType = new HSBType(hsbType.getHue(), hsbType.getSaturation(), new PercentType(0)); } updateState(CHANNEL_COLOR, hsbType); ColorMode colorMode = fullLight.getState().getColorMode(); <START> if (colorMode != null && ColorMode.CT.equals(colorMode)) { <END> \/\/ is null check required turn equals call PercentType colorTempPercentType = LightStateConverter.toColorTemperaturePercentType(fullLight.getState()); updateState(CHANNEL_COLORTEMPERATURE, colorTempPercentType); } else { updateState(CHANNEL_COLORTEMPERATURE, UnDefType.NULL); } PercentType brightnessPercentType = LightStateConverter.toBrightnessPercentType(fullLight.getState()); if (!fullLight.getState().isOn()) { brightnessPercentType = new PercentType(0); } updateState(CHANNEL_BRIGHTNESS, brightnessPercentType); if (fullLight.getState().isOn()) { updateState(CHANNEL_SWITCH, OnOffType.ON); } else { updateState(CHANNEL_SWITCH, OnOffType.OFF); } StringType stringType = LightStateConverter.toAlertStringType(fullLight.getState()); if (!stringType.toString().equals(\"NULL\")) { updateState(CHANNEL_ALERT, stringType); scheduleAlertStateRestore(stringType); } }'","output":"public void onLightStateChanged(@Nullable HueBridge bridge, FullLight fullLight) { logger.trace(\"onLightStateChanged() was called\"); if (!fullLight.getId().equals(lightId)) { logger.trace(\"Received state change for another handler's light ({}). Will be ignored.\", fullLight.getId()); return; } initializeProperties(); lastSentColorTemp = null; lastSentBrightness = null; if (fullLight.getState().isReachable()) { updateStatus(ThingStatus.ONLINE); } else { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"@text\/offline.light-not-reachable\"); } HSBType hsbType = LightStateConverter.toHSBType(fullLight.getState()); if (!fullLight.getState().isOn()) { hsbType = new HSBType(hsbType.getHue(), hsbType.getSaturation(), new PercentType(0)); } updateState(CHANNEL_COLOR, hsbType); ColorMode colorMode = fullLight.getState().getColorMode(); if (ColorMode.CT.equals(colorMode)) { PercentType colorTempPercentType = LightStateConverter.toColorTemperaturePercentType(fullLight.getState()); updateState(CHANNEL_COLORTEMPERATURE, colorTempPercentType); } else { updateState(CHANNEL_COLORTEMPERATURE, UnDefType.NULL); } PercentType brightnessPercentType = LightStateConverter.toBrightnessPercentType(fullLight.getState()); if (!fullLight.getState().isOn()) { brightnessPercentType = new PercentType(0); } updateState(CHANNEL_BRIGHTNESS, brightnessPercentType); if (fullLight.getState().isOn()) { updateState(CHANNEL_SWITCH, OnOffType.ON); } else { updateState(CHANNEL_SWITCH, OnOffType.OFF); } StringType stringType = LightStateConverter.toAlertStringType(fullLight.getState()); if (!stringType.toString().equals(\"NULL\")) { updateState(CHANNEL_ALERT, stringType); scheduleAlertStateRestore(stringType); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'is totalPartitionIds needed? partitionToReplicaMap.keySet() iterate partitions? If need map do java partitionToReplicaMap = replicaIds.stream().collect(Collectors.toMap(ReplicaId::getPartitionId, Function.identity()));'\nThe code is: 'StatsManager(StorageManager storageManager, List<? extends ReplicaId> replicaIds, MetricRegistry registry, StatsManagerConfig config, Time time) throws IOException { this.storageManager = storageManager; statsOutputFile = new File(config.outputFilePath); publishPeriodInSecs = config.publishPeriodInSecs; initialDelayInSecs = config.initialDelayUpperBoundInSecs; metrics = new StatsManagerMetrics(registry); mapper.setVisibilityChecker(mapper.getVisibilityChecker().withFieldVisibility(JsonAutoDetect.Visibility.ANY)); totalPartitionIds = new ArrayList<>(); partitionToReplicaMap = new HashMap<>(); PartitionId partitionId; for (ReplicaId replicaId : replicaIds) { partitionId = replicaId.getPartitionId(); totalPartitionIds.add(partitionId); <START> partitionToReplicaMap.put(partitionId, replicaId); <END> \/\/ is totalPartitionIds needed? partitionToReplicaMap.keySet() iterate partitions? If need map do java partitionToReplicaMap = replicaIds.stream().collect(Collectors.toMap(ReplicaId::getPartitionId, Function.identity())); } this.time = time; }'","output":"StatsManager(StorageManager storageManager, List<? extends ReplicaId> replicaIds, MetricRegistry registry, StatsManagerConfig config, Time time) throws IOException { this.storageManager = storageManager; statsOutputFile = new File(config.outputFilePath); publishPeriodInSecs = config.publishPeriodInSecs; initialDelayInSecs = config.initialDelayUpperBoundInSecs; metrics = new StatsManagerMetrics(registry); partitionToReplicaMap = replicaIds.stream().collect(Collectors.toMap(ReplicaId::getPartitionId, Function.identity())); this.time = time; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '@merciesa matter of taste, i-- instead of i -= 1'\nThe code is: 'public final void visitNewClass(NewClassTree tree) { scan(tree.arguments()); SymbolicValue newValue = createSymbolicInstanceValue(); for (ExecutionState executionState : currentStates) { SymbolicValue[] arguments = new SymbolicValue[tree.arguments().size()]; <START> for (int i = arguments.length - 1; i >= 0; i -= 1) { <END> \/\/ @merciesa matter of taste, i-- instead of i -= 1 arguments[i] = executionState.pop(); } executionState.push(newValue); check.onExecutableElementInvocation(executionState, tree, Arrays.asList(arguments)); } }'","output":"public final void visitNewClass(NewClassTree tree) { scan(tree.arguments()); SymbolicValue newValue = createSymbolicInstanceValue(); for (ExecutionState executionState : currentStates) { SymbolicValue[] arguments = new SymbolicValue[tree.arguments().size()]; for (int i = arguments.length - 1; i >= 0; i--) { arguments[i] = executionState.pop(); } executionState.push(newValue); check.onExecutableElementInvocation(executionState, tree, Arrays.asList(arguments)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import if star'\nThe code is: 'public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(\"Test runner executed successfully.\"); pluginConsole.waitMethodMarkedAsPassed(\"shouldSuccessOfAppOne\"); pluginConsole.waitMethodMarkedAsFailed(\"shouldFailOfAppOne\"); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); Assert.assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); <START> assertTrue( <END> \/\/ static import if star testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), \"Actual message was: \" + testErrorMessage); }'","output":"public void shouldExecuteTestClassSuccessfully() throws InterruptedException { projectExplorer.quickRevealToItemWithJavaScript(PATH_TO_ANOTHER_TEST_CLASS); projectExplorer.openItemByPath(PATH_TO_TEST_CLASS); editor.waitActiveEditor(); menu.runCommand(RUN_MENU, TEST, TEST_NG_TEST_DROP_DAWN_ITEM); notifications.waitExpectedMessageOnProgressPanelAndClosed(\"Test runner executed successfully.\"); pluginConsole.waitMethodMarkedAsPassed(\"shouldSuccessOfAppOne\"); pluginConsole.waitMethodMarkedAsFailed(\"shouldFailOfAppOne\"); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(PASSED).size() == 1); assertTrue(pluginConsole.getAllNamesOfMethodsMarkedDefinedStatus(FAILED).size() == 1); String testErrorMessage = pluginConsole.getTestErrorMessage(); assertTrue( testErrorMessage.startsWith(APP_TEST_ONE_FAIL_OUTPUT_TEMPLATE), \"Actual message was: \" + testErrorMessage); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'param a line'\nThe code is: 'public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } boolean anyRewritten = false; ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), <START> aggregation.isDistinct(), aggregation.getMask())); <END> \/\/ param a line } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedSymbols(), node.getStep(), node.getHashSymbol(), node.getGroupIdSymbol())); }'","output":"public Result apply(AggregationNode node, Captures captures, Context context) { if (!node.hasOrderings()) { return Result.empty(); } boolean anyRewritten = false; ImmutableMap.Builder<VariableReferenceExpression, Aggregation> aggregations = ImmutableMap.builder(); for (Map.Entry<VariableReferenceExpression, Aggregation> entry : node.getAggregations().entrySet()) { Aggregation aggregation = entry.getValue(); if (!aggregation.getOrderBy().isPresent()) { aggregations.put(entry); } else if (functionManager.getAggregateFunctionImplementation(aggregation.getFunctionHandle()).isOrderSensitive()) { aggregations.put(entry); } else { anyRewritten = true; aggregations.put(entry.getKey(), new Aggregation( aggregation.getCall(), aggregation.getFilter(), Optional.empty(), aggregation.isDistinct(), aggregation.getMask())); } } if (!anyRewritten) { return Result.empty(); } return Result.ofPlanNode(new AggregationNode( node.getId(), node.getSource(), aggregations.build(), node.getGroupingSets(), node.getPreGroupedVariables(), node.getStep(), node.getHashVariable(), node.getGroupIdVariable())); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I add new method AnalysisReporter, call existing public sendReport do line 65, WDYT'\nThe code is: 'private void received(final String json) { try { LOGGER.finest(\"Receiving: \" + json); final Object o = fromJSON(json); if (o instanceof WebWorkerLogMessage) { LOGGER.info(\"Web Worker log message: \" + ((WebWorkerLogMessage) o).getMessage()); } else if (o instanceof WebWorkerException) { LOGGER.severe(\"Web Worker failed: \" + ((WebWorkerException) o).getMessage()); shutdown(); <START> reporter.shutdownOnFailure(); <END> \/\/ I add new method AnalysisReporter, call existing public sendReport do line 65, WDYT } else if (o instanceof Status) { reporter.sendStatus((Status) o); } else if (o instanceof Issues) { reporter.sendReport(new HashSet<>(((Issues) o).getSet())); } } catch (Exception e) { LOGGER.severe(\"Could not manage received json: \" + e.getMessage() + \" JSON: \" + json); } }'","output":"private void received(final String json) { try { LOGGER.finest(\"Receiving: \" + json); final Object o = fromJSON(json); if (o instanceof WebWorkerLogMessage) { LOGGER.info(\"Web Worker log message: \" + ((WebWorkerLogMessage) o).getMessage()); } else if (o instanceof WebWorkerException) { LOGGER.severe(\"Web Worker failed: \" + ((WebWorkerException) o).getMessage()); shutdown(); } else if (o instanceof Status) { reporter.sendStatus((Status) o); } else if (o instanceof Issues) { reporter.sendReport(new HashSet<>(((Issues) o).getSet())); } } catch (Exception e) { LOGGER.severe(\"Could not manage received json: \" + e.getMessage() + \" JSON: \" + json); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'entire onPreferenceChangeListener avoided set android:persistent=true'\nThe code is: 'public void onResume() { super.onResume(); AccountManager manager = AccountManager.get(getActivity()); final Account account = manager.getAccountsByType(Constants.ACCOUNT_TYPE)[0]; initializeSyncCheckBox( (SwitchPreference) findPreference(Constants.Pref.SYNC_KEYSERVER), account, Constants.PROVIDER_AUTHORITY ); initializeSyncCheckBox( (SwitchPreference) findPreference(Constants.Pref.SYNC_CONTACTS), account, ContactsContract.AUTHORITY ); <START> SwitchPreference pref = (SwitchPreference) findPreference(Constants.Pref.ENABLE_WIFI_SYNC_ONLY); <END> \/\/ entire onPreferenceChangeListener avoided set android:persistent=true pref.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() { @Override public boolean onPreferenceChange(Preference preference, Object newValue) { Preferences prefs = Preferences.getPreferences(getContext()); prefs.setWifiOnlySync((Boolean) newValue); return true; } }); }'","output":"public void onResume() { super.onResume(); AccountManager manager = AccountManager.get(getActivity()); final Account account = manager.getAccountsByType(Constants.ACCOUNT_TYPE)[0]; initializeSyncCheckBox( (SwitchPreference) findPreference(Constants.Pref.SYNC_KEYSERVER), account, Constants.PROVIDER_AUTHORITY ); initializeSyncCheckBox( (SwitchPreference) findPreference(Constants.Pref.SYNC_CONTACTS), account, ContactsContract.AUTHORITY ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 's\/pmPption\/pmOptions'\nThe code is: 'public static void Init() { mUpdateVdsStatic = new ObjectIdentityChecker( VdsHandler.class, new java.util.ArrayList<String>(java.util.Arrays.asList(new String[] { \"VDS\", \"VdsStatic\", \"VdsDynamic\" })), VDSStatus.class); mUpdateVdsStatic.AddPermittedField(\"vdsName\"); mUpdateVdsStatic.AddPermittedField(\"managmentIp\"); mUpdateVdsStatic.AddPermittedField(\"pmType\"); mUpdateVdsStatic.AddPermittedField(\"pmUser\"); mUpdateVdsStatic.AddPermittedField(\"pmPassword\"); mUpdateVdsStatic.AddPermittedField(\"pmPort\"); <START> mUpdateVdsStatic.AddPermittedField(\"pmPptions\"); <END> \/\/ s\/pmPption\/pmOptions mUpdateVdsStatic.AddPermittedField(\"pmEnabled\"); mUpdateVdsStatic.AddPermittedField(\"pmProxyPreferences\"); mUpdateVdsStatic.AddPermittedField(\"PmOptionsMap\"); mUpdateVdsStatic.AddPermittedField(\"managmentIp\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryIp\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryType\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryUser\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryPassword\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryPort\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryOptions\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryOptionsMap\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryConcurrent\"); mUpdateVdsStatic.AddPermittedField(\"vdsSpmPriority\"); mUpdateVdsStatic.AddPermittedField(\"otpValidity\"); mUpdateVdsStatic.AddPermittedField(\"consoleAddress\"); mUpdateVdsStatic.AddFields( java.util.Arrays.asList(new Enum<?>[] { VDSStatus.NonResponsive, VDSStatus.Maintenance, VDSStatus.Down, VDSStatus.Unassigned, VDSStatus.InstallFailed, VDSStatus.PendingApproval }), java.util.Arrays.asList(new String[] { \"ip\", \"vdsUniqueId\", \"hostName\", \"port\", \"vdsGroupId\" })); }'","output":"public static void Init() { mUpdateVdsStatic = new ObjectIdentityChecker( VdsHandler.class, new java.util.ArrayList<String>(java.util.Arrays.asList(new String[] { \"VDS\", \"VdsStatic\", \"VdsDynamic\" })), VDSStatus.class); mUpdateVdsStatic.AddPermittedField(\"vdsName\"); mUpdateVdsStatic.AddPermittedField(\"managmentIp\"); mUpdateVdsStatic.AddPermittedField(\"pmType\"); mUpdateVdsStatic.AddPermittedField(\"pmUser\"); mUpdateVdsStatic.AddPermittedField(\"pmPassword\"); mUpdateVdsStatic.AddPermittedField(\"pmPort\"); mUpdateVdsStatic.AddPermittedField(\"pmOptions\"); mUpdateVdsStatic.AddPermittedField(\"pmEnabled\"); mUpdateVdsStatic.AddPermittedField(\"pmProxyPreferences\"); mUpdateVdsStatic.AddPermittedField(\"PmOptionsMap\"); mUpdateVdsStatic.AddPermittedField(\"managmentIp\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryIp\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryType\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryUser\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryPassword\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryPort\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryOptions\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryOptionsMap\"); mUpdateVdsStatic.AddPermittedField(\"pmSecondaryConcurrent\"); mUpdateVdsStatic.AddPermittedField(\"vdsSpmPriority\"); mUpdateVdsStatic.AddPermittedField(\"otpValidity\"); mUpdateVdsStatic.AddPermittedField(\"consoleAddress\"); mUpdateVdsStatic.AddFields( java.util.Arrays.asList(new Enum<?>[] { VDSStatus.NonResponsive, VDSStatus.Maintenance, VDSStatus.Down, VDSStatus.Unassigned, VDSStatus.InstallFailed, VDSStatus.PendingApproval }), java.util.Arrays.asList(new String[] { \"ip\", \"vdsUniqueId\", \"hostName\", \"port\", \"vdsGroupId\" })); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Wrapping logic in a try-catch is excessive harder understand. resulting service error error Rest.li unable build criteria URI, sense put this try-catch service error #buildCriteriaURI'\nThe code is: 'public RestLiResponseData<BatchFinderResponseEnvelope> buildRestLiResponseData(Request request, RoutingResult routingResult, Object object, Map<String, String> headers, List<HttpCookie> cookies) { BatchFinderResult<RecordTemplate, RecordTemplate, RecordTemplate> result = (BatchFinderResult<RecordTemplate, RecordTemplate, RecordTemplate>) object; DataList criteriaParams = getCriteriaParameters(routingResult); List<BatchFinderEntry> collectionResponse = new ArrayList<>(criteriaParams.size()); final ResourceContextImpl resourceContext = (ResourceContextImpl) routingResult.getContext(); TimingContextUtil.beginTiming(routingResult.getContext().getRawRequestContext(), FrameworkTimingKeys.SERVER_RESPONSE_RESTLI_PROJECTION_APPLY.key()); <START> try <END> \/\/ Wrapping logic in a try-catch is excessive harder understand. resulting service error error Rest.li unable build criteria URI, sense put this try-catch service error #buildCriteriaURI { for (Object criteriaParam : criteriaParams.values()) { RecordTemplate criteria = new AnyRecord((DataMap) criteriaParam); BatchFinderEntry entry; if (result.getResults().containsKey(criteria)) { CollectionResult<RecordTemplate, RecordTemplate> cr = result.getResult(criteria); List<AnyRecord> elements = buildElements(cr, resourceContext); final CollectionMetadata projectedPaging = buildPaginationMetaData(routingResult, criteria, resourceContext, request, cr); final AnyRecord projectedCustomMetadata = buildMetaData(cr, resourceContext); entry = new BatchFinderEntry(elements, projectedPaging, projectedCustomMetadata); } else if (result.getErrors().containsKey(criteria)) { entry = new BatchFinderEntry(result.getErrors().get(criteria)); } else { entry = new BatchFinderEntry( new RestLiServiceException(S_404_NOT_FOUND, \"The server didn't find a representation for this criteria\")); } collectionResponse.add(entry); } TimingContextUtil.endTiming(routingResult.getContext().getRawRequestContext(), FrameworkTimingKeys.SERVER_RESPONSE_RESTLI_PROJECTION_APPLY.key()); return new RestLiResponseDataImpl<>(new BatchFinderResponseEnvelope(HttpStatus.S_200_OK, collectionResponse), headers, cookies); } catch (CloneNotSupportedException exception) { throw new RestLiServiceException(S_500_INTERNAL_SERVER_ERROR, \"Batch finder response builder failed when rebuild projection URI\"); } }'","output":"public RestLiResponseData<BatchFinderResponseEnvelope> buildRestLiResponseData(Request request, RoutingResult routingResult, Object object, Map<String, String> headers, List<HttpCookie> cookies) { BatchFinderResult<RecordTemplate, RecordTemplate, RecordTemplate> result = (BatchFinderResult<RecordTemplate, RecordTemplate, RecordTemplate>) object; DataList criteriaParams = getCriteriaParameters(routingResult); List<BatchFinderEntry> collectionResponse = new ArrayList<>(criteriaParams.size()); final ResourceContextImpl resourceContext = (ResourceContextImpl) routingResult.getContext(); TimingContextUtil.beginTiming(routingResult.getContext().getRawRequestContext(), FrameworkTimingKeys.SERVER_RESPONSE_RESTLI_PROJECTION_APPLY.key()); for (Object criteriaParam : criteriaParams.values()) { RecordTemplate criteria = new AnyRecord((DataMap) criteriaParam); BatchFinderEntry entry; if (result.getResults().containsKey(criteria)) { CollectionResult<RecordTemplate, RecordTemplate> cr = result.getResult(criteria); List<AnyRecord> elements = buildElements(cr, resourceContext); final CollectionMetadata projectedPaging = buildPaginationMetaData(routingResult, criteria, resourceContext, request, cr); final AnyRecord projectedCustomMetadata = buildMetaData(cr, resourceContext); entry = new BatchFinderEntry(elements, projectedPaging, projectedCustomMetadata); } else if (result.getErrors().containsKey(criteria)) { entry = new BatchFinderEntry(result.getErrors().get(criteria)); } else { entry = new BatchFinderEntry( new RestLiServiceException(S_404_NOT_FOUND, \"The server didn't find a representation for this criteria\")); } collectionResponse.add(entry); } TimingContextUtil.endTiming(routingResult.getContext().getRawRequestContext(), FrameworkTimingKeys.SERVER_RESPONSE_RESTLI_PROJECTION_APPLY.key()); return new RestLiResponseDataImpl<>(new BatchFinderResponseEnvelope(HttpStatus.S_200_OK, collectionResponse), headers, cookies); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'I this blame, while it, change this \"Successfully\" :wink:'\nThe code is: 'public void finish() { try { CryptoFileSystemProvider.changePassphrase(vault.getPath(), MASTERKEY_FILENAME, oldPasswordField.getCharacters(), newPassword.get()); <START> LOG.info(\"Successful changed password for {}\", vault.getDisplayableName()); <END> \/\/ I this blame, while it, change this \"Successfully\" :wink: window.close(); updatePasswordInSystemkeychain(); } catch (IOException e) { LOG.error(\"IO error occured during password change. Unable to perform operation.\", e); errorComponent.cause(e).window(window).returnToScene(window.getScene()).build().showErrorScene(); } catch (InvalidPassphraseException e) { Animations.createShakeWindowAnimation(window).play(); oldPasswordField.selectAll(); oldPasswordField.requestFocus(); } }'","output":"public void finish() { try { CryptoFileSystemProvider.changePassphrase(vault.getPath(), MASTERKEY_FILENAME, oldPasswordField.getCharacters(), newPassword.get()); LOG.info(\"Successfully changed password for {}\", vault.getDisplayableName()); window.close(); updatePasswordInSystemkeychain(); } catch (IOException e) { LOG.error(\"IO error occured during password change. Unable to perform operation.\", e); errorComponent.cause(e).window(window).returnToScene(window.getScene()).build().showErrorScene(); } catch (InvalidPassphraseException e) { Animations.createShakeWindowAnimation(window).play(); oldPasswordField.selectAll(); oldPasswordField.requestFocus(); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'model is injected reinstantiated again'\nThe code is: 'public ModelAndView saveAbout(@ProjectIdentifier @PathVariable(\"ProjectId\") String projectId, @Validated @ModelAttribute(\"aboutTextBean\") AboutText formBean, BindingResult result, ModelAndView model, Principal principal, @InjectProject IProject project) throws QuadrigaStorageException { <START> model = new ModelAndView(\"auth\/editabout\"); <END> \/\/ model is injected reinstantiated again List<INetwork> networks = nwManager.getNetworksInProject(projectId, INetworkStatus.APPROVED); model.addObject(\"project\", project); model.addObject(\"networks\", networks); if (result.hasErrors()) { model.addObject(\"aboutTextBean\", formBean); } else { aboutTextManager.saveAbout(projectId, formBean); model.addObject(\"show_success_alert\", true); model.addObject(\"success_alert_msg\", \"You successfully edited the about text\"); } return model; }'","output":"public ModelAndView saveAbout(@ProjectIdentifier @PathVariable(\"ProjectId\") String projectId, @Validated @ModelAttribute(\"aboutTextBean\") AboutText formBean, BindingResult result, ModelAndView model, Principal principal, @InjectProject IProject project) throws QuadrigaStorageException { List<INetwork> networks = nwManager.getNetworksInProject(projectId, INetworkStatus.APPROVED); model.addObject(\"project\", project); model.addObject(\"networks\", networks); if (result.hasErrors()) { model.addObject(\"aboutTextBean\", formBean); } else { aboutTextManager.saveAbout(projectId, formBean); model.addObject(\"show_success_alert\", true); model.addObject(\"success_alert_msg\", \"You successfully edited the about text\"); } return model; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'this active instance'\nThe code is: 'protected int run() { <START> Jenkins.getActiveInstance().checkPermission(Jenkins.ADMINISTER); <END> \/\/ this active instance System.setProperty(\"jline.terminal\", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append(\" \"); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }'","output":"protected int run() { Jenkins.get().checkPermission(Jenkins.ADMINISTER); System.setProperty(\"jline.terminal\", UnsupportedTerminal.class.getName()); TerminalFactory.reset(); StringBuilder commandLine = new StringBuilder(); for (String arg : args) { if (commandLine.length() > 0) { commandLine.append(\" \"); } commandLine.append(arg); } Groovysh shell = createShell(stdin, stdout, stderr); return shell.run(commandLine.toString()); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Typo in variable name'\nThe code is: 'public static UserSession createMockUserSession(Person person) { UserSession userSession = mock(UserSession.class); <START> String principleId = person.getPrincipalId(); <END> \/\/ Typo in variable name when(userSession.getPrincipalId()).thenReturn(principleId); String principleName = person.getPrincipalName(); when(userSession.getPrincipalName()).thenReturn(principleName); when(userSession.getLoggedInUserPrincipalName()).thenReturn(principleName); when(userSession.getPerson()).thenReturn(person); when(userSession.getActualPerson()).thenReturn(person); return userSession; }'","output":"public static UserSession createMockUserSession(Person person) { UserSession userSession = mock(UserSession.class); String principalId = person.getPrincipalId(); when(userSession.getPrincipalId()).thenReturn(principalId); String principalName = person.getPrincipalName(); when(userSession.getPrincipalName()).thenReturn(principalName); when(userSession.getLoggedInUserPrincipalName()).thenReturn(principalName); when(userSession.getPerson()).thenReturn(person); when(userSession.getActualPerson()).thenReturn(person); return userSession; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'here, input empty list'\nThe code is: 'public void refresh(HelixDataAccessor accessor) { long startTime = System.currentTimeMillis(); PropertyKey.Builder keyBuilder = accessor.keyBuilder(); Set<PropertyKey> currentPropertyKeys = new HashSet<>(); List<String> resources = accessor.getChildNames(externalViewsKey(keyBuilder)); for (String resource : resources) { currentPropertyKeys.add(externalViewKey(keyBuilder, resource)); } Set<PropertyKey> cachedKeys = new HashSet<>(); Map<PropertyKey, ExternalView> cachedExternalViewMap = Maps.newHashMap(); for (String resource : _externalViewCache.keySet()) { PropertyKey key = externalViewKey(keyBuilder, resource); cachedKeys.add(key); cachedExternalViewMap.put(key, _externalViewCache.get(resource)); } cachedKeys.retainAll(currentPropertyKeys); Set<PropertyKey> reloadKeys = new HashSet<>(currentPropertyKeys); reloadKeys.removeAll(cachedKeys); Map<PropertyKey, ExternalView> updatedMap = refreshProperties(accessor, reloadKeys, new ArrayList<>(cachedKeys), <START> cachedExternalViewMap, reloadKeys); <END> \/\/ here, input empty list Map<String, ExternalView> newExternalViewMap = Maps.newHashMap(); for (ExternalView externalView : updatedMap.values()) { newExternalViewMap.put(externalView.getResourceName(), externalView); } _externalViewCache = new HashMap<>(newExternalViewMap); _externalViewMap = new HashMap<>(newExternalViewMap); long endTime = System.currentTimeMillis(); LOG.info(\"Refresh \" + _externalViewMap.size() + \" ExternalViews for cluster \" + _clusterName + \", took \" + (endTime - startTime) + \" ms\"); }'","output":"public void refresh(HelixDataAccessor accessor) { long startTime = System.currentTimeMillis(); PropertyKey.Builder keyBuilder = accessor.keyBuilder(); Set<PropertyKey> currentPropertyKeys = new HashSet<>(); List<String> resources = accessor.getChildNames(externalViewsKey(keyBuilder)); for (String resource : resources) { currentPropertyKeys.add(externalViewKey(keyBuilder, resource)); } Set<PropertyKey> cachedKeys = new HashSet<>(); Map<PropertyKey, ExternalView> cachedExternalViewMap = Maps.newHashMap(); for (String resource : _externalViewCache.keySet()) { PropertyKey key = externalViewKey(keyBuilder, resource); cachedKeys.add(key); cachedExternalViewMap.put(key, _externalViewCache.get(resource)); } cachedKeys.retainAll(currentPropertyKeys); Set<PropertyKey> reloadKeys = new HashSet<>(currentPropertyKeys); reloadKeys.removeAll(cachedKeys); Map<PropertyKey, ExternalView> updatedMap = refreshProperties(accessor, reloadKeys, new ArrayList<>(cachedKeys), cachedExternalViewMap, new HashSet<>()); Map<String, ExternalView> newExternalViewMap = Maps.newHashMap(); for (ExternalView externalView : updatedMap.values()) { newExternalViewMap.put(externalView.getResourceName(), externalView); } _externalViewCache = new HashMap<>(newExternalViewMap); _externalViewMap = new HashMap<>(newExternalViewMap); long endTime = System.currentTimeMillis(); LOG.info(\"Refresh \" + _externalViewMap.size() + \" ExternalViews for cluster \" + _clusterName + \", took \" + (endTime - startTime) + \" ms\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'interrupt flag restored here'\nThe code is: 'public synchronized void init() { if (!initialized) { initializeRouteMatcher(); if (!isRunningFromServlet()) { new Thread(() -> { EmbeddedServers.initialize(); if (embeddedServerIdentifier == null) { embeddedServerIdentifier = EmbeddedServers.defaultIdentifier(); } server = EmbeddedServers.create(embeddedServerIdentifier, routes, staticFilesConfiguration, hasMultipleHandlers()); server.configureWebSockets(webSocketHandlers, webSocketIdleTimeoutMillis); port = server.ignite( ipAddress, port, sslStores, maxThreads, minThreads, threadIdleTimeoutMillis); try { latch.countDown(); server.join(); } catch (InterruptedException e) { <START> LOG.error(\"server interrupted\", e); <END> \/\/ interrupt flag restored here } }).start(); } initialized = true; } }'","output":"public synchronized void init() { if (!initialized) { initializeRouteMatcher(); if (!isRunningFromServlet()) { new Thread(() -> { EmbeddedServers.initialize(); if (embeddedServerIdentifier == null) { embeddedServerIdentifier = EmbeddedServers.defaultIdentifier(); } server = EmbeddedServers.create(embeddedServerIdentifier, routes, staticFilesConfiguration, hasMultipleHandlers()); server.configureWebSockets(webSocketHandlers, webSocketIdleTimeoutMillis); port = server.ignite( ipAddress, port, sslStores, maxThreads, minThreads, threadIdleTimeoutMillis); try { latch.countDown(); server.join(); } catch (InterruptedException e) { LOG.error(\"server interrupted\", e); Thread.currentThread().interrupt(); } }).start(); } initialized = true; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'return directly'\nThe code is: 'private static JsonParserIterator<TaskStatusPlus> getTasks( DruidLeaderClient indexingServiceClient, ObjectMapper jsonMapper, BytesAccumulatingResponseHandler responseHandler ) { Request request; try { request = indexingServiceClient.makeRequest( HttpMethod.GET, StringUtils.format(\"\/druid\/indexer\/v1\/tasks\") ); } catch (IOException e) { throw new RuntimeException(e); } ListenableFuture<InputStream> future = indexingServiceClient.goStream( request, responseHandler ); try { future.get(); } catch (InterruptedException | ExecutionException e) { throw new RuntimeException(e); } if (responseHandler.getStatus() != HttpServletResponse.SC_OK) { throw new ISE( \"Error while fetching tasks status[%s] description[%s]\", responseHandler.status, responseHandler.description ); } final JavaType typeRef = jsonMapper.getTypeFactory().constructType(new TypeReference<TaskStatusPlus>() { }); <START> JsonParserIterator<TaskStatusPlus> iterator = new JsonParserIterator<>( <END> \/\/ return directly typeRef, future, request.getUrl().toString(), null, request.getUrl().getHost(), jsonMapper ); return iterator; }'","output":"private static JsonParserIterator<TaskStatusPlus> getTasks( DruidLeaderClient indexingServiceClient, ObjectMapper jsonMapper, BytesAccumulatingResponseHandler responseHandler ) { Request request; try { request = indexingServiceClient.makeRequest( HttpMethod.GET, StringUtils.format(\"\/druid\/indexer\/v1\/tasks\") ); } catch (IOException e) { throw new RuntimeException(e); } ListenableFuture<InputStream> future = indexingServiceClient.goAsync( request, responseHandler ); final JavaType typeRef = jsonMapper.getTypeFactory().constructType(new TypeReference<TaskStatusPlus>() { }); return new JsonParserIterator<>( typeRef, future, request.getUrl().toString(), null, request.getUrl().getHost(), jsonMapper ); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion checkDeploymentOrder(!legacy); (same elsewhere)'\nThe code is: 'public void checkReference(boolean partial, boolean legacy) { checkCommon(\"Bundle org.nuxeo.apidoc.core\", \"Bundle org.nuxeo.apidoc.core\", \"In bundle group org.nuxeo.ecm.platform\", \"Documentation\\n\" + \"Deployment Order\\n\" + \"Components\\n\" + \"Maven Artifact\\n\" + \"Manifest\"); try { String readme = AbstractExplorerTest.getReferenceContent(\"data\/core_readme.txt\"); String parentReadme = AbstractExplorerTest.getReferenceContent(\"data\/apidoc_readme.txt\"); checkDocumentationText(\"ReadMe.md\\n\" + readme + \"\\nParent Documentation: ReadMe.md\\n\" + parentReadme); } catch (IOException e) { throw new RuntimeException(e); } checkGroupId(\"org.nuxeo.ecm.platform\"); checkArtifactId(\"nuxeo-apidoc-core\"); checkRequirements(null); <START> checkDeploymentOrder(legacy ? false : true); <END> \/\/ suggestion checkDeploymentOrder(!legacy); (same elsewhere) }'","output":"public void checkReference(boolean partial, boolean legacy) { checkCommon(\"Bundle org.nuxeo.apidoc.core\", \"Bundle org.nuxeo.apidoc.core\", \"In bundle group org.nuxeo.ecm.platform\", \"Documentation\\n\" + \"Deployment Order\\n\" + \"Components\\n\" + \"Maven Artifact\\n\" + \"Manifest\"); try { String readme = AbstractExplorerTest.getReferenceContent(\"data\/core_readme.txt\"); String parentReadme = AbstractExplorerTest.getReferenceContent(\"data\/apidoc_readme.txt\"); checkDocumentationText(\"ReadMe.md\\n\" + readme + \"\\nParent Documentation: ReadMe.md\\n\" + parentReadme); } catch (IOException e) { throw new RuntimeException(e); } checkGroupId(\"org.nuxeo.ecm.platform\"); checkArtifactId(\"nuxeo-apidoc-core\"); checkRequirements(null); checkDeploymentOrder(!legacy); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'nit: LinkedList adding removing entries'\nThe code is: 'public SortedComponentGroupedEvents(ComponentGroupedEvents groupedEvents, String selectedEventId) { this.componentName = groupedEvents.getComponentName(); this.inputEventIds = new ArrayList<>(groupedEvents.getInputEventIds()); this.outputEventIds = new ArrayList<>(groupedEvents.getOutputEventIds()); if (this.outputEventIds.contains(selectedEventId)) { this.containingSelectedEvent = true; <START> this.outputEventIds.remove(selectedEventId); <END> \/\/ nit: LinkedList adding removing entries this.outputEventIds.add(0, selectedEventId); } else { this.containingSelectedEvent = false; } }'","output":"public SortedComponentGroupedEvents(ComponentGroupedEvents groupedEvents, String selectedEventId) { this.componentName = groupedEvents.getComponentName(); this.inputEventIds = new LinkedList<>(groupedEvents.getInputEventIds()); this.outputEventIds = new LinkedList<>(groupedEvents.getOutputEventIds()); if (this.outputEventIds.contains(selectedEventId)) { this.containingSelectedEvent = true; this.outputEventIds.remove(selectedEventId); this.outputEventIds.add(0, selectedEventId); } else { this.containingSelectedEvent = false; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'suggestion List<RestEntry> entries = new ArrayList<>();'\nThe code is: 'public void execute(DiagnosticContext context) { try { DiagConfig diagConfig = context.getDiagsConfig(); <START> List<RestEntry> entries = new ArrayList(); <END> \/\/ suggestion List<RestEntry> entries = new ArrayList<>(); entries.addAll(context.getElasticRestCalls().values()); runQueries(context.getEsRestClient(), entries, context.getTempDir(), diagConfig.getCallRetries(), diagConfig.getPauseRetries()); } catch (Throwable t) { logger.log(SystemProperties.DIAG, \"Error executing REST queries\", t); throw new DiagnosticException(String.format(\"Unrecoverable REST Query Execution error - exiting. %s\", Constants.CHECK_LOG)); } }'","output":"public void execute(DiagnosticContext context) { try { DiagConfig diagConfig = context.getDiagsConfig(); List<RestEntry> entries = new ArrayList<>(); entries.addAll(context.getElasticRestCalls().values()); runQueries(context.getEsRestClient(), entries, context.getTempDir(), diagConfig.getCallRetries(), diagConfig.getPauseRetries()); } catch (Throwable t) { logger.log(SystemProperties.DIAG, \"Error executing REST queries\", t); throw new DiagnosticException(String.format(\"Unrecoverable REST Query Execution error - exiting. %s\", Constants.CHECK_LOG)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please == comparing enums'\nThe code is: 'public Map<String, String> getJobMessageProperties() { List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue()); String sourceSDName = StringUtils.EMPTY; if (storageDomains.size() > 0) { sourceSDName = storageDomains.get(0).getstorage_name(); } if (jobProperties == null) { jobProperties = super.getJobMessageProperties(); jobProperties.put(\"sourcesd\", sourceSDName); <START> jobProperties.put(\"targetsd\", getStorageDomainName()); <END> \/\/ please == comparing enums if (ImageOperation.Move.equals(getParameters().getOperation())) { jobProperties.put(\"action\", \"Moving\"); } else { jobProperties.put(\"action\", \"Copying\"); } } return jobProperties; }'","output":"public Map<String, String> getJobMessageProperties() { List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue()); String sourceSDName = StringUtils.EMPTY; if (storageDomains.size() > 0) { sourceSDName = storageDomains.get(0).getstorage_name(); } if (jobProperties == null) { jobProperties = super.getJobMessageProperties(); jobProperties.put(\"sourcesd\", sourceSDName); jobProperties.put(\"targetsd\", getStorageDomainName()); if (ImageOperation.Move == getParameters().getOperation()) { jobProperties.put(\"action\", \"Moving\"); } else { jobProperties.put(\"action\", \"Copying\"); } } return jobProperties; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This is consistent code GoogleComputeInstance, I || ipMappingList.isEmpty() for clarity'\nThe code is: 'private static InetAddress getPrivateIpAddress(DatabaseInstance instance) { Preconditions.checkNotNull(instance, \"instance is null\"); List<IpMapping> ipMappingList = instance.getIpAddresses(); <START> if (ipMappingList == null || ipMappingList.size() == 0) { <END> \/\/ This is consistent code GoogleComputeInstance, I || ipMappingList.isEmpty() for clarity throw new IllegalArgumentException(\"No network interfaces found for database instance '\" + instance.getName() + \"'.\"); } else { try { return InetAddress.getByName(ipMappingList.get(0).getIpAddress()); } catch (UnknownHostException e) { throw new IllegalArgumentException(\"Invalid IPv4 address\", e); } } }'","output":"private static InetAddress getPrivateIpAddress(DatabaseInstance instance) { Preconditions.checkNotNull(instance, \"instance is null\"); List<IpMapping> ipMappingList = instance.getIpAddresses(); if (ipMappingList == null || ipMappingList.isEmpty()) { throw new IllegalArgumentException(\"No network interfaces found for database instance '\" + instance.getName() + \"'.\"); } else { try { return InetAddress.getByName(ipMappingList.get(0).getIpAddress()); } catch (UnknownHostException e) { throw new IllegalArgumentException(\"Invalid IPv4 address\", e); } } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: '\"TestCase name null\"'\nThe code is: 'protected void runTest() throws Throwable { <START> assertNotNull(\"TestCase.name cannot be null\", name); END> Method runMethod = null; try { runMethod = getClass().getMethod(name, (Class[]) null); } catch (NoSuchMethodException e) { fail(\"Method \\\"\" + name + \"\\\" not found\"); } if (!Modifier.isPublic(runMethod.getModifiers())) { fail(\"Method \\\"\" + name + \"\\\" should be public\"); } try { runMethod.invoke(this); } catch (InvocationTargetException e) { e.fillInStackTrace(); throw e.getTargetException(); } catch (IllegalAccessException e) { e.fillInStackTrace(); throw e; } }'","output":"protected void runTest() throws Throwable { assertNotNull(\"TestCase name cannot be null\", name); Method runMethod = null; try { runMethod = getClass().getMethod(name, (Class[]) null); } catch (NoSuchMethodException e) { fail(\"Method \\\"\" + name + \"\\\" not found\"); } if (!Modifier.isPublic(runMethod.getModifiers())) { fail(\"Method \\\"\" + name + \"\\\" should be public\"); } try { runMethod.invoke(this); } catch (InvocationTargetException e) { e.fillInStackTrace(); throw e.getTargetException(); } catch (IllegalAccessException e) { e.fillInStackTrace(); throw e; } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Same. strings refactoring friendly. Lets address this'\nThe code is: 'public void verify_fallback_in_download_presigned_urls() throws Exception { AmazonServiceException firstException = new AmazonServiceException(\"Didn't find Object Id in bucket\"); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); int bucketPoolSize = 32; int bucketKeySize = 2; <START> ReflectionTestUtils.setField(service, \"bucketPoolSize\", bucketPoolSize); <END> \/\/ Same. strings refactoring friendly. Lets address this ReflectionTestUtils.setField(service, \"bucketKeySize\", bucketKeySize); ObjectURLGenerator urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, \"s3Client\", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, \"urlGenerator\", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); List<Part> parts = ObjectDownloadServiceStubFactory.createParts(5); ObjectSpecification os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); ObjectDownloadService sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); Part p = objSpec.getParts().get(0); URL url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(\"\/\")) { path = path.substring(1, path.length() - 1); } String bucket = Splitter.on('\/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(dataBucketName, bucket); System.out.println(); }'","output":"public void verify_fallback_in_download_presigned_urls() throws Exception { val firstException = new AmazonServiceException(\"Didn't find Object Id in bucket\"); firstException.setStatusCode(HttpStatus.NOT_FOUND.value()); int bucketPoolSize = 32; int bucketKeySize = 2; namingService.setBucketPoolSize(bucketPoolSize); namingService.setBucketKeySize(bucketKeySize); val urlGen = new AmazonURLGenerator(); ReflectionTestUtils.setField(urlGen, \"s3Client\", ObjectDownloadServiceStubFactory.createS3ClientForRadosGW(endpointUrl)); ReflectionTestUtils.setField(service, \"urlGenerator\", urlGen); when(s3Client.getObject(Mockito.any())).thenThrow(firstException); val parts = ObjectDownloadServiceStubFactory.createParts(5); val os = ObjectDownloadServiceStubFactory.createObjectSpecification(objectId, ObjectKeys.getObjectKey(dataDir, objectId), 104857600); os.setParts(parts); os.setRelocated(true); val sut = spy(service); doReturn(os).when(sut).getSpecification(objectId); val objSpec = sut.download(objectId, 0, 104857600, false); val p = objSpec.getParts().get(0); val url = new URL(p.getUrl()); String path = url.getPath(); if (path.startsWith(\"\/\")) { path = path.substring(1, path.length() - 1); } val bucket = Splitter.on('\/').trimResults().omitEmptyStrings().split(path).iterator().next(); assertEquals(objectBucketName, bucket); System.out.println(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a command line app -- print STDOUT (or STDERR if a warning etc)'\nThe code is: 'protected int processArgument(String[] args, int current) throws Exception { if (args[current].equals(\"-c\")) <START> bracketedOutput = false; <END> \/\/ a command line app -- print STDOUT (or STDERR if a warning etc) else { if (new File(args[current]).exists()) { logger.info(\"Loading properties from \" + args[current]); this.resourceManager = new ResourceManager(args[current]); logger.info(\"Completed loading properties.\"); } else throw new RuntimeException(\"The configuration file \\\"\" + args[current] + \"\\\" did not exist.\"); } return current++; }'","output":"protected int processArgument(String[] args, int current) throws Exception { if (args[current].equals(\"-c\")) bracketedOutput = false; else { if (new File(args[current]).exists()) { System.out.println(\"Loading properties from \" + args[current]); this.resourceManager = new ResourceManager(args[current]); System.out.println(\"Completed loading properties.\"); } else throw new RuntimeException(\"The configuration file \\\"\" + args[current] + \"\\\" did not exist.\"); } return current++; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This creates anonymous class extends HashMap, is considered a bad practice. for a simpler approach: Map<String, String> migrationMap = new HashMap<>(); migrationMap.put(\"undefined\", \"true\"); migrationMap.put(\"x86\", \"true\"); migrationMap.put(\"ppc\", \"true\");'\nThe code is: 'public void testBlockUseHostCpuWithPPCArch() { when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID); when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true); doNothing().when(cmd).initTemplateDisks(); setupCanAddPpcTest(); cmd.setEffectiveCompatibilityVersion(Version.v4_0); doReturn(Collections.emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains(); initPpcCluster(); doReturn(true).when(cmd).validateAddVmCommand(); doReturn(true).when(cmd).isVmNameValidLength(any(VM.class)); when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.ppc64); cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64); cmd.getParameters().getVm().setUseHostCpuFlags(true); cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST); cmd.getParameters().getVm().setClusterId(cluster.getId()); cmd.getParameters().getVm().setVmOs(OsType.Other.ordinal()); cmd.init(); <START> Map<String, String> migrationMap = new HashMap<String, String>() { { put(\"undefined\", \"true\"); put(\"x86\", \"true\"); put(\"ppc\", \"true\"); } }; <END> \/\/ This creates anonymous class extends HashMap, is considered a bad practice. for a simpler approach: Map<String, String> migrationMap = new HashMap<>(); migrationMap.put(\"undefined\", \"true\"); migrationMap.put(\"x86\", \"true\"); migrationMap.put(\"ppc\", \"true\"); mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap); ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH); }'","output":"public void testBlockUseHostCpuWithPPCArch() { when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID); when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true); doNothing().when(cmd).initTemplateDisks(); setupCanAddPpcTest(); cmd.setEffectiveCompatibilityVersion(Version.v4_0); doReturn(Collections.emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains(); initPpcCluster(); doReturn(true).when(cmd).validateAddVmCommand(); doReturn(true).when(cmd).isVmNameValidLength(any(VM.class)); when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.ppc64); cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64); cmd.getParameters().getVm().setUseHostCpuFlags(true); cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST); cmd.getParameters().getVm().setClusterId(cluster.getId()); cmd.getParameters().getVm().setVmOs(OsType.Other.ordinal()); cmd.init(); Map<String, String> migrationMap = new HashMap<>(); migrationMap.put(\"undefined\", \"true\"); migrationMap.put(\"x86\", \"true\"); migrationMap.put(\"ppc\", \"true\"); mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap); ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'This a NPE. Consider returning empty list'\nThe code is: 'public List<SnapshotInfo> getSnapshots(long volumeId, DataStoreRole role) { SnapshotDataStoreVO snapshotStore = snapshotStoreDao.findByVolume(volumeId, role); if (snapshotStore == null) { <START> return null; <END> \/\/ This a NPE. Consider returning empty list } DataStore store = storeMgr.getDataStore(snapshotStore.getDataStoreId(), role); List<SnapshotVO> volSnapShots = snapshotDao.listByVolumeId(volumeId); List<SnapshotInfo> infos = new ArrayList<>(); for(SnapshotVO snapshot: volSnapShots) { SnapshotObject info = SnapshotObject.getSnapshotObject(snapshot, store); infos.add(info); } return infos; }'","output":"public List<SnapshotInfo> getSnapshots(long volumeId, DataStoreRole role) { SnapshotDataStoreVO snapshotStore = snapshotStoreDao.findByVolume(volumeId, role); if (snapshotStore == null) { return new ArrayList<>(); } DataStore store = storeMgr.getDataStore(snapshotStore.getDataStoreId(), role); List<SnapshotVO> volSnapShots = snapshotDao.listByVolumeId(volumeId); List<SnapshotInfo> infos = new ArrayList<>(); for(SnapshotVO snapshot: volSnapShots) { SnapshotObject info = SnapshotObject.getSnapshotObject(snapshot, store); infos.add(info); } return infos; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Redundant UnsupportedEncodingException'\nThe code is: '<START> private byte[] fromBytesPayload(Message<byte[]> message) throws UnsupportedEncodingException, Exception { <END> \/\/ Redundant UnsupportedEncodingException byte[] headers = this.objectMapper.writeValueAsBytes(message.getHeaders()); byte[] payload = message.getPayload(); ByteBuffer buffer = ByteBuffer.wrap(new byte[8 + headers.length + payload.length]); buffer.putInt(headers.length); buffer.put(headers); buffer.putInt(payload.length); buffer.put(payload); return buffer.array(); }'","output":"private byte[] fromBytesPayload(Message<byte[]> message) throws Exception { byte[] headers = this.objectMapper.writeValueAsBytes(message.getHeaders()); byte[] payload = message.getPayload(); ByteBuffer buffer = ByteBuffer.wrap(new byte[8 + headers.length + payload.length]); buffer.putInt(headers.length); buffer.put(headers); buffer.putInt(payload.length); buffer.put(payload); return buffer.array(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'create a hash set directly'\nThe code is: 'public BookieSocketAddress replaceBookie(List<BookieSocketAddress> existingBookies, int bookieIdx) throws BKNotEnoughBookiesException { BookieSocketAddress addr = existingBookies.get(bookieIdx); try { <START> List<BookieSocketAddress> existingAndQuarantinedBookies = Lists.newArrayList(); <END> \/\/ create a hash set directly existingAndQuarantinedBookies.addAll(existingBookies); existingAndQuarantinedBookies.addAll(quarantinedBookies.asMap().keySet()); return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingAndQuarantinedBookies)); } catch (BKNotEnoughBookiesException e) { if (logger.isDebugEnabled()) { logger.debug(\"Not enough healthy bookies available, using quarantined bookies\"); } return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies)); } }'","output":"public BookieSocketAddress replaceBookie(List<BookieSocketAddress> existingBookies, int bookieIdx) throws BKNotEnoughBookiesException { BookieSocketAddress addr = existingBookies.get(bookieIdx); try { Set<BookieSocketAddress> existingAndQuarantinedBookies = new HashSet<BookieSocketAddress>(existingBookies); existingAndQuarantinedBookies.addAll(quarantinedBookies.asMap().keySet()); return placementPolicy.replaceBookie(addr, existingAndQuarantinedBookies); } catch (BKNotEnoughBookiesException e) { if (logger.isDebugEnabled()) { logger.debug(\"Not enough healthy bookies available, using quarantined bookies\"); } return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies)); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'latch'\nThe code is: 'public void testCaptcha() { PageTitle title = new PageTitle(null, \"Test_page_for_app_testing\/Captcha\", TEST_WIKI_SITE); String wikitext = \"== Section 2 ==\\n\\nEditing by inserting an external link https:\/\/\" + System.currentTimeMillis(); service.edit(TEST_WIKI_SITE, title, DEFAULT_SECTION_ID, wikitext, ANONYMOUS_TOKEN, DEFAULT_SUMMARY, false, null, null, new Edit.Callback() { @Override public void success(@NonNull EditingResult result) { <START> validateCaptcha(result); <END> \/\/ latch } @Override public void failure(@NonNull Throwable caught) { throw new RuntimeException(caught); } }); }'","output":"public void testCaptcha() { PageTitle title = new PageTitle(null, \"Test_page_for_app_testing\/Captcha\", TEST_WIKI_SITE); String wikitext = \"== Section 2 ==\\n\\nEditing by inserting an external link https:\/\/\" + System.currentTimeMillis(); final TestLatch latch = new TestLatch(); client.request(TEST_WIKI_SITE, title, DEFAULT_SECTION_ID, wikitext, ANONYMOUS_TOKEN, DEFAULT_SUMMARY, false, null, null, new EditClient.Callback() { @Override public void success(@NonNull Call<Edit> call, @NonNull EditingResult result) { validateCaptcha(result); latch.countDown(); } @Override public void failure(@NonNull Call<Edit> call, @NonNull Throwable caught) { throw new RuntimeException(caught); } }); latch.await(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'else needed here'\nThe code is: 'public Optional<DeviceData> getMostRecent(final Long accountId, final String externalDeviceId, final DateTime maxTsLimit, final DateTime minTsLimit) { final Expression keyConditionExpression = Expressions.and( Expressions.equals(DeviceDataAttribute.ACCOUNT_ID, toAttributeValue(accountId)), Expressions.between(DeviceDataAttribute.RANGE_KEY, getRangeKey(minTsLimit, externalDeviceId), getRangeKey(maxTsLimit, externalDeviceId))); final Expression filterExpression = Expressions.contains(DeviceDataAttribute.RANGE_KEY, toAttributeValue(externalDeviceId)); final Collection<DeviceDataAttribute> attributes = ALL_ATTRIBUTES; final List<String> tableNames = getTableNames(minTsLimit, maxTsLimit); final Optional<Map<String, AttributeValue>> result = getLatest(tableNames, keyConditionExpression, filterExpression, attributes); if (result.isPresent()) { return Optional.of(attributeMapToDeviceData(result.get())); <START> } else { <END> \/\/ else needed here return Optional.absent(); } }'","output":"public Optional<DeviceData> getMostRecent(final Long accountId, final String externalDeviceId, final DateTime maxTsLimit, final DateTime minTsLimit) { final Expression keyConditionExpression = Expressions.and( Expressions.equals(DeviceDataAttribute.ACCOUNT_ID, toAttributeValue(accountId)), Expressions.between(DeviceDataAttribute.RANGE_KEY, getRangeKey(minTsLimit, externalDeviceId), getRangeKey(maxTsLimit, externalDeviceId))); final Expression filterExpression = Expressions.contains(DeviceDataAttribute.RANGE_KEY, toAttributeValue(externalDeviceId)); final Collection<DeviceDataAttribute> attributes = ALL_ATTRIBUTES; final List<String> tableNames = getTableNames(minTsLimit, maxTsLimit); final Optional<Map<String, AttributeValue>> result = getLatest(tableNames, keyConditionExpression, filterExpression, attributes); if (result.isPresent()) { return Optional.of(attributeMapToDeviceData(result.get())); } return Optional.absent(); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'please split this lines avoid long lines in code? java final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() \/ 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate);'\nThe code is: 'public void startEditingHeaderCell(final int uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final BaseGridRendererHelper.RenderingInformation ri = rendererHelper.getRenderingInformation(); <START> final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(rendererHelper.getColumnOffset(this) + this.getWidth() \/ 2); <END> \/\/ please split this lines avoid long lines in code? java final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() \/ 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ri, ci, uiHeaderRowIndex); headerMetaData.edit(context); }'","output":"public void startEditingHeaderCell(final int uiHeaderRowIndex) { if (!EditableHeaderUtilities.hasEditableHeader(this)) { return; } if (!EditableHeaderUtilities.isEditableHeader(this, uiHeaderRowIndex)) { return; } final BaseGridRendererHelper rendererHelper = gridWidget.getRendererHelper(); final BaseGridRendererHelper.RenderingInformation ri = rendererHelper.getRenderingInformation(); final double columnXCoordinate = rendererHelper.getColumnOffset(this) + this.getWidth() \/ 2; final BaseGridRendererHelper.ColumnInformation ci = rendererHelper.getColumnInformation(columnXCoordinate); final EditableHeaderMetaData headerMetaData = (EditableHeaderMetaData) this.getHeaderMetaData().get(uiHeaderRowIndex); final GridBodyCellEditContext context = EditableHeaderUtilities.makeRenderContext(gridWidget, ri, ci, uiHeaderRowIndex); headerMetaData.edit(context); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'static import'\nThe code is: 'public void getClassLoaderModelByArtifact() { ClassLoaderModel pluginClassLoaderModel = new ClassLoaderModel(VERSION_100, mulePluginArtifact.getArtifactCoordinates()); Artifact otherThirdPartyArtifact = new Artifact(new ArtifactCoordinates(ORG_TESTS, \"other-third-party\", VERSION_100), URI.create(\"\")); pluginClassLoaderModel.setDependencies(ImmutableList.of(otherThirdPartyArtifact)); applicationClassloaderModel.mergeDependencies(ImmutableList.of(pluginClassLoaderModel)); assertThat(applicationClassloaderModel.getArtifacts(), hasSize(3)); assertThat(applicationClassloaderModel.getArtifacts(), contains(thirdPartyArtifact, mulePluginArtifact, otherThirdPartyArtifact)); assertThat(applicationClassloaderModel.getClassLoaderModel(mulePluginArtifact), <START> CoreMatchers.sameInstance(pluginClassLoaderModel)); <END> \/\/ static import }'","output":"public void getClassLoaderModelByArtifact() { ClassLoaderModel pluginClassLoaderModel = new ClassLoaderModel(VERSION_100, mulePluginArtifact.getArtifactCoordinates()); Artifact otherThirdPartyArtifact = new Artifact(new ArtifactCoordinates(ORG_TESTS, \"other-third-party\", VERSION_100), URI.create(\"\")); pluginClassLoaderModel.setDependencies(ImmutableList.of(otherThirdPartyArtifact)); applicationClassloaderModel.mergeDependencies(ImmutableList.of(pluginClassLoaderModel)); assertThat(applicationClassloaderModel.getArtifacts(), hasSize(3)); assertThat(applicationClassloaderModel.getArtifacts(), contains(thirdPartyArtifact, mulePluginArtifact, otherThirdPartyArtifact)); assertThat(applicationClassloaderModel.getClassLoaderModel(mulePluginArtifact), sameInstance(pluginClassLoaderModel)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'missing checkValidPosition(positionCount, position); below'\nThe code is: 'public Block copyPositions(int[] positions, int offset, int length) { <START> checkValidPositionsArray(positions, offset, length); <END> \/\/ missing checkValidPosition(positionCount, position); below IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); int[] newIds = new int[length]; for (int i = 0; i < length; i++) { int position = positions[offset + i]; int oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }'","output":"public Block copyPositions(int[] positions, int offset, int length) { checkArrayRange(positions, offset, length); IntArrayList positionsToCopy = new IntArrayList(); Map<Integer, Integer> oldIndexToNewIndex = new HashMap<>(); int[] newIds = new int[length]; for (int i = 0; i < length; i++) { int position = positions[offset + i]; int oldIndex = getId(position); if (!oldIndexToNewIndex.containsKey(oldIndex)) { oldIndexToNewIndex.put(oldIndex, positionsToCopy.size()); positionsToCopy.add(oldIndex); } newIds[i] = oldIndexToNewIndex.get(oldIndex); } return new DictionaryBlock(dictionary.copyPositions(positionsToCopy.elements(), 0, positionsToCopy.size()), newIds); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'progress bar is hidden onFinally() callback of Task, is called _after_ onSuccess(), causing potentially hidden immediately shown pagination loader initialization. solution manually managed here, ensure hidden _before_ potential call populatePostListRunnable.run()'\nThe code is: 'public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EventBus.getDefault().register(this); if (discussionTopic == null) { String topicId = getArguments().getString(Router.EXTRA_DISCUSSION_TOPIC_ID); GetSpecificCourseTopicsTask getTopicsTask = new GetSpecificCourseTopicsTask(getContext(), courseData.getCourse().getId(), Collections.singletonList(topicId)) { @Override protected void onSuccess(CourseTopics courseTopics) throws Exception { discussionTopic = courseTopics.getCoursewareTopics().get(0).getChildren().get(0); if (!getArguments().getBoolean(ARG_DISCUSSION_HAS_TOPIC_NAME)) { getActivity().setTitle(discussionTopic.getName()); } if (populatePostListRunnable != null) { populatePostListRunnable.run(); } } }; <START> getTopicsTask.setProgressDialog(loadingIndicator); <END> \/\/ progress bar is hidden onFinally() callback of Task, is called _after_ onSuccess(), causing potentially hidden immediately shown pagination loader initialization. solution manually managed here, ensure hidden _before_ potential call populatePostListRunnable.run() getTopicsTask.execute(); } else { getActivity().setTitle(discussionTopic.getName()); } }'","output":"public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EventBus.getDefault().register(this); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'consolidate this logic below. this: scala if (remainingToSearch.isEmpty()) { return result; } else { client.awaitMetadataUpdate(timer); }'\nThe code is: 'private ListOffsetResult fetchOffsetsByTimes(Map<TopicPartition, Long> timestampsToSearch, Timer timer, boolean requireTimestamps) { ListOffsetResult result = new ListOffsetResult(); if (timestampsToSearch.isEmpty()) return result; Map<TopicPartition, Long> remainingToSearch = new HashMap<>(timestampsToSearch); do { RequestFuture<ListOffsetResult> future = sendListOffsetsRequests(remainingToSearch, requireTimestamps); client.poll(future, timer); if (!future.isDone()) { break; } else if (future.succeeded()) { ListOffsetResult value = future.value(); result.fetchedOffsets.putAll(value.fetchedOffsets); remainingToSearch.keySet().retainAll(value.partitionsToRetry); } else if (!future.isRetriable()) { throw future.exception(); } <START> if (remainingToSearch.isEmpty()) { <END> \/\/ consolidate this logic below. this: scala if (remainingToSearch.isEmpty()) { return result; } else { client.awaitMetadataUpdate(timer); } return result; } else { metadata.requestUpdate(); } if (metadata.updateRequested()) client.awaitMetadataUpdate(timer); else timer.sleep(retryBackoffMs); } while (timer.notExpired()); throw new TimeoutException(\"Failed to get offsets by times in \" + timer.elapsedMs() + \"ms\"); }'","output":"private ListOffsetResult fetchOffsetsByTimes(Map<TopicPartition, Long> timestampsToSearch, Timer timer, boolean requireTimestamps) { ListOffsetResult result = new ListOffsetResult(); if (timestampsToSearch.isEmpty()) return result; Map<TopicPartition, Long> remainingToSearch = new HashMap<>(timestampsToSearch); do { RequestFuture<ListOffsetResult> future = sendListOffsetsRequests(remainingToSearch, requireTimestamps); client.poll(future, timer); if (!future.isDone()) { break; } else if (future.succeeded()) { ListOffsetResult value = future.value(); result.fetchedOffsets.putAll(value.fetchedOffsets); remainingToSearch.keySet().retainAll(value.partitionsToRetry); } else if (!future.isRetriable()) { throw future.exception(); } if (remainingToSearch.isEmpty()) { return result; } else { client.awaitMetadataUpdate(timer); } } while (timer.notExpired()); throw new TimeoutException(\"Failed to get offsets by times in \" + timer.elapsedMs() + \"ms\"); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'null == adapter'\nThe code is: 'public Adapter getContentAdapter() { if <START> (adapter == null) { <END> \/\/ null == adapter adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { int type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }'","output":"public Adapter getContentAdapter() { if (null == adapter) { adapter = new EContentAdapter() { @Override public void notifyChanged(final Notification notification) { int type = notification.getEventType(); switch (type) { case Notification.ADD: case Notification.ADD_MANY: case Notification.REMOVE: case Notification.REMOVE_MANY: Display.getDefault().asyncExec(() -> refreshChildren()); break; case Notification.SET: break; default: break; } } }; } return adapter; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'import static Assert'\nThe code is: 'public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(\"good_session_id\"); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(\"good_session_id\")).thenReturn(new VdcUser(Guid.NewGuid(), \"myUser\", \"myDomain\")); query.Execute(); <START> Assert.assertTrue(query.getQueryReturnValue().getSucceeded()); <END> \/\/ import static Assert Assert.assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); Assert.assertTrue(user.getDomainControler().equals(\"myDomain\")); Assert.assertTrue(user.getUserName().equals(\"myUser\")); }'","output":"public void testSuccessfulSessionId() { VdcQueryParametersBase params = new VdcQueryParametersBase();; params.setHttpSessionId(\"good_session_id\"); ValidateSessionQuery<VdcQueryParametersBase> query = spy(new ValidateSessionQuery<VdcQueryParametersBase>(params)); when(query.getSessionUser(\"good_session_id\")).thenReturn(new VdcUser(Guid.NewGuid(), \"myUser\", \"myDomain\")); query.Execute(); assertTrue(query.getQueryReturnValue().getSucceeded()); assertTrue(query.getQueryReturnValue().getReturnValue() instanceof VdcUser); VdcUser user = (VdcUser) query.getQueryReturnValue().getReturnValue(); assertTrue(user.getDomainControler().equals(\"myDomain\")); assertTrue(user.getUserName().equals(\"myUser\")); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'more sense merge if (pair.length == 2) a single if statements: if (pair.length == 2) { if (pair[1].isEmpty() && i < args.length - 1) { pair[1] = args[++i]; } if (!parseOption(pair[0], pair[1], false)) { messageStream.println(); usage(messageStream, true); return false; } } if changing code'\nThe code is: 'public boolean parseOptions(final PrintStream messageStream, final String[] args) { this.argv = args; this.messageStream = messageStream; if (prefix.isEmpty()) { commandLine = callerOptions.getClass().getName(); } for (int i = 0; i < args.length; ++i) { final String arg = args[i]; if (arg.equals(\"-h\") || arg.equals(\"--help\")) { usage(messageStream, false); return false; } if (arg.equals(\"-H\") || arg.equals(\"--stdhelp\")) { usage(messageStream, true); return false; } if (arg.equals(\"--version\")) { messageStream.println(getVersion()); return false; } final String[] pair = arg.split(\"=\", 2); <START> if (pair.length == 2 && pair[1].isEmpty() && i < args.length - 1) { <END> \/\/ more sense merge if (pair.length == 2) a single if statements: if (pair.length == 2) { if (pair[1].isEmpty() && i < args.length - 1) { pair[1] = args[++i]; } if (!parseOption(pair[0], pair[1], false)) { messageStream.println(); usage(messageStream, true); return false; } } if changing code pair[1] = args[++i]; } if (pair.length == 2) { if (!parseOption(pair[0], pair[1], false)) { messageStream.println(); usage(messageStream, true); return false; } } else if (!parsePositionalArgument(arg)) { messageStream.println(); usage(messageStream, false); return false; } } if (!checkNumArguments()) { messageStream.println(); usage(messageStream, false); return false; } if (!parseChildOptions()) { messageStream.println(); usage(messageStream, false); return false; } return true; }'","output":"public boolean parseOptions(final PrintStream messageStream, final String[] args) { this.argv = args; this.messageStream = messageStream; if (prefix.isEmpty()) { commandLine = callerOptions.getClass().getName(); } for (int i = 0; i < args.length; ++i) { final String arg = args[i]; if (arg.equals(\"-h\") || arg.equals(\"--help\")) { usage(messageStream, false); return false; } if (arg.equals(\"-H\") || arg.equals(\"--stdhelp\")) { usage(messageStream, true); return false; } if (arg.equals(\"--version\")) { messageStream.println(getVersion()); return false; } final String[] pair = arg.split(\"=\", 2); if (pair.length == 2) { if (pair[1].isEmpty() && i < args.length - 1) { pair[1] = args[++i]; } if (!parseOption(pair[0], pair[1], false)) { messageStream.println(); usage(messageStream, true); return false; } } else if (!parsePositionalArgument(arg)) { messageStream.println(); usage(messageStream, false); return false; } } if (!checkNumArguments()) { messageStream.println(); usage(messageStream, false); return false; } if (!parseChildOptions()) { messageStream.println(); usage(messageStream, false); return false; } return true; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Inline this, please. FQNs ugly'\nThe code is: 'private List<Target<Object>> createTargets(ControllerMethod method) { Method javaMethod = method.getMethod(); List<Target<Object>> targets = new ArrayList<>(); <START> List<br.com.caelum.vraptor.http.Parameter> parameterNames = nameProvider.parametersFor(javaMethod); <END> \/\/ Inline this, please. FQNs ugly for (br.com.caelum.vraptor.http.Parameter p : parameterNames) { Type type = p.getParameterizedType(); if (type instanceof TypeVariable) { type = extractType(method); } targets.add(new Target<>(type, p.getName())); } return targets; }'","output":"private List<Target<Object>> createTargets(ControllerMethod method) { Method javaMethod = method.getMethod(); List<Target<Object>> targets = new ArrayList<>(); for (br.com.caelum.vraptor.http.Parameter p : nameProvider.parametersFor(javaMethod)) { Type type = p.getParameterizedType(); if (type instanceof TypeVariable) { type = extractType(method); } targets.add(new Target<>(type, p.getName())); } return targets; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'add this populate'\nThe code is: 'public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(\"\"); for (int i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (int j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; <START> case MIStrings.SNAPSHOT_DATA_URL: <END> \/\/ add this populate break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }'","output":"public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { StringBuffer command = createCommand(LTTngControlServiceConstants.COMMAND_LIST_SNAPSHOT_OUTPUT, LTTngControlServiceConstants.OPTION_SESSION, sessionName); ICommandResult result = executeCommand(command.toString(), monitor); Document doc = getDocumentFromStrings(result.getOutput()); NodeList rawSnapshotsOutputs = doc.getElementsByTagName(MIStrings.SNAPSHOT_OUTPUTS); ISnapshotInfo snapshotInfo = new SnapshotInfo(\"\"); for (int i = 0; i < rawSnapshotsOutputs.getLength(); i++) { NodeList rawSnapshotOutput = rawSnapshotsOutputs.item(i).getChildNodes(); for (int j = 0; j < rawSnapshotOutput.getLength(); j++) { Node rawInfo = rawSnapshotOutput.item(j); switch (rawInfo.getNodeName()) { case MIStrings.ID: snapshotInfo.setId(Integer.parseInt(rawInfo.getTextContent())); break; case MIStrings.NAME: snapshotInfo.setName(rawInfo.getTextContent()); break; case MIStrings.SNAPSHOT_CTRL_URL: snapshotInfo.setSnapshotPath(rawInfo.getTextContent()); break; default: break; } } } Matcher matcher2 = LTTngControlServiceConstants.TRACE_NETWORK_PATTERN.matcher(snapshotInfo.getSnapshotPath()); if (matcher2.matches()) { snapshotInfo.setStreamedSnapshot(true); } return snapshotInfo; }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'Again, assertNotNull more readable'\nThe code is: 'public void testEquals() { String value = \"someValue\"; String type = \"someType\"; float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); <START> assertNotEquals(null, typedId); <END> \/\/ Again, assertNotNull more readable assertNotEquals(\"string\", typedId); assertNotEquals(typedId, new TypedId(\"otherValue\", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, \"otherType\", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }'","output":"public void testEquals() { String value = \"someValue\"; String type = \"someType\"; float confidenceLevel = 0.9f; TypedId typedId = new TypedId(value, type, confidenceLevel); assertNotNull(typedId); assertNotEquals(\"string\", typedId); assertNotEquals(typedId, new TypedId(\"otherValue\", type, confidenceLevel)); assertNotEquals(typedId, new TypedId(value, \"otherType\", confidenceLevel)); assertNotEquals(typedId, new TypedId(value, type, 0.8f)); assertEquals(typedId, new TypedId(value, type, confidenceLevel)); }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'UTF-8'\nThe code is: 'public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { <START> pd.addEventFromKafka(100L + i + 1, (\"test_\" + i).getBytes()); <END> \/\/ UTF-8 } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }'","output":"public void normalOperationShouldNotReconfigureKafkaConsumer() { final PartitionData pd = new PartitionData(null, 100L); for (long i = 0; i < 100; ++i) { pd.addEventFromKafka(100L + i + 1, (\"test_\" + i).getBytes(UTF_8)); } pd.takeEventsToStream(currentTimeMillis(), 1000, 0L); assertEquals(100L, pd.getUnconfirmed()); for (long i = 0; i < 10; ++i) { final PartitionData.CommitResult cr = pd.onCommitOffset(110L + i * 10L); assertEquals(10L, cr.committedCount); assertFalse(cr.seekOnKafka); assertEquals(90L - i * 10L, pd.getUnconfirmed()); } }"}
{"input":"Refine the code based on the feedback provided in the code review comment, with a focus on the segment between <START> and <END>. The comment is: 'a dedicated method CallExpression'\nThe code is: 'public void initialize(Context context) { context.registerSyntaxNodeConsumer(Kind.CALL_EXPR, ctx -> { PyCallExpressionTree callExpression = (PyCallExpressionTree) ctx.syntaxNode(); <START> List<PyArgumentTree> arguments = callExpression.arguments() != null ? callExpression.arguments().arguments() : Collections.emptyList(); <END> \/\/ a dedicated method CallExpression String qualifiedName = getQualifiedName(callExpression, ctx); if (CRYPTOGRAPHY.matcher(qualifiedName).matches()) { new CryptographyModuleCheck().checkArguments(ctx, arguments); } else if (CRYPTO.matcher(qualifiedName).matches()) { new CryptoModuleCheck().checkArguments(ctx, arguments); } else if (CRYPTODOME.matcher(qualifiedName).matches()) { new CryptodomeModuleCheck().checkArguments(ctx, arguments); } }); }'","output":"public void initialize(Context context) { context.registerSyntaxNodeConsumer(Kind.CALL_EXPR, ctx -> { PyCallExpressionTree callExpression = (PyCallExpressionTree) ctx.syntaxNode(); List<PyArgumentTree> arguments = callExpression.arguments(); String qualifiedName = getQualifiedName(callExpression, ctx); if (CRYPTOGRAPHY.matcher(qualifiedName).matches()) { new CryptographyModuleCheck().checkArguments(ctx, arguments); } else if (CRYPTO.matcher(qualifiedName).matches()) { new CryptoModuleCheck().checkArguments(ctx, arguments); } else if (CRYPTODOME.matcher(qualifiedName).matches()) { new CryptodomeModuleCheck().checkArguments(ctx, arguments); } }); }"}
